/* Version 1.0.0-alpha.1 - 2025-09-06T03:12:27.416Z - 200680b */
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const IS_DEV = false;
const equalFn = (a, b2) => a === b2;
const $PROXY = Symbol("solid-proxy");
const SUPPORTS_PROXY = typeof Proxy === "function";
const $TRACK = Symbol("solid-track");
const signalOptions = {
  equals: equalFn
};
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var Owner = null;
let Transition = null;
let ExternalSourceConfig = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: current ? current.context : null,
    owner: current
  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
  Owner = root;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal(value2, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s = {
    value: value2,
    observers: null,
    observerSlots: null,
    comparator: options.equals || void 0
  };
  const setter = (value3) => {
    if (typeof value3 === "function") {
      value3 = value3(s.value);
    }
    return writeSignal(s, value3);
  };
  return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value2, options) {
  const c = createComputation(fn, value2, false, STALE);
  updateComputation(c);
}
function createEffect(fn, value2, options) {
  runEffects = runUserEffects;
  const c = createComputation(fn, value2, false, STALE);
  if (!options || !options.render) c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function createMemo(fn, value2, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const c = createComputation(fn, value2, true, 0);
  c.observers = null;
  c.observerSlots = null;
  c.comparator = options.equals || void 0;
  updateComputation(c);
  return readSignal.bind(c);
}
function batch(fn) {
  return runUpdates(fn, false);
}
function untrack(fn) {
  if (Listener === null) return fn();
  const listener = Listener;
  Listener = null;
  try {
    if (ExternalSourceConfig) ;
    return fn();
  } finally {
    Listener = listener;
  }
}
function onMount(fn) {
  createEffect(() => untrack(fn));
}
function onCleanup(fn) {
  if (Owner === null) ;
  else if (Owner.cleanups === null) Owner.cleanups = [fn];
  else Owner.cleanups.push(fn);
  return fn;
}
function getListener() {
  return Listener;
}
function getOwner() {
  return Owner;
}
function runWithOwner(o, fn) {
  const prev = Owner;
  const prevListener = Listener;
  Owner = o;
  Listener = null;
  try {
    return runUpdates(fn, true);
  } catch (err) {
    handleError(err);
  } finally {
    Owner = prev;
    Listener = prevListener;
  }
}
function readSignal() {
  if (this.sources && this.state) {
    if (this.state === STALE) updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  return this.value;
}
function writeSignal(node, value2, isComp) {
  let current = node.value;
  if (!node.comparator || !node.comparator(current, value2)) {
    node.value = value2;
    if (node.observers && node.observers.length) {
      runUpdates(() => {
        for (let i = 0; i < node.observers.length; i += 1) {
          const o = node.observers[i];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o)) ;
          if (TransitionRunning ? !o.tState : !o.state) {
            if (o.pure) Updates.push(o);
            else Effects.push(o);
            if (o.observers) markDownstream(o);
          }
          if (!TransitionRunning) o.state = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (IS_DEV) ;
          throw new Error();
        }
      }, false);
    }
  }
  return value2;
}
function updateComputation(node) {
  if (!node.fn) return;
  cleanNode(node);
  const time = ExecCount;
  runComputation(node, node.value, time);
}
function runComputation(node, value2, time) {
  let nextValue;
  const owner = Owner, listener = Listener;
  Listener = Owner = node;
  try {
    nextValue = node.fn(value2);
  } catch (err) {
    if (node.pure) {
      {
        node.state = STALE;
        node.owned && node.owned.forEach(cleanNode);
        node.owned = null;
      }
    }
    node.updatedAt = time + 1;
    return handleError(err);
  } finally {
    Listener = listener;
    Owner = owner;
  }
  if (!node.updatedAt || node.updatedAt <= time) {
    if (node.updatedAt != null && "observers" in node) {
      writeSignal(node, nextValue);
    } else node.value = nextValue;
    node.updatedAt = time;
  }
}
function createComputation(fn, init, pure, state2 = STALE, options) {
  const c = {
    fn,
    state: state2,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: Owner ? Owner.context : null,
    pure
  };
  if (Owner === null) ;
  else if (Owner !== UNOWNED) {
    {
      if (!Owner.owned) Owner.owned = [c];
      else Owner.owned.push(c);
    }
  }
  return c;
}
function runTop(node) {
  if (node.state === 0) return;
  if (node.state === PENDING) return lookUpstream(node);
  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
  const ancestors = [node];
  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
    if (node.state) ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    node = ancestors[i];
    if (node.state === STALE) {
      updateComputation(node);
    } else if (node.state === PENDING) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init) {
  if (Updates) return fn();
  let wait = false;
  if (!init) Updates = [];
  if (Effects) wait = true;
  else Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait) Effects = null;
    Updates = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    runQueue(Updates);
    Updates = null;
  }
  if (wait) return;
  const e = Effects;
  Effects = null;
  if (e.length) runUpdates(() => runEffects(e), false);
}
function runQueue(queue) {
  for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function runUserEffects(queue) {
  let i, userLength = 0;
  for (i = 0; i < queue.length; i++) {
    const e = queue[i];
    if (!e.user) runTop(e);
    else queue[userLength++] = e;
  }
  for (i = 0; i < userLength; i++) runTop(queue[i]);
}
function lookUpstream(node, ignore) {
  node.state = 0;
  for (let i = 0; i < node.sources.length; i += 1) {
    const source = node.sources[i];
    if (source.sources) {
      const state2 = source.state;
      if (state2 === STALE) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
      } else if (state2 === PENDING) lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node) {
  for (let i = 0; i < node.observers.length; i += 1) {
    const o = node.observers[i];
    if (!o.state) {
      o.state = PENDING;
      if (o.pure) Updates.push(o);
      else Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node) {
  let i;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (node.tOwned) {
    for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
    delete node.tOwned;
  }
  if (node.owned) {
    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
    node.cleanups = null;
  }
  node.state = 0;
}
function castError(err) {
  if (err instanceof Error) return err;
  return new Error(typeof err === "string" ? err : "Unknown error", {
    cause: err
  });
}
function handleError(err, owner = Owner) {
  const error = castError(err);
  throw error;
}
const FALLBACK = Symbol("fallback");
function dispose(d) {
  for (let i = 0; i < d.length; i++) d[i]();
}
function mapArray(list, mapFn, options = {}) {
  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => dispose(disposers));
  return () => {
    let newItems = list() || [], newLen = newItems.length, i, j;
    newItems[$TRACK];
    return untrack(() => {
      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
      } else if (len === 0) {
        mapped = new Array(newLen);
        for (j = 0; j < newLen; j++) {
          items[j] = newItems[j];
          mapped[j] = createRoot(mapper);
        }
        len = newLen;
      } else {
        temp = new Array(newLen);
        tempdisposers = new Array(newLen);
        indexes && (tempIndexes = new Array(newLen));
        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++) ;
        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
          temp[newEnd] = mapped[end];
          tempdisposers[newEnd] = disposers[end];
          indexes && (tempIndexes[newEnd] = indexes[end]);
        }
        newIndices = /* @__PURE__ */ new Map();
        newIndicesNext = new Array(newEnd + 1);
        for (j = newEnd; j >= start; j--) {
          item = newItems[j];
          i = newIndices.get(item);
          newIndicesNext[j] = i === void 0 ? -1 : i;
          newIndices.set(item, j);
        }
        for (i = start; i <= end; i++) {
          item = items[i];
          j = newIndices.get(item);
          if (j !== void 0 && j !== -1) {
            temp[j] = mapped[i];
            tempdisposers[j] = disposers[i];
            indexes && (tempIndexes[j] = indexes[i]);
            j = newIndicesNext[j];
            newIndices.set(item, j);
          } else disposers[i]();
        }
        for (j = start; j < newLen; j++) {
          if (j in temp) {
            mapped[j] = temp[j];
            disposers[j] = tempdisposers[j];
            if (indexes) {
              indexes[j] = tempIndexes[j];
              indexes[j](j);
            }
          } else mapped[j] = createRoot(mapper);
        }
        mapped = mapped.slice(0, len = newLen);
        items = newItems.slice(0);
      }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j] = disposer;
      if (indexes) {
        const [s, set] = createSignal(j);
        indexes[j] = set;
        return mapFn(newItems[j], s);
      }
      return mapFn(newItems[j]);
    }
  };
}
function createComponent(Comp, props) {
  return untrack(() => Comp(props || {}));
}
function trueFn() {
  return true;
}
const propTraps = {
  get(_, property, receiver) {
    if (property === $PROXY) return receiver;
    return _.get(property);
  },
  has(_, property) {
    if (property === $PROXY) return true;
    return _.has(property);
  },
  set: trueFn,
  deleteProperty: trueFn,
  getOwnPropertyDescriptor(_, property) {
    return {
      configurable: true,
      enumerable: true,
      get() {
        return _.get(property);
      },
      set: trueFn,
      deleteProperty: trueFn
    };
  },
  ownKeys(_) {
    return _.keys();
  }
};
function resolveSource(s) {
  return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
  for (let i = 0, length = this.length; i < length; ++i) {
    const v = this[i]();
    if (v !== void 0) return v;
  }
}
function mergeProps(...sources) {
  let proxy = false;
  for (let i = 0; i < sources.length; i++) {
    const s = sources[i];
    proxy = proxy || !!s && $PROXY in s;
    sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
  }
  if (SUPPORTS_PROXY && proxy) {
    return new Proxy({
      get(property) {
        for (let i = sources.length - 1; i >= 0; i--) {
          const v = resolveSource(sources[i])[property];
          if (v !== void 0) return v;
        }
      },
      has(property) {
        for (let i = sources.length - 1; i >= 0; i--) {
          if (property in resolveSource(sources[i])) return true;
        }
        return false;
      },
      keys() {
        const keys = [];
        for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));
        return [...new Set(keys)];
      }
    }, propTraps);
  }
  const sourcesMap = {};
  const defined = /* @__PURE__ */ Object.create(null);
  for (let i = sources.length - 1; i >= 0; i--) {
    const source = sources[i];
    if (!source) continue;
    const sourceKeys = Object.getOwnPropertyNames(source);
    for (let i2 = sourceKeys.length - 1; i2 >= 0; i2--) {
      const key = sourceKeys[i2];
      if (key === "__proto__" || key === "constructor") continue;
      const desc = Object.getOwnPropertyDescriptor(source, key);
      if (!defined[key]) {
        defined[key] = desc.get ? {
          enumerable: true,
          configurable: true,
          get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
        } : desc.value !== void 0 ? desc : void 0;
      } else {
        const sources2 = sourcesMap[key];
        if (sources2) {
          if (desc.get) sources2.push(desc.get.bind(source));
          else if (desc.value !== void 0) sources2.push(() => desc.value);
        }
      }
    }
  }
  const target = {};
  const definedKeys = Object.keys(defined);
  for (let i = definedKeys.length - 1; i >= 0; i--) {
    const key = definedKeys[i], desc = defined[key];
    if (desc && desc.get) Object.defineProperty(target, key, desc);
    else target[key] = desc ? desc.value : void 0;
  }
  return target;
}
function splitProps(props, ...keys) {
  if (SUPPORTS_PROXY && $PROXY in props) {
    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
    const res = keys.map((k) => {
      return new Proxy({
        get(property) {
          return k.includes(property) ? props[property] : void 0;
        },
        has(property) {
          return k.includes(property) && property in props;
        },
        keys() {
          return k.filter((property) => property in props);
        }
      }, propTraps);
    });
    res.push(new Proxy({
      get(property) {
        return blocked.has(property) ? void 0 : props[property];
      },
      has(property) {
        return blocked.has(property) ? false : property in props;
      },
      keys() {
        return Object.keys(props).filter((k) => !blocked.has(k));
      }
    }, propTraps));
    return res;
  }
  const otherObject = {};
  const objects = keys.map(() => ({}));
  for (const propName of Object.getOwnPropertyNames(props)) {
    const desc = Object.getOwnPropertyDescriptor(props, propName);
    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
    let blocked = false;
    let objectIndex = 0;
    for (const k of keys) {
      if (k.includes(propName)) {
        blocked = true;
        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
      }
      ++objectIndex;
    }
    if (!blocked) {
      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
    }
  }
  return [...objects, otherObject];
}
const narrowedError = (name) => `Stale read from <${name}>.`;
function For(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(mapArray(() => props.each, props.children, fallback || void 0));
}
function Show(props) {
  const keyed = props.keyed;
  const conditionValue = createMemo(() => props.when, void 0, void 0);
  const condition = keyed ? conditionValue : createMemo(conditionValue, void 0, {
    equals: (a, b2) => !a === !b2
  });
  return createMemo(() => {
    const c = condition();
    if (c) {
      const child = props.children;
      const fn = typeof child === "function" && child.length > 0;
      return fn ? untrack(() => child(keyed ? c : () => {
        if (!untrack(condition)) throw narrowedError("Show");
        return conditionValue();
      })) : child;
    }
    return props.fallback;
  }, void 0, void 0);
}
const booleans = [
  "allowfullscreen",
  "async",
  "alpha",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "adauctionheaders",
  "browsingtopics",
  "credentialless",
  "defaultchecked",
  "defaultmuted",
  "defaultselected",
  "defer",
  "disablepictureinpicture",
  "disableremoteplayback",
  "preservespitch",
  "shadowrootclonable",
  "shadowrootcustomelementregistry",
  "shadowrootdelegatesfocus",
  "shadowrootserializable",
  "sharedstoragewritable"
];
const Properties = /* @__PURE__ */ new Set([
  "className",
  "value",
  "readOnly",
  "noValidate",
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "adAuctionHeaders",
  "allowFullscreen",
  "browsingTopics",
  "defaultChecked",
  "defaultMuted",
  "defaultSelected",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "preservesPitch",
  "shadowRootClonable",
  "shadowRootCustomElementRegistry",
  "shadowRootDelegatesFocus",
  "shadowRootSerializable",
  "sharedStorageWritable",
  ...booleans
]);
const ChildProperties = /* @__PURE__ */ new Set(["innerHTML", "textContent", "innerText", "children"]);
const Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  novalidate: {
    $: "noValidate",
    FORM: 1
  },
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  },
  adauctionheaders: {
    $: "adAuctionHeaders",
    IFRAME: 1
  },
  allowfullscreen: {
    $: "allowFullscreen",
    IFRAME: 1
  },
  browsingtopics: {
    $: "browsingTopics",
    IMG: 1
  },
  defaultchecked: {
    $: "defaultChecked",
    INPUT: 1
  },
  defaultmuted: {
    $: "defaultMuted",
    AUDIO: 1,
    VIDEO: 1
  },
  defaultselected: {
    $: "defaultSelected",
    OPTION: 1
  },
  disablepictureinpicture: {
    $: "disablePictureInPicture",
    VIDEO: 1
  },
  disableremoteplayback: {
    $: "disableRemotePlayback",
    AUDIO: 1,
    VIDEO: 1
  },
  preservespitch: {
    $: "preservesPitch",
    AUDIO: 1,
    VIDEO: 1
  },
  shadowrootclonable: {
    $: "shadowRootClonable",
    TEMPLATE: 1
  },
  shadowrootdelegatesfocus: {
    $: "shadowRootDelegatesFocus",
    TEMPLATE: 1
  },
  shadowrootserializable: {
    $: "shadowRootSerializable",
    TEMPLATE: 1
  },
  sharedstoragewritable: {
    $: "sharedStorageWritable",
    IFRAME: 1,
    IMG: 1
  }
});
function getPropAlias(prop, tagName) {
  const a = PropAliases[prop];
  return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
}
const DelegatedEvents = /* @__PURE__ */ new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]);
const memo = (fn) => createMemo(() => fn());
function reconcileArrays(parentNode, a, b2) {
  let bLength = b2.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (a[aStart] === b2[bStart]) {
      aStart++;
      bStart++;
      continue;
    }
    while (a[aEnd - 1] === b2[bEnd - 1]) {
      aEnd--;
      bEnd--;
    }
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? b2[bStart - 1].nextSibling : b2[bEnd - bStart] : after;
      while (bStart < bEnd) parentNode.insertBefore(b2[bStart++], node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a[aStart])) a[aStart].remove();
        aStart++;
      }
    } else if (a[aStart] === b2[bEnd - 1] && b2[bStart] === a[aEnd - 1]) {
      const node = a[--aEnd].nextSibling;
      parentNode.insertBefore(b2[bStart++], a[aStart++].nextSibling);
      parentNode.insertBefore(b2[--bEnd], node);
      a[aEnd] = b2[bEnd];
    } else {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        let i = bStart;
        while (i < bEnd) map.set(b2[i], i++);
      }
      const index = map.get(a[aStart]);
      if (index != null) {
        if (bStart < index && index < bEnd) {
          let i = aStart, sequence = 1, t;
          while (++i < aEnd && i < bEnd) {
            if ((t = map.get(a[i])) == null || t !== index + sequence) break;
            sequence++;
          }
          if (sequence > index - bStart) {
            const node = a[aStart];
            while (bStart < index) parentNode.insertBefore(b2[bStart++], node);
          } else parentNode.replaceChild(b2[bStart++], a[aStart++]);
        } else aStart++;
      } else a[aStart++].remove();
    }
  }
}
const $$EVENTS = "_$DX_DELEGATE";
function render(code, element, init, options = {}) {
  let disposer;
  createRoot((dispose2) => {
    disposer = dispose2;
    element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
  }, options.owner);
  return () => {
    disposer();
    element.textContent = "";
  };
}
function template(html, isImportNode, isSVG, isMathML) {
  let node;
  const create = () => {
    const t = document.createElement("template");
    t.innerHTML = html;
    return t.content.firstChild;
  };
  const fn = () => (node || (node = create())).cloneNode(true);
  fn.cloneNode = fn;
  return fn;
}
function delegateEvents(eventNames, document2 = window.document) {
  const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
  for (let i = 0, l = eventNames.length; i < l; i++) {
    const name = eventNames[i];
    if (!e.has(name)) {
      e.add(name);
      document2.addEventListener(name, eventHandler);
    }
  }
}
function setAttribute(node, name, value2) {
  if (value2 == null) node.removeAttribute(name);
  else node.setAttribute(name, value2);
}
function setBoolAttribute(node, name, value2) {
  value2 ? node.setAttribute(name, "") : node.removeAttribute(name);
}
function className(node, value2) {
  if (value2 == null) node.removeAttribute("class");
  else node.className = value2;
}
function addEventListener$1(node, name, handler, delegate) {
  if (delegate) {
    if (Array.isArray(handler)) {
      node[`$$${name}`] = handler[0];
      node[`$$${name}Data`] = handler[1];
    } else node[`$$${name}`] = handler;
  } else if (Array.isArray(handler)) {
    const handlerFn = handler[0];
    node.addEventListener(name, handler[0] = (e) => handlerFn.call(node, handler[1], e));
  } else node.addEventListener(name, handler, typeof handler !== "function" && handler);
}
function classList(node, value2, prev = {}) {
  const classKeys = Object.keys(value2 || {}), prevKeys = Object.keys(prev);
  let i, len;
  for (i = 0, len = prevKeys.length; i < len; i++) {
    const key = prevKeys[i];
    if (!key || key === "undefined" || value2[key]) continue;
    toggleClassKey(node, key, false);
    delete prev[key];
  }
  for (i = 0, len = classKeys.length; i < len; i++) {
    const key = classKeys[i], classValue = !!value2[key];
    if (!key || key === "undefined" || prev[key] === classValue || !classValue) continue;
    toggleClassKey(node, key, true);
    prev[key] = classValue;
  }
  return prev;
}
function style(node, value2, prev) {
  if (!value2) return prev ? setAttribute(node, "style") : value2;
  const nodeStyle = node.style;
  if (typeof value2 === "string") return nodeStyle.cssText = value2;
  typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
  prev || (prev = {});
  value2 || (value2 = {});
  let v, s;
  for (s in prev) {
    value2[s] == null && nodeStyle.removeProperty(s);
    delete prev[s];
  }
  for (s in value2) {
    v = value2[s];
    if (v !== prev[s]) {
      nodeStyle.setProperty(s, v);
      prev[s] = v;
    }
  }
  return prev;
}
function setStyleProperty(node, name, value2) {
  value2 != null ? node.style.setProperty(name, value2) : node.style.removeProperty(name);
}
function spread(node, props = {}, isSVG, skipChildren) {
  const prevProps = {};
  {
    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));
  }
  createRenderEffect(() => typeof props.ref === "function" && use(props.ref, node));
  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
  return prevProps;
}
function use(fn, element, arg) {
  return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
  if (marker !== void 0 && !initial) initial = [];
  if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
  props || (props = {});
  for (const prop in prevProps) {
    if (!(prop in props)) {
      if (prop === "children") continue;
      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);
    }
  }
  for (const prop in props) {
    if (prop === "children") {
      continue;
    }
    const value2 = props[prop];
    prevProps[prop] = assignProp(node, prop, value2, prevProps[prop], isSVG, skipRef, props);
  }
}
function toPropertyName(name) {
  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
}
function toggleClassKey(node, key, value2) {
  const classNames = key.trim().split(/\s+/);
  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value2);
}
function assignProp(node, prop, value2, prev, isSVG, skipRef, props) {
  let isCE, isProp, isChildProp, propAlias, forceProp;
  if (prop === "style") return style(node, value2, prev);
  if (prop === "classList") return classList(node, value2, prev);
  if (value2 === prev) return prev;
  if (prop === "ref") {
    if (!skipRef) value2(node);
  } else if (prop.slice(0, 3) === "on:") {
    const e = prop.slice(3);
    prev && node.removeEventListener(e, prev, typeof prev !== "function" && prev);
    value2 && node.addEventListener(e, value2, typeof value2 !== "function" && value2);
  } else if (prop.slice(0, 10) === "oncapture:") {
    const e = prop.slice(10);
    prev && node.removeEventListener(e, prev, true);
    value2 && node.addEventListener(e, value2, true);
  } else if (prop.slice(0, 2) === "on") {
    const name = prop.slice(2).toLowerCase();
    const delegate = DelegatedEvents.has(name);
    if (!delegate && prev) {
      const h = Array.isArray(prev) ? prev[0] : prev;
      node.removeEventListener(name, h);
    }
    if (delegate || value2) {
      addEventListener$1(node, name, value2, delegate);
      delegate && delegateEvents([name]);
    }
  } else if (prop.slice(0, 5) === "attr:") {
    setAttribute(node, prop.slice(5), value2);
  } else if (prop.slice(0, 5) === "bool:") {
    setBoolAttribute(node, prop.slice(5), value2);
  } else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-") || "is" in props)) {
    if (forceProp) {
      prop = prop.slice(5);
      isProp = true;
    }
    if (prop === "class" || prop === "className") className(node, value2);
    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value2;
    else node[propAlias || prop] = value2;
  } else {
    setAttribute(node, Aliases[prop] || prop, value2);
  }
  return value2;
}
function eventHandler(e) {
  let node = e.target;
  const key = `$$${e.type}`;
  const oriTarget = e.target;
  const oriCurrentTarget = e.currentTarget;
  const retarget = (value2) => Object.defineProperty(e, "target", {
    configurable: true,
    value: value2
  });
  const handleNode = () => {
    const handler = node[key];
    if (handler && !node.disabled) {
      const data = node[`${key}Data`];
      data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
      if (e.cancelBubble) return;
    }
    node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
    return true;
  };
  const walkUpTree = () => {
    while (handleNode() && (node = node._$host || node.parentNode || node.host)) ;
  };
  Object.defineProperty(e, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  if (e.composedPath) {
    const path = e.composedPath();
    retarget(path[0]);
    for (let i = 0; i < path.length - 2; i++) {
      node = path[i];
      if (!handleNode()) break;
      if (node._$host) {
        node = node._$host;
        walkUpTree();
        break;
      }
      if (node.parentNode === oriCurrentTarget) {
        break;
      }
    }
  } else walkUpTree();
  retarget(oriTarget);
}
function insertExpression(parent, value2, current, marker, unwrapArray) {
  while (typeof current === "function") current = current();
  if (value2 === current) return current;
  const t = typeof value2, multi = marker !== void 0;
  parent = multi && current[0] && current[0].parentNode || parent;
  if (t === "string" || t === "number") {
    if (t === "number") {
      value2 = value2.toString();
      if (value2 === current) return current;
    }
    if (multi) {
      let node = current[0];
      if (node && node.nodeType === 3) {
        node.data !== value2 && (node.data = value2);
      } else node = document.createTextNode(value2);
      current = cleanChildren(parent, current, marker, node);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent.firstChild.data = value2;
      } else current = parent.textContent = value2;
    }
  } else if (value2 == null || t === "boolean") {
    current = cleanChildren(parent, current, marker);
  } else if (t === "function") {
    createRenderEffect(() => {
      let v = value2();
      while (typeof v === "function") v = v();
      current = insertExpression(parent, v, current, marker);
    });
    return () => current;
  } else if (Array.isArray(value2)) {
    const array = [];
    const currentArray = current && Array.isArray(current);
    if (normalizeIncomingArray(array, value2, current, unwrapArray)) {
      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
      return () => current;
    }
    if (array.length === 0) {
      current = cleanChildren(parent, current, marker);
      if (multi) return current;
    } else if (currentArray) {
      if (current.length === 0) {
        appendNodes(parent, array, marker);
      } else reconcileArrays(parent, current, array);
    } else {
      current && cleanChildren(parent);
      appendNodes(parent, array);
    }
    current = array;
  } else if (value2.nodeType) {
    if (Array.isArray(current)) {
      if (multi) return current = cleanChildren(parent, current, marker, value2);
      cleanChildren(parent, current, null, value2);
    } else if (current == null || current === "" || !parent.firstChild) {
      parent.appendChild(value2);
    } else parent.replaceChild(value2, parent.firstChild);
    current = value2;
  } else ;
  return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap2) {
  let dynamic = false;
  for (let i = 0, len = array.length; i < len; i++) {
    let item = array[i], prev = current && current[normalized.length], t;
    if (item == null || item === true || item === false) ;
    else if ((t = typeof item) === "object" && item.nodeType) {
      normalized.push(item);
    } else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
    } else if (t === "function") {
      if (unwrap2) {
        while (typeof item === "function") item = item();
        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else {
      const value2 = String(item);
      if (prev && prev.nodeType === 3 && prev.data === value2) normalized.push(prev);
      else normalized.push(document.createTextNode(value2));
    }
  }
  return dynamic;
}
function appendNodes(parent, array, marker = null) {
  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
  if (marker === void 0) return parent.textContent = "";
  const node = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i = current.length - 1; i >= 0; i--) {
      const el = current[i];
      if (node !== el) {
        const isParent = el.parentNode === parent;
        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else isParent && el.remove();
      } else inserted = true;
    }
  } else parent.insertBefore(node, marker);
  return [node];
}
const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(tagName, isSVG = false, is = void 0) {
  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName, {
    is
  });
}
function Portal(props) {
  const {
    useShadow
  } = props, marker = document.createTextNode(""), mount = () => props.mount || document.body, owner = getOwner();
  let content;
  createEffect(() => {
    content || (content = runWithOwner(owner, () => createMemo(() => props.children)));
    const el = mount();
    if (el instanceof HTMLHeadElement) {
      const [clean, setClean] = createSignal(false);
      const cleanup = () => setClean(true);
      createRoot((dispose2) => insert(el, () => !clean() ? content() : dispose2(), null));
      onCleanup(cleanup);
    } else {
      const container = createElement(props.isSVG ? "g" : "div", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({
        mode: "open"
      }) : container;
      Object.defineProperty(container, "_$host", {
        get() {
          return marker.parentNode;
        },
        configurable: true
      });
      insert(renderRoot, content);
      el.appendChild(container);
      props.ref && props.ref(container);
      onCleanup(() => el.removeChild(container));
    }
  }, void 0, {
    render: true
  });
  return marker;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug2.debug = createDebug2;
    createDebug2.default = createDebug2;
    createDebug2.coerce = coerce;
    createDebug2.disable = disable;
    createDebug2.enable = enable;
    createDebug2.enabled = enabled;
    createDebug2.humanize = requireMs();
    createDebug2.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug2[key] = env[key];
    });
    createDebug2.names = [];
    createDebug2.skips = [];
    createDebug2.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
    }
    createDebug2.selectColor = selectColor;
    function createDebug2(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug2.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug2.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug2.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug2.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug2.useColors();
      debug2.color = createDebug2.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug2.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug2.namespaces) {
            namespacesCache = createDebug2.namespaces;
            enabledCache = createDebug2.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug2.init === "function") {
        createDebug2.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug2.save(namespaces);
      createDebug2.namespaces = namespaces;
      createDebug2.names = [];
      createDebug2.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug2.skips.push(ns.slice(1));
        } else {
          createDebug2.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template2) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template2.length && (template2[templateIndex] === search[searchIndex] || template2[templateIndex] === "*")) {
          if (template2[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template2.length && template2[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template2.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug2.names,
        ...createDebug2.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug2.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug2.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug2.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug2.enable(createDebug2.load());
    return createDebug2;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    var define_process_env_default = {};
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = define_process_env_default.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var browserExports = requireBrowser();
const createDebug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
function L(r, a, o, y = "*") {
  let u = r;
  return u === "random" && (u = Math.floor(Math.random() * (o - a + 1)) + a), y.repeat(u);
}
function b(r) {
  return r.toLowerCase().replace(/[^a-z0-9]/g, "");
}
function P(r, a = {}, o = /* @__PURE__ */ new WeakMap()) {
  const {
    properties: y = [
      "password",
      "key",
      "secret",
      "token",
      "privatekey",
      "passphrase"
    ],
    propertyMatcher: u = null,
    maskLength: j = 8,
    minLength: w = 5,
    maxLength: z = 15,
    maskChar: i = "*",
    fullMask: k = false
  } = a;
  if (o.has(r))
    return o.get(r);
  const A = y.map((e) => b(e));
  function O(e) {
    return typeof k == "string" ? k : k === true ? i.repeat(e.length) : L(j, w, z, i);
  }
  function g(e, s, n = []) {
    const t = b(e);
    return u && typeof u == "function" ? u(e, t, s, n) : A.indexOf(t) !== -1;
  }
  function h(e, s, n = []) {
    if (e == null)
      return e;
    if (typeof e == "object" && o.has(e))
      return o.get(e);
    let t;
    if (Array.isArray(e)) {
      t = [], o.set(e, t);
      for (let f = 0; f < e.length; f += 1) {
        const c = [...n, f];
        t[f] = h(e[f], s, c);
      }
    } else if (typeof e == "object") {
      t = {}, o.set(e, t);
      const f = Object.keys(e);
      for (let c = 0; c < f.length; c += 1) {
        const p = f[c], M = [...n, p], x = s || g(p, e[p], M);
        t[p] = h(
          e[p],
          x,
          M
        );
      }
    } else s && typeof e == "string" ? t = O(e) : t = e;
    return t;
  }
  let l;
  if (Array.isArray(r)) {
    l = [], o.set(r, l);
    for (let e = 0; e < r.length; e += 1)
      l[e] = h(r[e], false, [e]);
  } else if (r && typeof r == "object") {
    l = {}, o.set(r, l);
    const e = Object.keys(r);
    for (let s = 0; s < e.length; s += 1) {
      const n = e[s], t = g(n, r[n], [n]);
      l[n] = h(r[n], t, [n]);
    }
  } else
    l = r;
  return l;
}
const debug$a = createDebug("webssh2-client:validator");
const MAX_LENGTHS = {
  host: 253,
  // Max port number is 65535
  username: 32,
  // Typical Unix username limit
  password: 256,
  // Reasonable password length
  header: 200,
  // Header text length
  headerbackground: 50,
  // Color value length
  sshterm: 50
};
function validateHost(host) {
  if (!host || typeof host !== "string") return null;
  let value2 = host;
  value2 = value2.replace(/^https?:\/\//, "");
  value2 = value2.split("/")[0] ?? value2;
  value2 = value2.split(":")[0] ?? value2;
  if (value2.length > MAX_LENGTHS.host) return null;
  const hostnameRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::1|::)$/;
  if (hostnameRegex.test(value2) || ipv4Regex.test(value2) || ipv6Regex.test(value2)) {
    return value2.toLowerCase();
  }
  debug$a("Invalid hostname:", value2);
  return null;
}
function validatePort(port) {
  const portNum = typeof port === "number" ? port : parseInt(String(port), 10);
  if (Number.isNaN(portNum) || portNum < 1 || portNum > 65535) {
    debug$a("Invalid port:", port);
    return null;
  }
  return portNum;
}
function validateUsername(username) {
  if (!username || typeof username !== "string") return null;
  const value2 = username.trim();
  if (value2.length === 0 || value2.length > MAX_LENGTHS.username) {
    debug$a("Invalid username length:", value2.length);
    return null;
  }
  const usernameRegex = /^[a-zA-Z0-9._-]+$/;
  if (!usernameRegex.test(value2)) {
    debug$a("Invalid username characters:", value2);
    return null;
  }
  return value2;
}
function validatePassword(password) {
  if (typeof password !== "string") return null;
  if (password.length > MAX_LENGTHS.password) {
    debug$a("Password too long:", password.length);
    return null;
  }
  return password;
}
function validateText(text, maxLength = MAX_LENGTHS.header) {
  if (!text || typeof text !== "string") return "";
  let value2 = text;
  if (value2.length > maxLength) {
    debug$a("Text truncated from", value2.length, "to", maxLength);
    value2 = value2.substring(0, maxLength);
  }
  return value2.replace(/\0/g, "");
}
function validateColor(color) {
  if (!color || typeof color !== "string") return null;
  const value2 = color.trim();
  if (value2.length > MAX_LENGTHS.headerbackground) return null;
  const hexRegex = /^#([0-9a-fA-F]{3}){1,2}$/;
  const rgbRegex = /^rgba?\(\s*(\d{1,3}\s*,\s*){2,3}\s*\d{1,3}\s*\)$/;
  const namedColorRegex = /^[a-zA-Z]+$/;
  if (hexRegex.test(value2) || rgbRegex.test(value2) || namedColorRegex.test(value2)) {
    return value2;
  }
  debug$a("Invalid color:", value2);
  return null;
}
function validateTerminalType(term) {
  if (!term || typeof term !== "string") return null;
  const value2 = term.trim();
  if (value2.length === 0 || value2.length > MAX_LENGTHS.sshterm) return null;
  const validTermTypes = [
    "xterm",
    "xterm-256color",
    "xterm-color",
    "xterm-16color",
    "vt100",
    "vt102",
    "vt220",
    "ansi",
    "linux",
    "screen",
    "screen-256color",
    "rxvt",
    "rxvt-unicode",
    "tmux",
    "tmux-256color"
  ];
  if (validTermTypes.includes(value2.toLowerCase())) return value2.toLowerCase();
  const termRegex = /^[a-zA-Z0-9-]+$/;
  if (termRegex.test(value2)) return value2;
  debug$a("Invalid terminal type:", value2);
  return null;
}
function validateLogLevel(level) {
  if (!level || typeof level !== "string") return null;
  const value2 = level.trim().toLowerCase();
  const validLevels = ["error", "warn", "info", "debug", "trace", "silent"];
  if (validLevels.includes(value2)) return value2;
  debug$a("Invalid log level:", value2);
  return null;
}
const debug$9 = createDebug("webssh2-client:utils");
const defaultSettings = {
  cursorBlink: true,
  scrollback: 1e4,
  tabStopWidth: 8,
  bellStyle: "sound",
  fontSize: 14,
  fontFamily: "courier-new, courier, monospace",
  letterSpacing: 0,
  lineHeight: 1,
  logLevel: "info"
};
function validateNumber(value2, min, max, defaultValue) {
  const num = typeof value2 === "number" ? value2 : Number(value2);
  if (Number.isNaN(num) || num < min || num > max) {
    return defaultValue;
  }
  return num;
}
function isObject$1(item) {
  return !!item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(target, source) {
  const output = {
    ...target
  };
  if (isObject$1(target) && isObject$1(source)) {
    Object.keys(source).forEach((key) => {
      const sVal = source[key];
      const tVal = target[key];
      if (isObject$1(sVal)) {
        if (!(key in target)) {
          output[key] = sVal;
        } else {
          output[key] = mergeDeep(
            isObject$1(tVal) ? tVal : {},
            sVal
          );
        }
      } else {
        output[key] = sVal;
      }
    });
  }
  return output;
}
function formatDate(date) {
  return `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, "0")}/${String(date.getDate()).padStart(2, "0")} @ ${String(date.getHours()).padStart(2, "0")}:${String(date.getMinutes()).padStart(2, "0")}:${String(date.getSeconds()).padStart(2, "0")}`;
}
function initializeConfig() {
  const defaultConfig = {
    socket: {
      url: null,
      path: "/ssh/socket.io"
    },
    ssh: {
      host: null,
      port: 22,
      username: null,
      password: null,
      sshterm: "xterm-color"
    },
    terminal: { ...defaultSettings },
    header: {
      text: null,
      background: "green"
    },
    autoConnect: false,
    logLevel: "info"
  };
  const userConfig = window.webssh2Config || {};
  const config2 = mergeDeep(
    defaultConfig,
    userConfig
  );
  debug$9("initializeConfig", config2);
  return config2;
}
function populateFormFromUrl(config2) {
  const searchParams = getUrlParams();
  const params = {
    ssh: {},
    header: {},
    terminal: {}
  };
  const parameterList = [
    "host",
    "port",
    "header",
    "headerbackground",
    "sshterm",
    "username",
    "password",
    "logLevel"
  ];
  parameterList.forEach((param) => {
    let value2 = searchParams.get(param);
    if (param === "port" && (value2 === null || value2 === "")) {
      value2 = "22";
    }
    if (value2 !== null) {
      switch (param) {
        case "host":
          validateHost(value2);
          break;
        case "port":
          validatePort(value2);
          break;
        case "username":
          validateUsername(value2);
          break;
        case "password":
          validatePassword(value2);
          break;
        case "header": {
          const text = validateText(value2);
          if (text !== null) {
            const header = params["header"];
            params["header"] = {
              ...header ?? {},
              text
            };
          }
          break;
        }
        case "headerbackground": {
          const background = validateColor(value2);
          if (background !== null) {
            const header = params["header"];
            params["header"] = {
              ...header ?? {},
              background
            };
          }
          break;
        }
        case "sshterm":
          validateTerminalType(value2);
          break;
        case "logLevel":
          validateLogLevel(value2);
          break;
      }
    }
  });
  const result = mergeDeep(config2, params);
  const urlHost = searchParams.get("host");
  if (urlHost && result.ssh) {
    result.autoConnect = true;
    debug$9("populateFormFromUrl: autoConnect enabled due to URL host parameter");
  }
  debug$9("populateFormFromUrl", result);
  return result;
}
function getUrlParams() {
  return new URLSearchParams(window.location.search);
}
function getCredentials(formData = null, terminalDimensions2 = {}) {
  const cfg = window.webssh2Config || {};
  const urlParams = getUrlParams();
  const fd = formData;
  const portValue = fd?.["port"] || urlParams.get("port") || cfg.ssh?.port || "22";
  let port = parseInt(String(portValue), 10);
  if (Number.isNaN(port) || port < 1 || port > 65535) {
    console.warn(`Invalid port value: ${String(portValue)}, defaulting to 22`);
    port = 22;
  }
  const mergedConfig = {
    host: fd?.["host"] || urlParams.get("host") || cfg.ssh?.host || "",
    port,
    username: fd?.["username"] || urlParams.get("username") || cfg.ssh?.username || "",
    password: fd?.["password"] || urlParams.get("password") || cfg.ssh?.password || "",
    term: fd?.["term"] || urlParams.get("sshterm") || cfg.ssh?.sshterm || "xterm-color"
  };
  const privateKey = fd?.["privateKey"] || urlParams.get("privateKey") || cfg.ssh?.privateKey || "";
  if (privateKey) {
    mergedConfig.privateKey = privateKey;
    const passphrase = fd?.["passphrase"] || urlParams.get("passphrase") || cfg.ssh?.passphrase || "";
    if (passphrase) mergedConfig.passphrase = passphrase;
  }
  if (terminalDimensions2.cols) mergedConfig.cols = terminalDimensions2.cols;
  if (terminalDimensions2.rows) mergedConfig.rows = terminalDimensions2.rows;
  const maskedContent = P(mergedConfig);
  debug$9("getCredentials: mergedConfig:", maskedContent);
  return mergedConfig;
}
function getBasicAuthCookie() {
  const cookies = document.cookie.split(";");
  for (let i = 0; i < cookies.length; i++) {
    const cookie = cookies[i].trim();
    if (cookie.startsWith("basicauth=")) {
      try {
        const parsed = JSON.parse(
          decodeURIComponent(cookie.substring("basicauth=".length))
        );
        return parsed;
      } catch (e) {
        console.error(
          "getBasicAuthCookie: Failed to parse basicauth cookie:",
          e
        );
        return null;
      }
    }
  }
  return null;
}
function validatePrivateKey(key) {
  const text = String(key || "").trim();
  if (!text.startsWith("-----BEGIN") || !text.includes("PRIVATE KEY-----"))
    return false;
  const patterns = [
    // OpenSSH format
    /^-----BEGIN OPENSSH PRIVATE KEY-----[\s\S]+-----END OPENSSH PRIVATE KEY-----\s*$/m,
    // PKCS#8 generic
    /^-----BEGIN PRIVATE KEY-----[\s\S]+-----END PRIVATE KEY-----\s*$/m,
    // PKCS#1 RSA
    /^-----BEGIN RSA PRIVATE KEY-----[\s\S]+-----END RSA PRIVATE KEY-----\s*$/m,
    // EC and DSA
    /^-----BEGIN EC PRIVATE KEY-----[\s\S]+-----END EC PRIVATE KEY-----\s*$/m,
    /^-----BEGIN DSA PRIVATE KEY-----[\s\S]+-----END DSA PRIVATE KEY-----\s*$/m
  ];
  return patterns.some((re2) => re2.test(text));
}
function validatePrivateKeyDeep(key) {
  const text = String(key || "").trim();
  const blocks = [];
  const patterns = [
    {
      type: "OPENSSH",
      re: /-----BEGIN OPENSSH PRIVATE KEY-----(?<body>[\s\S]+?)-----END OPENSSH PRIVATE KEY-----/m
    },
    {
      type: "PKCS8",
      re: /-----BEGIN PRIVATE KEY-----(?<body>[\s\S]+?)-----END PRIVATE KEY-----/m
    },
    {
      type: "PKCS1-RSA",
      re: /-----BEGIN RSA PRIVATE KEY-----(?<body>[\s\S]+?)-----END RSA PRIVATE KEY-----/m
    },
    {
      type: "EC",
      re: /-----BEGIN EC PRIVATE KEY-----(?<body>[\s\S]+?)-----END EC PRIVATE KEY-----/m
    },
    {
      type: "DSA",
      re: /-----BEGIN DSA PRIVATE KEY-----(?<body>[\s\S]+?)-----END DSA PRIVATE KEY-----/m
    }
  ];
  for (const { type: type2, re: re2 } of patterns) {
    const m = text.match(re2);
    if (m && m.groups && m.groups["body"]) {
      blocks.push({ type: type2, body: m.groups["body"] });
      break;
    }
  }
  if (blocks.length === 0) return null;
  const { type, body } = blocks[0];
  const b64 = body.replace(/\s+/g, "");
  let bytes;
  try {
    if (typeof atob === "function") {
      const bin = atob(b64);
      bytes = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    } else if (typeof globalThis !== "undefined" && globalThis["Buffer"]) {
      const B = globalThis["Buffer"];
      const buf = B.from(b64, "base64");
      bytes = buf instanceof Uint8Array ? buf : new Uint8Array(buf);
    } else {
      return null;
    }
  } catch {
    return null;
  }
  if (type === "OPENSSH") {
    const magic = "openssh-key-v1\0";
    const prefix = new TextDecoder().decode(bytes.slice(0, magic.length));
    if (prefix === magic) return { format: "OPENSSH" };
    return null;
  }
  if (bytes.length >= 2 && bytes[0] === 48) {
    return { format: type };
  }
  return null;
}
const $RAW = Symbol("store-raw"), $NODE = Symbol("store-node"), $HAS = Symbol("store-has"), $SELF = Symbol("store-self");
function wrap$1(value2) {
  let p = value2[$PROXY];
  if (!p) {
    Object.defineProperty(value2, $PROXY, {
      value: p = new Proxy(value2, proxyTraps$1)
    });
    if (!Array.isArray(value2)) {
      const keys = Object.keys(value2), desc = Object.getOwnPropertyDescriptors(value2);
      for (let i = 0, l = keys.length; i < l; i++) {
        const prop = keys[i];
        if (desc[prop].get) {
          Object.defineProperty(value2, prop, {
            enumerable: desc[prop].enumerable,
            get: desc[prop].get.bind(p)
          });
        }
      }
    }
  }
  return p;
}
function isWrappable(obj) {
  let proto;
  return obj != null && typeof obj === "object" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));
}
function unwrap(item, set = /* @__PURE__ */ new Set()) {
  let result, unwrapped, v, prop;
  if (result = item != null && item[$RAW]) return result;
  if (!isWrappable(item) || set.has(item)) return item;
  if (Array.isArray(item)) {
    if (Object.isFrozen(item)) item = item.slice(0);
    else set.add(item);
    for (let i = 0, l = item.length; i < l; i++) {
      v = item[i];
      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;
    }
  } else {
    if (Object.isFrozen(item)) item = Object.assign({}, item);
    else set.add(item);
    const keys = Object.keys(item), desc = Object.getOwnPropertyDescriptors(item);
    for (let i = 0, l = keys.length; i < l; i++) {
      prop = keys[i];
      if (desc[prop].get) continue;
      v = item[prop];
      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;
    }
  }
  return item;
}
function getNodes(target, symbol) {
  let nodes = target[symbol];
  if (!nodes) Object.defineProperty(target, symbol, {
    value: nodes = /* @__PURE__ */ Object.create(null)
  });
  return nodes;
}
function getNode(nodes, property, value2) {
  if (nodes[property]) return nodes[property];
  const [s, set] = createSignal(value2, {
    equals: false,
    internal: true
  });
  s.$ = set;
  return nodes[property] = s;
}
function proxyDescriptor$1(target, property) {
  const desc = Reflect.getOwnPropertyDescriptor(target, property);
  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE) return desc;
  delete desc.value;
  delete desc.writable;
  desc.get = () => target[$PROXY][property];
  return desc;
}
function trackSelf(target) {
  getListener() && getNode(getNodes(target, $NODE), $SELF)();
}
function ownKeys(target) {
  trackSelf(target);
  return Reflect.ownKeys(target);
}
const proxyTraps$1 = {
  get(target, property, receiver) {
    if (property === $RAW) return target;
    if (property === $PROXY) return receiver;
    if (property === $TRACK) {
      trackSelf(target);
      return receiver;
    }
    const nodes = getNodes(target, $NODE);
    const tracked = nodes[property];
    let value2 = tracked ? tracked() : target[property];
    if (property === $NODE || property === $HAS || property === "__proto__") return value2;
    if (!tracked) {
      const desc = Object.getOwnPropertyDescriptor(target, property);
      if (getListener() && (typeof value2 !== "function" || target.hasOwnProperty(property)) && !(desc && desc.get)) value2 = getNode(nodes, property, value2)();
    }
    return isWrappable(value2) ? wrap$1(value2) : value2;
  },
  has(target, property) {
    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === "__proto__") return true;
    getListener() && getNode(getNodes(target, $HAS), property)();
    return property in target;
  },
  set() {
    return true;
  },
  deleteProperty() {
    return true;
  },
  ownKeys,
  getOwnPropertyDescriptor: proxyDescriptor$1
};
function setProperty(state2, property, value2, deleting = false) {
  if (!deleting && state2[property] === value2) return;
  const prev = state2[property], len = state2.length;
  if (value2 === void 0) {
    delete state2[property];
    if (state2[$HAS] && state2[$HAS][property] && prev !== void 0) state2[$HAS][property].$();
  } else {
    state2[property] = value2;
    if (state2[$HAS] && state2[$HAS][property] && prev === void 0) state2[$HAS][property].$();
  }
  let nodes = getNodes(state2, $NODE), node;
  if (node = getNode(nodes, property, prev)) node.$(() => value2);
  if (Array.isArray(state2) && state2.length !== len) {
    for (let i = state2.length; i < len; i++) (node = nodes[i]) && node.$();
    (node = getNode(nodes, "length", len)) && node.$(state2.length);
  }
  (node = nodes[$SELF]) && node.$();
}
function mergeStoreNode(state2, value2) {
  const keys = Object.keys(value2);
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    setProperty(state2, key, value2[key]);
  }
}
function updateArray(current, next) {
  if (typeof next === "function") next = next(current);
  next = unwrap(next);
  if (Array.isArray(next)) {
    if (current === next) return;
    let i = 0, len = next.length;
    for (; i < len; i++) {
      const value2 = next[i];
      if (current[i] !== value2) setProperty(current, i, value2);
    }
    setProperty(current, "length", len);
  } else mergeStoreNode(current, next);
}
function updatePath(current, path, traversed = []) {
  let part, prev = current;
  if (path.length > 1) {
    part = path.shift();
    const partType = typeof part, isArray = Array.isArray(current);
    if (Array.isArray(part)) {
      for (let i = 0; i < part.length; i++) {
        updatePath(current, [part[i]].concat(path), traversed);
      }
      return;
    } else if (isArray && partType === "function") {
      for (let i = 0; i < current.length; i++) {
        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);
      }
      return;
    } else if (isArray && partType === "object") {
      const {
        from = 0,
        to = current.length - 1,
        by = 1
      } = part;
      for (let i = from; i <= to; i += by) {
        updatePath(current, [i].concat(path), traversed);
      }
      return;
    } else if (path.length > 1) {
      updatePath(current[part], path, [part].concat(traversed));
      return;
    }
    prev = current[part];
    traversed = [part].concat(traversed);
  }
  let value2 = path[0];
  if (typeof value2 === "function") {
    value2 = value2(prev, traversed);
    if (value2 === prev) return;
  }
  if (part === void 0 && value2 == void 0) return;
  value2 = unwrap(value2);
  if (part === void 0 || isWrappable(prev) && isWrappable(value2) && !Array.isArray(value2)) {
    mergeStoreNode(prev, value2);
  } else setProperty(current, part, value2);
}
function createStore(...[store, options]) {
  const unwrappedStore = unwrap(store || {});
  const isArray = Array.isArray(unwrappedStore);
  const wrappedStore = wrap$1(unwrappedStore);
  function setStore(...args) {
    batch(() => {
      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);
    });
  }
  return [wrappedStore, setStore];
}
createDebug("webssh2-client:state-solid");
const initialState = {
  allowReauth: false,
  allowReconnect: false,
  allowReplay: false,
  isBasicAuthCookiePresent: false,
  isConnecting: false,
  loggedData: false,
  reauthRequired: false,
  sessionLogEnable: false,
  term: null
};
const [state, setState] = createStore(initialState);
const [sessionFooter$1, setSessionFooter$1] = createSignal(
  null
);
const [errorMessage, setErrorMessage] = createSignal(null);
const [isLoginDialogOpen, setIsLoginDialogOpen] = createSignal(false);
const [isErrorDialogOpen, setIsErrorDialogOpen] = createSignal(false);
const [isTerminalSettingsOpen, setIsTerminalSettingsOpen] = createSignal(false);
const [showReconnectButton, setShowReconnectButton] = createSignal(false);
const [headerContent, setHeaderContent] = createSignal(null);
const [promptData, setPromptData] = createSignal(null);
const debug$8 = createDebug("webssh2-client:browser-utils");
function triggerDownload(blob, filename) {
  debug$8(`triggerDownload: ${filename}`);
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(link.href);
}
const debug$7 = createDebug("webssh2-client:logging-service");
const LOG_KEY = "webssh2_session_log";
const LOG_DATE_KEY = "webssh2_session_log_date";
let sessionFooter = null;
class LoggingServiceImpl {
  // Reactive computations
  hasLogData = createMemo(() => {
    return state.loggedData;
  });
  isLogging = () => state.sessionLogEnable;
  setSessionFooter(footer) {
    sessionFooter = footer;
    debug$7("Session footer set:", footer);
  }
  addToLog(data) {
    if (!state.sessionLogEnable) return;
    let sessionLog = window.localStorage.getItem(LOG_KEY) || "";
    const isNewLog = sessionLog === "";
    sessionLog += data;
    window.localStorage.setItem(LOG_KEY, sessionLog);
    if (isNewLog) {
      setState("loggedData", true);
      debug$7("Started logging session");
    }
  }
  startLogging() {
    debug$7("Starting log session");
    setState("sessionLogEnable", true);
    setState("loggedData", true);
    const footer = sessionFooter ?? "";
    const logStartMessage = `Log Start for ${footer} - ${formatDate(/* @__PURE__ */ new Date())}\r
\r
`;
    let sessionLog = window.localStorage.getItem(LOG_KEY) || "";
    sessionLog += logStartMessage;
    window.localStorage.setItem(LOG_KEY, sessionLog);
    window.localStorage.setItem(LOG_DATE_KEY, (/* @__PURE__ */ new Date()).toISOString());
    debug$7("Log session started");
  }
  stopLogging() {
    debug$7("Stopping log session");
    setState("sessionLogEnable", false);
    const hasLogData2 = !!window.localStorage.getItem(LOG_KEY);
    if (hasLogData2) {
      const footer = sessionFooter ?? "";
      const logEndMessage = `\r
\r
Log End for ${footer} - ${formatDate(/* @__PURE__ */ new Date())}\r
`;
      let sessionLog = window.localStorage.getItem(LOG_KEY) || "";
      sessionLog += logEndMessage;
      window.localStorage.setItem(LOG_KEY, sessionLog);
      debug$7("Log session stopped with end message");
    }
  }
  clearLog() {
    const sessionLog = window.localStorage.getItem(LOG_KEY);
    if (!sessionLog) {
      debug$7("No session log found to clear");
      return;
    }
    const deleteLog = window.confirm("Clear the session log?");
    if (deleteLog) {
      window.localStorage.removeItem(LOG_KEY);
      window.localStorage.removeItem(LOG_DATE_KEY);
      setState("loggedData", false);
      debug$7("Session log cleared from localStorage");
    }
  }
  downloadLog() {
    const sessionLog = window.localStorage.getItem(LOG_KEY);
    const hasLogData2 = !!sessionLog;
    if (!sessionLog || !hasLogData2) {
      debug$7("No log data available for download");
      return;
    }
    const autoDownload = window.confirm(
      "Would you like to download the session log?"
    );
    if (!autoDownload) return;
    const filename = `WebSSH2-${formatDate(/* @__PURE__ */ new Date()).replace(/[/:\s@]/g, "")}.log`;
    const blob = new Blob([sessionLog], { type: "text/plain" });
    try {
      triggerDownload(blob, filename);
      debug$7("Log downloaded successfully");
      const isLogging2 = state.sessionLogEnable;
      if (!isLogging2) {
        window.localStorage.removeItem(LOG_KEY);
        window.localStorage.removeItem(LOG_DATE_KEY);
        setState("loggedData", false);
        debug$7(
          "Log cleared from localStorage after download (logging was stopped)"
        );
      } else {
        window.localStorage.setItem(LOG_DATE_KEY, (/* @__PURE__ */ new Date()).toISOString());
        debug$7("Log kept in localStorage (logging is still active)");
      }
    } catch (error) {
      console.error("Failed to download session log:", error);
      triggerDownload(blob, filename);
      window.localStorage.removeItem(LOG_KEY);
      window.localStorage.removeItem(LOG_DATE_KEY);
      setState("loggedData", false);
    }
  }
  checkSavedLog() {
    const savedLog = window.localStorage.getItem(LOG_KEY);
    const savedDate = window.localStorage.getItem(LOG_DATE_KEY);
    if (savedLog && savedDate) {
      const restoreLog = window.confirm(
        `A saved session log from ${new Date(savedDate).toLocaleString()} was found. Would you like to download it?`
      );
      if (restoreLog) {
        const filename = `WebSSH2-Recovered-${formatDate(new Date(savedDate)).replace(/[/:\s@]/g, "")}.log`;
        const blob = new Blob([savedLog], { type: "text/plain" });
        triggerDownload(blob, filename);
        window.localStorage.removeItem(LOG_KEY);
        window.localStorage.removeItem(LOG_DATE_KEY);
        setState("loggedData", false);
        debug$7("Recovered log downloaded and cleared");
      } else {
        setState("loggedData", true);
        debug$7("Recovered log kept, state updated");
      }
    }
  }
}
const loggingService = new LoggingServiceImpl();
const {
  hasLogData,
  isLogging,
  startLogging,
  stopLogging,
  clearLog,
  downloadLog,
  addToLog,
  checkSavedLog,
  setSessionFooter
} = loggingService;
var addonFit = { exports: {} };
var hasRequiredAddonFit;
function requireAddonFit() {
  if (hasRequiredAddonFit) return addonFit.exports;
  hasRequiredAddonFit = 1;
  (function(module, exports) {
    !(function(e, t) {
      module.exports = t();
    })(self, (() => (() => {
      var e = {};
      return (() => {
        var t = e;
        Object.defineProperty(t, "__esModule", { value: true }), t.FitAddon = void 0, t.FitAddon = class {
          activate(e2) {
            this._terminal = e2;
          }
          dispose() {
          }
          fit() {
            const e2 = this.proposeDimensions();
            if (!e2 || !this._terminal || isNaN(e2.cols) || isNaN(e2.rows)) return;
            const t2 = this._terminal._core;
            this._terminal.rows === e2.rows && this._terminal.cols === e2.cols || (t2._renderService.clear(), this._terminal.resize(e2.cols, e2.rows));
          }
          proposeDimensions() {
            if (!this._terminal) return;
            if (!this._terminal.element || !this._terminal.element.parentElement) return;
            const e2 = this._terminal._core, t2 = e2._renderService.dimensions;
            if (0 === t2.css.cell.width || 0 === t2.css.cell.height) return;
            const r = 0 === this._terminal.options.scrollback ? 0 : e2.viewport.scrollBarWidth, i = window.getComputedStyle(this._terminal.element.parentElement), o = parseInt(i.getPropertyValue("height")), s = Math.max(0, parseInt(i.getPropertyValue("width"))), n = window.getComputedStyle(this._terminal.element), l = o - (parseInt(n.getPropertyValue("padding-top")) + parseInt(n.getPropertyValue("padding-bottom"))), a = s - (parseInt(n.getPropertyValue("padding-right")) + parseInt(n.getPropertyValue("padding-left"))) - r;
            return { cols: Math.max(2, Math.floor(a / t2.css.cell.width)), rows: Math.max(1, Math.floor(l / t2.css.cell.height)) };
          }
        };
      })(), e;
    })()));
  })(addonFit);
  return addonFit.exports;
}
var addonFitExports = requireAddonFit();
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled = function(promises$2) {
      return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
        status: "fulfilled",
        value: value$1
      }), (reason) => ({
        status: "rejected",
        reason
      }))));
    };
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = allSettled(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen) return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      if (isBaseRelative) for (let i$1 = links.length - 1; i$1 >= 0; i$1--) {
        const link$1 = links[i$1];
        if (link$1.href === dep && (!isCss || link$1.rel === "stylesheet")) return;
      }
      else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) link.as = "script";
      link.crossOrigin = "";
      link.href = dep;
      if (cspNonce) link.setAttribute("nonce", cspNonce);
      document.head.appendChild(link);
      if (isCss) return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
      });
    }));
  }
  function handlePreloadError(err$2) {
    const e$1 = new Event("vite:preloadError", { cancelable: true });
    e$1.payload = err$2;
    window.dispatchEvent(e$1);
    if (!e$1.defaultPrevented) throw err$2;
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
var xterm$1 = { exports: {} };
var hasRequiredXterm;
function requireXterm() {
  if (hasRequiredXterm) return xterm$1.exports;
  hasRequiredXterm = 1;
  (function(module, exports) {
    !(function(e, t) {
      module.exports = t();
    })(globalThis, (() => (() => {
      var e = { 4567: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.AccessibilityManager = void 0;
        const n = i2(9042), o = i2(9924), a = i2(844), h = i2(4725), c = i2(2585), l = i2(3656);
        let d = t2.AccessibilityManager = class extends a.Disposable {
          constructor(e3, t3, i3, s3) {
            super(), this._terminal = e3, this._coreBrowserService = i3, this._renderService = s3, this._rowColumns = /* @__PURE__ */ new WeakMap(), this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = this._coreBrowserService.mainDocument.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = this._coreBrowserService.mainDocument.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
            for (let e4 = 0; e4 < this._terminal.rows; e4++) this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
            if (this._topBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 0), this._bottomBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = this._coreBrowserService.mainDocument.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new o.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element) throw new Error("Cannot enable accessibility before Terminal.open");
            this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize(((e4) => this._handleResize(e4.rows)))), this.register(this._terminal.onRender(((e4) => this._refreshRows(e4.start, e4.end)))), this.register(this._terminal.onScroll((() => this._refreshRows()))), this.register(this._terminal.onA11yChar(((e4) => this._handleChar(e4)))), this.register(this._terminal.onLineFeed((() => this._handleChar("\n")))), this.register(this._terminal.onA11yTab(((e4) => this._handleTab(e4)))), this.register(this._terminal.onKey(((e4) => this._handleKey(e4.key)))), this.register(this._terminal.onBlur((() => this._clearLiveRegion()))), this.register(this._renderService.onDimensionsChange((() => this._refreshRowsDimensions()))), this.register((0, l.addDisposableDomListener)(document, "selectionchange", (() => this._handleSelectionChange()))), this.register(this._coreBrowserService.onDprChange((() => this._refreshRowsDimensions()))), this._refreshRows(), this.register((0, a.toDisposable)((() => {
              this._accessibilityContainer.remove(), this._rowElements.length = 0;
            })));
          }
          _handleTab(e3) {
            for (let t3 = 0; t3 < e3; t3++) this._handleChar(" ");
          }
          _handleChar(e3) {
            this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== e3 && (this._charsToAnnounce += e3) : this._charsToAnnounce += e3, "\n" === e3 && (this._liveRegionLineCount++, 21 === this._liveRegionLineCount && (this._liveRegion.textContent += n.tooMuchOutput)));
          }
          _clearLiveRegion() {
            this._liveRegion.textContent = "", this._liveRegionLineCount = 0;
          }
          _handleKey(e3) {
            this._clearLiveRegion(), new RegExp("\\p{Control}", "u").test(e3) || this._charsToConsume.push(e3);
          }
          _refreshRows(e3, t3) {
            this._liveRegionDebouncer.refresh(e3, t3, this._terminal.rows);
          }
          _renderRows(e3, t3) {
            const i3 = this._terminal.buffer, s3 = i3.lines.length.toString();
            for (let r2 = e3; r2 <= t3; r2++) {
              const e4 = i3.lines.get(i3.ydisp + r2), t4 = [], n2 = e4?.translateToString(true, void 0, void 0, t4) || "", o2 = (i3.ydisp + r2 + 1).toString(), a2 = this._rowElements[r2];
              a2 && (0 === n2.length ? (a2.innerText = "", this._rowColumns.set(a2, [0, 1])) : (a2.textContent = n2, this._rowColumns.set(a2, t4)), a2.setAttribute("aria-posinset", o2), a2.setAttribute("aria-setsize", s3));
            }
            this._announceCharacters();
          }
          _announceCharacters() {
            0 !== this._charsToAnnounce.length && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
          }
          _handleBoundaryFocus(e3, t3) {
            const i3 = e3.target, s3 = this._rowElements[0 === t3 ? 1 : this._rowElements.length - 2];
            if (i3.getAttribute("aria-posinset") === (0 === t3 ? "1" : `${this._terminal.buffer.lines.length}`)) return;
            if (e3.relatedTarget !== s3) return;
            let r2, n2;
            if (0 === t3 ? (r2 = i3, n2 = this._rowElements.pop(), this._rowContainer.removeChild(n2)) : (r2 = this._rowElements.shift(), n2 = i3, this._rowContainer.removeChild(r2)), r2.removeEventListener("focus", this._topBoundaryFocusListener), n2.removeEventListener("focus", this._bottomBoundaryFocusListener), 0 === t3) {
              const e4 = this._createAccessibilityTreeNode();
              this._rowElements.unshift(e4), this._rowContainer.insertAdjacentElement("afterbegin", e4);
            } else {
              const e4 = this._createAccessibilityTreeNode();
              this._rowElements.push(e4), this._rowContainer.appendChild(e4);
            }
            this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(0 === t3 ? -1 : 1), this._rowElements[0 === t3 ? 1 : this._rowElements.length - 2].focus(), e3.preventDefault(), e3.stopImmediatePropagation();
          }
          _handleSelectionChange() {
            if (0 === this._rowElements.length) return;
            const e3 = document.getSelection();
            if (!e3) return;
            if (e3.isCollapsed) return void (this._rowContainer.contains(e3.anchorNode) && this._terminal.clearSelection());
            if (!e3.anchorNode || !e3.focusNode) return void console.error("anchorNode and/or focusNode are null");
            let t3 = { node: e3.anchorNode, offset: e3.anchorOffset }, i3 = { node: e3.focusNode, offset: e3.focusOffset };
            if ((t3.node.compareDocumentPosition(i3.node) & Node.DOCUMENT_POSITION_PRECEDING || t3.node === i3.node && t3.offset > i3.offset) && ([t3, i3] = [i3, t3]), t3.node.compareDocumentPosition(this._rowElements[0]) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING) && (t3 = { node: this._rowElements[0].childNodes[0], offset: 0 }), !this._rowContainer.contains(t3.node)) return;
            const s3 = this._rowElements.slice(-1)[0];
            if (i3.node.compareDocumentPosition(s3) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_PRECEDING) && (i3 = { node: s3, offset: s3.textContent?.length ?? 0 }), !this._rowContainer.contains(i3.node)) return;
            const r2 = ({ node: e4, offset: t4 }) => {
              const i4 = e4 instanceof Text ? e4.parentNode : e4;
              let s4 = parseInt(i4?.getAttribute("aria-posinset"), 10) - 1;
              if (isNaN(s4)) return console.warn("row is invalid. Race condition?"), null;
              const r3 = this._rowColumns.get(i4);
              if (!r3) return console.warn("columns is null. Race condition?"), null;
              let n3 = t4 < r3.length ? r3[t4] : r3.slice(-1)[0] + 1;
              return n3 >= this._terminal.cols && (++s4, n3 = 0), { row: s4, column: n3 };
            }, n2 = r2(t3), o2 = r2(i3);
            if (n2 && o2) {
              if (n2.row > o2.row || n2.row === o2.row && n2.column >= o2.column) throw new Error("invalid range");
              this._terminal.select(n2.column, n2.row, (o2.row - n2.row) * this._terminal.cols - n2.column + o2.column);
            }
          }
          _handleResize(e3) {
            this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
            for (let e4 = this._rowContainer.children.length; e4 < this._terminal.rows; e4++) this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
            for (; this._rowElements.length > e3; ) this._rowContainer.removeChild(this._rowElements.pop());
            this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
          }
          _createAccessibilityTreeNode() {
            const e3 = this._coreBrowserService.mainDocument.createElement("div");
            return e3.setAttribute("role", "listitem"), e3.tabIndex = -1, this._refreshRowDimensions(e3), e3;
          }
          _refreshRowsDimensions() {
            if (this._renderService.dimensions.css.cell.height) {
              this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
              for (let e3 = 0; e3 < this._terminal.rows; e3++) this._refreshRowDimensions(this._rowElements[e3]);
            }
          }
          _refreshRowDimensions(e3) {
            e3.style.height = `${this._renderService.dimensions.css.cell.height}px`;
          }
        };
        t2.AccessibilityManager = d = s2([r(1, c.IInstantiationService), r(2, h.ICoreBrowserService), r(3, h.IRenderService)], d);
      }, 3614: (e2, t2) => {
        function i2(e3) {
          return e3.replace(/\r?\n/g, "\r");
        }
        function s2(e3, t3) {
          return t3 ? "\x1B[200~" + e3 + "\x1B[201~" : e3;
        }
        function r(e3, t3, r2, n2) {
          e3 = s2(e3 = i2(e3), r2.decPrivateModes.bracketedPasteMode && true !== n2.rawOptions.ignoreBracketedPasteMode), r2.triggerDataEvent(e3, true), t3.value = "";
        }
        function n(e3, t3, i3) {
          const s3 = i3.getBoundingClientRect(), r2 = e3.clientX - s3.left - 10, n2 = e3.clientY - s3.top - 10;
          t3.style.width = "20px", t3.style.height = "20px", t3.style.left = `${r2}px`, t3.style.top = `${n2}px`, t3.style.zIndex = "1000", t3.focus();
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.rightClickHandler = t2.moveTextAreaUnderMouseCursor = t2.paste = t2.handlePasteEvent = t2.copyHandler = t2.bracketTextForPaste = t2.prepareTextForTerminal = void 0, t2.prepareTextForTerminal = i2, t2.bracketTextForPaste = s2, t2.copyHandler = function(e3, t3) {
          e3.clipboardData && e3.clipboardData.setData("text/plain", t3.selectionText), e3.preventDefault();
        }, t2.handlePasteEvent = function(e3, t3, i3, s3) {
          e3.stopPropagation(), e3.clipboardData && r(e3.clipboardData.getData("text/plain"), t3, i3, s3);
        }, t2.paste = r, t2.moveTextAreaUnderMouseCursor = n, t2.rightClickHandler = function(e3, t3, i3, s3, r2) {
          n(e3, t3, i3), r2 && s3.rightClickSelect(e3), t3.value = s3.selectionText, t3.select();
        };
      }, 7239: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorContrastCache = void 0;
        const s2 = i2(1505);
        t2.ColorContrastCache = class {
          constructor() {
            this._color = new s2.TwoKeyMap(), this._css = new s2.TwoKeyMap();
          }
          setCss(e3, t3, i3) {
            this._css.set(e3, t3, i3);
          }
          getCss(e3, t3) {
            return this._css.get(e3, t3);
          }
          setColor(e3, t3, i3) {
            this._color.set(e3, t3, i3);
          }
          getColor(e3, t3) {
            return this._color.get(e3, t3);
          }
          clear() {
            this._color.clear(), this._css.clear();
          }
        };
      }, 3656: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.addDisposableDomListener = void 0, t2.addDisposableDomListener = function(e3, t3, i2, s2) {
          e3.addEventListener(t3, i2, s2);
          let r = false;
          return { dispose: () => {
            r || (r = true, e3.removeEventListener(t3, i2, s2));
          } };
        };
      }, 3551: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Linkifier = void 0;
        const n = i2(3656), o = i2(8460), a = i2(844), h = i2(2585), c = i2(4725);
        let l = t2.Linkifier = class extends a.Disposable {
          get currentLink() {
            return this._currentLink;
          }
          constructor(e3, t3, i3, s3, r2) {
            super(), this._element = e3, this._mouseService = t3, this._renderService = i3, this._bufferService = s3, this._linkProviderService = r2, this._linkCacheDisposables = [], this._isMouseOut = true, this._wasResized = false, this._activeLine = -1, this._onShowLinkUnderline = this.register(new o.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new o.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, a.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, a.toDisposable)((() => {
              this._lastMouseEvent = void 0, this._activeProviderReplies?.clear();
            }))), this.register(this._bufferService.onResize((() => {
              this._clearCurrentLink(), this._wasResized = true;
            }))), this.register((0, n.addDisposableDomListener)(this._element, "mouseleave", (() => {
              this._isMouseOut = true, this._clearCurrentLink();
            }))), this.register((0, n.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
          }
          _handleMouseMove(e3) {
            this._lastMouseEvent = e3;
            const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
            if (!t3) return;
            this._isMouseOut = false;
            const i3 = e3.composedPath();
            for (let e4 = 0; e4 < i3.length; e4++) {
              const t4 = i3[e4];
              if (t4.classList.contains("xterm")) break;
              if (t4.classList.contains("xterm-hover")) return;
            }
            this._lastBufferCell && t3.x === this._lastBufferCell.x && t3.y === this._lastBufferCell.y || (this._handleHover(t3), this._lastBufferCell = t3);
          }
          _handleHover(e3) {
            if (this._activeLine !== e3.y || this._wasResized) return this._clearCurrentLink(), this._askForLink(e3, false), void (this._wasResized = false);
            this._currentLink && this._linkAtPosition(this._currentLink.link, e3) || (this._clearCurrentLink(), this._askForLink(e3, true));
          }
          _askForLink(e3, t3) {
            this._activeProviderReplies && t3 || (this._activeProviderReplies?.forEach(((e4) => {
              e4?.forEach(((e5) => {
                e5.link.dispose && e5.link.dispose();
              }));
            })), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = e3.y);
            let i3 = false;
            for (const [s3, r2] of this._linkProviderService.linkProviders.entries()) if (t3) {
              const t4 = this._activeProviderReplies?.get(s3);
              t4 && (i3 = this._checkLinkProviderResult(s3, e3, i3));
            } else r2.provideLinks(e3.y, ((t4) => {
              if (this._isMouseOut) return;
              const r3 = t4?.map(((e4) => ({ link: e4 })));
              this._activeProviderReplies?.set(s3, r3), i3 = this._checkLinkProviderResult(s3, e3, i3), this._activeProviderReplies?.size === this._linkProviderService.linkProviders.length && this._removeIntersectingLinks(e3.y, this._activeProviderReplies);
            }));
          }
          _removeIntersectingLinks(e3, t3) {
            const i3 = /* @__PURE__ */ new Set();
            for (let s3 = 0; s3 < t3.size; s3++) {
              const r2 = t3.get(s3);
              if (r2) for (let t4 = 0; t4 < r2.length; t4++) {
                const s4 = r2[t4], n2 = s4.link.range.start.y < e3 ? 0 : s4.link.range.start.x, o2 = s4.link.range.end.y > e3 ? this._bufferService.cols : s4.link.range.end.x;
                for (let e4 = n2; e4 <= o2; e4++) {
                  if (i3.has(e4)) {
                    r2.splice(t4--, 1);
                    break;
                  }
                  i3.add(e4);
                }
              }
            }
          }
          _checkLinkProviderResult(e3, t3, i3) {
            if (!this._activeProviderReplies) return i3;
            const s3 = this._activeProviderReplies.get(e3);
            let r2 = false;
            for (let t4 = 0; t4 < e3; t4++) this._activeProviderReplies.has(t4) && !this._activeProviderReplies.get(t4) || (r2 = true);
            if (!r2 && s3) {
              const e4 = s3.find(((e5) => this._linkAtPosition(e5.link, t3)));
              e4 && (i3 = true, this._handleNewLink(e4));
            }
            if (this._activeProviderReplies.size === this._linkProviderService.linkProviders.length && !i3) for (let e4 = 0; e4 < this._activeProviderReplies.size; e4++) {
              const s4 = this._activeProviderReplies.get(e4)?.find(((e5) => this._linkAtPosition(e5.link, t3)));
              if (s4) {
                i3 = true, this._handleNewLink(s4);
                break;
              }
            }
            return i3;
          }
          _handleMouseDown() {
            this._mouseDownLink = this._currentLink;
          }
          _handleMouseUp(e3) {
            if (!this._currentLink) return;
            const t3 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
            t3 && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, t3) && this._currentLink.link.activate(e3, this._currentLink.link.text);
          }
          _clearCurrentLink(e3, t3) {
            this._currentLink && this._lastMouseEvent && (!e3 || !t3 || this._currentLink.link.range.start.y >= e3 && this._currentLink.link.range.end.y <= t3) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, a.disposeArray)(this._linkCacheDisposables));
          }
          _handleNewLink(e3) {
            if (!this._lastMouseEvent) return;
            const t3 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
            t3 && this._linkAtPosition(e3.link, t3) && (this._currentLink = e3, this._currentLink.state = { decorations: { underline: void 0 === e3.link.decorations || e3.link.decorations.underline, pointerCursor: void 0 === e3.link.decorations || e3.link.decorations.pointerCursor }, isHovered: true }, this._linkHover(this._element, e3.link, this._lastMouseEvent), e3.link.decorations = {}, Object.defineProperties(e3.link.decorations, { pointerCursor: { get: () => this._currentLink?.state?.decorations.pointerCursor, set: (e4) => {
              this._currentLink?.state && this._currentLink.state.decorations.pointerCursor !== e4 && (this._currentLink.state.decorations.pointerCursor = e4, this._currentLink.state.isHovered && this._element.classList.toggle("xterm-cursor-pointer", e4));
            } }, underline: { get: () => this._currentLink?.state?.decorations.underline, set: (t4) => {
              this._currentLink?.state && this._currentLink?.state?.decorations.underline !== t4 && (this._currentLink.state.decorations.underline = t4, this._currentLink.state.isHovered && this._fireUnderlineEvent(e3.link, t4));
            } } }), this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange(((e4) => {
              if (!this._currentLink) return;
              const t4 = 0 === e4.start ? 0 : e4.start + 1 + this._bufferService.buffer.ydisp, i3 = this._bufferService.buffer.ydisp + 1 + e4.end;
              if (this._currentLink.link.range.start.y >= t4 && this._currentLink.link.range.end.y <= i3 && (this._clearCurrentLink(t4, i3), this._lastMouseEvent)) {
                const e5 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                e5 && this._askForLink(e5, false);
              }
            }))));
          }
          _linkHover(e3, t3, i3) {
            this._currentLink?.state && (this._currentLink.state.isHovered = true, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, true), this._currentLink.state.decorations.pointerCursor && e3.classList.add("xterm-cursor-pointer")), t3.hover && t3.hover(i3, t3.text);
          }
          _fireUnderlineEvent(e3, t3) {
            const i3 = e3.range, s3 = this._bufferService.buffer.ydisp, r2 = this._createLinkUnderlineEvent(i3.start.x - 1, i3.start.y - s3 - 1, i3.end.x, i3.end.y - s3 - 1, void 0);
            (t3 ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(r2);
          }
          _linkLeave(e3, t3, i3) {
            this._currentLink?.state && (this._currentLink.state.isHovered = false, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t3, false), this._currentLink.state.decorations.pointerCursor && e3.classList.remove("xterm-cursor-pointer")), t3.leave && t3.leave(i3, t3.text);
          }
          _linkAtPosition(e3, t3) {
            const i3 = e3.range.start.y * this._bufferService.cols + e3.range.start.x, s3 = e3.range.end.y * this._bufferService.cols + e3.range.end.x, r2 = t3.y * this._bufferService.cols + t3.x;
            return i3 <= r2 && r2 <= s3;
          }
          _positionFromMouseEvent(e3, t3, i3) {
            const s3 = i3.getCoords(e3, t3, this._bufferService.cols, this._bufferService.rows);
            if (s3) return { x: s3[0], y: s3[1] + this._bufferService.buffer.ydisp };
          }
          _createLinkUnderlineEvent(e3, t3, i3, s3, r2) {
            return { x1: e3, y1: t3, x2: i3, y2: s3, cols: this._bufferService.cols, fg: r2 };
          }
        };
        t2.Linkifier = l = s2([r(1, c.IMouseService), r(2, c.IRenderService), r(3, h.IBufferService), r(4, c.ILinkProviderService)], l);
      }, 9042: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.tooMuchOutput = t2.promptLabel = void 0, t2.promptLabel = "Terminal input", t2.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
      }, 3730: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkProvider = void 0;
        const n = i2(511), o = i2(2585);
        let a = t2.OscLinkProvider = class {
          constructor(e3, t3, i3) {
            this._bufferService = e3, this._optionsService = t3, this._oscLinkService = i3;
          }
          provideLinks(e3, t3) {
            const i3 = this._bufferService.buffer.lines.get(e3 - 1);
            if (!i3) return void t3(void 0);
            const s3 = [], r2 = this._optionsService.rawOptions.linkHandler, o2 = new n.CellData(), a2 = i3.getTrimmedLength();
            let c = -1, l = -1, d = false;
            for (let t4 = 0; t4 < a2; t4++) if (-1 !== l || i3.hasContent(t4)) {
              if (i3.loadCell(t4, o2), o2.hasExtendedAttrs() && o2.extended.urlId) {
                if (-1 === l) {
                  l = t4, c = o2.extended.urlId;
                  continue;
                }
                d = o2.extended.urlId !== c;
              } else -1 !== l && (d = true);
              if (d || -1 !== l && t4 === a2 - 1) {
                const i4 = this._oscLinkService.getLinkData(c)?.uri;
                if (i4) {
                  const n2 = { start: { x: l + 1, y: e3 }, end: { x: t4 + (d || t4 !== a2 - 1 ? 0 : 1), y: e3 } };
                  let o3 = false;
                  if (!r2?.allowNonHttpProtocols) try {
                    const e4 = new URL(i4);
                    ["http:", "https:"].includes(e4.protocol) || (o3 = true);
                  } catch (e4) {
                    o3 = true;
                  }
                  o3 || s3.push({ text: i4, range: n2, activate: (e4, t5) => r2 ? r2.activate(e4, t5, n2) : h(0, t5), hover: (e4, t5) => r2?.hover?.(e4, t5, n2), leave: (e4, t5) => r2?.leave?.(e4, t5, n2) });
                }
                d = false, o2.hasExtendedAttrs() && o2.extended.urlId ? (l = t4, c = o2.extended.urlId) : (l = -1, c = -1);
              }
            }
            t3(s3);
          }
        };
        function h(e3, t3) {
          if (confirm(`Do you want to navigate to ${t3}?

WARNING: This link could potentially be dangerous`)) {
            const e4 = window.open();
            if (e4) {
              try {
                e4.opener = null;
              } catch {
              }
              e4.location.href = t3;
            } else console.warn("Opening link blocked as opener could not be cleared");
          }
        }
        t2.OscLinkProvider = a = s2([r(0, o.IBufferService), r(1, o.IOptionsService), r(2, o.IOscLinkService)], a);
      }, 6193: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderDebouncer = void 0, t2.RenderDebouncer = class {
          constructor(e3, t3) {
            this._renderCallback = e3, this._coreBrowserService = t3, this._refreshCallbacks = [];
          }
          dispose() {
            this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
          }
          addRefreshCallback(e3) {
            return this._refreshCallbacks.push(e3), this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame((() => this._innerRefresh()))), this._animationFrame;
          }
          refresh(e3, t3, i2) {
            this._rowCount = i2, e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t3) : t3, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame((() => this._innerRefresh())));
          }
          _innerRefresh() {
            if (this._animationFrame = void 0, void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return void this._runRefreshCallbacks();
            const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t3), this._runRefreshCallbacks();
          }
          _runRefreshCallbacks() {
            for (const e3 of this._refreshCallbacks) e3(0);
            this._refreshCallbacks = [];
          }
        };
      }, 3236: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Terminal = void 0;
        const s2 = i2(3614), r = i2(3656), n = i2(3551), o = i2(9042), a = i2(3730), h = i2(1680), c = i2(3107), l = i2(5744), d = i2(2950), _ = i2(1296), u = i2(428), f = i2(4269), v = i2(5114), p = i2(8934), g = i2(3230), m = i2(9312), S = i2(4725), C = i2(6731), b2 = i2(8055), w = i2(8969), y = i2(8460), E = i2(844), k = i2(6114), L2 = i2(8437), D = i2(2584), R = i2(7399), x = i2(5941), A = i2(9074), B = i2(2585), T = i2(5435), M = i2(4567), O = i2(779);
        class P2 extends w.CoreTerminal {
          get onFocus() {
            return this._onFocus.event;
          }
          get onBlur() {
            return this._onBlur.event;
          }
          get onA11yChar() {
            return this._onA11yCharEmitter.event;
          }
          get onA11yTab() {
            return this._onA11yTabEmitter.event;
          }
          get onWillOpen() {
            return this._onWillOpen.event;
          }
          constructor(e3 = {}) {
            super(e3), this.browser = k, this._keyDownHandled = false, this._keyDownSeen = false, this._keyPressHandled = false, this._unprocessedDeadKey = false, this._accessibilityManager = this.register(new E.MutableDisposable()), this._onCursorMove = this.register(new y.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new y.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new y.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new y.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new y.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new y.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new y.EventEmitter()), this._onBlur = this.register(new y.EventEmitter()), this._onA11yCharEmitter = this.register(new y.EventEmitter()), this._onA11yTabEmitter = this.register(new y.EventEmitter()), this._onWillOpen = this.register(new y.EventEmitter()), this._setup(), this._decorationService = this._instantiationService.createInstance(A.DecorationService), this._instantiationService.setService(B.IDecorationService, this._decorationService), this._linkProviderService = this._instantiationService.createInstance(O.LinkProviderService), this._instantiationService.setService(S.ILinkProviderService, this._linkProviderService), this._linkProviderService.registerLinkProvider(this._instantiationService.createInstance(a.OscLinkProvider)), this.register(this._inputHandler.onRequestBell((() => this._onBell.fire()))), this.register(this._inputHandler.onRequestRefreshRows(((e4, t3) => this.refresh(e4, t3)))), this.register(this._inputHandler.onRequestSendFocus((() => this._reportFocus()))), this.register(this._inputHandler.onRequestReset((() => this.reset()))), this.register(this._inputHandler.onRequestWindowsOptionsReport(((e4) => this._reportWindowsOptions(e4)))), this.register(this._inputHandler.onColor(((e4) => this._handleColorEvent(e4)))), this.register((0, y.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, y.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, y.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, y.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize(((e4) => this._afterResize(e4.cols, e4.rows)))), this.register((0, E.toDisposable)((() => {
              this._customKeyEventHandler = void 0, this.element?.parentNode?.removeChild(this.element);
            })));
          }
          _handleColorEvent(e3) {
            if (this._themeService) for (const t3 of e3) {
              let e4, i3 = "";
              switch (t3.index) {
                case 256:
                  e4 = "foreground", i3 = "10";
                  break;
                case 257:
                  e4 = "background", i3 = "11";
                  break;
                case 258:
                  e4 = "cursor", i3 = "12";
                  break;
                default:
                  e4 = "ansi", i3 = "4;" + t3.index;
              }
              switch (t3.type) {
                case 0:
                  const s3 = b2.color.toColorRGB("ansi" === e4 ? this._themeService.colors.ansi[t3.index] : this._themeService.colors[e4]);
                  this.coreService.triggerDataEvent(`${D.C0.ESC}]${i3};${(0, x.toRgbString)(s3)}${D.C1_ESCAPED.ST}`);
                  break;
                case 1:
                  if ("ansi" === e4) this._themeService.modifyColors(((e5) => e5.ansi[t3.index] = b2.channels.toColor(...t3.color)));
                  else {
                    const i4 = e4;
                    this._themeService.modifyColors(((e5) => e5[i4] = b2.channels.toColor(...t3.color)));
                  }
                  break;
                case 2:
                  this._themeService.restoreColor(t3.index);
              }
            }
          }
          _setup() {
            super._setup(), this._customKeyEventHandler = void 0;
          }
          get buffer() {
            return this.buffers.active;
          }
          focus() {
            this.textarea && this.textarea.focus({ preventScroll: true });
          }
          _handleScreenReaderModeOptionChange(e3) {
            e3 ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)) : this._accessibilityManager.clear();
          }
          _handleTextAreaFocus(e3) {
            this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[I"), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
          }
          blur() {
            return this.textarea?.blur();
          }
          _handleTextAreaBlur() {
            this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
          }
          _syncTextArea() {
            if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return;
            const e3 = this.buffer.ybase + this.buffer.y, t3 = this.buffer.lines.get(e3);
            if (!t3) return;
            const i3 = Math.min(this.buffer.x, this.cols - 1), s3 = this._renderService.dimensions.css.cell.height, r2 = t3.getWidth(i3), n2 = this._renderService.dimensions.css.cell.width * r2, o2 = this.buffer.y * this._renderService.dimensions.css.cell.height, a2 = i3 * this._renderService.dimensions.css.cell.width;
            this.textarea.style.left = a2 + "px", this.textarea.style.top = o2 + "px", this.textarea.style.width = n2 + "px", this.textarea.style.height = s3 + "px", this.textarea.style.lineHeight = s3 + "px", this.textarea.style.zIndex = "-5";
          }
          _initGlobal() {
            this._bindKeys(), this.register((0, r.addDisposableDomListener)(this.element, "copy", ((e4) => {
              this.hasSelection() && (0, s2.copyHandler)(e4, this._selectionService);
            })));
            const e3 = (e4) => (0, s2.handlePasteEvent)(e4, this.textarea, this.coreService, this.optionsService);
            this.register((0, r.addDisposableDomListener)(this.textarea, "paste", e3)), this.register((0, r.addDisposableDomListener)(this.element, "paste", e3)), k.isFirefox ? this.register((0, r.addDisposableDomListener)(this.element, "mousedown", ((e4) => {
              2 === e4.button && (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            }))) : this.register((0, r.addDisposableDomListener)(this.element, "contextmenu", ((e4) => {
              (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
            }))), k.isLinux && this.register((0, r.addDisposableDomListener)(this.element, "auxclick", ((e4) => {
              1 === e4.button && (0, s2.moveTextAreaUnderMouseCursor)(e4, this.textarea, this.screenElement);
            })));
          }
          _bindKeys() {
            this.register((0, r.addDisposableDomListener)(this.textarea, "keyup", ((e3) => this._keyUp(e3)), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keydown", ((e3) => this._keyDown(e3)), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keypress", ((e3) => this._keyPress(e3)), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionstart", (() => this._compositionHelper.compositionstart()))), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionupdate", ((e3) => this._compositionHelper.compositionupdate(e3)))), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionend", (() => this._compositionHelper.compositionend()))), this.register((0, r.addDisposableDomListener)(this.textarea, "input", ((e3) => this._inputEvent(e3)), true)), this.register(this.onRender((() => this._compositionHelper.updateCompositionElements())));
          }
          open(e3) {
            if (!e3) throw new Error("Terminal requires a parent element.");
            if (e3.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), this.element?.ownerDocument.defaultView && this._coreBrowserService) return void (this.element.ownerDocument.defaultView !== this._coreBrowserService.window && (this._coreBrowserService.window = this.element.ownerDocument.defaultView));
            this._document = e3.ownerDocument, this.options.documentOverride && this.options.documentOverride instanceof Document && (this._document = this.optionsService.rawOptions.documentOverride), this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), e3.appendChild(this.element);
            const t3 = this._document.createDocumentFragment();
            this._viewportElement = this._document.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), t3.appendChild(this._viewportElement), this._viewportScrollArea = this._document.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = this._document.createElement("div"), this.screenElement.classList.add("xterm-screen"), this.register((0, r.addDisposableDomListener)(this.screenElement, "mousemove", ((e4) => this.updateCursorStyle(e4)))), this._helperContainer = this._document.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), t3.appendChild(this.screenElement), this.textarea = this._document.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", o.promptLabel), k.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this.register(this._instantiationService.createInstance(v.CoreBrowserService, this.textarea, e3.ownerDocument.defaultView ?? window, this._document ?? "undefined" != typeof window ? window.document : null)), this._instantiationService.setService(S.ICoreBrowserService, this._coreBrowserService), this.register((0, r.addDisposableDomListener)(this.textarea, "focus", ((e4) => this._handleTextAreaFocus(e4)))), this.register((0, r.addDisposableDomListener)(this.textarea, "blur", (() => this._handleTextAreaBlur()))), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(u.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(S.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(C.ThemeService), this._instantiationService.setService(S.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(f.CharacterJoinerService), this._instantiationService.setService(S.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(g.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(S.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange(((e4) => this._onRender.fire(e4)))), this.onResize(((e4) => this._renderService.resize(e4.cols, e4.rows))), this._compositionView = this._document.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(d.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this._mouseService = this._instantiationService.createInstance(p.MouseService), this._instantiationService.setService(S.IMouseService, this._mouseService), this.linkifier = this.register(this._instantiationService.createInstance(n.Linkifier, this.screenElement)), this.element.appendChild(t3);
            try {
              this._onWillOpen.fire(this.element);
            } catch {
            }
            this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this.viewport = this._instantiationService.createInstance(h.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines(((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent, 1))), this.register(this._inputHandler.onRequestSyncScrollBar((() => this.viewport.syncScrollArea()))), this.register(this.viewport), this.register(this.onCursorMove((() => {
              this._renderService.handleCursorMove(), this._syncTextArea();
            }))), this.register(this.onResize((() => this._renderService.handleResize(this.cols, this.rows)))), this.register(this.onBlur((() => this._renderService.handleBlur()))), this.register(this.onFocus((() => this._renderService.handleFocus()))), this.register(this._renderService.onDimensionsChange((() => this.viewport.syncScrollArea()))), this._selectionService = this.register(this._instantiationService.createInstance(m.SelectionService, this.element, this.screenElement, this.linkifier)), this._instantiationService.setService(S.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines(((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent)))), this.register(this._selectionService.onSelectionChange((() => this._onSelectionChange.fire()))), this.register(this._selectionService.onRequestRedraw(((e4) => this._renderService.handleSelectionChanged(e4.start, e4.end, e4.columnSelectMode)))), this.register(this._selectionService.onLinuxMouseSelection(((e4) => {
              this.textarea.value = e4, this.textarea.focus(), this.textarea.select();
            }))), this.register(this._onScroll.event(((e4) => {
              this.viewport.syncScrollArea(), this._selectionService.refresh();
            }))), this.register((0, r.addDisposableDomListener)(this._viewportElement, "scroll", (() => this._selectionService.refresh()))), this.register(this._instantiationService.createInstance(c.BufferDecorationRenderer, this.screenElement)), this.register((0, r.addDisposableDomListener)(this.element, "mousedown", ((e4) => this._selectionService.handleMouseDown(e4)))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", ((e4) => this._handleScreenReaderModeOptionChange(e4)))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", ((e4) => {
              !this._overviewRulerRenderer && e4 && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
            })), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
          }
          _createRenderer() {
            return this._instantiationService.createInstance(_.DomRenderer, this, this._document, this.element, this.screenElement, this._viewportElement, this._helperContainer, this.linkifier);
          }
          bindMouse() {
            const e3 = this, t3 = this.element;
            function i3(t4) {
              const i4 = e3._mouseService.getMouseReportCoords(t4, e3.screenElement);
              if (!i4) return false;
              let s4, r2;
              switch (t4.overrideType || t4.type) {
                case "mousemove":
                  r2 = 32, void 0 === t4.buttons ? (s4 = 3, void 0 !== t4.button && (s4 = t4.button < 3 ? t4.button : 3)) : s4 = 1 & t4.buttons ? 0 : 4 & t4.buttons ? 1 : 2 & t4.buttons ? 2 : 3;
                  break;
                case "mouseup":
                  r2 = 0, s4 = t4.button < 3 ? t4.button : 3;
                  break;
                case "mousedown":
                  r2 = 1, s4 = t4.button < 3 ? t4.button : 3;
                  break;
                case "wheel":
                  if (e3._customWheelEventHandler && false === e3._customWheelEventHandler(t4)) return false;
                  if (0 === e3.viewport.getLinesScrolled(t4)) return false;
                  r2 = t4.deltaY < 0 ? 0 : 1, s4 = 4;
                  break;
                default:
                  return false;
              }
              return !(void 0 === r2 || void 0 === s4 || s4 > 4) && e3.coreMouseService.triggerMouseEvent({ col: i4.col, row: i4.row, x: i4.x, y: i4.y, button: s4, action: r2, ctrl: t4.ctrlKey, alt: t4.altKey, shift: t4.shiftKey });
            }
            const s3 = { mouseup: null, wheel: null, mousedrag: null, mousemove: null }, n2 = { mouseup: (e4) => (i3(e4), e4.buttons || (this._document.removeEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.removeEventListener("mousemove", s3.mousedrag)), this.cancel(e4)), wheel: (e4) => (i3(e4), this.cancel(e4, true)), mousedrag: (e4) => {
              e4.buttons && i3(e4);
            }, mousemove: (e4) => {
              e4.buttons || i3(e4);
            } };
            this.register(this.coreMouseService.onProtocolChange(((e4) => {
              e4 ? ("debug" === this.optionsService.rawOptions.logLevel && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(e4)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & e4 ? s3.mousemove || (t3.addEventListener("mousemove", n2.mousemove), s3.mousemove = n2.mousemove) : (t3.removeEventListener("mousemove", s3.mousemove), s3.mousemove = null), 16 & e4 ? s3.wheel || (t3.addEventListener("wheel", n2.wheel, { passive: false }), s3.wheel = n2.wheel) : (t3.removeEventListener("wheel", s3.wheel), s3.wheel = null), 2 & e4 ? s3.mouseup || (s3.mouseup = n2.mouseup) : (this._document.removeEventListener("mouseup", s3.mouseup), s3.mouseup = null), 4 & e4 ? s3.mousedrag || (s3.mousedrag = n2.mousedrag) : (this._document.removeEventListener("mousemove", s3.mousedrag), s3.mousedrag = null);
            }))), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, r.addDisposableDomListener)(t3, "mousedown", ((e4) => {
              if (e4.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(e4)) return i3(e4), s3.mouseup && this._document.addEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.addEventListener("mousemove", s3.mousedrag), this.cancel(e4);
            }))), this.register((0, r.addDisposableDomListener)(t3, "wheel", ((e4) => {
              if (!s3.wheel) {
                if (this._customWheelEventHandler && false === this._customWheelEventHandler(e4)) return false;
                if (!this.buffer.hasScrollback) {
                  const t4 = this.viewport.getLinesScrolled(e4);
                  if (0 === t4) return;
                  const i4 = D.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (e4.deltaY < 0 ? "A" : "B");
                  let s4 = "";
                  for (let e5 = 0; e5 < Math.abs(t4); e5++) s4 += i4;
                  return this.coreService.triggerDataEvent(s4, true), this.cancel(e4, true);
                }
                return this.viewport.handleWheel(e4) ? this.cancel(e4) : void 0;
              }
            }), { passive: false })), this.register((0, r.addDisposableDomListener)(t3, "touchstart", ((e4) => {
              if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchStart(e4), this.cancel(e4);
            }), { passive: true })), this.register((0, r.addDisposableDomListener)(t3, "touchmove", ((e4) => {
              if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchMove(e4) ? void 0 : this.cancel(e4);
            }), { passive: false }));
          }
          refresh(e3, t3) {
            this._renderService?.refreshRows(e3, t3);
          }
          updateCursorStyle(e3) {
            this._selectionService?.shouldColumnSelect(e3) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
          }
          _showCursor() {
            this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = true, this.refresh(this.buffer.y, this.buffer.y));
          }
          scrollLines(e3, t3, i3 = 0) {
            1 === i3 ? (super.scrollLines(e3, t3, i3), this.refresh(0, this.rows - 1)) : this.viewport?.scrollLines(e3);
          }
          paste(e3) {
            (0, s2.paste)(e3, this.textarea, this.coreService, this.optionsService);
          }
          attachCustomKeyEventHandler(e3) {
            this._customKeyEventHandler = e3;
          }
          attachCustomWheelEventHandler(e3) {
            this._customWheelEventHandler = e3;
          }
          registerLinkProvider(e3) {
            return this._linkProviderService.registerLinkProvider(e3);
          }
          registerCharacterJoiner(e3) {
            if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
            const t3 = this._characterJoinerService.register(e3);
            return this.refresh(0, this.rows - 1), t3;
          }
          deregisterCharacterJoiner(e3) {
            if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
            this._characterJoinerService.deregister(e3) && this.refresh(0, this.rows - 1);
          }
          get markers() {
            return this.buffer.markers;
          }
          registerMarker(e3) {
            return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + e3);
          }
          registerDecoration(e3) {
            return this._decorationService.registerDecoration(e3);
          }
          hasSelection() {
            return !!this._selectionService && this._selectionService.hasSelection;
          }
          select(e3, t3, i3) {
            this._selectionService.setSelection(e3, t3, i3);
          }
          getSelection() {
            return this._selectionService ? this._selectionService.selectionText : "";
          }
          getSelectionPosition() {
            if (this._selectionService && this._selectionService.hasSelection) return { start: { x: this._selectionService.selectionStart[0], y: this._selectionService.selectionStart[1] }, end: { x: this._selectionService.selectionEnd[0], y: this._selectionService.selectionEnd[1] } };
          }
          clearSelection() {
            this._selectionService?.clearSelection();
          }
          selectAll() {
            this._selectionService?.selectAll();
          }
          selectLines(e3, t3) {
            this._selectionService?.selectLines(e3, t3);
          }
          _keyDown(e3) {
            if (this._keyDownHandled = false, this._keyDownSeen = true, this._customKeyEventHandler && false === this._customKeyEventHandler(e3)) return false;
            const t3 = this.browser.isMac && this.options.macOptionIsMeta && e3.altKey;
            if (!t3 && !this._compositionHelper.keydown(e3)) return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), false;
            t3 || "Dead" !== e3.key && "AltGraph" !== e3.key || (this._unprocessedDeadKey = true);
            const i3 = (0, R.evaluateKeyboardEvent)(e3, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
            if (this.updateCursorStyle(e3), 3 === i3.type || 2 === i3.type) {
              const t4 = this.rows - 1;
              return this.scrollLines(2 === i3.type ? -t4 : t4), this.cancel(e3, true);
            }
            return 1 === i3.type && this.selectAll(), !!this._isThirdLevelShift(this.browser, e3) || (i3.cancel && this.cancel(e3, true), !i3.key || !!(e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && 1 === e3.key.length && e3.key.charCodeAt(0) >= 65 && e3.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = false, true) : (i3.key !== D.C0.ETX && i3.key !== D.C0.CR || (this.textarea.value = ""), this._onKey.fire({ key: i3.key, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(i3.key, true), !this.optionsService.rawOptions.screenReaderMode || e3.altKey || e3.ctrlKey ? this.cancel(e3, true) : void (this._keyDownHandled = true))));
          }
          _isThirdLevelShift(e3, t3) {
            const i3 = e3.isMac && !this.options.macOptionIsMeta && t3.altKey && !t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.altKey && t3.ctrlKey && !t3.metaKey || e3.isWindows && t3.getModifierState("AltGraph");
            return "keypress" === t3.type ? i3 : i3 && (!t3.keyCode || t3.keyCode > 47);
          }
          _keyUp(e3) {
            this._keyDownSeen = false, this._customKeyEventHandler && false === this._customKeyEventHandler(e3) || ((function(e4) {
              return 16 === e4.keyCode || 17 === e4.keyCode || 18 === e4.keyCode;
            })(e3) || this.focus(), this.updateCursorStyle(e3), this._keyPressHandled = false);
          }
          _keyPress(e3) {
            let t3;
            if (this._keyPressHandled = false, this._keyDownHandled) return false;
            if (this._customKeyEventHandler && false === this._customKeyEventHandler(e3)) return false;
            if (this.cancel(e3), e3.charCode) t3 = e3.charCode;
            else if (null === e3.which || void 0 === e3.which) t3 = e3.keyCode;
            else {
              if (0 === e3.which || 0 === e3.charCode) return false;
              t3 = e3.which;
            }
            return !(!t3 || (e3.altKey || e3.ctrlKey || e3.metaKey) && !this._isThirdLevelShift(this.browser, e3) || (t3 = String.fromCharCode(t3), this._onKey.fire({ key: t3, domEvent: e3 }), this._showCursor(), this.coreService.triggerDataEvent(t3, true), this._keyPressHandled = true, this._unprocessedDeadKey = false, 0));
          }
          _inputEvent(e3) {
            if (e3.data && "insertText" === e3.inputType && (!e3.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
              if (this._keyPressHandled) return false;
              this._unprocessedDeadKey = false;
              const t3 = e3.data;
              return this.coreService.triggerDataEvent(t3, true), this.cancel(e3), true;
            }
            return false;
          }
          resize(e3, t3) {
            e3 !== this.cols || t3 !== this.rows ? super.resize(e3, t3) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
          }
          _afterResize(e3, t3) {
            this._charSizeService?.measure(), this.viewport?.syncScrollArea(true);
          }
          clear() {
            if (0 !== this.buffer.ybase || 0 !== this.buffer.y) {
              this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
              for (let e3 = 1; e3 < this.rows; e3++) this.buffer.lines.push(this.buffer.getBlankLine(L2.DEFAULT_ATTR_DATA));
              this._onScroll.fire({ position: this.buffer.ydisp, source: 0 }), this.viewport?.reset(), this.refresh(0, this.rows - 1);
            }
          }
          reset() {
            this.options.rows = this.rows, this.options.cols = this.cols;
            const e3 = this._customKeyEventHandler;
            this._setup(), super.reset(), this._selectionService?.reset(), this._decorationService.reset(), this.viewport?.reset(), this._customKeyEventHandler = e3, this.refresh(0, this.rows - 1);
          }
          clearTextureAtlas() {
            this._renderService?.clearTextureAtlas();
          }
          _reportFocus() {
            this.element?.classList.contains("focus") ? this.coreService.triggerDataEvent(D.C0.ESC + "[I") : this.coreService.triggerDataEvent(D.C0.ESC + "[O");
          }
          _reportWindowsOptions(e3) {
            if (this._renderService) switch (e3) {
              case T.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                const e4 = this._renderService.dimensions.css.canvas.width.toFixed(0), t3 = this._renderService.dimensions.css.canvas.height.toFixed(0);
                this.coreService.triggerDataEvent(`${D.C0.ESC}[4;${t3};${e4}t`);
                break;
              case T.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                const i3 = this._renderService.dimensions.css.cell.width.toFixed(0), s3 = this._renderService.dimensions.css.cell.height.toFixed(0);
                this.coreService.triggerDataEvent(`${D.C0.ESC}[6;${s3};${i3}t`);
            }
          }
          cancel(e3, t3) {
            if (this.options.cancelEvents || t3) return e3.preventDefault(), e3.stopPropagation(), false;
          }
        }
        t2.Terminal = P2;
      }, 9924: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TimeBasedDebouncer = void 0, t2.TimeBasedDebouncer = class {
          constructor(e3, t3 = 1e3) {
            this._renderCallback = e3, this._debounceThresholdMS = t3, this._lastRefreshMs = 0, this._additionalRefreshRequested = false;
          }
          dispose() {
            this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
          }
          refresh(e3, t3, i2) {
            this._rowCount = i2, e3 = void 0 !== e3 ? e3 : 0, t3 = void 0 !== t3 ? t3 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t3) : t3;
            const s2 = Date.now();
            if (s2 - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = s2, this._innerRefresh();
            else if (!this._additionalRefreshRequested) {
              const e4 = s2 - this._lastRefreshMs, t4 = this._debounceThresholdMS - e4;
              this._additionalRefreshRequested = true, this._refreshTimeoutID = window.setTimeout((() => {
                this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = false, this._refreshTimeoutID = void 0;
              }), t4);
            }
          }
          _innerRefresh() {
            if (void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return;
            const e3 = Math.max(this._rowStart, 0), t3 = Math.min(this._rowEnd, this._rowCount - 1);
            this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t3);
          }
        };
      }, 1680: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Viewport = void 0;
        const n = i2(3656), o = i2(4725), a = i2(8460), h = i2(844), c = i2(2585);
        let l = t2.Viewport = class extends h.Disposable {
          constructor(e3, t3, i3, s3, r2, o2, h2, c2) {
            super(), this._viewportElement = e3, this._scrollArea = t3, this._bufferService = i3, this._optionsService = s3, this._charSizeService = r2, this._renderService = o2, this._coreBrowserService = h2, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = false, this._smoothScrollState = { startTime: 0, origin: -1, target: -1 }, this._onRequestScrollLines = this.register(new a.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, n.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate(((e4) => this._activeBuffer = e4.activeBuffer))), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange(((e4) => this._renderDimensions = e4))), this._handleThemeChange(c2.colors), this.register(c2.onChangeColors(((e4) => this._handleThemeChange(e4)))), this.register(this._optionsService.onSpecificOptionChange("scrollback", (() => this.syncScrollArea()))), setTimeout((() => this.syncScrollArea()));
          }
          _handleThemeChange(e3) {
            this._viewportElement.style.backgroundColor = e3.background.css;
          }
          reset() {
            this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame((() => this.syncScrollArea()));
          }
          _refresh(e3) {
            if (e3) return this._innerRefresh(), void (null !== this._refreshAnimationFrame && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
            null === this._refreshAnimationFrame && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame((() => this._innerRefresh())));
          }
          _innerRefresh() {
            if (this._charSizeService.height > 0) {
              this._currentRowHeight = this._renderDimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderDimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
              const e4 = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderDimensions.css.canvas.height);
              this._lastRecordedBufferHeight !== e4 && (this._lastRecordedBufferHeight = e4, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
            }
            const e3 = this._bufferService.buffer.ydisp * this._currentRowHeight;
            this._viewportElement.scrollTop !== e3 && (this._ignoreNextScrollEvent = true, this._viewportElement.scrollTop = e3), this._refreshAnimationFrame = null;
          }
          syncScrollArea(e3 = false) {
            if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(e3);
            this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(e3);
          }
          _handleScroll(e3) {
            if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return;
            if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = false, void this._onRequestScrollLines.fire({ amount: 0, suppressScrollEvent: true });
            const t3 = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
            this._onRequestScrollLines.fire({ amount: t3, suppressScrollEvent: true });
          }
          _smoothScroll() {
            if (this._isDisposed || -1 === this._smoothScrollState.origin || -1 === this._smoothScrollState.target) return;
            const e3 = this._smoothScrollPercent();
            this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(e3 * (this._smoothScrollState.target - this._smoothScrollState.origin)), e3 < 1 ? this._coreBrowserService.window.requestAnimationFrame((() => this._smoothScroll())) : this._clearSmoothScrollState();
          }
          _smoothScrollPercent() {
            return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
          }
          _clearSmoothScrollState() {
            this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
          }
          _bubbleScroll(e3, t3) {
            const i3 = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
            return !(t3 < 0 && 0 !== this._viewportElement.scrollTop || t3 > 0 && i3 < this._lastRecordedBufferHeight) || (e3.cancelable && e3.preventDefault(), false);
          }
          handleWheel(e3) {
            const t3 = this._getPixelsScrolled(e3);
            return 0 !== t3 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, -1 === this._smoothScrollState.target ? this._smoothScrollState.target = this._viewportElement.scrollTop + t3 : this._smoothScrollState.target += t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
          }
          scrollLines(e3) {
            if (0 !== e3) if (this._optionsService.rawOptions.smoothScrollDuration) {
              const t3 = e3 * this._currentRowHeight;
              this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + t3, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
            } else this._onRequestScrollLines.fire({ amount: e3, suppressScrollEvent: false });
          }
          _getPixelsScrolled(e3) {
            if (0 === e3.deltaY || e3.shiftKey) return 0;
            let t3 = this._applyScrollModifier(e3.deltaY, e3);
            return e3.deltaMode === WheelEvent.DOM_DELTA_LINE ? t3 *= this._currentRowHeight : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._currentRowHeight * this._bufferService.rows), t3;
          }
          getBufferElements(e3, t3) {
            let i3, s3 = "";
            const r2 = [], n2 = t3 ?? this._bufferService.buffer.lines.length, o2 = this._bufferService.buffer.lines;
            for (let t4 = e3; t4 < n2; t4++) {
              const e4 = o2.get(t4);
              if (!e4) continue;
              const n3 = o2.get(t4 + 1)?.isWrapped;
              if (s3 += e4.translateToString(!n3), !n3 || t4 === o2.length - 1) {
                const e5 = document.createElement("div");
                e5.textContent = s3, r2.push(e5), s3.length > 0 && (i3 = e5), s3 = "";
              }
            }
            return { bufferElements: r2, cursorElement: i3 };
          }
          getLinesScrolled(e3) {
            if (0 === e3.deltaY || e3.shiftKey) return 0;
            let t3 = this._applyScrollModifier(e3.deltaY, e3);
            return e3.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t3 /= this._currentRowHeight + 0, this._wheelPartialScroll += t3, t3 = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t3 *= this._bufferService.rows), t3;
          }
          _applyScrollModifier(e3, t3) {
            const i3 = this._optionsService.rawOptions.fastScrollModifier;
            return "alt" === i3 && t3.altKey || "ctrl" === i3 && t3.ctrlKey || "shift" === i3 && t3.shiftKey ? e3 * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : e3 * this._optionsService.rawOptions.scrollSensitivity;
          }
          handleTouchStart(e3) {
            this._lastTouchY = e3.touches[0].pageY;
          }
          handleTouchMove(e3) {
            const t3 = this._lastTouchY - e3.touches[0].pageY;
            return this._lastTouchY = e3.touches[0].pageY, 0 !== t3 && (this._viewportElement.scrollTop += t3, this._bubbleScroll(e3, t3));
          }
        };
        t2.Viewport = l = s2([r(2, c.IBufferService), r(3, c.IOptionsService), r(4, o.ICharSizeService), r(5, o.IRenderService), r(6, o.ICoreBrowserService), r(7, o.IThemeService)], l);
      }, 3107: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferDecorationRenderer = void 0;
        const n = i2(4725), o = i2(844), a = i2(2585);
        let h = t2.BufferDecorationRenderer = class extends o.Disposable {
          constructor(e3, t3, i3, s3, r2) {
            super(), this._screenElement = e3, this._bufferService = t3, this._coreBrowserService = i3, this._decorationService = s3, this._renderService = r2, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = false, this._dimensionsChanged = false, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange((() => this._doRefreshDecorations()))), this.register(this._renderService.onDimensionsChange((() => {
              this._dimensionsChanged = true, this._queueRefresh();
            }))), this.register(this._coreBrowserService.onDprChange((() => this._queueRefresh()))), this.register(this._bufferService.buffers.onBufferActivate((() => {
              this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
            }))), this.register(this._decorationService.onDecorationRegistered((() => this._queueRefresh()))), this.register(this._decorationService.onDecorationRemoved(((e4) => this._removeDecoration(e4)))), this.register((0, o.toDisposable)((() => {
              this._container.remove(), this._decorationElements.clear();
            })));
          }
          _queueRefresh() {
            void 0 === this._animationFrame && (this._animationFrame = this._renderService.addRefreshCallback((() => {
              this._doRefreshDecorations(), this._animationFrame = void 0;
            })));
          }
          _doRefreshDecorations() {
            for (const e3 of this._decorationService.decorations) this._renderDecoration(e3);
            this._dimensionsChanged = false;
          }
          _renderDecoration(e3) {
            this._refreshStyle(e3), this._dimensionsChanged && this._refreshXPosition(e3);
          }
          _createElement(e3) {
            const t3 = this._coreBrowserService.mainDocument.createElement("div");
            t3.classList.add("xterm-decoration"), t3.classList.toggle("xterm-decoration-top-layer", "top" === e3?.options?.layer), t3.style.width = `${Math.round((e3.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, t3.style.height = (e3.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", t3.style.top = (e3.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", t3.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
            const i3 = e3.options.x ?? 0;
            return i3 && i3 > this._bufferService.cols && (t3.style.display = "none"), this._refreshXPosition(e3, t3), t3;
          }
          _refreshStyle(e3) {
            const t3 = e3.marker.line - this._bufferService.buffers.active.ydisp;
            if (t3 < 0 || t3 >= this._bufferService.rows) e3.element && (e3.element.style.display = "none", e3.onRenderEmitter.fire(e3.element));
            else {
              let i3 = this._decorationElements.get(e3);
              i3 || (i3 = this._createElement(e3), e3.element = i3, this._decorationElements.set(e3, i3), this._container.appendChild(i3), e3.onDispose((() => {
                this._decorationElements.delete(e3), i3.remove();
              }))), i3.style.top = t3 * this._renderService.dimensions.css.cell.height + "px", i3.style.display = this._altBufferIsActive ? "none" : "block", e3.onRenderEmitter.fire(i3);
            }
          }
          _refreshXPosition(e3, t3 = e3.element) {
            if (!t3) return;
            const i3 = e3.options.x ?? 0;
            "right" === (e3.options.anchor || "left") ? t3.style.right = i3 ? i3 * this._renderService.dimensions.css.cell.width + "px" : "" : t3.style.left = i3 ? i3 * this._renderService.dimensions.css.cell.width + "px" : "";
          }
          _removeDecoration(e3) {
            this._decorationElements.get(e3)?.remove(), this._decorationElements.delete(e3), e3.dispose();
          }
        };
        t2.BufferDecorationRenderer = h = s2([r(1, a.IBufferService), r(2, n.ICoreBrowserService), r(3, a.IDecorationService), r(4, n.IRenderService)], h);
      }, 5871: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ColorZoneStore = void 0, t2.ColorZoneStore = class {
          constructor() {
            this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = { full: 0, left: 0, center: 0, right: 0 };
          }
          get zones() {
            return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
          }
          clear() {
            this._zones.length = 0, this._zonePoolIndex = 0;
          }
          addDecoration(e3) {
            if (e3.options.overviewRulerOptions) {
              for (const t3 of this._zones) if (t3.color === e3.options.overviewRulerOptions.color && t3.position === e3.options.overviewRulerOptions.position) {
                if (this._lineIntersectsZone(t3, e3.marker.line)) return;
                if (this._lineAdjacentToZone(t3, e3.marker.line, e3.options.overviewRulerOptions.position)) return void this._addLineToZone(t3, e3.marker.line);
              }
              if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = e3.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = e3.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = e3.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = e3.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
              this._zones.push({ color: e3.options.overviewRulerOptions.color, position: e3.options.overviewRulerOptions.position, startBufferLine: e3.marker.line, endBufferLine: e3.marker.line }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
            }
          }
          setPadding(e3) {
            this._linePadding = e3;
          }
          _lineIntersectsZone(e3, t3) {
            return t3 >= e3.startBufferLine && t3 <= e3.endBufferLine;
          }
          _lineAdjacentToZone(e3, t3, i2) {
            return t3 >= e3.startBufferLine - this._linePadding[i2 || "full"] && t3 <= e3.endBufferLine + this._linePadding[i2 || "full"];
          }
          _addLineToZone(e3, t3) {
            e3.startBufferLine = Math.min(e3.startBufferLine, t3), e3.endBufferLine = Math.max(e3.endBufferLine, t3);
          }
        };
      }, 5744: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OverviewRulerRenderer = void 0;
        const n = i2(5871), o = i2(4725), a = i2(844), h = i2(2585), c = { full: 0, left: 0, center: 0, right: 0 }, l = { full: 0, left: 0, center: 0, right: 0 }, d = { full: 0, left: 0, center: 0, right: 0 };
        let _ = t2.OverviewRulerRenderer = class extends a.Disposable {
          get _width() {
            return this._optionsService.options.overviewRulerWidth || 0;
          }
          constructor(e3, t3, i3, s3, r2, o2, h2) {
            super(), this._viewportElement = e3, this._screenElement = t3, this._bufferService = i3, this._decorationService = s3, this._renderService = r2, this._optionsService = o2, this._coreBrowserService = h2, this._colorZoneStore = new n.ColorZoneStore(), this._shouldUpdateDimensions = true, this._shouldUpdateAnchor = true, this._lastKnownBufferLength = 0, this._canvas = this._coreBrowserService.mainDocument.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), this._viewportElement.parentElement?.insertBefore(this._canvas, this._viewportElement);
            const c2 = this._canvas.getContext("2d");
            if (!c2) throw new Error("Ctx cannot be null");
            this._ctx = c2, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, a.toDisposable)((() => {
              this._canvas?.remove();
            })));
          }
          _registerDecorationListeners() {
            this.register(this._decorationService.onDecorationRegistered((() => this._queueRefresh(void 0, true)))), this.register(this._decorationService.onDecorationRemoved((() => this._queueRefresh(void 0, true))));
          }
          _registerBufferChangeListeners() {
            this.register(this._renderService.onRenderedViewportChange((() => this._queueRefresh()))), this.register(this._bufferService.buffers.onBufferActivate((() => {
              this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
            }))), this.register(this._bufferService.onScroll((() => {
              this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
            })));
          }
          _registerDimensionChangeListeners() {
            this.register(this._renderService.onRender((() => {
              this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(true), this._containerHeight = this._screenElement.clientHeight);
            }))), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", (() => this._queueRefresh(true)))), this.register(this._coreBrowserService.onDprChange((() => this._queueRefresh(true)))), this._queueRefresh(true);
          }
          _refreshDrawConstants() {
            const e3 = Math.floor(this._canvas.width / 3), t3 = Math.ceil(this._canvas.width / 3);
            l.full = this._canvas.width, l.left = e3, l.center = t3, l.right = e3, this._refreshDrawHeightConstants(), d.full = 0, d.left = 0, d.center = l.left, d.right = l.left + l.center;
          }
          _refreshDrawHeightConstants() {
            c.full = Math.round(2 * this._coreBrowserService.dpr);
            const e3 = this._canvas.height / this._bufferService.buffer.lines.length, t3 = Math.round(Math.max(Math.min(e3, 12), 6) * this._coreBrowserService.dpr);
            c.left = t3, c.center = t3, c.right = t3;
          }
          _refreshColorZonePadding() {
            this._colorZoneStore.setPadding({ full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.full), left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.left), center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.center), right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.right) }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
          }
          _refreshCanvasDimensions() {
            this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowserService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowserService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
          }
          _refreshDecorations() {
            this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
            for (const e4 of this._decorationService.decorations) this._colorZoneStore.addDecoration(e4);
            this._ctx.lineWidth = 1;
            const e3 = this._colorZoneStore.zones;
            for (const t3 of e3) "full" !== t3.position && this._renderColorZone(t3);
            for (const t3 of e3) "full" === t3.position && this._renderColorZone(t3);
            this._shouldUpdateDimensions = false, this._shouldUpdateAnchor = false;
          }
          _renderColorZone(e3) {
            this._ctx.fillStyle = e3.color, this._ctx.fillRect(d[e3.position || "full"], Math.round((this._canvas.height - 1) * (e3.startBufferLine / this._bufferService.buffers.active.lines.length) - c[e3.position || "full"] / 2), l[e3.position || "full"], Math.round((this._canvas.height - 1) * ((e3.endBufferLine - e3.startBufferLine) / this._bufferService.buffers.active.lines.length) + c[e3.position || "full"]));
          }
          _queueRefresh(e3, t3) {
            this._shouldUpdateDimensions = e3 || this._shouldUpdateDimensions, this._shouldUpdateAnchor = t3 || this._shouldUpdateAnchor, void 0 === this._animationFrame && (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame((() => {
              this._refreshDecorations(), this._animationFrame = void 0;
            })));
          }
        };
        t2.OverviewRulerRenderer = _ = s2([r(2, h.IBufferService), r(3, h.IDecorationService), r(4, o.IRenderService), r(5, h.IOptionsService), r(6, o.ICoreBrowserService)], _);
      }, 2950: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CompositionHelper = void 0;
        const n = i2(4725), o = i2(2585), a = i2(2584);
        let h = t2.CompositionHelper = class {
          get isComposing() {
            return this._isComposing;
          }
          constructor(e3, t3, i3, s3, r2, n2) {
            this._textarea = e3, this._compositionView = t3, this._bufferService = i3, this._optionsService = s3, this._coreService = r2, this._renderService = n2, this._isComposing = false, this._isSendingComposition = false, this._compositionPosition = { start: 0, end: 0 }, this._dataAlreadySent = "";
          }
          compositionstart() {
            this._isComposing = true, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
          }
          compositionupdate(e3) {
            this._compositionView.textContent = e3.data, this.updateCompositionElements(), setTimeout((() => {
              this._compositionPosition.end = this._textarea.value.length;
            }), 0);
          }
          compositionend() {
            this._finalizeComposition(true);
          }
          keydown(e3) {
            if (this._isComposing || this._isSendingComposition) {
              if (229 === e3.keyCode) return false;
              if (16 === e3.keyCode || 17 === e3.keyCode || 18 === e3.keyCode) return false;
              this._finalizeComposition(false);
            }
            return 229 !== e3.keyCode || (this._handleAnyTextareaChanges(), false);
          }
          _finalizeComposition(e3) {
            if (this._compositionView.classList.remove("active"), this._isComposing = false, e3) {
              const e4 = { start: this._compositionPosition.start, end: this._compositionPosition.end };
              this._isSendingComposition = true, setTimeout((() => {
                if (this._isSendingComposition) {
                  let t3;
                  this._isSendingComposition = false, e4.start += this._dataAlreadySent.length, t3 = this._isComposing ? this._textarea.value.substring(e4.start, e4.end) : this._textarea.value.substring(e4.start), t3.length > 0 && this._coreService.triggerDataEvent(t3, true);
                }
              }), 0);
            } else {
              this._isSendingComposition = false;
              const e4 = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
              this._coreService.triggerDataEvent(e4, true);
            }
          }
          _handleAnyTextareaChanges() {
            const e3 = this._textarea.value;
            setTimeout((() => {
              if (!this._isComposing) {
                const t3 = this._textarea.value, i3 = t3.replace(e3, "");
                this._dataAlreadySent = i3, t3.length > e3.length ? this._coreService.triggerDataEvent(i3, true) : t3.length < e3.length ? this._coreService.triggerDataEvent(`${a.C0.DEL}`, true) : t3.length === e3.length && t3 !== e3 && this._coreService.triggerDataEvent(t3, true);
              }
            }), 0);
          }
          updateCompositionElements(e3) {
            if (this._isComposing) {
              if (this._bufferService.buffer.isCursorInViewport) {
                const e4 = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), t3 = this._renderService.dimensions.css.cell.height, i3 = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, s3 = e4 * this._renderService.dimensions.css.cell.width;
                this._compositionView.style.left = s3 + "px", this._compositionView.style.top = i3 + "px", this._compositionView.style.height = t3 + "px", this._compositionView.style.lineHeight = t3 + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                const r2 = this._compositionView.getBoundingClientRect();
                this._textarea.style.left = s3 + "px", this._textarea.style.top = i3 + "px", this._textarea.style.width = Math.max(r2.width, 1) + "px", this._textarea.style.height = Math.max(r2.height, 1) + "px", this._textarea.style.lineHeight = r2.height + "px";
              }
              e3 || setTimeout((() => this.updateCompositionElements(true)), 0);
            }
          }
        };
        t2.CompositionHelper = h = s2([r(2, o.IBufferService), r(3, o.IOptionsService), r(4, o.ICoreService), r(5, n.IRenderService)], h);
      }, 9806: (e2, t2) => {
        function i2(e3, t3, i3) {
          const s2 = i3.getBoundingClientRect(), r = e3.getComputedStyle(i3), n = parseInt(r.getPropertyValue("padding-left")), o = parseInt(r.getPropertyValue("padding-top"));
          return [t3.clientX - s2.left - n, t3.clientY - s2.top - o];
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getCoords = t2.getCoordsRelativeToElement = void 0, t2.getCoordsRelativeToElement = i2, t2.getCoords = function(e3, t3, s2, r, n, o, a, h, c) {
          if (!o) return;
          const l = i2(e3, t3, s2);
          return l ? (l[0] = Math.ceil((l[0] + (c ? a / 2 : 0)) / a), l[1] = Math.ceil(l[1] / h), l[0] = Math.min(Math.max(l[0], 1), r + (c ? 1 : 0)), l[1] = Math.min(Math.max(l[1], 1), n), l) : void 0;
        };
      }, 9504: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.moveToCellSequence = void 0;
        const s2 = i2(2584);
        function r(e3, t3, i3, s3) {
          const r2 = e3 - n(e3, i3), a2 = t3 - n(t3, i3), l = Math.abs(r2 - a2) - (function(e4, t4, i4) {
            let s4 = 0;
            const r3 = e4 - n(e4, i4), a3 = t4 - n(t4, i4);
            for (let n2 = 0; n2 < Math.abs(r3 - a3); n2++) {
              const a4 = "A" === o(e4, t4) ? -1 : 1, h2 = i4.buffer.lines.get(r3 + a4 * n2);
              h2?.isWrapped && s4++;
            }
            return s4;
          })(e3, t3, i3);
          return c(l, h(o(e3, t3), s3));
        }
        function n(e3, t3) {
          let i3 = 0, s3 = t3.buffer.lines.get(e3), r2 = s3?.isWrapped;
          for (; r2 && e3 >= 0 && e3 < t3.rows; ) i3++, s3 = t3.buffer.lines.get(--e3), r2 = s3?.isWrapped;
          return i3;
        }
        function o(e3, t3) {
          return e3 > t3 ? "A" : "B";
        }
        function a(e3, t3, i3, s3, r2, n2) {
          let o2 = e3, a2 = t3, h2 = "";
          for (; o2 !== i3 || a2 !== s3; ) o2 += r2 ? 1 : -1, r2 && o2 > n2.cols - 1 ? (h2 += n2.buffer.translateBufferLineToString(a2, false, e3, o2), o2 = 0, e3 = 0, a2++) : !r2 && o2 < 0 && (h2 += n2.buffer.translateBufferLineToString(a2, false, 0, e3 + 1), o2 = n2.cols - 1, e3 = o2, a2--);
          return h2 + n2.buffer.translateBufferLineToString(a2, false, e3, o2);
        }
        function h(e3, t3) {
          const i3 = t3 ? "O" : "[";
          return s2.C0.ESC + i3 + e3;
        }
        function c(e3, t3) {
          e3 = Math.floor(e3);
          let i3 = "";
          for (let s3 = 0; s3 < e3; s3++) i3 += t3;
          return i3;
        }
        t2.moveToCellSequence = function(e3, t3, i3, s3) {
          const o2 = i3.buffer.x, l = i3.buffer.y;
          if (!i3.buffer.hasScrollback) return (function(e4, t4, i4, s4, o3, l2) {
            return 0 === r(t4, s4, o3, l2).length ? "" : c(a(e4, t4, e4, t4 - n(t4, o3), false, o3).length, h("D", l2));
          })(o2, l, 0, t3, i3, s3) + r(l, t3, i3, s3) + (function(e4, t4, i4, s4, o3, l2) {
            let d2;
            d2 = r(t4, s4, o3, l2).length > 0 ? s4 - n(s4, o3) : t4;
            const _2 = s4, u = (function(e5, t5, i5, s5, o4, a2) {
              let h2;
              return h2 = r(i5, s5, o4, a2).length > 0 ? s5 - n(s5, o4) : t5, e5 < i5 && h2 <= s5 || e5 >= i5 && h2 < s5 ? "C" : "D";
            })(e4, t4, i4, s4, o3, l2);
            return c(a(e4, d2, i4, _2, "C" === u, o3).length, h(u, l2));
          })(o2, l, e3, t3, i3, s3);
          let d;
          if (l === t3) return d = o2 > e3 ? "D" : "C", c(Math.abs(o2 - e3), h(d, s3));
          d = l > t3 ? "D" : "C";
          const _ = Math.abs(l - t3);
          return c((function(e4, t4) {
            return t4.cols - e4;
          })(l > t3 ? e3 : o2, i3) + (_ - 1) * i3.cols + 1 + ((l > t3 ? o2 : e3) - 1), h(d, s3));
        };
      }, 1296: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRenderer = void 0;
        const n = i2(3787), o = i2(2550), a = i2(2223), h = i2(6171), c = i2(6052), l = i2(4725), d = i2(8055), _ = i2(8460), u = i2(844), f = i2(2585), v = "xterm-dom-renderer-owner-", p = "xterm-rows", g = "xterm-fg-", m = "xterm-bg-", S = "xterm-focus", C = "xterm-selection";
        let b2 = 1, w = t2.DomRenderer = class extends u.Disposable {
          constructor(e3, t3, i3, s3, r2, a2, l2, d2, f2, g2, m2, S2, w2) {
            super(), this._terminal = e3, this._document = t3, this._element = i3, this._screenElement = s3, this._viewportElement = r2, this._helperContainer = a2, this._linkifier2 = l2, this._charSizeService = f2, this._optionsService = g2, this._bufferService = m2, this._coreBrowserService = S2, this._themeService = w2, this._terminalClass = b2++, this._rowElements = [], this._selectionRenderModel = (0, c.createSelectionRenderModel)(), this.onRequestRedraw = this.register(new _.EventEmitter()).event, this._rowContainer = this._document.createElement("div"), this._rowContainer.classList.add(p), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = this._document.createElement("div"), this._selectionContainer.classList.add(C), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, h.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange((() => this._handleOptionsChanged()))), this.register(this._themeService.onChangeColors(((e4) => this._injectCss(e4)))), this._injectCss(this._themeService.colors), this._rowFactory = d2.createInstance(n.DomRendererRowFactory, document), this._element.classList.add(v + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline(((e4) => this._handleLinkHover(e4)))), this.register(this._linkifier2.onHideLinkUnderline(((e4) => this._handleLinkLeave(e4)))), this.register((0, u.toDisposable)((() => {
              this._element.classList.remove(v + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
            }))), this._widthCache = new o.WidthCache(this._document, this._helperContainer), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
          }
          _updateDimensions() {
            const e3 = this._coreBrowserService.dpr;
            this.dimensions.device.char.width = this._charSizeService.width * e3, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * e3), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / e3), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / e3), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
            for (const e4 of this._rowElements) e4.style.width = `${this.dimensions.css.canvas.width}px`, e4.style.height = `${this.dimensions.css.cell.height}px`, e4.style.lineHeight = `${this.dimensions.css.cell.height}px`, e4.style.overflow = "hidden";
            this._dimensionsStyleElement || (this._dimensionsStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
            const t3 = `${this._terminalSelector} .${p} span { display: inline-block; height: 100%; vertical-align: top;}`;
            this._dimensionsStyleElement.textContent = t3, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
          }
          _injectCss(e3) {
            this._themeStyleElement || (this._themeStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
            let t3 = `${this._terminalSelector} .${p} { color: ${e3.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
            t3 += `${this._terminalSelector} .${p} .xterm-dim { color: ${d.color.multiplyOpacity(e3.foreground, 0.5).css};}`, t3 += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`;
            const i3 = `blink_underline_${this._terminalClass}`, s3 = `blink_bar_${this._terminalClass}`, r2 = `blink_block_${this._terminalClass}`;
            t3 += `@keyframes ${i3} { 50% {  border-bottom-style: hidden; }}`, t3 += `@keyframes ${s3} { 50% {  box-shadow: none; }}`, t3 += `@keyframes ${r2} { 0% {  background-color: ${e3.cursor.css};  color: ${e3.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${e3.cursor.css}; }}`, t3 += `${this._terminalSelector} .${p}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-underline { animation: ${i3} 1s step-end infinite;}${this._terminalSelector} .${p}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-bar { animation: ${s3} 1s step-end infinite;}${this._terminalSelector} .${p}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: ${r2} 1s step-end infinite;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-block { background-color: ${e3.cursor.css}; color: ${e3.cursorAccent.css};}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-block:not(.xterm-cursor-blink) { background-color: ${e3.cursor.css} !important; color: ${e3.cursorAccent.css} !important;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${e3.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e3.cursor.css} inset;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${e3.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, t3 += `${this._terminalSelector} .${C} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${C} div { position: absolute; background-color: ${e3.selectionBackgroundOpaque.css};}${this._terminalSelector} .${C} div { position: absolute; background-color: ${e3.selectionInactiveBackgroundOpaque.css};}`;
            for (const [i4, s4] of e3.ansi.entries()) t3 += `${this._terminalSelector} .${g}${i4} { color: ${s4.css}; }${this._terminalSelector} .${g}${i4}.xterm-dim { color: ${d.color.multiplyOpacity(s4, 0.5).css}; }${this._terminalSelector} .${m}${i4} { background-color: ${s4.css}; }`;
            t3 += `${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR} { color: ${d.color.opaque(e3.background).css}; }${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${d.color.multiplyOpacity(d.color.opaque(e3.background), 0.5).css}; }${this._terminalSelector} .${m}${a.INVERTED_DEFAULT_COLOR} { background-color: ${e3.foreground.css}; }`, this._themeStyleElement.textContent = t3;
          }
          _setDefaultSpacing() {
            const e3 = this.dimensions.css.cell.width - this._widthCache.get("W", false, false);
            this._rowContainer.style.letterSpacing = `${e3}px`, this._rowFactory.defaultSpacing = e3;
          }
          handleDevicePixelRatioChange() {
            this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
          }
          _refreshRowElements(e3, t3) {
            for (let e4 = this._rowElements.length; e4 <= t3; e4++) {
              const e5 = this._document.createElement("div");
              this._rowContainer.appendChild(e5), this._rowElements.push(e5);
            }
            for (; this._rowElements.length > t3; ) this._rowContainer.removeChild(this._rowElements.pop());
          }
          handleResize(e3, t3) {
            this._refreshRowElements(e3, t3), this._updateDimensions(), this.handleSelectionChanged(this._selectionRenderModel.selectionStart, this._selectionRenderModel.selectionEnd, this._selectionRenderModel.columnSelectMode);
          }
          handleCharSizeChanged() {
            this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
          }
          handleBlur() {
            this._rowContainer.classList.remove(S), this.renderRows(0, this._bufferService.rows - 1);
          }
          handleFocus() {
            this._rowContainer.classList.add(S), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
          }
          handleSelectionChanged(e3, t3, i3) {
            if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(e3, t3, i3), this.renderRows(0, this._bufferService.rows - 1), !e3 || !t3) return;
            this._selectionRenderModel.update(this._terminal, e3, t3, i3);
            const s3 = this._selectionRenderModel.viewportStartRow, r2 = this._selectionRenderModel.viewportEndRow, n2 = this._selectionRenderModel.viewportCappedStartRow, o2 = this._selectionRenderModel.viewportCappedEndRow;
            if (n2 >= this._bufferService.rows || o2 < 0) return;
            const a2 = this._document.createDocumentFragment();
            if (i3) {
              const i4 = e3[0] > t3[0];
              a2.appendChild(this._createSelectionElement(n2, i4 ? t3[0] : e3[0], i4 ? e3[0] : t3[0], o2 - n2 + 1));
            } else {
              const i4 = s3 === n2 ? e3[0] : 0, h2 = n2 === r2 ? t3[0] : this._bufferService.cols;
              a2.appendChild(this._createSelectionElement(n2, i4, h2));
              const c2 = o2 - n2 - 1;
              if (a2.appendChild(this._createSelectionElement(n2 + 1, 0, this._bufferService.cols, c2)), n2 !== o2) {
                const e4 = r2 === o2 ? t3[0] : this._bufferService.cols;
                a2.appendChild(this._createSelectionElement(o2, 0, e4));
              }
            }
            this._selectionContainer.appendChild(a2);
          }
          _createSelectionElement(e3, t3, i3, s3 = 1) {
            const r2 = this._document.createElement("div"), n2 = t3 * this.dimensions.css.cell.width;
            let o2 = this.dimensions.css.cell.width * (i3 - t3);
            return n2 + o2 > this.dimensions.css.canvas.width && (o2 = this.dimensions.css.canvas.width - n2), r2.style.height = s3 * this.dimensions.css.cell.height + "px", r2.style.top = e3 * this.dimensions.css.cell.height + "px", r2.style.left = `${n2}px`, r2.style.width = `${o2}px`, r2;
          }
          handleCursorMove() {
          }
          _handleOptionsChanged() {
            this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
          }
          clear() {
            for (const e3 of this._rowElements) e3.replaceChildren();
          }
          renderRows(e3, t3) {
            const i3 = this._bufferService.buffer, s3 = i3.ybase + i3.y, r2 = Math.min(i3.x, this._bufferService.cols - 1), n2 = this._optionsService.rawOptions.cursorBlink, o2 = this._optionsService.rawOptions.cursorStyle, a2 = this._optionsService.rawOptions.cursorInactiveStyle;
            for (let h2 = e3; h2 <= t3; h2++) {
              const e4 = h2 + i3.ydisp, t4 = this._rowElements[h2], c2 = i3.lines.get(e4);
              if (!t4 || !c2) break;
              t4.replaceChildren(...this._rowFactory.createRow(c2, e4, e4 === s3, o2, a2, r2, n2, this.dimensions.css.cell.width, this._widthCache, -1, -1));
            }
          }
          get _terminalSelector() {
            return `.${v}${this._terminalClass}`;
          }
          _handleLinkHover(e3) {
            this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, true);
          }
          _handleLinkLeave(e3) {
            this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, false);
          }
          _setCellUnderline(e3, t3, i3, s3, r2, n2) {
            i3 < 0 && (e3 = 0), s3 < 0 && (t3 = 0);
            const o2 = this._bufferService.rows - 1;
            i3 = Math.max(Math.min(i3, o2), 0), s3 = Math.max(Math.min(s3, o2), 0), r2 = Math.min(r2, this._bufferService.cols);
            const a2 = this._bufferService.buffer, h2 = a2.ybase + a2.y, c2 = Math.min(a2.x, r2 - 1), l2 = this._optionsService.rawOptions.cursorBlink, d2 = this._optionsService.rawOptions.cursorStyle, _2 = this._optionsService.rawOptions.cursorInactiveStyle;
            for (let o3 = i3; o3 <= s3; ++o3) {
              const u2 = o3 + a2.ydisp, f2 = this._rowElements[o3], v2 = a2.lines.get(u2);
              if (!f2 || !v2) break;
              f2.replaceChildren(...this._rowFactory.createRow(v2, u2, u2 === h2, d2, _2, c2, l2, this.dimensions.css.cell.width, this._widthCache, n2 ? o3 === i3 ? e3 : 0 : -1, n2 ? (o3 === s3 ? t3 : r2) - 1 : -1));
            }
          }
        };
        t2.DomRenderer = w = s2([r(7, f.IInstantiationService), r(8, l.ICharSizeService), r(9, f.IOptionsService), r(10, f.IBufferService), r(11, l.ICoreBrowserService), r(12, l.IThemeService)], w);
      }, 3787: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DomRendererRowFactory = void 0;
        const n = i2(2223), o = i2(643), a = i2(511), h = i2(2585), c = i2(8055), l = i2(4725), d = i2(4269), _ = i2(6171), u = i2(3734);
        let f = t2.DomRendererRowFactory = class {
          constructor(e3, t3, i3, s3, r2, n2, o2) {
            this._document = e3, this._characterJoinerService = t3, this._optionsService = i3, this._coreBrowserService = s3, this._coreService = r2, this._decorationService = n2, this._themeService = o2, this._workCell = new a.CellData(), this._columnSelectMode = false, this.defaultSpacing = 0;
          }
          handleSelectionChanged(e3, t3, i3) {
            this._selectionStart = e3, this._selectionEnd = t3, this._columnSelectMode = i3;
          }
          createRow(e3, t3, i3, s3, r2, a2, h2, l2, _2, f2, p) {
            const g = [], m = this._characterJoinerService.getJoinedCharacters(t3), S = this._themeService.colors;
            let C, b2 = e3.getNoBgTrimmedLength();
            i3 && b2 < a2 + 1 && (b2 = a2 + 1);
            let w = 0, y = "", E = 0, k = 0, L2 = 0, D = false, R = 0, x = false, A = 0;
            const B = [], T = -1 !== f2 && -1 !== p;
            for (let M = 0; M < b2; M++) {
              e3.loadCell(M, this._workCell);
              let b3 = this._workCell.getWidth();
              if (0 === b3) continue;
              let O = false, P2 = M, I = this._workCell;
              if (m.length > 0 && M === m[0][0]) {
                O = true;
                const t4 = m.shift();
                I = new d.JoinedCellData(this._workCell, e3.translateToString(true, t4[0], t4[1]), t4[1] - t4[0]), P2 = t4[1] - 1, b3 = I.getWidth();
              }
              const H = this._isCellInSelection(M, t3), F = i3 && M === a2, W = T && M >= f2 && M <= p;
              let U = false;
              this._decorationService.forEachDecorationAtCell(M, t3, void 0, ((e4) => {
                U = true;
              }));
              let N = I.getChars() || o.WHITESPACE_CELL_CHAR;
              if (" " === N && (I.isUnderline() || I.isOverline()) && (N = ""), A = b3 * l2 - _2.get(N, I.isBold(), I.isItalic()), C) {
                if (w && (H && x || !H && !x && I.bg === E) && (H && x && S.selectionForeground || I.fg === k) && I.extended.ext === L2 && W === D && A === R && !F && !O && !U) {
                  I.isInvisible() ? y += o.WHITESPACE_CELL_CHAR : y += N, w++;
                  continue;
                }
                w && (C.textContent = y), C = this._document.createElement("span"), w = 0, y = "";
              } else C = this._document.createElement("span");
              if (E = I.bg, k = I.fg, L2 = I.extended.ext, D = W, R = A, x = H, O && a2 >= M && a2 <= P2 && (a2 = M), !this._coreService.isCursorHidden && F && this._coreService.isCursorInitialized) {
                if (B.push("xterm-cursor"), this._coreBrowserService.isFocused) h2 && B.push("xterm-cursor-blink"), B.push("bar" === s3 ? "xterm-cursor-bar" : "underline" === s3 ? "xterm-cursor-underline" : "xterm-cursor-block");
                else if (r2) switch (r2) {
                  case "outline":
                    B.push("xterm-cursor-outline");
                    break;
                  case "block":
                    B.push("xterm-cursor-block");
                    break;
                  case "bar":
                    B.push("xterm-cursor-bar");
                    break;
                  case "underline":
                    B.push("xterm-cursor-underline");
                }
              }
              if (I.isBold() && B.push("xterm-bold"), I.isItalic() && B.push("xterm-italic"), I.isDim() && B.push("xterm-dim"), y = I.isInvisible() ? o.WHITESPACE_CELL_CHAR : I.getChars() || o.WHITESPACE_CELL_CHAR, I.isUnderline() && (B.push(`xterm-underline-${I.extended.underlineStyle}`), " " === y && (y = ""), !I.isUnderlineColorDefault())) if (I.isUnderlineColorRGB()) C.style.textDecorationColor = `rgb(${u.AttributeData.toColorRGB(I.getUnderlineColor()).join(",")})`;
              else {
                let e4 = I.getUnderlineColor();
                this._optionsService.rawOptions.drawBoldTextInBrightColors && I.isBold() && e4 < 8 && (e4 += 8), C.style.textDecorationColor = S.ansi[e4].css;
              }
              I.isOverline() && (B.push("xterm-overline"), " " === y && (y = "")), I.isStrikethrough() && B.push("xterm-strikethrough"), W && (C.style.textDecoration = "underline");
              let $ = I.getFgColor(), j = I.getFgColorMode(), z = I.getBgColor(), K = I.getBgColorMode();
              const q = !!I.isInverse();
              if (q) {
                const e4 = $;
                $ = z, z = e4;
                const t4 = j;
                j = K, K = t4;
              }
              let V, G, X, J = false;
              switch (this._decorationService.forEachDecorationAtCell(M, t3, void 0, ((e4) => {
                "top" !== e4.options.layer && J || (e4.backgroundColorRGB && (K = 50331648, z = e4.backgroundColorRGB.rgba >> 8 & 16777215, V = e4.backgroundColorRGB), e4.foregroundColorRGB && (j = 50331648, $ = e4.foregroundColorRGB.rgba >> 8 & 16777215, G = e4.foregroundColorRGB), J = "top" === e4.options.layer);
              })), !J && H && (V = this._coreBrowserService.isFocused ? S.selectionBackgroundOpaque : S.selectionInactiveBackgroundOpaque, z = V.rgba >> 8 & 16777215, K = 50331648, J = true, S.selectionForeground && (j = 50331648, $ = S.selectionForeground.rgba >> 8 & 16777215, G = S.selectionForeground)), J && B.push("xterm-decoration-top"), K) {
                case 16777216:
                case 33554432:
                  X = S.ansi[z], B.push(`xterm-bg-${z}`);
                  break;
                case 50331648:
                  X = c.channels.toColor(z >> 16, z >> 8 & 255, 255 & z), this._addStyle(C, `background-color:#${v((z >>> 0).toString(16), "0", 6)}`);
                  break;
                default:
                  q ? (X = S.foreground, B.push(`xterm-bg-${n.INVERTED_DEFAULT_COLOR}`)) : X = S.background;
              }
              switch (V || I.isDim() && (V = c.color.multiplyOpacity(X, 0.5)), j) {
                case 16777216:
                case 33554432:
                  I.isBold() && $ < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && ($ += 8), this._applyMinimumContrast(C, X, S.ansi[$], I, V, void 0) || B.push(`xterm-fg-${$}`);
                  break;
                case 50331648:
                  const e4 = c.channels.toColor($ >> 16 & 255, $ >> 8 & 255, 255 & $);
                  this._applyMinimumContrast(C, X, e4, I, V, G) || this._addStyle(C, `color:#${v($.toString(16), "0", 6)}`);
                  break;
                default:
                  this._applyMinimumContrast(C, X, S.foreground, I, V, G) || q && B.push(`xterm-fg-${n.INVERTED_DEFAULT_COLOR}`);
              }
              B.length && (C.className = B.join(" "), B.length = 0), F || O || U ? C.textContent = y : w++, A !== this.defaultSpacing && (C.style.letterSpacing = `${A}px`), g.push(C), M = P2;
            }
            return C && w && (C.textContent = y), g;
          }
          _applyMinimumContrast(e3, t3, i3, s3, r2, n2) {
            if (1 === this._optionsService.rawOptions.minimumContrastRatio || (0, _.treatGlyphAsBackgroundColor)(s3.getCode())) return false;
            const o2 = this._getContrastCache(s3);
            let a2;
            if (r2 || n2 || (a2 = o2.getColor(t3.rgba, i3.rgba)), void 0 === a2) {
              const e4 = this._optionsService.rawOptions.minimumContrastRatio / (s3.isDim() ? 2 : 1);
              a2 = c.color.ensureContrastRatio(r2 || t3, n2 || i3, e4), o2.setColor((r2 || t3).rgba, (n2 || i3).rgba, a2 ?? null);
            }
            return !!a2 && (this._addStyle(e3, `color:${a2.css}`), true);
          }
          _getContrastCache(e3) {
            return e3.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
          }
          _addStyle(e3, t3) {
            e3.setAttribute("style", `${e3.getAttribute("style") || ""}${t3};`);
          }
          _isCellInSelection(e3, t3) {
            const i3 = this._selectionStart, s3 = this._selectionEnd;
            return !(!i3 || !s3) && (this._columnSelectMode ? i3[0] <= s3[0] ? e3 >= i3[0] && t3 >= i3[1] && e3 < s3[0] && t3 <= s3[1] : e3 < i3[0] && t3 >= i3[1] && e3 >= s3[0] && t3 <= s3[1] : t3 > i3[1] && t3 < s3[1] || i3[1] === s3[1] && t3 === i3[1] && e3 >= i3[0] && e3 < s3[0] || i3[1] < s3[1] && t3 === s3[1] && e3 < s3[0] || i3[1] < s3[1] && t3 === i3[1] && e3 >= i3[0]);
          }
        };
        function v(e3, t3, i3) {
          for (; e3.length < i3; ) e3 = t3 + e3;
          return e3;
        }
        t2.DomRendererRowFactory = f = s2([r(1, l.ICharacterJoinerService), r(2, h.IOptionsService), r(3, l.ICoreBrowserService), r(4, h.ICoreService), r(5, h.IDecorationService), r(6, l.IThemeService)], f);
      }, 2550: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.WidthCache = void 0, t2.WidthCache = class {
          constructor(e3, t3) {
            this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = e3.createElement("div"), this._container.classList.add("xterm-width-cache-measure-container"), this._container.setAttribute("aria-hidden", "true"), this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
            const i2 = e3.createElement("span");
            i2.classList.add("xterm-char-measure-element");
            const s2 = e3.createElement("span");
            s2.classList.add("xterm-char-measure-element"), s2.style.fontWeight = "bold";
            const r = e3.createElement("span");
            r.classList.add("xterm-char-measure-element"), r.style.fontStyle = "italic";
            const n = e3.createElement("span");
            n.classList.add("xterm-char-measure-element"), n.style.fontWeight = "bold", n.style.fontStyle = "italic", this._measureElements = [i2, s2, r, n], this._container.appendChild(i2), this._container.appendChild(s2), this._container.appendChild(r), this._container.appendChild(n), t3.appendChild(this._container), this.clear();
          }
          dispose() {
            this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
          }
          clear() {
            this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
          }
          setFont(e3, t3, i2, s2) {
            e3 === this._font && t3 === this._fontSize && i2 === this._weight && s2 === this._weightBold || (this._font = e3, this._fontSize = t3, this._weight = i2, this._weightBold = s2, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${i2}`, this._measureElements[1].style.fontWeight = `${s2}`, this._measureElements[2].style.fontWeight = `${i2}`, this._measureElements[3].style.fontWeight = `${s2}`, this.clear());
          }
          get(e3, t3, i2) {
            let s2 = 0;
            if (!t3 && !i2 && 1 === e3.length && (s2 = e3.charCodeAt(0)) < 256) {
              if (-9999 !== this._flat[s2]) return this._flat[s2];
              const t4 = this._measure(e3, 0);
              return t4 > 0 && (this._flat[s2] = t4), t4;
            }
            let r = e3;
            t3 && (r += "B"), i2 && (r += "I");
            let n = this._holey.get(r);
            if (void 0 === n) {
              let s3 = 0;
              t3 && (s3 |= 1), i2 && (s3 |= 2), n = this._measure(e3, s3), n > 0 && this._holey.set(r, n);
            }
            return n;
          }
          _measure(e3, t3) {
            const i2 = this._measureElements[t3];
            return i2.textContent = e3.repeat(32), i2.offsetWidth / 32;
          }
        };
      }, 2223: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TEXT_BASELINE = t2.DIM_OPACITY = t2.INVERTED_DEFAULT_COLOR = void 0;
        const s2 = i2(6114);
        t2.INVERTED_DEFAULT_COLOR = 257, t2.DIM_OPACITY = 0.5, t2.TEXT_BASELINE = s2.isFirefox || s2.isLegacyEdge ? "bottom" : "ideographic";
      }, 6171: (e2, t2) => {
        function i2(e3) {
          return 57508 <= e3 && e3 <= 57558;
        }
        function s2(e3) {
          return e3 >= 128512 && e3 <= 128591 || e3 >= 127744 && e3 <= 128511 || e3 >= 128640 && e3 <= 128767 || e3 >= 9728 && e3 <= 9983 || e3 >= 9984 && e3 <= 10175 || e3 >= 65024 && e3 <= 65039 || e3 >= 129280 && e3 <= 129535 || e3 >= 127462 && e3 <= 127487;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.computeNextVariantOffset = t2.createRenderDimensions = t2.treatGlyphAsBackgroundColor = t2.allowRescaling = t2.isEmoji = t2.isRestrictedPowerlineGlyph = t2.isPowerlineGlyph = t2.throwIfFalsy = void 0, t2.throwIfFalsy = function(e3) {
          if (!e3) throw new Error("value must not be falsy");
          return e3;
        }, t2.isPowerlineGlyph = i2, t2.isRestrictedPowerlineGlyph = function(e3) {
          return 57520 <= e3 && e3 <= 57527;
        }, t2.isEmoji = s2, t2.allowRescaling = function(e3, t3, r, n) {
          return 1 === t3 && r > Math.ceil(1.5 * n) && void 0 !== e3 && e3 > 255 && !s2(e3) && !i2(e3) && !(function(e4) {
            return 57344 <= e4 && e4 <= 63743;
          })(e3);
        }, t2.treatGlyphAsBackgroundColor = function(e3) {
          return i2(e3) || (function(e4) {
            return 9472 <= e4 && e4 <= 9631;
          })(e3);
        }, t2.createRenderDimensions = function() {
          return { css: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 } }, device: { canvas: { width: 0, height: 0 }, cell: { width: 0, height: 0 }, char: { width: 0, height: 0, left: 0, top: 0 } } };
        }, t2.computeNextVariantOffset = function(e3, t3, i3 = 0) {
          return (e3 - (2 * Math.round(t3) - i3)) % (2 * Math.round(t3));
        };
      }, 6052: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createSelectionRenderModel = void 0;
        class i2 {
          constructor() {
            this.clear();
          }
          clear() {
            this.hasSelection = false, this.columnSelectMode = false, this.viewportStartRow = 0, this.viewportEndRow = 0, this.viewportCappedStartRow = 0, this.viewportCappedEndRow = 0, this.startCol = 0, this.endCol = 0, this.selectionStart = void 0, this.selectionEnd = void 0;
          }
          update(e3, t3, i3, s2 = false) {
            if (this.selectionStart = t3, this.selectionEnd = i3, !t3 || !i3 || t3[0] === i3[0] && t3[1] === i3[1]) return void this.clear();
            const r = e3.buffers.active.ydisp, n = t3[1] - r, o = i3[1] - r, a = Math.max(n, 0), h = Math.min(o, e3.rows - 1);
            a >= e3.rows || h < 0 ? this.clear() : (this.hasSelection = true, this.columnSelectMode = s2, this.viewportStartRow = n, this.viewportEndRow = o, this.viewportCappedStartRow = a, this.viewportCappedEndRow = h, this.startCol = t3[0], this.endCol = i3[0]);
          }
          isCellSelected(e3, t3, i3) {
            return !!this.hasSelection && (i3 -= e3.buffer.active.viewportY, this.columnSelectMode ? this.startCol <= this.endCol ? t3 >= this.startCol && i3 >= this.viewportCappedStartRow && t3 < this.endCol && i3 <= this.viewportCappedEndRow : t3 < this.startCol && i3 >= this.viewportCappedStartRow && t3 >= this.endCol && i3 <= this.viewportCappedEndRow : i3 > this.viewportStartRow && i3 < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && i3 === this.viewportStartRow && t3 >= this.startCol && t3 < this.endCol || this.viewportStartRow < this.viewportEndRow && i3 === this.viewportEndRow && t3 < this.endCol || this.viewportStartRow < this.viewportEndRow && i3 === this.viewportStartRow && t3 >= this.startCol);
          }
        }
        t2.createSelectionRenderModel = function() {
          return new i2();
        };
      }, 456: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionModel = void 0, t2.SelectionModel = class {
          constructor(e3) {
            this._bufferService = e3, this.isSelectAllActive = false, this.selectionStartLength = 0;
          }
          clearSelection() {
            this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = false, this.selectionStartLength = 0;
          }
          get finalSelectionStart() {
            return this.isSelectAllActive ? [0, 0] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
          }
          get finalSelectionEnd() {
            if (this.isSelectAllActive) return [this._bufferService.cols, this._bufferService.buffer.ybase + this._bufferService.rows - 1];
            if (this.selectionStart) {
              if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                const e3 = this.selectionStart[0] + this.selectionStartLength;
                return e3 > this._bufferService.cols ? e3 % this._bufferService.cols == 0 ? [this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols) - 1] : [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [e3, this.selectionStart[1]];
              }
              if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                const e3 = this.selectionStart[0] + this.selectionStartLength;
                return e3 > this._bufferService.cols ? [e3 % this._bufferService.cols, this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)] : [Math.max(e3, this.selectionEnd[0]), this.selectionEnd[1]];
              }
              return this.selectionEnd;
            }
          }
          areSelectionValuesReversed() {
            const e3 = this.selectionStart, t3 = this.selectionEnd;
            return !(!e3 || !t3) && (e3[1] > t3[1] || e3[1] === t3[1] && e3[0] > t3[0]);
          }
          handleTrim(e3) {
            return this.selectionStart && (this.selectionStart[1] -= e3), this.selectionEnd && (this.selectionEnd[1] -= e3), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), true) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), false);
          }
        };
      }, 428: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CharSizeService = void 0;
        const n = i2(2585), o = i2(8460), a = i2(844);
        let h = t2.CharSizeService = class extends a.Disposable {
          get hasValidSize() {
            return this.width > 0 && this.height > 0;
          }
          constructor(e3, t3, i3) {
            super(), this._optionsService = i3, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new o.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event;
            try {
              this._measureStrategy = this.register(new d(this._optionsService));
            } catch {
              this._measureStrategy = this.register(new l(e3, t3, this._optionsService));
            }
            this.register(this._optionsService.onMultipleOptionChange(["fontFamily", "fontSize"], (() => this.measure())));
          }
          measure() {
            const e3 = this._measureStrategy.measure();
            e3.width === this.width && e3.height === this.height || (this.width = e3.width, this.height = e3.height, this._onCharSizeChange.fire());
          }
        };
        t2.CharSizeService = h = s2([r(2, n.IOptionsService)], h);
        class c extends a.Disposable {
          constructor() {
            super(...arguments), this._result = { width: 0, height: 0 };
          }
          _validateAndSet(e3, t3) {
            void 0 !== e3 && e3 > 0 && void 0 !== t3 && t3 > 0 && (this._result.width = e3, this._result.height = t3);
          }
        }
        class l extends c {
          constructor(e3, t3, i3) {
            super(), this._document = e3, this._parentElement = t3, this._optionsService = i3, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
          }
          measure() {
            return this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`, this._validateAndSet(Number(this._measureElement.offsetWidth) / 32, Number(this._measureElement.offsetHeight)), this._result;
          }
        }
        class d extends c {
          constructor(e3) {
            super(), this._optionsService = e3, this._canvas = new OffscreenCanvas(100, 100), this._ctx = this._canvas.getContext("2d");
            const t3 = this._ctx.measureText("W");
            if (!("width" in t3 && "fontBoundingBoxAscent" in t3 && "fontBoundingBoxDescent" in t3)) throw new Error("Required font metrics not supported");
          }
          measure() {
            this._ctx.font = `${this._optionsService.rawOptions.fontSize}px ${this._optionsService.rawOptions.fontFamily}`;
            const e3 = this._ctx.measureText("W");
            return this._validateAndSet(e3.width, e3.fontBoundingBoxAscent + e3.fontBoundingBoxDescent), this._result;
          }
        }
      }, 4269: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CharacterJoinerService = t2.JoinedCellData = void 0;
        const n = i2(3734), o = i2(643), a = i2(511), h = i2(2585);
        class c extends n.AttributeData {
          constructor(e3, t3, i3) {
            super(), this.content = 0, this.combinedData = "", this.fg = e3.fg, this.bg = e3.bg, this.combinedData = t3, this._width = i3;
          }
          isCombined() {
            return 2097152;
          }
          getWidth() {
            return this._width;
          }
          getChars() {
            return this.combinedData;
          }
          getCode() {
            return 2097151;
          }
          setFromCharData(e3) {
            throw new Error("not implemented");
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        t2.JoinedCellData = c;
        let l = t2.CharacterJoinerService = class e3 {
          constructor(e4) {
            this._bufferService = e4, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData();
          }
          register(e4) {
            const t3 = { id: this._nextCharacterJoinerId++, handler: e4 };
            return this._characterJoiners.push(t3), t3.id;
          }
          deregister(e4) {
            for (let t3 = 0; t3 < this._characterJoiners.length; t3++) if (this._characterJoiners[t3].id === e4) return this._characterJoiners.splice(t3, 1), true;
            return false;
          }
          getJoinedCharacters(e4) {
            if (0 === this._characterJoiners.length) return [];
            const t3 = this._bufferService.buffer.lines.get(e4);
            if (!t3 || 0 === t3.length) return [];
            const i3 = [], s3 = t3.translateToString(true);
            let r2 = 0, n2 = 0, a2 = 0, h2 = t3.getFg(0), c2 = t3.getBg(0);
            for (let e5 = 0; e5 < t3.getTrimmedLength(); e5++) if (t3.loadCell(e5, this._workCell), 0 !== this._workCell.getWidth()) {
              if (this._workCell.fg !== h2 || this._workCell.bg !== c2) {
                if (e5 - r2 > 1) {
                  const e6 = this._getJoinedRanges(s3, a2, n2, t3, r2);
                  for (let t4 = 0; t4 < e6.length; t4++) i3.push(e6[t4]);
                }
                r2 = e5, a2 = n2, h2 = this._workCell.fg, c2 = this._workCell.bg;
              }
              n2 += this._workCell.getChars().length || o.WHITESPACE_CELL_CHAR.length;
            }
            if (this._bufferService.cols - r2 > 1) {
              const e5 = this._getJoinedRanges(s3, a2, n2, t3, r2);
              for (let t4 = 0; t4 < e5.length; t4++) i3.push(e5[t4]);
            }
            return i3;
          }
          _getJoinedRanges(t3, i3, s3, r2, n2) {
            const o2 = t3.substring(i3, s3);
            let a2 = [];
            try {
              a2 = this._characterJoiners[0].handler(o2);
            } catch (e4) {
              console.error(e4);
            }
            for (let t4 = 1; t4 < this._characterJoiners.length; t4++) try {
              const i4 = this._characterJoiners[t4].handler(o2);
              for (let t5 = 0; t5 < i4.length; t5++) e3._mergeRanges(a2, i4[t5]);
            } catch (e4) {
              console.error(e4);
            }
            return this._stringRangesToCellRanges(a2, r2, n2), a2;
          }
          _stringRangesToCellRanges(e4, t3, i3) {
            let s3 = 0, r2 = false, n2 = 0, a2 = e4[s3];
            if (a2) {
              for (let h2 = i3; h2 < this._bufferService.cols; h2++) {
                const i4 = t3.getWidth(h2), c2 = t3.getString(h2).length || o.WHITESPACE_CELL_CHAR.length;
                if (0 !== i4) {
                  if (!r2 && a2[0] <= n2 && (a2[0] = h2, r2 = true), a2[1] <= n2) {
                    if (a2[1] = h2, a2 = e4[++s3], !a2) break;
                    a2[0] <= n2 ? (a2[0] = h2, r2 = true) : r2 = false;
                  }
                  n2 += c2;
                }
              }
              a2 && (a2[1] = this._bufferService.cols);
            }
          }
          static _mergeRanges(e4, t3) {
            let i3 = false;
            for (let s3 = 0; s3 < e4.length; s3++) {
              const r2 = e4[s3];
              if (i3) {
                if (t3[1] <= r2[0]) return e4[s3 - 1][1] = t3[1], e4;
                if (t3[1] <= r2[1]) return e4[s3 - 1][1] = Math.max(t3[1], r2[1]), e4.splice(s3, 1), e4;
                e4.splice(s3, 1), s3--;
              } else {
                if (t3[1] <= r2[0]) return e4.splice(s3, 0, t3), e4;
                if (t3[1] <= r2[1]) return r2[0] = Math.min(t3[0], r2[0]), e4;
                t3[0] < r2[1] && (r2[0] = Math.min(t3[0], r2[0]), i3 = true);
              }
            }
            return i3 ? e4[e4.length - 1][1] = t3[1] : e4.push(t3), e4;
          }
        };
        t2.CharacterJoinerService = l = s2([r(0, h.IBufferService)], l);
      }, 5114: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreBrowserService = void 0;
        const s2 = i2(844), r = i2(8460), n = i2(3656);
        class o extends s2.Disposable {
          constructor(e3, t3, i3) {
            super(), this._textarea = e3, this._window = t3, this.mainDocument = i3, this._isFocused = false, this._cachedIsFocused = void 0, this._screenDprMonitor = new a(this._window), this._onDprChange = this.register(new r.EventEmitter()), this.onDprChange = this._onDprChange.event, this._onWindowChange = this.register(new r.EventEmitter()), this.onWindowChange = this._onWindowChange.event, this.register(this.onWindowChange(((e4) => this._screenDprMonitor.setWindow(e4)))), this.register((0, r.forwardEvent)(this._screenDprMonitor.onDprChange, this._onDprChange)), this._textarea.addEventListener("focus", (() => this._isFocused = true)), this._textarea.addEventListener("blur", (() => this._isFocused = false));
          }
          get window() {
            return this._window;
          }
          set window(e3) {
            this._window !== e3 && (this._window = e3, this._onWindowChange.fire(this._window));
          }
          get dpr() {
            return this.window.devicePixelRatio;
          }
          get isFocused() {
            return void 0 === this._cachedIsFocused && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask((() => this._cachedIsFocused = void 0))), this._cachedIsFocused;
          }
        }
        t2.CoreBrowserService = o;
        class a extends s2.Disposable {
          constructor(e3) {
            super(), this._parentWindow = e3, this._windowResizeListener = this.register(new s2.MutableDisposable()), this._onDprChange = this.register(new r.EventEmitter()), this.onDprChange = this._onDprChange.event, this._outerListener = () => this._setDprAndFireIfDiffers(), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._updateDpr(), this._setWindowResizeListener(), this.register((0, s2.toDisposable)((() => this.clearListener())));
          }
          setWindow(e3) {
            this._parentWindow = e3, this._setWindowResizeListener(), this._setDprAndFireIfDiffers();
          }
          _setWindowResizeListener() {
            this._windowResizeListener.value = (0, n.addDisposableDomListener)(this._parentWindow, "resize", (() => this._setDprAndFireIfDiffers()));
          }
          _setDprAndFireIfDiffers() {
            this._parentWindow.devicePixelRatio !== this._currentDevicePixelRatio && this._onDprChange.fire(this._parentWindow.devicePixelRatio), this._updateDpr();
          }
          _updateDpr() {
            this._outerListener && (this._resolutionMediaMatchList?.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
          }
          clearListener() {
            this._resolutionMediaMatchList && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._outerListener = void 0);
          }
        }
      }, 779: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.LinkProviderService = void 0;
        const s2 = i2(844);
        class r extends s2.Disposable {
          constructor() {
            super(), this.linkProviders = [], this.register((0, s2.toDisposable)((() => this.linkProviders.length = 0)));
          }
          registerLinkProvider(e3) {
            return this.linkProviders.push(e3), { dispose: () => {
              const t3 = this.linkProviders.indexOf(e3);
              -1 !== t3 && this.linkProviders.splice(t3, 1);
            } };
          }
        }
        t2.LinkProviderService = r;
      }, 8934: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.MouseService = void 0;
        const n = i2(4725), o = i2(9806);
        let a = t2.MouseService = class {
          constructor(e3, t3) {
            this._renderService = e3, this._charSizeService = t3;
          }
          getCoords(e3, t3, i3, s3, r2) {
            return (0, o.getCoords)(window, e3, t3, i3, s3, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, r2);
          }
          getMouseReportCoords(e3, t3) {
            const i3 = (0, o.getCoordsRelativeToElement)(window, e3, t3);
            if (this._charSizeService.hasValidSize) return i3[0] = Math.min(Math.max(i3[0], 0), this._renderService.dimensions.css.canvas.width - 1), i3[1] = Math.min(Math.max(i3[1], 0), this._renderService.dimensions.css.canvas.height - 1), { col: Math.floor(i3[0] / this._renderService.dimensions.css.cell.width), row: Math.floor(i3[1] / this._renderService.dimensions.css.cell.height), x: Math.floor(i3[0]), y: Math.floor(i3[1]) };
          }
        };
        t2.MouseService = a = s2([r(0, n.IRenderService), r(1, n.ICharSizeService)], a);
      }, 3230: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.RenderService = void 0;
        const n = i2(6193), o = i2(4725), a = i2(8460), h = i2(844), c = i2(7226), l = i2(2585);
        let d = t2.RenderService = class extends h.Disposable {
          get dimensions() {
            return this._renderer.value.dimensions;
          }
          constructor(e3, t3, i3, s3, r2, o2, l2, d2) {
            super(), this._rowCount = e3, this._charSizeService = s3, this._renderer = this.register(new h.MutableDisposable()), this._pausedResizeTask = new c.DebouncedIdleTask(), this._observerDisposable = this.register(new h.MutableDisposable()), this._isPaused = false, this._needsFullRefresh = false, this._isNextRenderRedrawOnly = true, this._needsSelectionRefresh = false, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = { start: void 0, end: void 0, columnSelectMode: false }, this._onDimensionsChange = this.register(new a.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new a.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new a.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new a.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new n.RenderDebouncer(((e4, t4) => this._renderRows(e4, t4)), l2), this.register(this._renderDebouncer), this.register(l2.onDprChange((() => this.handleDevicePixelRatioChange()))), this.register(o2.onResize((() => this._fullRefresh()))), this.register(o2.buffers.onBufferActivate((() => this._renderer.value?.clear()))), this.register(i3.onOptionChange((() => this._handleOptionsChanged()))), this.register(this._charSizeService.onCharSizeChange((() => this.handleCharSizeChanged()))), this.register(r2.onDecorationRegistered((() => this._fullRefresh()))), this.register(r2.onDecorationRemoved((() => this._fullRefresh()))), this.register(i3.onMultipleOptionChange(["customGlyphs", "drawBoldTextInBrightColors", "letterSpacing", "lineHeight", "fontFamily", "fontSize", "fontWeight", "fontWeightBold", "minimumContrastRatio", "rescaleOverlappingGlyphs"], (() => {
              this.clear(), this.handleResize(o2.cols, o2.rows), this._fullRefresh();
            }))), this.register(i3.onMultipleOptionChange(["cursorBlink", "cursorStyle"], (() => this.refreshRows(o2.buffer.y, o2.buffer.y, true)))), this.register(d2.onChangeColors((() => this._fullRefresh()))), this._registerIntersectionObserver(l2.window, t3), this.register(l2.onWindowChange(((e4) => this._registerIntersectionObserver(e4, t3))));
          }
          _registerIntersectionObserver(e3, t3) {
            if ("IntersectionObserver" in e3) {
              const i3 = new e3.IntersectionObserver(((e4) => this._handleIntersectionChange(e4[e4.length - 1])), { threshold: 0 });
              i3.observe(t3), this._observerDisposable.value = (0, h.toDisposable)((() => i3.disconnect()));
            }
          }
          _handleIntersectionChange(e3) {
            this._isPaused = void 0 === e3.isIntersecting ? 0 === e3.intersectionRatio : !e3.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = false);
          }
          refreshRows(e3, t3, i3 = false) {
            this._isPaused ? this._needsFullRefresh = true : (i3 || (this._isNextRenderRedrawOnly = false), this._renderDebouncer.refresh(e3, t3, this._rowCount));
          }
          _renderRows(e3, t3) {
            this._renderer.value && (e3 = Math.min(e3, this._rowCount - 1), t3 = Math.min(t3, this._rowCount - 1), this._renderer.value.renderRows(e3, t3), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = false), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({ start: e3, end: t3 }), this._onRender.fire({ start: e3, end: t3 }), this._isNextRenderRedrawOnly = true);
          }
          resize(e3, t3) {
            this._rowCount = t3, this._fireOnCanvasResize();
          }
          _handleOptionsChanged() {
            this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
          }
          _fireOnCanvasResize() {
            this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
          }
          hasRenderer() {
            return !!this._renderer.value;
          }
          setRenderer(e3) {
            this._renderer.value = e3, this._renderer.value && (this._renderer.value.onRequestRedraw(((e4) => this.refreshRows(e4.start, e4.end, true))), this._needsSelectionRefresh = true, this._fullRefresh());
          }
          addRefreshCallback(e3) {
            return this._renderDebouncer.addRefreshCallback(e3);
          }
          _fullRefresh() {
            this._isPaused ? this._needsFullRefresh = true : this.refreshRows(0, this._rowCount - 1);
          }
          clearTextureAtlas() {
            this._renderer.value && (this._renderer.value.clearTextureAtlas?.(), this._fullRefresh());
          }
          handleDevicePixelRatioChange() {
            this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
          }
          handleResize(e3, t3) {
            this._renderer.value && (this._isPaused ? this._pausedResizeTask.set((() => this._renderer.value?.handleResize(e3, t3))) : this._renderer.value.handleResize(e3, t3), this._fullRefresh());
          }
          handleCharSizeChanged() {
            this._renderer.value?.handleCharSizeChanged();
          }
          handleBlur() {
            this._renderer.value?.handleBlur();
          }
          handleFocus() {
            this._renderer.value?.handleFocus();
          }
          handleSelectionChanged(e3, t3, i3) {
            this._selectionState.start = e3, this._selectionState.end = t3, this._selectionState.columnSelectMode = i3, this._renderer.value?.handleSelectionChanged(e3, t3, i3);
          }
          handleCursorMove() {
            this._renderer.value?.handleCursorMove();
          }
          clear() {
            this._renderer.value?.clear();
          }
        };
        t2.RenderService = d = s2([r(2, l.IOptionsService), r(3, o.ICharSizeService), r(4, l.IDecorationService), r(5, l.IBufferService), r(6, o.ICoreBrowserService), r(7, o.IThemeService)], d);
      }, 9312: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.SelectionService = void 0;
        const n = i2(9806), o = i2(9504), a = i2(456), h = i2(4725), c = i2(8460), l = i2(844), d = i2(6114), _ = i2(4841), u = i2(511), f = i2(2585), v = String.fromCharCode(160), p = new RegExp(v, "g");
        let g = t2.SelectionService = class extends l.Disposable {
          constructor(e3, t3, i3, s3, r2, n2, o2, h2, d2) {
            super(), this._element = e3, this._screenElement = t3, this._linkifier = i3, this._bufferService = s3, this._coreService = r2, this._mouseService = n2, this._optionsService = o2, this._renderService = h2, this._coreBrowserService = d2, this._dragScrollAmount = 0, this._enabled = true, this._workCell = new u.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = false, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new c.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new c.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new c.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new c.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (e4) => this._handleMouseMove(e4), this._mouseUpListener = (e4) => this._handleMouseUp(e4), this._coreService.onUserInput((() => {
              this.hasSelection && this.clearSelection();
            })), this._trimListener = this._bufferService.buffer.lines.onTrim(((e4) => this._handleTrim(e4))), this.register(this._bufferService.buffers.onBufferActivate(((e4) => this._handleBufferActivate(e4)))), this.enable(), this._model = new a.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, l.toDisposable)((() => {
              this._removeMouseDownListeners();
            })));
          }
          reset() {
            this.clearSelection();
          }
          disable() {
            this.clearSelection(), this._enabled = false;
          }
          enable() {
            this._enabled = true;
          }
          get selectionStart() {
            return this._model.finalSelectionStart;
          }
          get selectionEnd() {
            return this._model.finalSelectionEnd;
          }
          get hasSelection() {
            const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
            return !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
          }
          get selectionText() {
            const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd;
            if (!e3 || !t3) return "";
            const i3 = this._bufferService.buffer, s3 = [];
            if (3 === this._activeSelectionMode) {
              if (e3[0] === t3[0]) return "";
              const r2 = e3[0] < t3[0] ? e3[0] : t3[0], n2 = e3[0] < t3[0] ? t3[0] : e3[0];
              for (let o2 = e3[1]; o2 <= t3[1]; o2++) {
                const e4 = i3.translateBufferLineToString(o2, true, r2, n2);
                s3.push(e4);
              }
            } else {
              const r2 = e3[1] === t3[1] ? t3[0] : void 0;
              s3.push(i3.translateBufferLineToString(e3[1], true, e3[0], r2));
              for (let r3 = e3[1] + 1; r3 <= t3[1] - 1; r3++) {
                const e4 = i3.lines.get(r3), t4 = i3.translateBufferLineToString(r3, true);
                e4?.isWrapped ? s3[s3.length - 1] += t4 : s3.push(t4);
              }
              if (e3[1] !== t3[1]) {
                const e4 = i3.lines.get(t3[1]), r3 = i3.translateBufferLineToString(t3[1], true, 0, t3[0]);
                e4 && e4.isWrapped ? s3[s3.length - 1] += r3 : s3.push(r3);
              }
            }
            return s3.map(((e4) => e4.replace(p, " "))).join(d.isWindows ? "\r\n" : "\n");
          }
          clearSelection() {
            this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
          }
          refresh(e3) {
            this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame((() => this._refresh()))), d.isLinux && e3 && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
          }
          _refresh() {
            this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({ start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd, columnSelectMode: 3 === this._activeSelectionMode });
          }
          _isClickInSelection(e3) {
            const t3 = this._getMouseBufferCoords(e3), i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
            return !!(i3 && s3 && t3) && this._areCoordsInSelection(t3, i3, s3);
          }
          isCellInSelection(e3, t3) {
            const i3 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
            return !(!i3 || !s3) && this._areCoordsInSelection([e3, t3], i3, s3);
          }
          _areCoordsInSelection(e3, t3, i3) {
            return e3[1] > t3[1] && e3[1] < i3[1] || t3[1] === i3[1] && e3[1] === t3[1] && e3[0] >= t3[0] && e3[0] < i3[0] || t3[1] < i3[1] && e3[1] === i3[1] && e3[0] < i3[0] || t3[1] < i3[1] && e3[1] === t3[1] && e3[0] >= t3[0];
          }
          _selectWordAtCursor(e3, t3) {
            const i3 = this._linkifier.currentLink?.link?.range;
            if (i3) return this._model.selectionStart = [i3.start.x - 1, i3.start.y - 1], this._model.selectionStartLength = (0, _.getRangeLength)(i3, this._bufferService.cols), this._model.selectionEnd = void 0, true;
            const s3 = this._getMouseBufferCoords(e3);
            return !!s3 && (this._selectWordAt(s3, t3), this._model.selectionEnd = void 0, true);
          }
          selectAll() {
            this._model.isSelectAllActive = true, this.refresh(), this._onSelectionChange.fire();
          }
          selectLines(e3, t3) {
            this._model.clearSelection(), e3 = Math.max(e3, 0), t3 = Math.min(t3, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [0, e3], this._model.selectionEnd = [this._bufferService.cols, t3], this.refresh(), this._onSelectionChange.fire();
          }
          _handleTrim(e3) {
            this._model.handleTrim(e3) && this.refresh();
          }
          _getMouseBufferCoords(e3) {
            const t3 = this._mouseService.getCoords(e3, this._screenElement, this._bufferService.cols, this._bufferService.rows, true);
            if (t3) return t3[0]--, t3[1]--, t3[1] += this._bufferService.buffer.ydisp, t3;
          }
          _getMouseEventScrollAmount(e3) {
            let t3 = (0, n.getCoordsRelativeToElement)(this._coreBrowserService.window, e3, this._screenElement)[1];
            const i3 = this._renderService.dimensions.css.canvas.height;
            return t3 >= 0 && t3 <= i3 ? 0 : (t3 > i3 && (t3 -= i3), t3 = Math.min(Math.max(t3, -50), 50), t3 /= 50, t3 / Math.abs(t3) + Math.round(14 * t3));
          }
          shouldForceSelection(e3) {
            return d.isMac ? e3.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : e3.shiftKey;
          }
          handleMouseDown(e3) {
            if (this._mouseDownTimeStamp = e3.timeStamp, (2 !== e3.button || !this.hasSelection) && 0 === e3.button) {
              if (!this._enabled) {
                if (!this.shouldForceSelection(e3)) return;
                e3.stopPropagation();
              }
              e3.preventDefault(), this._dragScrollAmount = 0, this._enabled && e3.shiftKey ? this._handleIncrementalClick(e3) : 1 === e3.detail ? this._handleSingleClick(e3) : 2 === e3.detail ? this._handleDoubleClick(e3) : 3 === e3.detail && this._handleTripleClick(e3), this._addMouseDownListeners(), this.refresh(true);
            }
          }
          _addMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval((() => this._dragScroll()), 50);
          }
          _removeMouseDownListeners() {
            this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
          }
          _handleIncrementalClick(e3) {
            this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(e3));
          }
          _handleSingleClick(e3) {
            if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = false, this._activeSelectionMode = this.shouldColumnSelect(e3) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(e3), !this._model.selectionStart) return;
            this._model.selectionEnd = void 0;
            const t3 = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
            t3 && t3.length !== this._model.selectionStart[0] && 0 === t3.hasWidth(this._model.selectionStart[0]) && this._model.selectionStart[0]++;
          }
          _handleDoubleClick(e3) {
            this._selectWordAtCursor(e3, true) && (this._activeSelectionMode = 1);
          }
          _handleTripleClick(e3) {
            const t3 = this._getMouseBufferCoords(e3);
            t3 && (this._activeSelectionMode = 2, this._selectLineAt(t3[1]));
          }
          shouldColumnSelect(e3) {
            return e3.altKey && !(d.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
          }
          _handleMouseMove(e3) {
            if (e3.stopImmediatePropagation(), !this._model.selectionStart) return;
            const t3 = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
            if (this._model.selectionEnd = this._getMouseBufferCoords(e3), !this._model.selectionEnd) return void this.refresh(true);
            2 === this._activeSelectionMode ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : 1 === this._activeSelectionMode && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(e3), 3 !== this._activeSelectionMode && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
            const i3 = this._bufferService.buffer;
            if (this._model.selectionEnd[1] < i3.lines.length) {
              const e4 = i3.lines.get(this._model.selectionEnd[1]);
              e4 && 0 === e4.hasWidth(this._model.selectionEnd[0]) && this._model.selectionEnd[0] < this._bufferService.cols && this._model.selectionEnd[0]++;
            }
            t3 && t3[0] === this._model.selectionEnd[0] && t3[1] === this._model.selectionEnd[1] || this.refresh(true);
          }
          _dragScroll() {
            if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
              this._onRequestScrollLines.fire({ amount: this._dragScrollAmount, suppressScrollEvent: false });
              const e3 = this._bufferService.buffer;
              this._dragScrollAmount > 0 ? (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(e3.ydisp + this._bufferService.rows, e3.lines.length - 1)) : (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = e3.ydisp), this.refresh();
            }
          }
          _handleMouseUp(e3) {
            const t3 = e3.timeStamp - this._mouseDownTimeStamp;
            if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && t3 < 500 && e3.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
              if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                const t4 = this._mouseService.getCoords(e3, this._element, this._bufferService.cols, this._bufferService.rows, false);
                if (t4 && void 0 !== t4[0] && void 0 !== t4[1]) {
                  const e4 = (0, o.moveToCellSequence)(t4[0] - 1, t4[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                  this._coreService.triggerDataEvent(e4, true);
                }
              }
            } else this._fireEventIfSelectionChanged();
          }
          _fireEventIfSelectionChanged() {
            const e3 = this._model.finalSelectionStart, t3 = this._model.finalSelectionEnd, i3 = !(!e3 || !t3 || e3[0] === t3[0] && e3[1] === t3[1]);
            i3 ? e3 && t3 && (this._oldSelectionStart && this._oldSelectionEnd && e3[0] === this._oldSelectionStart[0] && e3[1] === this._oldSelectionStart[1] && t3[0] === this._oldSelectionEnd[0] && t3[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(e3, t3, i3)) : this._oldHasSelection && this._fireOnSelectionChange(e3, t3, i3);
          }
          _fireOnSelectionChange(e3, t3, i3) {
            this._oldSelectionStart = e3, this._oldSelectionEnd = t3, this._oldHasSelection = i3, this._onSelectionChange.fire();
          }
          _handleBufferActivate(e3) {
            this.clearSelection(), this._trimListener.dispose(), this._trimListener = e3.activeBuffer.lines.onTrim(((e4) => this._handleTrim(e4)));
          }
          _convertViewportColToCharacterIndex(e3, t3) {
            let i3 = t3;
            for (let s3 = 0; t3 >= s3; s3++) {
              const r2 = e3.loadCell(s3, this._workCell).getChars().length;
              0 === this._workCell.getWidth() ? i3-- : r2 > 1 && t3 !== s3 && (i3 += r2 - 1);
            }
            return i3;
          }
          setSelection(e3, t3, i3) {
            this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [e3, t3], this._model.selectionStartLength = i3, this.refresh(), this._fireEventIfSelectionChanged();
          }
          rightClickSelect(e3) {
            this._isClickInSelection(e3) || (this._selectWordAtCursor(e3, false) && this.refresh(true), this._fireEventIfSelectionChanged());
          }
          _getWordAt(e3, t3, i3 = true, s3 = true) {
            if (e3[0] >= this._bufferService.cols) return;
            const r2 = this._bufferService.buffer, n2 = r2.lines.get(e3[1]);
            if (!n2) return;
            const o2 = r2.translateBufferLineToString(e3[1], false);
            let a2 = this._convertViewportColToCharacterIndex(n2, e3[0]), h2 = a2;
            const c2 = e3[0] - a2;
            let l2 = 0, d2 = 0, _2 = 0, u2 = 0;
            if (" " === o2.charAt(a2)) {
              for (; a2 > 0 && " " === o2.charAt(a2 - 1); ) a2--;
              for (; h2 < o2.length && " " === o2.charAt(h2 + 1); ) h2++;
            } else {
              let t4 = e3[0], i4 = e3[0];
              0 === n2.getWidth(t4) && (l2++, t4--), 2 === n2.getWidth(i4) && (d2++, i4++);
              const s4 = n2.getString(i4).length;
              for (s4 > 1 && (u2 += s4 - 1, h2 += s4 - 1); t4 > 0 && a2 > 0 && !this._isCharWordSeparator(n2.loadCell(t4 - 1, this._workCell)); ) {
                n2.loadCell(t4 - 1, this._workCell);
                const e4 = this._workCell.getChars().length;
                0 === this._workCell.getWidth() ? (l2++, t4--) : e4 > 1 && (_2 += e4 - 1, a2 -= e4 - 1), a2--, t4--;
              }
              for (; i4 < n2.length && h2 + 1 < o2.length && !this._isCharWordSeparator(n2.loadCell(i4 + 1, this._workCell)); ) {
                n2.loadCell(i4 + 1, this._workCell);
                const e4 = this._workCell.getChars().length;
                2 === this._workCell.getWidth() ? (d2++, i4++) : e4 > 1 && (u2 += e4 - 1, h2 += e4 - 1), h2++, i4++;
              }
            }
            h2++;
            let f2 = a2 + c2 - l2 + _2, v2 = Math.min(this._bufferService.cols, h2 - a2 + l2 + d2 - _2 - u2);
            if (t3 || "" !== o2.slice(a2, h2).trim()) {
              if (i3 && 0 === f2 && 32 !== n2.getCodePoint(0)) {
                const t4 = r2.lines.get(e3[1] - 1);
                if (t4 && n2.isWrapped && 32 !== t4.getCodePoint(this._bufferService.cols - 1)) {
                  const t5 = this._getWordAt([this._bufferService.cols - 1, e3[1] - 1], false, true, false);
                  if (t5) {
                    const e4 = this._bufferService.cols - t5.start;
                    f2 -= e4, v2 += e4;
                  }
                }
              }
              if (s3 && f2 + v2 === this._bufferService.cols && 32 !== n2.getCodePoint(this._bufferService.cols - 1)) {
                const t4 = r2.lines.get(e3[1] + 1);
                if (t4?.isWrapped && 32 !== t4.getCodePoint(0)) {
                  const t5 = this._getWordAt([0, e3[1] + 1], false, false, true);
                  t5 && (v2 += t5.length);
                }
              }
              return { start: f2, length: v2 };
            }
          }
          _selectWordAt(e3, t3) {
            const i3 = this._getWordAt(e3, t3);
            if (i3) {
              for (; i3.start < 0; ) i3.start += this._bufferService.cols, e3[1]--;
              this._model.selectionStart = [i3.start, e3[1]], this._model.selectionStartLength = i3.length;
            }
          }
          _selectToWordAt(e3) {
            const t3 = this._getWordAt(e3, true);
            if (t3) {
              let i3 = e3[1];
              for (; t3.start < 0; ) t3.start += this._bufferService.cols, i3--;
              if (!this._model.areSelectionValuesReversed()) for (; t3.start + t3.length > this._bufferService.cols; ) t3.length -= this._bufferService.cols, i3++;
              this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? t3.start : t3.start + t3.length, i3];
            }
          }
          _isCharWordSeparator(e3) {
            return 0 !== e3.getWidth() && this._optionsService.rawOptions.wordSeparator.indexOf(e3.getChars()) >= 0;
          }
          _selectLineAt(e3) {
            const t3 = this._bufferService.buffer.getWrappedRangeForLine(e3), i3 = { start: { x: 0, y: t3.first }, end: { x: this._bufferService.cols - 1, y: t3.last } };
            this._model.selectionStart = [0, t3.first], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, _.getRangeLength)(i3, this._bufferService.cols);
          }
        };
        t2.SelectionService = g = s2([r(3, f.IBufferService), r(4, f.ICoreService), r(5, h.IMouseService), r(6, f.IOptionsService), r(7, h.IRenderService), r(8, h.ICoreBrowserService)], g);
      }, 4725: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ILinkProviderService = t2.IThemeService = t2.ICharacterJoinerService = t2.ISelectionService = t2.IRenderService = t2.IMouseService = t2.ICoreBrowserService = t2.ICharSizeService = void 0;
        const s2 = i2(8343);
        t2.ICharSizeService = (0, s2.createDecorator)("CharSizeService"), t2.ICoreBrowserService = (0, s2.createDecorator)("CoreBrowserService"), t2.IMouseService = (0, s2.createDecorator)("MouseService"), t2.IRenderService = (0, s2.createDecorator)("RenderService"), t2.ISelectionService = (0, s2.createDecorator)("SelectionService"), t2.ICharacterJoinerService = (0, s2.createDecorator)("CharacterJoinerService"), t2.IThemeService = (0, s2.createDecorator)("ThemeService"), t2.ILinkProviderService = (0, s2.createDecorator)("LinkProviderService");
      }, 6731: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ThemeService = t2.DEFAULT_ANSI_COLORS = void 0;
        const n = i2(7239), o = i2(8055), a = i2(8460), h = i2(844), c = i2(2585), l = o.css.toColor("#ffffff"), d = o.css.toColor("#000000"), _ = o.css.toColor("#ffffff"), u = o.css.toColor("#000000"), f = { css: "rgba(255, 255, 255, 0.3)", rgba: 4294967117 };
        t2.DEFAULT_ANSI_COLORS = Object.freeze((() => {
          const e3 = [o.css.toColor("#2e3436"), o.css.toColor("#cc0000"), o.css.toColor("#4e9a06"), o.css.toColor("#c4a000"), o.css.toColor("#3465a4"), o.css.toColor("#75507b"), o.css.toColor("#06989a"), o.css.toColor("#d3d7cf"), o.css.toColor("#555753"), o.css.toColor("#ef2929"), o.css.toColor("#8ae234"), o.css.toColor("#fce94f"), o.css.toColor("#729fcf"), o.css.toColor("#ad7fa8"), o.css.toColor("#34e2e2"), o.css.toColor("#eeeeec")], t3 = [0, 95, 135, 175, 215, 255];
          for (let i3 = 0; i3 < 216; i3++) {
            const s3 = t3[i3 / 36 % 6 | 0], r2 = t3[i3 / 6 % 6 | 0], n2 = t3[i3 % 6];
            e3.push({ css: o.channels.toCss(s3, r2, n2), rgba: o.channels.toRgba(s3, r2, n2) });
          }
          for (let t4 = 0; t4 < 24; t4++) {
            const i3 = 8 + 10 * t4;
            e3.push({ css: o.channels.toCss(i3, i3, i3), rgba: o.channels.toRgba(i3, i3, i3) });
          }
          return e3;
        })());
        let v = t2.ThemeService = class extends h.Disposable {
          get colors() {
            return this._colors;
          }
          constructor(e3) {
            super(), this._optionsService = e3, this._contrastCache = new n.ColorContrastCache(), this._halfContrastCache = new n.ColorContrastCache(), this._onChangeColors = this.register(new a.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = { foreground: l, background: d, cursor: _, cursorAccent: u, selectionForeground: void 0, selectionBackgroundTransparent: f, selectionBackgroundOpaque: o.color.blend(d, f), selectionInactiveBackgroundTransparent: f, selectionInactiveBackgroundOpaque: o.color.blend(d, f), ansi: t2.DEFAULT_ANSI_COLORS.slice(), contrastCache: this._contrastCache, halfContrastCache: this._halfContrastCache }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", (() => this._contrastCache.clear()))), this.register(this._optionsService.onSpecificOptionChange("theme", (() => this._setTheme(this._optionsService.rawOptions.theme))));
          }
          _setTheme(e3 = {}) {
            const i3 = this._colors;
            if (i3.foreground = p(e3.foreground, l), i3.background = p(e3.background, d), i3.cursor = p(e3.cursor, _), i3.cursorAccent = p(e3.cursorAccent, u), i3.selectionBackgroundTransparent = p(e3.selectionBackground, f), i3.selectionBackgroundOpaque = o.color.blend(i3.background, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundTransparent = p(e3.selectionInactiveBackground, i3.selectionBackgroundTransparent), i3.selectionInactiveBackgroundOpaque = o.color.blend(i3.background, i3.selectionInactiveBackgroundTransparent), i3.selectionForeground = e3.selectionForeground ? p(e3.selectionForeground, o.NULL_COLOR) : void 0, i3.selectionForeground === o.NULL_COLOR && (i3.selectionForeground = void 0), o.color.isOpaque(i3.selectionBackgroundTransparent)) {
              const e4 = 0.3;
              i3.selectionBackgroundTransparent = o.color.opacity(i3.selectionBackgroundTransparent, e4);
            }
            if (o.color.isOpaque(i3.selectionInactiveBackgroundTransparent)) {
              const e4 = 0.3;
              i3.selectionInactiveBackgroundTransparent = o.color.opacity(i3.selectionInactiveBackgroundTransparent, e4);
            }
            if (i3.ansi = t2.DEFAULT_ANSI_COLORS.slice(), i3.ansi[0] = p(e3.black, t2.DEFAULT_ANSI_COLORS[0]), i3.ansi[1] = p(e3.red, t2.DEFAULT_ANSI_COLORS[1]), i3.ansi[2] = p(e3.green, t2.DEFAULT_ANSI_COLORS[2]), i3.ansi[3] = p(e3.yellow, t2.DEFAULT_ANSI_COLORS[3]), i3.ansi[4] = p(e3.blue, t2.DEFAULT_ANSI_COLORS[4]), i3.ansi[5] = p(e3.magenta, t2.DEFAULT_ANSI_COLORS[5]), i3.ansi[6] = p(e3.cyan, t2.DEFAULT_ANSI_COLORS[6]), i3.ansi[7] = p(e3.white, t2.DEFAULT_ANSI_COLORS[7]), i3.ansi[8] = p(e3.brightBlack, t2.DEFAULT_ANSI_COLORS[8]), i3.ansi[9] = p(e3.brightRed, t2.DEFAULT_ANSI_COLORS[9]), i3.ansi[10] = p(e3.brightGreen, t2.DEFAULT_ANSI_COLORS[10]), i3.ansi[11] = p(e3.brightYellow, t2.DEFAULT_ANSI_COLORS[11]), i3.ansi[12] = p(e3.brightBlue, t2.DEFAULT_ANSI_COLORS[12]), i3.ansi[13] = p(e3.brightMagenta, t2.DEFAULT_ANSI_COLORS[13]), i3.ansi[14] = p(e3.brightCyan, t2.DEFAULT_ANSI_COLORS[14]), i3.ansi[15] = p(e3.brightWhite, t2.DEFAULT_ANSI_COLORS[15]), e3.extendedAnsi) {
              const s3 = Math.min(i3.ansi.length - 16, e3.extendedAnsi.length);
              for (let r2 = 0; r2 < s3; r2++) i3.ansi[r2 + 16] = p(e3.extendedAnsi[r2], t2.DEFAULT_ANSI_COLORS[r2 + 16]);
            }
            this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
          }
          restoreColor(e3) {
            this._restoreColor(e3), this._onChangeColors.fire(this.colors);
          }
          _restoreColor(e3) {
            if (void 0 !== e3) switch (e3) {
              case 256:
                this._colors.foreground = this._restoreColors.foreground;
                break;
              case 257:
                this._colors.background = this._restoreColors.background;
                break;
              case 258:
                this._colors.cursor = this._restoreColors.cursor;
                break;
              default:
                this._colors.ansi[e3] = this._restoreColors.ansi[e3];
            }
            else for (let e4 = 0; e4 < this._restoreColors.ansi.length; ++e4) this._colors.ansi[e4] = this._restoreColors.ansi[e4];
          }
          modifyColors(e3) {
            e3(this._colors), this._onChangeColors.fire(this.colors);
          }
          _updateRestoreColors() {
            this._restoreColors = { foreground: this._colors.foreground, background: this._colors.background, cursor: this._colors.cursor, ansi: this._colors.ansi.slice() };
          }
        };
        function p(e3, t3) {
          if (void 0 !== e3) try {
            return o.css.toColor(e3);
          } catch {
          }
          return t3;
        }
        t2.ThemeService = v = s2([r(0, c.IOptionsService)], v);
      }, 6349: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CircularList = void 0;
        const s2 = i2(8460), r = i2(844);
        class n extends r.Disposable {
          constructor(e3) {
            super(), this._maxLength = e3, this.onDeleteEmitter = this.register(new s2.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new s2.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new s2.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
          }
          get maxLength() {
            return this._maxLength;
          }
          set maxLength(e3) {
            if (this._maxLength === e3) return;
            const t3 = new Array(e3);
            for (let i3 = 0; i3 < Math.min(e3, this.length); i3++) t3[i3] = this._array[this._getCyclicIndex(i3)];
            this._array = t3, this._maxLength = e3, this._startIndex = 0;
          }
          get length() {
            return this._length;
          }
          set length(e3) {
            if (e3 > this._length) for (let t3 = this._length; t3 < e3; t3++) this._array[t3] = void 0;
            this._length = e3;
          }
          get(e3) {
            return this._array[this._getCyclicIndex(e3)];
          }
          set(e3, t3) {
            this._array[this._getCyclicIndex(e3)] = t3;
          }
          push(e3) {
            this._array[this._getCyclicIndex(this._length)] = e3, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
          }
          recycle() {
            if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full");
            return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
          }
          get isFull() {
            return this._length === this._maxLength;
          }
          pop() {
            return this._array[this._getCyclicIndex(this._length-- - 1)];
          }
          splice(e3, t3, ...i3) {
            if (t3) {
              for (let i4 = e3; i4 < this._length - t3; i4++) this._array[this._getCyclicIndex(i4)] = this._array[this._getCyclicIndex(i4 + t3)];
              this._length -= t3, this.onDeleteEmitter.fire({ index: e3, amount: t3 });
            }
            for (let t4 = this._length - 1; t4 >= e3; t4--) this._array[this._getCyclicIndex(t4 + i3.length)] = this._array[this._getCyclicIndex(t4)];
            for (let t4 = 0; t4 < i3.length; t4++) this._array[this._getCyclicIndex(e3 + t4)] = i3[t4];
            if (i3.length && this.onInsertEmitter.fire({ index: e3, amount: i3.length }), this._length + i3.length > this._maxLength) {
              const e4 = this._length + i3.length - this._maxLength;
              this._startIndex += e4, this._length = this._maxLength, this.onTrimEmitter.fire(e4);
            } else this._length += i3.length;
          }
          trimStart(e3) {
            e3 > this._length && (e3 = this._length), this._startIndex += e3, this._length -= e3, this.onTrimEmitter.fire(e3);
          }
          shiftElements(e3, t3, i3) {
            if (!(t3 <= 0)) {
              if (e3 < 0 || e3 >= this._length) throw new Error("start argument out of range");
              if (e3 + i3 < 0) throw new Error("Cannot shift elements in list beyond index 0");
              if (i3 > 0) {
                for (let s4 = t3 - 1; s4 >= 0; s4--) this.set(e3 + s4 + i3, this.get(e3 + s4));
                const s3 = e3 + t3 + i3 - this._length;
                if (s3 > 0) for (this._length += s3; this._length > this._maxLength; ) this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
              } else for (let s3 = 0; s3 < t3; s3++) this.set(e3 + s3 + i3, this.get(e3 + s3));
            }
          }
          _getCyclicIndex(e3) {
            return (this._startIndex + e3) % this._maxLength;
          }
        }
        t2.CircularList = n;
      }, 1439: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.clone = void 0, t2.clone = function e3(t3, i2 = 5) {
          if ("object" != typeof t3) return t3;
          const s2 = Array.isArray(t3) ? [] : {};
          for (const r in t3) s2[r] = i2 <= 1 ? t3[r] : t3[r] && e3(t3[r], i2 - 1);
          return s2;
        };
      }, 8055: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.contrastRatio = t2.toPaddedHex = t2.rgba = t2.rgb = t2.css = t2.color = t2.channels = t2.NULL_COLOR = void 0;
        let i2 = 0, s2 = 0, r = 0, n = 0;
        var o, a, h, c, l;
        function d(e3) {
          const t3 = e3.toString(16);
          return t3.length < 2 ? "0" + t3 : t3;
        }
        function _(e3, t3) {
          return e3 < t3 ? (t3 + 0.05) / (e3 + 0.05) : (e3 + 0.05) / (t3 + 0.05);
        }
        t2.NULL_COLOR = { css: "#00000000", rgba: 0 }, (function(e3) {
          e3.toCss = function(e4, t3, i3, s3) {
            return void 0 !== s3 ? `#${d(e4)}${d(t3)}${d(i3)}${d(s3)}` : `#${d(e4)}${d(t3)}${d(i3)}`;
          }, e3.toRgba = function(e4, t3, i3, s3 = 255) {
            return (e4 << 24 | t3 << 16 | i3 << 8 | s3) >>> 0;
          }, e3.toColor = function(t3, i3, s3, r2) {
            return { css: e3.toCss(t3, i3, s3, r2), rgba: e3.toRgba(t3, i3, s3, r2) };
          };
        })(o || (t2.channels = o = {})), (function(e3) {
          function t3(e4, t4) {
            return n = Math.round(255 * t4), [i2, s2, r] = l.toChannels(e4.rgba), { css: o.toCss(i2, s2, r, n), rgba: o.toRgba(i2, s2, r, n) };
          }
          e3.blend = function(e4, t4) {
            if (n = (255 & t4.rgba) / 255, 1 === n) return { css: t4.css, rgba: t4.rgba };
            const a2 = t4.rgba >> 24 & 255, h2 = t4.rgba >> 16 & 255, c2 = t4.rgba >> 8 & 255, l2 = e4.rgba >> 24 & 255, d2 = e4.rgba >> 16 & 255, _2 = e4.rgba >> 8 & 255;
            return i2 = l2 + Math.round((a2 - l2) * n), s2 = d2 + Math.round((h2 - d2) * n), r = _2 + Math.round((c2 - _2) * n), { css: o.toCss(i2, s2, r), rgba: o.toRgba(i2, s2, r) };
          }, e3.isOpaque = function(e4) {
            return 255 == (255 & e4.rgba);
          }, e3.ensureContrastRatio = function(e4, t4, i3) {
            const s3 = l.ensureContrastRatio(e4.rgba, t4.rgba, i3);
            if (s3) return o.toColor(s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255);
          }, e3.opaque = function(e4) {
            const t4 = (255 | e4.rgba) >>> 0;
            return [i2, s2, r] = l.toChannels(t4), { css: o.toCss(i2, s2, r), rgba: t4 };
          }, e3.opacity = t3, e3.multiplyOpacity = function(e4, i3) {
            return n = 255 & e4.rgba, t3(e4, n * i3 / 255);
          }, e3.toColorRGB = function(e4) {
            return [e4.rgba >> 24 & 255, e4.rgba >> 16 & 255, e4.rgba >> 8 & 255];
          };
        })(a || (t2.color = a = {})), (function(e3) {
          let t3, a2;
          try {
            const e4 = document.createElement("canvas");
            e4.width = 1, e4.height = 1;
            const i3 = e4.getContext("2d", { willReadFrequently: true });
            i3 && (t3 = i3, t3.globalCompositeOperation = "copy", a2 = t3.createLinearGradient(0, 0, 1, 1));
          } catch {
          }
          e3.toColor = function(e4) {
            if (e4.match(/#[\da-f]{3,8}/i)) switch (e4.length) {
              case 4:
                return i2 = parseInt(e4.slice(1, 2).repeat(2), 16), s2 = parseInt(e4.slice(2, 3).repeat(2), 16), r = parseInt(e4.slice(3, 4).repeat(2), 16), o.toColor(i2, s2, r);
              case 5:
                return i2 = parseInt(e4.slice(1, 2).repeat(2), 16), s2 = parseInt(e4.slice(2, 3).repeat(2), 16), r = parseInt(e4.slice(3, 4).repeat(2), 16), n = parseInt(e4.slice(4, 5).repeat(2), 16), o.toColor(i2, s2, r, n);
              case 7:
                return { css: e4, rgba: (parseInt(e4.slice(1), 16) << 8 | 255) >>> 0 };
              case 9:
                return { css: e4, rgba: parseInt(e4.slice(1), 16) >>> 0 };
            }
            const h2 = e4.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
            if (h2) return i2 = parseInt(h2[1]), s2 = parseInt(h2[2]), r = parseInt(h2[3]), n = Math.round(255 * (void 0 === h2[5] ? 1 : parseFloat(h2[5]))), o.toColor(i2, s2, r, n);
            if (!t3 || !a2) throw new Error("css.toColor: Unsupported css format");
            if (t3.fillStyle = a2, t3.fillStyle = e4, "string" != typeof t3.fillStyle) throw new Error("css.toColor: Unsupported css format");
            if (t3.fillRect(0, 0, 1, 1), [i2, s2, r, n] = t3.getImageData(0, 0, 1, 1).data, 255 !== n) throw new Error("css.toColor: Unsupported css format");
            return { rgba: o.toRgba(i2, s2, r, n), css: e4 };
          };
        })(h || (t2.css = h = {})), (function(e3) {
          function t3(e4, t4, i3) {
            const s3 = e4 / 255, r2 = t4 / 255, n2 = i3 / 255;
            return 0.2126 * (s3 <= 0.03928 ? s3 / 12.92 : Math.pow((s3 + 0.055) / 1.055, 2.4)) + 0.7152 * (r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4)) + 0.0722 * (n2 <= 0.03928 ? n2 / 12.92 : Math.pow((n2 + 0.055) / 1.055, 2.4));
          }
          e3.relativeLuminance = function(e4) {
            return t3(e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4);
          }, e3.relativeLuminance2 = t3;
        })(c || (t2.rgb = c = {})), (function(e3) {
          function t3(e4, t4, i3) {
            const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
            let o2 = t4 >> 24 & 255, a3 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
            for (; l2 < i3 && (o2 > 0 || a3 > 0 || h2 > 0); ) o2 -= Math.max(0, Math.ceil(0.1 * o2)), a3 -= Math.max(0, Math.ceil(0.1 * a3)), h2 -= Math.max(0, Math.ceil(0.1 * h2)), l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
            return (o2 << 24 | a3 << 16 | h2 << 8 | 255) >>> 0;
          }
          function a2(e4, t4, i3) {
            const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
            let o2 = t4 >> 24 & 255, a3 = t4 >> 16 & 255, h2 = t4 >> 8 & 255, l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
            for (; l2 < i3 && (o2 < 255 || a3 < 255 || h2 < 255); ) o2 = Math.min(255, o2 + Math.ceil(0.1 * (255 - o2))), a3 = Math.min(255, a3 + Math.ceil(0.1 * (255 - a3))), h2 = Math.min(255, h2 + Math.ceil(0.1 * (255 - h2))), l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
            return (o2 << 24 | a3 << 16 | h2 << 8 | 255) >>> 0;
          }
          e3.blend = function(e4, t4) {
            if (n = (255 & t4) / 255, 1 === n) return t4;
            const a3 = t4 >> 24 & 255, h2 = t4 >> 16 & 255, c2 = t4 >> 8 & 255, l2 = e4 >> 24 & 255, d2 = e4 >> 16 & 255, _2 = e4 >> 8 & 255;
            return i2 = l2 + Math.round((a3 - l2) * n), s2 = d2 + Math.round((h2 - d2) * n), r = _2 + Math.round((c2 - _2) * n), o.toRgba(i2, s2, r);
          }, e3.ensureContrastRatio = function(e4, i3, s3) {
            const r2 = c.relativeLuminance(e4 >> 8), n2 = c.relativeLuminance(i3 >> 8);
            if (_(r2, n2) < s3) {
              if (n2 < r2) {
                const n3 = t3(e4, i3, s3), o3 = _(r2, c.relativeLuminance(n3 >> 8));
                if (o3 < s3) {
                  const t4 = a2(e4, i3, s3);
                  return o3 > _(r2, c.relativeLuminance(t4 >> 8)) ? n3 : t4;
                }
                return n3;
              }
              const o2 = a2(e4, i3, s3), h2 = _(r2, c.relativeLuminance(o2 >> 8));
              if (h2 < s3) {
                const n3 = t3(e4, i3, s3);
                return h2 > _(r2, c.relativeLuminance(n3 >> 8)) ? o2 : n3;
              }
              return o2;
            }
          }, e3.reduceLuminance = t3, e3.increaseLuminance = a2, e3.toChannels = function(e4) {
            return [e4 >> 24 & 255, e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4];
          };
        })(l || (t2.rgba = l = {})), t2.toPaddedHex = d, t2.contrastRatio = _;
      }, 8969: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreTerminal = void 0;
        const s2 = i2(844), r = i2(2585), n = i2(4348), o = i2(7866), a = i2(744), h = i2(7302), c = i2(6975), l = i2(8460), d = i2(1753), _ = i2(1480), u = i2(7994), f = i2(9282), v = i2(5435), p = i2(5981), g = i2(2660);
        let m = false;
        class S extends s2.Disposable {
          get onScroll() {
            return this._onScrollApi || (this._onScrollApi = this.register(new l.EventEmitter()), this._onScroll.event(((e3) => {
              this._onScrollApi?.fire(e3.position);
            }))), this._onScrollApi.event;
          }
          get cols() {
            return this._bufferService.cols;
          }
          get rows() {
            return this._bufferService.rows;
          }
          get buffers() {
            return this._bufferService.buffers;
          }
          get options() {
            return this.optionsService.options;
          }
          set options(e3) {
            for (const t3 in e3) this.optionsService.options[t3] = e3[t3];
          }
          constructor(e3) {
            super(), this._windowsWrappingHeuristics = this.register(new s2.MutableDisposable()), this._onBinary = this.register(new l.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new l.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new l.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new l.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new l.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new l.EventEmitter()), this._instantiationService = new n.InstantiationService(), this.optionsService = this.register(new h.OptionsService(e3)), this._instantiationService.setService(r.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(r.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(o.LogService)), this._instantiationService.setService(r.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(c.CoreService)), this._instantiationService.setService(r.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(d.CoreMouseService)), this._instantiationService.setService(r.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(_.UnicodeService)), this._instantiationService.setService(r.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(u.CharsetService), this._instantiationService.setService(r.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(g.OscLinkService), this._instantiationService.setService(r.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new v.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, l.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, l.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, l.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, l.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom((() => this.scrollToBottom()))), this.register(this.coreService.onUserInput((() => this._writeBuffer.handleUserInput()))), this.register(this.optionsService.onMultipleOptionChange(["windowsMode", "windowsPty"], (() => this._handleWindowsPtyOptionChange()))), this.register(this._bufferService.onScroll(((e4) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            }))), this.register(this._inputHandler.onScroll(((e4) => {
              this._onScroll.fire({ position: this._bufferService.buffer.ydisp, source: 0 }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
            }))), this._writeBuffer = this.register(new p.WriteBuffer(((e4, t3) => this._inputHandler.parse(e4, t3)))), this.register((0, l.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
          }
          write(e3, t3) {
            this._writeBuffer.write(e3, t3);
          }
          writeSync(e3, t3) {
            this._logService.logLevel <= r.LogLevelEnum.WARN && !m && (this._logService.warn("writeSync is unreliable and will be removed soon."), m = true), this._writeBuffer.writeSync(e3, t3);
          }
          input(e3, t3 = true) {
            this.coreService.triggerDataEvent(e3, t3);
          }
          resize(e3, t3) {
            isNaN(e3) || isNaN(t3) || (e3 = Math.max(e3, a.MINIMUM_COLS), t3 = Math.max(t3, a.MINIMUM_ROWS), this._bufferService.resize(e3, t3));
          }
          scroll(e3, t3 = false) {
            this._bufferService.scroll(e3, t3);
          }
          scrollLines(e3, t3, i3) {
            this._bufferService.scrollLines(e3, t3, i3);
          }
          scrollPages(e3) {
            this.scrollLines(e3 * (this.rows - 1));
          }
          scrollToTop() {
            this.scrollLines(-this._bufferService.buffer.ydisp);
          }
          scrollToBottom() {
            this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
          }
          scrollToLine(e3) {
            const t3 = e3 - this._bufferService.buffer.ydisp;
            0 !== t3 && this.scrollLines(t3);
          }
          registerEscHandler(e3, t3) {
            return this._inputHandler.registerEscHandler(e3, t3);
          }
          registerDcsHandler(e3, t3) {
            return this._inputHandler.registerDcsHandler(e3, t3);
          }
          registerCsiHandler(e3, t3) {
            return this._inputHandler.registerCsiHandler(e3, t3);
          }
          registerOscHandler(e3, t3) {
            return this._inputHandler.registerOscHandler(e3, t3);
          }
          _setup() {
            this._handleWindowsPtyOptionChange();
          }
          reset() {
            this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
          }
          _handleWindowsPtyOptionChange() {
            let e3 = false;
            const t3 = this.optionsService.rawOptions.windowsPty;
            t3 && void 0 !== t3.buildNumber && void 0 !== t3.buildNumber ? e3 = !!("conpty" === t3.backend && t3.buildNumber < 21376) : this.optionsService.rawOptions.windowsMode && (e3 = true), e3 ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
          }
          _enableWindowsWrappingHeuristics() {
            if (!this._windowsWrappingHeuristics.value) {
              const e3 = [];
              e3.push(this.onLineFeed(f.updateWindowsModeWrappedState.bind(null, this._bufferService))), e3.push(this.registerCsiHandler({ final: "H" }, (() => ((0, f.updateWindowsModeWrappedState)(this._bufferService), false)))), this._windowsWrappingHeuristics.value = (0, s2.toDisposable)((() => {
                for (const t3 of e3) t3.dispose();
              }));
            }
          }
        }
        t2.CoreTerminal = S;
      }, 8460: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.runAndSubscribe = t2.forwardEvent = t2.EventEmitter = void 0, t2.EventEmitter = class {
          constructor() {
            this._listeners = [], this._disposed = false;
          }
          get event() {
            return this._event || (this._event = (e3) => (this._listeners.push(e3), { dispose: () => {
              if (!this._disposed) {
                for (let t3 = 0; t3 < this._listeners.length; t3++) if (this._listeners[t3] === e3) return void this._listeners.splice(t3, 1);
              }
            } })), this._event;
          }
          fire(e3, t3) {
            const i2 = [];
            for (let e4 = 0; e4 < this._listeners.length; e4++) i2.push(this._listeners[e4]);
            for (let s2 = 0; s2 < i2.length; s2++) i2[s2].call(void 0, e3, t3);
          }
          dispose() {
            this.clearListeners(), this._disposed = true;
          }
          clearListeners() {
            this._listeners && (this._listeners.length = 0);
          }
        }, t2.forwardEvent = function(e3, t3) {
          return e3(((e4) => t3.fire(e4)));
        }, t2.runAndSubscribe = function(e3, t3) {
          return t3(void 0), e3(((e4) => t3(e4)));
        };
      }, 5435: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.InputHandler = t2.WindowsOptionsReportType = void 0;
        const n = i2(2584), o = i2(7116), a = i2(2015), h = i2(844), c = i2(482), l = i2(8437), d = i2(8460), _ = i2(643), u = i2(511), f = i2(3734), v = i2(2585), p = i2(1480), g = i2(6242), m = i2(6351), S = i2(5941), C = { "(": 0, ")": 1, "*": 2, "+": 3, "-": 1, ".": 2 }, b2 = 131072;
        function w(e3, t3) {
          if (e3 > 24) return t3.setWinLines || false;
          switch (e3) {
            case 1:
              return !!t3.restoreWin;
            case 2:
              return !!t3.minimizeWin;
            case 3:
              return !!t3.setWinPosition;
            case 4:
              return !!t3.setWinSizePixels;
            case 5:
              return !!t3.raiseWin;
            case 6:
              return !!t3.lowerWin;
            case 7:
              return !!t3.refreshWin;
            case 8:
              return !!t3.setWinSizeChars;
            case 9:
              return !!t3.maximizeWin;
            case 10:
              return !!t3.fullscreenWin;
            case 11:
              return !!t3.getWinState;
            case 13:
              return !!t3.getWinPosition;
            case 14:
              return !!t3.getWinSizePixels;
            case 15:
              return !!t3.getScreenSizePixels;
            case 16:
              return !!t3.getCellSizePixels;
            case 18:
              return !!t3.getWinSizeChars;
            case 19:
              return !!t3.getScreenSizeChars;
            case 20:
              return !!t3.getIconTitle;
            case 21:
              return !!t3.getWinTitle;
            case 22:
              return !!t3.pushTitle;
            case 23:
              return !!t3.popTitle;
            case 24:
              return !!t3.setWinLines;
          }
          return false;
        }
        var y;
        !(function(e3) {
          e3[e3.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", e3[e3.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
        })(y || (t2.WindowsOptionsReportType = y = {}));
        let E = 0;
        class k extends h.Disposable {
          getAttrData() {
            return this._curAttrData;
          }
          constructor(e3, t3, i3, s3, r2, h2, _2, f2, v2 = new a.EscapeSequenceParser()) {
            super(), this._bufferService = e3, this._charsetService = t3, this._coreService = i3, this._logService = s3, this._optionsService = r2, this._oscLinkService = h2, this._coreMouseService = _2, this._unicodeService = f2, this._parser = v2, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new c.StringToUtf32(), this._utf8Decoder = new c.Utf8ToUtf32(), this._workCell = new u.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new d.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new d.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new d.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new d.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new d.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new d.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new d.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new d.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new d.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new d.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new d.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new d.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new d.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = { paused: false, cursorStartX: 0, cursorStartY: 0, decodedLength: 0, position: 0 }, this._specialColors = [256, 257, 258], this.register(this._parser), this._dirtyRowTracker = new L2(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate(((e4) => this._activeBuffer = e4.activeBuffer))), this._parser.setCsiHandlerFallback(((e4, t4) => {
              this._logService.debug("Unknown CSI code: ", { identifier: this._parser.identToString(e4), params: t4.toArray() });
            })), this._parser.setEscHandlerFallback(((e4) => {
              this._logService.debug("Unknown ESC code: ", { identifier: this._parser.identToString(e4) });
            })), this._parser.setExecuteHandlerFallback(((e4) => {
              this._logService.debug("Unknown EXECUTE code: ", { code: e4 });
            })), this._parser.setOscHandlerFallback(((e4, t4, i4) => {
              this._logService.debug("Unknown OSC code: ", { identifier: e4, action: t4, data: i4 });
            })), this._parser.setDcsHandlerFallback(((e4, t4, i4) => {
              "HOOK" === t4 && (i4 = i4.toArray()), this._logService.debug("Unknown DCS code: ", { identifier: this._parser.identToString(e4), action: t4, payload: i4 });
            })), this._parser.setPrintHandler(((e4, t4, i4) => this.print(e4, t4, i4))), this._parser.registerCsiHandler({ final: "@" }, ((e4) => this.insertChars(e4))), this._parser.registerCsiHandler({ intermediates: " ", final: "@" }, ((e4) => this.scrollLeft(e4))), this._parser.registerCsiHandler({ final: "A" }, ((e4) => this.cursorUp(e4))), this._parser.registerCsiHandler({ intermediates: " ", final: "A" }, ((e4) => this.scrollRight(e4))), this._parser.registerCsiHandler({ final: "B" }, ((e4) => this.cursorDown(e4))), this._parser.registerCsiHandler({ final: "C" }, ((e4) => this.cursorForward(e4))), this._parser.registerCsiHandler({ final: "D" }, ((e4) => this.cursorBackward(e4))), this._parser.registerCsiHandler({ final: "E" }, ((e4) => this.cursorNextLine(e4))), this._parser.registerCsiHandler({ final: "F" }, ((e4) => this.cursorPrecedingLine(e4))), this._parser.registerCsiHandler({ final: "G" }, ((e4) => this.cursorCharAbsolute(e4))), this._parser.registerCsiHandler({ final: "H" }, ((e4) => this.cursorPosition(e4))), this._parser.registerCsiHandler({ final: "I" }, ((e4) => this.cursorForwardTab(e4))), this._parser.registerCsiHandler({ final: "J" }, ((e4) => this.eraseInDisplay(e4, false))), this._parser.registerCsiHandler({ prefix: "?", final: "J" }, ((e4) => this.eraseInDisplay(e4, true))), this._parser.registerCsiHandler({ final: "K" }, ((e4) => this.eraseInLine(e4, false))), this._parser.registerCsiHandler({ prefix: "?", final: "K" }, ((e4) => this.eraseInLine(e4, true))), this._parser.registerCsiHandler({ final: "L" }, ((e4) => this.insertLines(e4))), this._parser.registerCsiHandler({ final: "M" }, ((e4) => this.deleteLines(e4))), this._parser.registerCsiHandler({ final: "P" }, ((e4) => this.deleteChars(e4))), this._parser.registerCsiHandler({ final: "S" }, ((e4) => this.scrollUp(e4))), this._parser.registerCsiHandler({ final: "T" }, ((e4) => this.scrollDown(e4))), this._parser.registerCsiHandler({ final: "X" }, ((e4) => this.eraseChars(e4))), this._parser.registerCsiHandler({ final: "Z" }, ((e4) => this.cursorBackwardTab(e4))), this._parser.registerCsiHandler({ final: "`" }, ((e4) => this.charPosAbsolute(e4))), this._parser.registerCsiHandler({ final: "a" }, ((e4) => this.hPositionRelative(e4))), this._parser.registerCsiHandler({ final: "b" }, ((e4) => this.repeatPrecedingCharacter(e4))), this._parser.registerCsiHandler({ final: "c" }, ((e4) => this.sendDeviceAttributesPrimary(e4))), this._parser.registerCsiHandler({ prefix: ">", final: "c" }, ((e4) => this.sendDeviceAttributesSecondary(e4))), this._parser.registerCsiHandler({ final: "d" }, ((e4) => this.linePosAbsolute(e4))), this._parser.registerCsiHandler({ final: "e" }, ((e4) => this.vPositionRelative(e4))), this._parser.registerCsiHandler({ final: "f" }, ((e4) => this.hVPosition(e4))), this._parser.registerCsiHandler({ final: "g" }, ((e4) => this.tabClear(e4))), this._parser.registerCsiHandler({ final: "h" }, ((e4) => this.setMode(e4))), this._parser.registerCsiHandler({ prefix: "?", final: "h" }, ((e4) => this.setModePrivate(e4))), this._parser.registerCsiHandler({ final: "l" }, ((e4) => this.resetMode(e4))), this._parser.registerCsiHandler({ prefix: "?", final: "l" }, ((e4) => this.resetModePrivate(e4))), this._parser.registerCsiHandler({ final: "m" }, ((e4) => this.charAttributes(e4))), this._parser.registerCsiHandler({ final: "n" }, ((e4) => this.deviceStatus(e4))), this._parser.registerCsiHandler({ prefix: "?", final: "n" }, ((e4) => this.deviceStatusPrivate(e4))), this._parser.registerCsiHandler({ intermediates: "!", final: "p" }, ((e4) => this.softReset(e4))), this._parser.registerCsiHandler({ intermediates: " ", final: "q" }, ((e4) => this.setCursorStyle(e4))), this._parser.registerCsiHandler({ final: "r" }, ((e4) => this.setScrollRegion(e4))), this._parser.registerCsiHandler({ final: "s" }, ((e4) => this.saveCursor(e4))), this._parser.registerCsiHandler({ final: "t" }, ((e4) => this.windowOptions(e4))), this._parser.registerCsiHandler({ final: "u" }, ((e4) => this.restoreCursor(e4))), this._parser.registerCsiHandler({ intermediates: "'", final: "}" }, ((e4) => this.insertColumns(e4))), this._parser.registerCsiHandler({ intermediates: "'", final: "~" }, ((e4) => this.deleteColumns(e4))), this._parser.registerCsiHandler({ intermediates: '"', final: "q" }, ((e4) => this.selectProtected(e4))), this._parser.registerCsiHandler({ intermediates: "$", final: "p" }, ((e4) => this.requestMode(e4, true))), this._parser.registerCsiHandler({ prefix: "?", intermediates: "$", final: "p" }, ((e4) => this.requestMode(e4, false))), this._parser.setExecuteHandler(n.C0.BEL, (() => this.bell())), this._parser.setExecuteHandler(n.C0.LF, (() => this.lineFeed())), this._parser.setExecuteHandler(n.C0.VT, (() => this.lineFeed())), this._parser.setExecuteHandler(n.C0.FF, (() => this.lineFeed())), this._parser.setExecuteHandler(n.C0.CR, (() => this.carriageReturn())), this._parser.setExecuteHandler(n.C0.BS, (() => this.backspace())), this._parser.setExecuteHandler(n.C0.HT, (() => this.tab())), this._parser.setExecuteHandler(n.C0.SO, (() => this.shiftOut())), this._parser.setExecuteHandler(n.C0.SI, (() => this.shiftIn())), this._parser.setExecuteHandler(n.C1.IND, (() => this.index())), this._parser.setExecuteHandler(n.C1.NEL, (() => this.nextLine())), this._parser.setExecuteHandler(n.C1.HTS, (() => this.tabSet())), this._parser.registerOscHandler(0, new g.OscHandler(((e4) => (this.setTitle(e4), this.setIconName(e4), true)))), this._parser.registerOscHandler(1, new g.OscHandler(((e4) => this.setIconName(e4)))), this._parser.registerOscHandler(2, new g.OscHandler(((e4) => this.setTitle(e4)))), this._parser.registerOscHandler(4, new g.OscHandler(((e4) => this.setOrReportIndexedColor(e4)))), this._parser.registerOscHandler(8, new g.OscHandler(((e4) => this.setHyperlink(e4)))), this._parser.registerOscHandler(10, new g.OscHandler(((e4) => this.setOrReportFgColor(e4)))), this._parser.registerOscHandler(11, new g.OscHandler(((e4) => this.setOrReportBgColor(e4)))), this._parser.registerOscHandler(12, new g.OscHandler(((e4) => this.setOrReportCursorColor(e4)))), this._parser.registerOscHandler(104, new g.OscHandler(((e4) => this.restoreIndexedColor(e4)))), this._parser.registerOscHandler(110, new g.OscHandler(((e4) => this.restoreFgColor(e4)))), this._parser.registerOscHandler(111, new g.OscHandler(((e4) => this.restoreBgColor(e4)))), this._parser.registerOscHandler(112, new g.OscHandler(((e4) => this.restoreCursorColor(e4)))), this._parser.registerEscHandler({ final: "7" }, (() => this.saveCursor())), this._parser.registerEscHandler({ final: "8" }, (() => this.restoreCursor())), this._parser.registerEscHandler({ final: "D" }, (() => this.index())), this._parser.registerEscHandler({ final: "E" }, (() => this.nextLine())), this._parser.registerEscHandler({ final: "H" }, (() => this.tabSet())), this._parser.registerEscHandler({ final: "M" }, (() => this.reverseIndex())), this._parser.registerEscHandler({ final: "=" }, (() => this.keypadApplicationMode())), this._parser.registerEscHandler({ final: ">" }, (() => this.keypadNumericMode())), this._parser.registerEscHandler({ final: "c" }, (() => this.fullReset())), this._parser.registerEscHandler({ final: "n" }, (() => this.setgLevel(2))), this._parser.registerEscHandler({ final: "o" }, (() => this.setgLevel(3))), this._parser.registerEscHandler({ final: "|" }, (() => this.setgLevel(3))), this._parser.registerEscHandler({ final: "}" }, (() => this.setgLevel(2))), this._parser.registerEscHandler({ final: "~" }, (() => this.setgLevel(1))), this._parser.registerEscHandler({ intermediates: "%", final: "@" }, (() => this.selectDefaultCharset())), this._parser.registerEscHandler({ intermediates: "%", final: "G" }, (() => this.selectDefaultCharset()));
            for (const e4 in o.CHARSETS) this._parser.registerEscHandler({ intermediates: "(", final: e4 }, (() => this.selectCharset("(" + e4))), this._parser.registerEscHandler({ intermediates: ")", final: e4 }, (() => this.selectCharset(")" + e4))), this._parser.registerEscHandler({ intermediates: "*", final: e4 }, (() => this.selectCharset("*" + e4))), this._parser.registerEscHandler({ intermediates: "+", final: e4 }, (() => this.selectCharset("+" + e4))), this._parser.registerEscHandler({ intermediates: "-", final: e4 }, (() => this.selectCharset("-" + e4))), this._parser.registerEscHandler({ intermediates: ".", final: e4 }, (() => this.selectCharset("." + e4))), this._parser.registerEscHandler({ intermediates: "/", final: e4 }, (() => this.selectCharset("/" + e4)));
            this._parser.registerEscHandler({ intermediates: "#", final: "8" }, (() => this.screenAlignmentPattern())), this._parser.setErrorHandler(((e4) => (this._logService.error("Parsing error: ", e4), e4))), this._parser.registerDcsHandler({ intermediates: "$", final: "q" }, new m.DcsHandler(((e4, t4) => this.requestStatusString(e4, t4))));
          }
          _preserveStack(e3, t3, i3, s3) {
            this._parseStack.paused = true, this._parseStack.cursorStartX = e3, this._parseStack.cursorStartY = t3, this._parseStack.decodedLength = i3, this._parseStack.position = s3;
          }
          _logSlowResolvingAsync(e3) {
            this._logService.logLevel <= v.LogLevelEnum.WARN && Promise.race([e3, new Promise(((e4, t3) => setTimeout((() => t3("#SLOW_TIMEOUT")), 5e3)))]).catch(((e4) => {
              if ("#SLOW_TIMEOUT" !== e4) throw e4;
              console.warn("async parser handler taking longer than 5000 ms");
            }));
          }
          _getCurrentLinkId() {
            return this._curAttrData.extended.urlId;
          }
          parse(e3, t3) {
            let i3, s3 = this._activeBuffer.x, r2 = this._activeBuffer.y, n2 = 0;
            const o2 = this._parseStack.paused;
            if (o2) {
              if (i3 = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, t3)) return this._logSlowResolvingAsync(i3), i3;
              s3 = this._parseStack.cursorStartX, r2 = this._parseStack.cursorStartY, this._parseStack.paused = false, e3.length > b2 && (n2 = this._parseStack.position + b2);
            }
            if (this._logService.logLevel <= v.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + ("string" == typeof e3 ? ` "${e3}"` : ` "${Array.prototype.map.call(e3, ((e4) => String.fromCharCode(e4))).join("")}"`), "string" == typeof e3 ? e3.split("").map(((e4) => e4.charCodeAt(0))) : e3), this._parseBuffer.length < e3.length && this._parseBuffer.length < b2 && (this._parseBuffer = new Uint32Array(Math.min(e3.length, b2))), o2 || this._dirtyRowTracker.clearRange(), e3.length > b2) for (let t4 = n2; t4 < e3.length; t4 += b2) {
              const n3 = t4 + b2 < e3.length ? t4 + b2 : e3.length, o3 = "string" == typeof e3 ? this._stringDecoder.decode(e3.substring(t4, n3), this._parseBuffer) : this._utf8Decoder.decode(e3.subarray(t4, n3), this._parseBuffer);
              if (i3 = this._parser.parse(this._parseBuffer, o3)) return this._preserveStack(s3, r2, o3, t4), this._logSlowResolvingAsync(i3), i3;
            }
            else if (!o2) {
              const t4 = "string" == typeof e3 ? this._stringDecoder.decode(e3, this._parseBuffer) : this._utf8Decoder.decode(e3, this._parseBuffer);
              if (i3 = this._parser.parse(this._parseBuffer, t4)) return this._preserveStack(s3, r2, t4, 0), this._logSlowResolvingAsync(i3), i3;
            }
            this._activeBuffer.x === s3 && this._activeBuffer.y === r2 || this._onCursorMove.fire();
            const a2 = this._dirtyRowTracker.end + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp), h2 = this._dirtyRowTracker.start + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
            h2 < this._bufferService.rows && this._onRequestRefreshRows.fire(Math.min(h2, this._bufferService.rows - 1), Math.min(a2, this._bufferService.rows - 1));
          }
          print(e3, t3, i3) {
            let s3, r2;
            const n2 = this._charsetService.charset, o2 = this._optionsService.rawOptions.screenReaderMode, a2 = this._bufferService.cols, h2 = this._coreService.decPrivateModes.wraparound, d2 = this._coreService.modes.insertMode, u2 = this._curAttrData;
            let f2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && i3 - t3 > 0 && 2 === f2.getWidth(this._activeBuffer.x - 1) && f2.setCellFromCodepoint(this._activeBuffer.x - 1, 0, 1, u2);
            let v2 = this._parser.precedingJoinState;
            for (let g2 = t3; g2 < i3; ++g2) {
              if (s3 = e3[g2], s3 < 127 && n2) {
                const e4 = n2[String.fromCharCode(s3)];
                e4 && (s3 = e4.charCodeAt(0));
              }
              const t4 = this._unicodeService.charProperties(s3, v2);
              r2 = p.UnicodeService.extractWidth(t4);
              const i4 = p.UnicodeService.extractShouldJoin(t4), m2 = i4 ? p.UnicodeService.extractWidth(v2) : 0;
              if (v2 = t4, o2 && this._onA11yChar.fire((0, c.stringFromCodePoint)(s3)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), this._activeBuffer.x + r2 - m2 > a2) {
                if (h2) {
                  const e4 = f2;
                  let t5 = this._activeBuffer.x - m2;
                  for (this._activeBuffer.x = m2, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), true)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = true), f2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y), m2 > 0 && f2 instanceof l.BufferLine && f2.copyCellsFrom(e4, t5, 0, m2, false); t5 < a2; ) e4.setCellFromCodepoint(t5++, 0, 1, u2);
                } else if (this._activeBuffer.x = a2 - 1, 2 === r2) continue;
              }
              if (i4 && this._activeBuffer.x) {
                const e4 = f2.getWidth(this._activeBuffer.x - 1) ? 1 : 2;
                f2.addCodepointToCell(this._activeBuffer.x - e4, s3, r2);
                for (let e5 = r2 - m2; --e5 >= 0; ) f2.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, u2);
              } else if (d2 && (f2.insertCells(this._activeBuffer.x, r2 - m2, this._activeBuffer.getNullCell(u2)), 2 === f2.getWidth(a2 - 1) && f2.setCellFromCodepoint(a2 - 1, _.NULL_CELL_CODE, _.NULL_CELL_WIDTH, u2)), f2.setCellFromCodepoint(this._activeBuffer.x++, s3, r2, u2), r2 > 0) for (; --r2; ) f2.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, u2);
            }
            this._parser.precedingJoinState = v2, this._activeBuffer.x < a2 && i3 - t3 > 0 && 0 === f2.getWidth(this._activeBuffer.x) && !f2.hasContent(this._activeBuffer.x) && f2.setCellFromCodepoint(this._activeBuffer.x, 0, 1, u2), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          registerCsiHandler(e3, t3) {
            return "t" !== e3.final || e3.prefix || e3.intermediates ? this._parser.registerCsiHandler(e3, t3) : this._parser.registerCsiHandler(e3, ((e4) => !w(e4.params[0], this._optionsService.rawOptions.windowOptions) || t3(e4)));
          }
          registerDcsHandler(e3, t3) {
            return this._parser.registerDcsHandler(e3, new m.DcsHandler(t3));
          }
          registerEscHandler(e3, t3) {
            return this._parser.registerEscHandler(e3, t3);
          }
          registerOscHandler(e3, t3) {
            return this._parser.registerOscHandler(e3, new g.OscHandler(t3));
          }
          bell() {
            return this._onRequestBell.fire(), true;
          }
          lineFeed() {
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), true;
          }
          carriageReturn() {
            return this._activeBuffer.x = 0, true;
          }
          backspace() {
            if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, true;
            if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;
            else if (0 === this._activeBuffer.x && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)?.isWrapped) {
              this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
              const e3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              e3.hasWidth(this._activeBuffer.x) && !e3.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
            }
            return this._restrictCursor(), true;
          }
          tab() {
            if (this._activeBuffer.x >= this._bufferService.cols) return true;
            const e3 = this._activeBuffer.x;
            return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - e3), true;
          }
          shiftOut() {
            return this._charsetService.setgLevel(1), true;
          }
          shiftIn() {
            return this._charsetService.setgLevel(0), true;
          }
          _restrictCursor(e3 = this._bufferService.cols - 1) {
            this._activeBuffer.x = Math.min(e3, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _setCursor(e3, t3) {
            this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = e3, this._activeBuffer.y = this._activeBuffer.scrollTop + t3) : (this._activeBuffer.x = e3, this._activeBuffer.y = t3), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
          }
          _moveCursor(e3, t3) {
            this._restrictCursor(), this._setCursor(this._activeBuffer.x + e3, this._activeBuffer.y + t3);
          }
          cursorUp(e3) {
            const t3 = this._activeBuffer.y - this._activeBuffer.scrollTop;
            return t3 >= 0 ? this._moveCursor(0, -Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, -(e3.params[0] || 1)), true;
          }
          cursorDown(e3) {
            const t3 = this._activeBuffer.scrollBottom - this._activeBuffer.y;
            return t3 >= 0 ? this._moveCursor(0, Math.min(t3, e3.params[0] || 1)) : this._moveCursor(0, e3.params[0] || 1), true;
          }
          cursorForward(e3) {
            return this._moveCursor(e3.params[0] || 1, 0), true;
          }
          cursorBackward(e3) {
            return this._moveCursor(-(e3.params[0] || 1), 0), true;
          }
          cursorNextLine(e3) {
            return this.cursorDown(e3), this._activeBuffer.x = 0, true;
          }
          cursorPrecedingLine(e3) {
            return this.cursorUp(e3), this._activeBuffer.x = 0, true;
          }
          cursorCharAbsolute(e3) {
            return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
          }
          cursorPosition(e3) {
            return this._setCursor(e3.length >= 2 ? (e3.params[1] || 1) - 1 : 0, (e3.params[0] || 1) - 1), true;
          }
          charPosAbsolute(e3) {
            return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
          }
          hPositionRelative(e3) {
            return this._moveCursor(e3.params[0] || 1, 0), true;
          }
          linePosAbsolute(e3) {
            return this._setCursor(this._activeBuffer.x, (e3.params[0] || 1) - 1), true;
          }
          vPositionRelative(e3) {
            return this._moveCursor(0, e3.params[0] || 1), true;
          }
          hVPosition(e3) {
            return this.cursorPosition(e3), true;
          }
          tabClear(e3) {
            const t3 = e3.params[0];
            return 0 === t3 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : 3 === t3 && (this._activeBuffer.tabs = {}), true;
          }
          cursorForwardTab(e3) {
            if (this._activeBuffer.x >= this._bufferService.cols) return true;
            let t3 = e3.params[0] || 1;
            for (; t3--; ) this._activeBuffer.x = this._activeBuffer.nextStop();
            return true;
          }
          cursorBackwardTab(e3) {
            if (this._activeBuffer.x >= this._bufferService.cols) return true;
            let t3 = e3.params[0] || 1;
            for (; t3--; ) this._activeBuffer.x = this._activeBuffer.prevStop();
            return true;
          }
          selectProtected(e3) {
            const t3 = e3.params[0];
            return 1 === t3 && (this._curAttrData.bg |= 536870912), 2 !== t3 && 0 !== t3 || (this._curAttrData.bg &= -536870913), true;
          }
          _eraseInBufferLine(e3, t3, i3, s3 = false, r2 = false) {
            const n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
            n2.replaceCells(t3, i3, this._activeBuffer.getNullCell(this._eraseAttrData()), r2), s3 && (n2.isWrapped = false);
          }
          _resetBufferLine(e3, t3 = false) {
            const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
            i3 && (i3.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), t3), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + e3), i3.isWrapped = false);
          }
          eraseInDisplay(e3, t3 = false) {
            let i3;
            switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
              case 0:
                for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3++, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t3); i3 < this._bufferService.rows; i3++) this._resetBufferLine(i3, t3);
                this._dirtyRowTracker.markDirty(i3);
                break;
              case 1:
                for (i3 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i3), this._eraseInBufferLine(i3, 0, this._activeBuffer.x + 1, true, t3), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(i3 + 1).isWrapped = false); i3--; ) this._resetBufferLine(i3, t3);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 2:
                for (i3 = this._bufferService.rows, this._dirtyRowTracker.markDirty(i3 - 1); i3--; ) this._resetBufferLine(i3, t3);
                this._dirtyRowTracker.markDirty(0);
                break;
              case 3:
                const e4 = this._activeBuffer.lines.length - this._bufferService.rows;
                e4 > 0 && (this._activeBuffer.lines.trimStart(e4), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - e4, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - e4, 0), this._onScroll.fire(0));
            }
            return true;
          }
          eraseInLine(e3, t3 = false) {
            switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
              case 0:
                this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t3);
                break;
              case 1:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, false, t3);
                break;
              case 2:
                this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, true, t3);
            }
            return this._dirtyRowTracker.markDirty(this._activeBuffer.y), true;
          }
          insertLines(e3) {
            this._restrictCursor();
            let t3 = e3.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const i3 = this._activeBuffer.ybase + this._activeBuffer.y, s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, r2 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3 + 1;
            for (; t3--; ) this._activeBuffer.lines.splice(r2 - 1, 1), this._activeBuffer.lines.splice(i3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
          }
          deleteLines(e3) {
            this._restrictCursor();
            let t3 = e3.params[0] || 1;
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const i3 = this._activeBuffer.ybase + this._activeBuffer.y;
            let s3;
            for (s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, s3 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3; t3--; ) this._activeBuffer.lines.splice(i3, 1), this._activeBuffer.lines.splice(s3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
          }
          insertChars(e3) {
            this._restrictCursor();
            const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return t3 && (t3.insertCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
          }
          deleteChars(e3) {
            this._restrictCursor();
            const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return t3 && (t3.deleteCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
          }
          scrollUp(e3) {
            let t3 = e3.params[0] || 1;
            for (; t3--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          scrollDown(e3) {
            let t3 = e3.params[0] || 1;
            for (; t3--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(l.DEFAULT_ATTR_DATA));
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          scrollLeft(e3) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const t3 = e3.params[0] || 1;
            for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
              i3.deleteCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData())), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          scrollRight(e3) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const t3 = e3.params[0] || 1;
            for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
              i3.insertCells(0, t3, this._activeBuffer.getNullCell(this._eraseAttrData())), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          insertColumns(e3) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const t3 = e3.params[0] || 1;
            for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
              i3.insertCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData())), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          deleteColumns(e3) {
            if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
            const t3 = e3.params[0] || 1;
            for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
              const i3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
              i3.deleteCells(this._activeBuffer.x, t3, this._activeBuffer.getNullCell(this._eraseAttrData())), i3.isWrapped = false;
            }
            return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
          }
          eraseChars(e3) {
            this._restrictCursor();
            const t3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
            return t3 && (t3.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (e3.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
          }
          repeatPrecedingCharacter(e3) {
            const t3 = this._parser.precedingJoinState;
            if (!t3) return true;
            const i3 = e3.params[0] || 1, s3 = p.UnicodeService.extractWidth(t3), r2 = this._activeBuffer.x - s3, n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).getString(r2), o2 = new Uint32Array(n2.length * i3);
            let a2 = 0;
            for (let e4 = 0; e4 < n2.length; ) {
              const t4 = n2.codePointAt(e4) || 0;
              o2[a2++] = t4, e4 += t4 > 65535 ? 2 : 1;
            }
            let h2 = a2;
            for (let e4 = 1; e4 < i3; ++e4) o2.copyWithin(h2, 0, a2), h2 += a2;
            return this.print(o2, 0, h2), true;
          }
          sendDeviceAttributesPrimary(e3) {
            return e3.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n.C0.ESC + "[?6c")), true;
          }
          sendDeviceAttributesSecondary(e3) {
            return e3.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(e3.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n.C0.ESC + "[>83;40003;0c")), true;
          }
          _is(e3) {
            return 0 === (this._optionsService.rawOptions.termName + "").indexOf(e3);
          }
          setMode(e3) {
            for (let t3 = 0; t3 < e3.length; t3++) switch (e3.params[t3]) {
              case 4:
                this._coreService.modes.insertMode = true;
                break;
              case 20:
                this._optionsService.options.convertEol = true;
            }
            return true;
          }
          setModePrivate(e3) {
            for (let t3 = 0; t3 < e3.length; t3++) switch (e3.params[t3]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = true;
                break;
              case 2:
                this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), this._charsetService.setgCharset(1, o.DEFAULT_CHARSET), this._charsetService.setgCharset(2, o.DEFAULT_CHARSET), this._charsetService.setgCharset(3, o.DEFAULT_CHARSET);
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = true, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = true;
                break;
              case 12:
                this._optionsService.options.cursorBlink = true;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = true;
                break;
              case 66:
                this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
                this._coreMouseService.activeProtocol = "X10";
                break;
              case 1e3:
                this._coreMouseService.activeProtocol = "VT200";
                break;
              case 1002:
                this._coreMouseService.activeProtocol = "DRAG";
                break;
              case 1003:
                this._coreMouseService.activeProtocol = "ANY";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = true, this._onRequestSendFocus.fire();
                break;
              case 1005:
                this._logService.debug("DECSET 1005 not supported (see #2507)");
                break;
              case 1006:
                this._coreMouseService.activeEncoding = "SGR";
                break;
              case 1015:
                this._logService.debug("DECSET 1015 not supported (see #2507)");
                break;
              case 1016:
                this._coreMouseService.activeEncoding = "SGR_PIXELS";
                break;
              case 25:
                this._coreService.isCursorHidden = false;
                break;
              case 1048:
                this.saveCursor();
                break;
              case 1049:
                this.saveCursor();
              case 47:
              case 1047:
                this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = true;
            }
            return true;
          }
          resetMode(e3) {
            for (let t3 = 0; t3 < e3.length; t3++) switch (e3.params[t3]) {
              case 4:
                this._coreService.modes.insertMode = false;
                break;
              case 20:
                this._optionsService.options.convertEol = false;
            }
            return true;
          }
          resetModePrivate(e3) {
            for (let t3 = 0; t3 < e3.length; t3++) switch (e3.params[t3]) {
              case 1:
                this._coreService.decPrivateModes.applicationCursorKeys = false;
                break;
              case 3:
                this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                break;
              case 6:
                this._coreService.decPrivateModes.origin = false, this._setCursor(0, 0);
                break;
              case 7:
                this._coreService.decPrivateModes.wraparound = false;
                break;
              case 12:
                this._optionsService.options.cursorBlink = false;
                break;
              case 45:
                this._coreService.decPrivateModes.reverseWraparound = false;
                break;
              case 66:
                this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire();
                break;
              case 9:
              case 1e3:
              case 1002:
              case 1003:
                this._coreMouseService.activeProtocol = "NONE";
                break;
              case 1004:
                this._coreService.decPrivateModes.sendFocus = false;
                break;
              case 1005:
                this._logService.debug("DECRST 1005 not supported (see #2507)");
                break;
              case 1006:
              case 1016:
                this._coreMouseService.activeEncoding = "DEFAULT";
                break;
              case 1015:
                this._logService.debug("DECRST 1015 not supported (see #2507)");
                break;
              case 25:
                this._coreService.isCursorHidden = true;
                break;
              case 1048:
                this.restoreCursor();
                break;
              case 1049:
              case 47:
              case 1047:
                this._bufferService.buffers.activateNormalBuffer(), 1049 === e3.params[t3] && this.restoreCursor(), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                break;
              case 2004:
                this._coreService.decPrivateModes.bracketedPasteMode = false;
            }
            return true;
          }
          requestMode(e3, t3) {
            const i3 = this._coreService.decPrivateModes, { activeProtocol: s3, activeEncoding: r2 } = this._coreMouseService, o2 = this._coreService, { buffers: a2, cols: h2 } = this._bufferService, { active: c2, alt: l2 } = a2, d2 = this._optionsService.rawOptions, _2 = (e4) => e4 ? 1 : 2, u2 = e3.params[0];
            return f2 = u2, v2 = t3 ? 2 === u2 ? 4 : 4 === u2 ? _2(o2.modes.insertMode) : 12 === u2 ? 3 : 20 === u2 ? _2(d2.convertEol) : 0 : 1 === u2 ? _2(i3.applicationCursorKeys) : 3 === u2 ? d2.windowOptions.setWinLines ? 80 === h2 ? 2 : 132 === h2 ? 1 : 0 : 0 : 6 === u2 ? _2(i3.origin) : 7 === u2 ? _2(i3.wraparound) : 8 === u2 ? 3 : 9 === u2 ? _2("X10" === s3) : 12 === u2 ? _2(d2.cursorBlink) : 25 === u2 ? _2(!o2.isCursorHidden) : 45 === u2 ? _2(i3.reverseWraparound) : 66 === u2 ? _2(i3.applicationKeypad) : 67 === u2 ? 4 : 1e3 === u2 ? _2("VT200" === s3) : 1002 === u2 ? _2("DRAG" === s3) : 1003 === u2 ? _2("ANY" === s3) : 1004 === u2 ? _2(i3.sendFocus) : 1005 === u2 ? 4 : 1006 === u2 ? _2("SGR" === r2) : 1015 === u2 ? 4 : 1016 === u2 ? _2("SGR_PIXELS" === r2) : 1048 === u2 ? 1 : 47 === u2 || 1047 === u2 || 1049 === u2 ? _2(c2 === l2) : 2004 === u2 ? _2(i3.bracketedPasteMode) : 0, o2.triggerDataEvent(`${n.C0.ESC}[${t3 ? "" : "?"}${f2};${v2}$y`), true;
            var f2, v2;
          }
          _updateAttrColor(e3, t3, i3, s3, r2) {
            return 2 === t3 ? (e3 |= 50331648, e3 &= -16777216, e3 |= f.AttributeData.fromColorRGB([i3, s3, r2])) : 5 === t3 && (e3 &= -50331904, e3 |= 33554432 | 255 & i3), e3;
          }
          _extractColor(e3, t3, i3) {
            const s3 = [0, 0, -1, 0, 0, 0];
            let r2 = 0, n2 = 0;
            do {
              if (s3[n2 + r2] = e3.params[t3 + n2], e3.hasSubParams(t3 + n2)) {
                const i4 = e3.getSubParams(t3 + n2);
                let o2 = 0;
                do {
                  5 === s3[1] && (r2 = 1), s3[n2 + o2 + 1 + r2] = i4[o2];
                } while (++o2 < i4.length && o2 + n2 + 1 + r2 < s3.length);
                break;
              }
              if (5 === s3[1] && n2 + r2 >= 2 || 2 === s3[1] && n2 + r2 >= 5) break;
              s3[1] && (r2 = 1);
            } while (++n2 + t3 < e3.length && n2 + r2 < s3.length);
            for (let e4 = 2; e4 < s3.length; ++e4) -1 === s3[e4] && (s3[e4] = 0);
            switch (s3[0]) {
              case 38:
                i3.fg = this._updateAttrColor(i3.fg, s3[1], s3[3], s3[4], s3[5]);
                break;
              case 48:
                i3.bg = this._updateAttrColor(i3.bg, s3[1], s3[3], s3[4], s3[5]);
                break;
              case 58:
                i3.extended = i3.extended.clone(), i3.extended.underlineColor = this._updateAttrColor(i3.extended.underlineColor, s3[1], s3[3], s3[4], s3[5]);
            }
            return n2;
          }
          _processUnderline(e3, t3) {
            t3.extended = t3.extended.clone(), (!~e3 || e3 > 5) && (e3 = 1), t3.extended.underlineStyle = e3, t3.fg |= 268435456, 0 === e3 && (t3.fg &= -268435457), t3.updateExtended();
          }
          _processSGR0(e3) {
            e3.fg = l.DEFAULT_ATTR_DATA.fg, e3.bg = l.DEFAULT_ATTR_DATA.bg, e3.extended = e3.extended.clone(), e3.extended.underlineStyle = 0, e3.extended.underlineColor &= -67108864, e3.updateExtended();
          }
          charAttributes(e3) {
            if (1 === e3.length && 0 === e3.params[0]) return this._processSGR0(this._curAttrData), true;
            const t3 = e3.length;
            let i3;
            const s3 = this._curAttrData;
            for (let r2 = 0; r2 < t3; r2++) i3 = e3.params[r2], i3 >= 30 && i3 <= 37 ? (s3.fg &= -50331904, s3.fg |= 16777216 | i3 - 30) : i3 >= 40 && i3 <= 47 ? (s3.bg &= -50331904, s3.bg |= 16777216 | i3 - 40) : i3 >= 90 && i3 <= 97 ? (s3.fg &= -50331904, s3.fg |= 16777224 | i3 - 90) : i3 >= 100 && i3 <= 107 ? (s3.bg &= -50331904, s3.bg |= 16777224 | i3 - 100) : 0 === i3 ? this._processSGR0(s3) : 1 === i3 ? s3.fg |= 134217728 : 3 === i3 ? s3.bg |= 67108864 : 4 === i3 ? (s3.fg |= 268435456, this._processUnderline(e3.hasSubParams(r2) ? e3.getSubParams(r2)[0] : 1, s3)) : 5 === i3 ? s3.fg |= 536870912 : 7 === i3 ? s3.fg |= 67108864 : 8 === i3 ? s3.fg |= 1073741824 : 9 === i3 ? s3.fg |= 2147483648 : 2 === i3 ? s3.bg |= 134217728 : 21 === i3 ? this._processUnderline(2, s3) : 22 === i3 ? (s3.fg &= -134217729, s3.bg &= -134217729) : 23 === i3 ? s3.bg &= -67108865 : 24 === i3 ? (s3.fg &= -268435457, this._processUnderline(0, s3)) : 25 === i3 ? s3.fg &= -536870913 : 27 === i3 ? s3.fg &= -67108865 : 28 === i3 ? s3.fg &= -1073741825 : 29 === i3 ? s3.fg &= 2147483647 : 39 === i3 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg) : 49 === i3 ? (s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : 38 === i3 || 48 === i3 || 58 === i3 ? r2 += this._extractColor(e3, r2, s3) : 53 === i3 ? s3.bg |= 1073741824 : 55 === i3 ? s3.bg &= -1073741825 : 59 === i3 ? (s3.extended = s3.extended.clone(), s3.extended.underlineColor = -1, s3.updateExtended()) : 100 === i3 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg, s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", i3);
            return true;
          }
          deviceStatus(e3) {
            switch (e3.params[0]) {
              case 5:
                this._coreService.triggerDataEvent(`${n.C0.ESC}[0n`);
                break;
              case 6:
                const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
                this._coreService.triggerDataEvent(`${n.C0.ESC}[${e4};${t3}R`);
            }
            return true;
          }
          deviceStatusPrivate(e3) {
            if (6 === e3.params[0]) {
              const e4 = this._activeBuffer.y + 1, t3 = this._activeBuffer.x + 1;
              this._coreService.triggerDataEvent(`${n.C0.ESC}[?${e4};${t3}R`);
            }
            return true;
          }
          softReset(e3) {
            return this._coreService.isCursorHidden = false, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = false, true;
          }
          setCursorStyle(e3) {
            const t3 = e3.params[0] || 1;
            switch (t3) {
              case 1:
              case 2:
                this._optionsService.options.cursorStyle = "block";
                break;
              case 3:
              case 4:
                this._optionsService.options.cursorStyle = "underline";
                break;
              case 5:
              case 6:
                this._optionsService.options.cursorStyle = "bar";
            }
            const i3 = t3 % 2 == 1;
            return this._optionsService.options.cursorBlink = i3, true;
          }
          setScrollRegion(e3) {
            const t3 = e3.params[0] || 1;
            let i3;
            return (e3.length < 2 || (i3 = e3.params[1]) > this._bufferService.rows || 0 === i3) && (i3 = this._bufferService.rows), i3 > t3 && (this._activeBuffer.scrollTop = t3 - 1, this._activeBuffer.scrollBottom = i3 - 1, this._setCursor(0, 0)), true;
          }
          windowOptions(e3) {
            if (!w(e3.params[0], this._optionsService.rawOptions.windowOptions)) return true;
            const t3 = e3.length > 1 ? e3.params[1] : 0;
            switch (e3.params[0]) {
              case 14:
                2 !== t3 && this._onRequestWindowsOptionsReport.fire(y.GET_WIN_SIZE_PIXELS);
                break;
              case 16:
                this._onRequestWindowsOptionsReport.fire(y.GET_CELL_SIZE_PIXELS);
                break;
              case 18:
                this._bufferService && this._coreService.triggerDataEvent(`${n.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                break;
              case 22:
                0 !== t3 && 2 !== t3 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), 0 !== t3 && 1 !== t3 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                break;
              case 23:
                0 !== t3 && 2 !== t3 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), 0 !== t3 && 1 !== t3 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
            }
            return true;
          }
          saveCursor(e3) {
            return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, true;
          }
          restoreCursor(e3) {
            return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), true;
          }
          setTitle(e3) {
            return this._windowTitle = e3, this._onTitleChange.fire(e3), true;
          }
          setIconName(e3) {
            return this._iconName = e3, true;
          }
          setOrReportIndexedColor(e3) {
            const t3 = [], i3 = e3.split(";");
            for (; i3.length > 1; ) {
              const e4 = i3.shift(), s3 = i3.shift();
              if (/^\d+$/.exec(e4)) {
                const i4 = parseInt(e4);
                if (D(i4)) if ("?" === s3) t3.push({ type: 0, index: i4 });
                else {
                  const e5 = (0, S.parseColor)(s3);
                  e5 && t3.push({ type: 1, index: i4, color: e5 });
                }
              }
            }
            return t3.length && this._onColor.fire(t3), true;
          }
          setHyperlink(e3) {
            const t3 = e3.split(";");
            return !(t3.length < 2) && (t3[1] ? this._createHyperlink(t3[0], t3[1]) : !t3[0] && this._finishHyperlink());
          }
          _createHyperlink(e3, t3) {
            this._getCurrentLinkId() && this._finishHyperlink();
            const i3 = e3.split(":");
            let s3;
            const r2 = i3.findIndex(((e4) => e4.startsWith("id=")));
            return -1 !== r2 && (s3 = i3[r2].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({ id: s3, uri: t3 }), this._curAttrData.updateExtended(), true;
          }
          _finishHyperlink() {
            return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), true;
          }
          _setOrReportSpecialColor(e3, t3) {
            const i3 = e3.split(";");
            for (let e4 = 0; e4 < i3.length && !(t3 >= this._specialColors.length); ++e4, ++t3) if ("?" === i3[e4]) this._onColor.fire([{ type: 0, index: this._specialColors[t3] }]);
            else {
              const s3 = (0, S.parseColor)(i3[e4]);
              s3 && this._onColor.fire([{ type: 1, index: this._specialColors[t3], color: s3 }]);
            }
            return true;
          }
          setOrReportFgColor(e3) {
            return this._setOrReportSpecialColor(e3, 0);
          }
          setOrReportBgColor(e3) {
            return this._setOrReportSpecialColor(e3, 1);
          }
          setOrReportCursorColor(e3) {
            return this._setOrReportSpecialColor(e3, 2);
          }
          restoreIndexedColor(e3) {
            if (!e3) return this._onColor.fire([{ type: 2 }]), true;
            const t3 = [], i3 = e3.split(";");
            for (let e4 = 0; e4 < i3.length; ++e4) if (/^\d+$/.exec(i3[e4])) {
              const s3 = parseInt(i3[e4]);
              D(s3) && t3.push({ type: 2, index: s3 });
            }
            return t3.length && this._onColor.fire(t3), true;
          }
          restoreFgColor(e3) {
            return this._onColor.fire([{ type: 2, index: 256 }]), true;
          }
          restoreBgColor(e3) {
            return this._onColor.fire([{ type: 2, index: 257 }]), true;
          }
          restoreCursorColor(e3) {
            return this._onColor.fire([{ type: 2, index: 258 }]), true;
          }
          nextLine() {
            return this._activeBuffer.x = 0, this.index(), true;
          }
          keypadApplicationMode() {
            return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire(), true;
          }
          keypadNumericMode() {
            return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire(), true;
          }
          selectDefaultCharset() {
            return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), true;
          }
          selectCharset(e3) {
            return 2 !== e3.length ? (this.selectDefaultCharset(), true) : ("/" === e3[0] || this._charsetService.setgCharset(C[e3[0]], o.CHARSETS[e3[1]] || o.DEFAULT_CHARSET), true);
          }
          index() {
            return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), true;
          }
          tabSet() {
            return this._activeBuffer.tabs[this._activeBuffer.x] = true, true;
          }
          reverseIndex() {
            if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
              const e3 = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
              this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, e3, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
            } else this._activeBuffer.y--, this._restrictCursor();
            return true;
          }
          fullReset() {
            return this._parser.reset(), this._onRequestReset.fire(), true;
          }
          reset() {
            this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone();
          }
          _eraseAttrData() {
            return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
          }
          setgLevel(e3) {
            return this._charsetService.setgLevel(e3), true;
          }
          screenAlignmentPattern() {
            const e3 = new u.CellData();
            e3.content = 1 << 22 | "E".charCodeAt(0), e3.fg = this._curAttrData.fg, e3.bg = this._curAttrData.bg, this._setCursor(0, 0);
            for (let t3 = 0; t3 < this._bufferService.rows; ++t3) {
              const i3 = this._activeBuffer.ybase + this._activeBuffer.y + t3, s3 = this._activeBuffer.lines.get(i3);
              s3 && (s3.fill(e3), s3.isWrapped = false);
            }
            return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), true;
          }
          requestStatusString(e3, t3) {
            const i3 = this._bufferService.buffer, s3 = this._optionsService.rawOptions;
            return ((e4) => (this._coreService.triggerDataEvent(`${n.C0.ESC}${e4}${n.C0.ESC}\\`), true))('"q' === e3 ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : '"p' === e3 ? 'P1$r61;1"p' : "r" === e3 ? `P1$r${i3.scrollTop + 1};${i3.scrollBottom + 1}r` : "m" === e3 ? "P1$r0m" : " q" === e3 ? `P1$r${{ block: 2, underline: 4, bar: 6 }[s3.cursorStyle] - (s3.cursorBlink ? 1 : 0)} q` : "P0$r");
          }
          markRangeDirty(e3, t3) {
            this._dirtyRowTracker.markRangeDirty(e3, t3);
          }
        }
        t2.InputHandler = k;
        let L2 = class {
          constructor(e3) {
            this._bufferService = e3, this.clearRange();
          }
          clearRange() {
            this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
          }
          markDirty(e3) {
            e3 < this.start ? this.start = e3 : e3 > this.end && (this.end = e3);
          }
          markRangeDirty(e3, t3) {
            e3 > t3 && (E = e3, e3 = t3, t3 = E), e3 < this.start && (this.start = e3), t3 > this.end && (this.end = t3);
          }
          markAllDirty() {
            this.markRangeDirty(0, this._bufferService.rows - 1);
          }
        };
        function D(e3) {
          return 0 <= e3 && e3 < 256;
        }
        L2 = s2([r(0, v.IBufferService)], L2);
      }, 844: (e2, t2) => {
        function i2(e3) {
          for (const t3 of e3) t3.dispose();
          e3.length = 0;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getDisposeArrayDisposable = t2.disposeArray = t2.toDisposable = t2.MutableDisposable = t2.Disposable = void 0, t2.Disposable = class {
          constructor() {
            this._disposables = [], this._isDisposed = false;
          }
          dispose() {
            this._isDisposed = true;
            for (const e3 of this._disposables) e3.dispose();
            this._disposables.length = 0;
          }
          register(e3) {
            return this._disposables.push(e3), e3;
          }
          unregister(e3) {
            const t3 = this._disposables.indexOf(e3);
            -1 !== t3 && this._disposables.splice(t3, 1);
          }
        }, t2.MutableDisposable = class {
          constructor() {
            this._isDisposed = false;
          }
          get value() {
            return this._isDisposed ? void 0 : this._value;
          }
          set value(e3) {
            this._isDisposed || e3 === this._value || (this._value?.dispose(), this._value = e3);
          }
          clear() {
            this.value = void 0;
          }
          dispose() {
            this._isDisposed = true, this._value?.dispose(), this._value = void 0;
          }
        }, t2.toDisposable = function(e3) {
          return { dispose: e3 };
        }, t2.disposeArray = i2, t2.getDisposeArrayDisposable = function(e3) {
          return { dispose: () => i2(e3) };
        };
      }, 1505: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.FourKeyMap = t2.TwoKeyMap = void 0;
        class i2 {
          constructor() {
            this._data = {};
          }
          set(e3, t3, i3) {
            this._data[e3] || (this._data[e3] = {}), this._data[e3][t3] = i3;
          }
          get(e3, t3) {
            return this._data[e3] ? this._data[e3][t3] : void 0;
          }
          clear() {
            this._data = {};
          }
        }
        t2.TwoKeyMap = i2, t2.FourKeyMap = class {
          constructor() {
            this._data = new i2();
          }
          set(e3, t3, s2, r, n) {
            this._data.get(e3, t3) || this._data.set(e3, t3, new i2()), this._data.get(e3, t3).set(s2, r, n);
          }
          get(e3, t3, i3, s2) {
            return this._data.get(e3, t3)?.get(i3, s2);
          }
          clear() {
            this._data.clear();
          }
        };
      }, 6114: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isChromeOS = t2.isLinux = t2.isWindows = t2.isIphone = t2.isIpad = t2.isMac = t2.getSafariVersion = t2.isSafari = t2.isLegacyEdge = t2.isFirefox = t2.isNode = void 0, t2.isNode = "undefined" != typeof process && "title" in process;
        const i2 = t2.isNode ? "node" : navigator.userAgent, s2 = t2.isNode ? "node" : navigator.platform;
        t2.isFirefox = i2.includes("Firefox"), t2.isLegacyEdge = i2.includes("Edge"), t2.isSafari = /^((?!chrome|android).)*safari/i.test(i2), t2.getSafariVersion = function() {
          if (!t2.isSafari) return 0;
          const e3 = i2.match(/Version\/(\d+)/);
          return null === e3 || e3.length < 2 ? 0 : parseInt(e3[1]);
        }, t2.isMac = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"].includes(s2), t2.isIpad = "iPad" === s2, t2.isIphone = "iPhone" === s2, t2.isWindows = ["Windows", "Win16", "Win32", "WinCE"].includes(s2), t2.isLinux = s2.indexOf("Linux") >= 0, t2.isChromeOS = /\bCrOS\b/.test(i2);
      }, 6106: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.SortedList = void 0;
        let i2 = 0;
        t2.SortedList = class {
          constructor(e3) {
            this._getKey = e3, this._array = [];
          }
          clear() {
            this._array.length = 0;
          }
          insert(e3) {
            0 !== this._array.length ? (i2 = this._search(this._getKey(e3)), this._array.splice(i2, 0, e3)) : this._array.push(e3);
          }
          delete(e3) {
            if (0 === this._array.length) return false;
            const t3 = this._getKey(e3);
            if (void 0 === t3) return false;
            if (i2 = this._search(t3), -1 === i2) return false;
            if (this._getKey(this._array[i2]) !== t3) return false;
            do {
              if (this._array[i2] === e3) return this._array.splice(i2, 1), true;
            } while (++i2 < this._array.length && this._getKey(this._array[i2]) === t3);
            return false;
          }
          *getKeyIterator(e3) {
            if (0 !== this._array.length && (i2 = this._search(e3), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e3)) do {
              yield this._array[i2];
            } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e3);
          }
          forEachByKey(e3, t3) {
            if (0 !== this._array.length && (i2 = this._search(e3), !(i2 < 0 || i2 >= this._array.length) && this._getKey(this._array[i2]) === e3)) do {
              t3(this._array[i2]);
            } while (++i2 < this._array.length && this._getKey(this._array[i2]) === e3);
          }
          values() {
            return [...this._array].values();
          }
          _search(e3) {
            let t3 = 0, i3 = this._array.length - 1;
            for (; i3 >= t3; ) {
              let s2 = t3 + i3 >> 1;
              const r = this._getKey(this._array[s2]);
              if (r > e3) i3 = s2 - 1;
              else {
                if (!(r < e3)) {
                  for (; s2 > 0 && this._getKey(this._array[s2 - 1]) === e3; ) s2--;
                  return s2;
                }
                t3 = s2 + 1;
              }
            }
            return t3;
          }
        };
      }, 7226: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DebouncedIdleTask = t2.IdleTaskQueue = t2.PriorityTaskQueue = void 0;
        const s2 = i2(6114);
        class r {
          constructor() {
            this._tasks = [], this._i = 0;
          }
          enqueue(e3) {
            this._tasks.push(e3), this._start();
          }
          flush() {
            for (; this._i < this._tasks.length; ) this._tasks[this._i]() || this._i++;
            this.clear();
          }
          clear() {
            this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
          }
          _start() {
            this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
          }
          _process(e3) {
            this._idleCallback = void 0;
            let t3 = 0, i3 = 0, s3 = e3.timeRemaining(), r2 = 0;
            for (; this._i < this._tasks.length; ) {
              if (t3 = Date.now(), this._tasks[this._i]() || this._i++, t3 = Math.max(1, Date.now() - t3), i3 = Math.max(t3, i3), r2 = e3.timeRemaining(), 1.5 * i3 > r2) return s3 - t3 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s3 - t3))}ms`), void this._start();
              s3 = r2;
            }
            this.clear();
          }
        }
        class n extends r {
          _requestCallback(e3) {
            return setTimeout((() => e3(this._createDeadline(16))));
          }
          _cancelCallback(e3) {
            clearTimeout(e3);
          }
          _createDeadline(e3) {
            const t3 = Date.now() + e3;
            return { timeRemaining: () => Math.max(0, t3 - Date.now()) };
          }
        }
        t2.PriorityTaskQueue = n, t2.IdleTaskQueue = !s2.isNode && "requestIdleCallback" in window ? class extends r {
          _requestCallback(e3) {
            return requestIdleCallback(e3);
          }
          _cancelCallback(e3) {
            cancelIdleCallback(e3);
          }
        } : n, t2.DebouncedIdleTask = class {
          constructor() {
            this._queue = new t2.IdleTaskQueue();
          }
          set(e3) {
            this._queue.clear(), this._queue.enqueue(e3);
          }
          flush() {
            this._queue.flush();
          }
        };
      }, 9282: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.updateWindowsModeWrappedState = void 0;
        const s2 = i2(643);
        t2.updateWindowsModeWrappedState = function(e3) {
          const t3 = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y - 1), i3 = t3?.get(e3.cols - 1), r = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y);
          r && i3 && (r.isWrapped = i3[s2.CHAR_DATA_CODE_INDEX] !== s2.NULL_CELL_CODE && i3[s2.CHAR_DATA_CODE_INDEX] !== s2.WHITESPACE_CELL_CODE);
        };
      }, 3734: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ExtendedAttrs = t2.AttributeData = void 0;
        class i2 {
          constructor() {
            this.fg = 0, this.bg = 0, this.extended = new s2();
          }
          static toColorRGB(e3) {
            return [e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3];
          }
          static fromColorRGB(e3) {
            return (255 & e3[0]) << 16 | (255 & e3[1]) << 8 | 255 & e3[2];
          }
          clone() {
            const e3 = new i2();
            return e3.fg = this.fg, e3.bg = this.bg, e3.extended = this.extended.clone(), e3;
          }
          isInverse() {
            return 67108864 & this.fg;
          }
          isBold() {
            return 134217728 & this.fg;
          }
          isUnderline() {
            return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;
          }
          isBlink() {
            return 536870912 & this.fg;
          }
          isInvisible() {
            return 1073741824 & this.fg;
          }
          isItalic() {
            return 67108864 & this.bg;
          }
          isDim() {
            return 134217728 & this.bg;
          }
          isStrikethrough() {
            return 2147483648 & this.fg;
          }
          isProtected() {
            return 536870912 & this.bg;
          }
          isOverline() {
            return 1073741824 & this.bg;
          }
          getFgColorMode() {
            return 50331648 & this.fg;
          }
          getBgColorMode() {
            return 50331648 & this.bg;
          }
          isFgRGB() {
            return 50331648 == (50331648 & this.fg);
          }
          isBgRGB() {
            return 50331648 == (50331648 & this.bg);
          }
          isFgPalette() {
            return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);
          }
          isBgPalette() {
            return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);
          }
          isFgDefault() {
            return 0 == (50331648 & this.fg);
          }
          isBgDefault() {
            return 0 == (50331648 & this.bg);
          }
          isAttributeDefault() {
            return 0 === this.fg && 0 === this.bg;
          }
          getFgColor() {
            switch (50331648 & this.fg) {
              case 16777216:
              case 33554432:
                return 255 & this.fg;
              case 50331648:
                return 16777215 & this.fg;
              default:
                return -1;
            }
          }
          getBgColor() {
            switch (50331648 & this.bg) {
              case 16777216:
              case 33554432:
                return 255 & this.bg;
              case 50331648:
                return 16777215 & this.bg;
              default:
                return -1;
            }
          }
          hasExtendedAttrs() {
            return 268435456 & this.bg;
          }
          updateExtended() {
            this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
          }
          getUnderlineColor() {
            if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {
              case 16777216:
              case 33554432:
                return 255 & this.extended.underlineColor;
              case 50331648:
                return 16777215 & this.extended.underlineColor;
              default:
                return this.getFgColor();
            }
            return this.getFgColor();
          }
          getUnderlineColorMode() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
          }
          isUnderlineColorRGB() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();
          }
          isUnderlineColorPalette() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();
          }
          isUnderlineColorDefault() {
            return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();
          }
          getUnderlineStyle() {
            return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
          }
          getUnderlineVariantOffset() {
            return this.extended.underlineVariantOffset;
          }
        }
        t2.AttributeData = i2;
        class s2 {
          get ext() {
            return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
          }
          set ext(e3) {
            this._ext = e3;
          }
          get underlineStyle() {
            return this._urlId ? 5 : (469762048 & this._ext) >> 26;
          }
          set underlineStyle(e3) {
            this._ext &= -469762049, this._ext |= e3 << 26 & 469762048;
          }
          get underlineColor() {
            return 67108863 & this._ext;
          }
          set underlineColor(e3) {
            this._ext &= -67108864, this._ext |= 67108863 & e3;
          }
          get urlId() {
            return this._urlId;
          }
          set urlId(e3) {
            this._urlId = e3;
          }
          get underlineVariantOffset() {
            const e3 = (3758096384 & this._ext) >> 29;
            return e3 < 0 ? 4294967288 ^ e3 : e3;
          }
          set underlineVariantOffset(e3) {
            this._ext &= 536870911, this._ext |= e3 << 29 & 3758096384;
          }
          constructor(e3 = 0, t3 = 0) {
            this._ext = 0, this._urlId = 0, this._ext = e3, this._urlId = t3;
          }
          clone() {
            return new s2(this._ext, this._urlId);
          }
          isEmpty() {
            return 0 === this.underlineStyle && 0 === this._urlId;
          }
        }
        t2.ExtendedAttrs = s2;
      }, 9092: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Buffer = t2.MAX_BUFFER_SIZE = void 0;
        const s2 = i2(6349), r = i2(7226), n = i2(3734), o = i2(8437), a = i2(4634), h = i2(511), c = i2(643), l = i2(4863), d = i2(7116);
        t2.MAX_BUFFER_SIZE = 4294967295, t2.Buffer = class {
          constructor(e3, t3, i3) {
            this._hasScrollback = e3, this._optionsService = t3, this._bufferService = i3, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = o.DEFAULT_ATTR_DATA.clone(), this.savedCharset = d.DEFAULT_CHARSET, this.markers = [], this._nullCell = h.CellData.fromCharData([0, c.NULL_CELL_CHAR, c.NULL_CELL_WIDTH, c.NULL_CELL_CODE]), this._whitespaceCell = h.CellData.fromCharData([0, c.WHITESPACE_CELL_CHAR, c.WHITESPACE_CELL_WIDTH, c.WHITESPACE_CELL_CODE]), this._isClearing = false, this._memoryCleanupQueue = new r.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          getNullCell(e3) {
            return e3 ? (this._nullCell.fg = e3.fg, this._nullCell.bg = e3.bg, this._nullCell.extended = e3.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new n.ExtendedAttrs()), this._nullCell;
          }
          getWhitespaceCell(e3) {
            return e3 ? (this._whitespaceCell.fg = e3.fg, this._whitespaceCell.bg = e3.bg, this._whitespaceCell.extended = e3.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new n.ExtendedAttrs()), this._whitespaceCell;
          }
          getBlankLine(e3, t3) {
            return new o.BufferLine(this._bufferService.cols, this.getNullCell(e3), t3);
          }
          get hasScrollback() {
            return this._hasScrollback && this.lines.maxLength > this._rows;
          }
          get isCursorInViewport() {
            const e3 = this.ybase + this.y - this.ydisp;
            return e3 >= 0 && e3 < this._rows;
          }
          _getCorrectBufferLength(e3) {
            if (!this._hasScrollback) return e3;
            const i3 = e3 + this._optionsService.rawOptions.scrollback;
            return i3 > t2.MAX_BUFFER_SIZE ? t2.MAX_BUFFER_SIZE : i3;
          }
          fillViewportRows(e3) {
            if (0 === this.lines.length) {
              void 0 === e3 && (e3 = o.DEFAULT_ATTR_DATA);
              let t3 = this._rows;
              for (; t3--; ) this.lines.push(this.getBlankLine(e3));
            }
          }
          clear() {
            this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
          }
          resize(e3, t3) {
            const i3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
            let s3 = 0;
            const r2 = this._getCorrectBufferLength(t3);
            if (r2 > this.lines.maxLength && (this.lines.maxLength = r2), this.lines.length > 0) {
              if (this._cols < e3) for (let t4 = 0; t4 < this.lines.length; t4++) s3 += +this.lines.get(t4).resize(e3, i3);
              let n2 = 0;
              if (this._rows < t3) for (let s4 = this._rows; s4 < t3; s4++) this.lines.length < t3 + this.ybase && (this._optionsService.rawOptions.windowsMode || void 0 !== this._optionsService.rawOptions.windowsPty.backend || void 0 !== this._optionsService.rawOptions.windowsPty.buildNumber ? this.lines.push(new o.BufferLine(e3, i3)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + n2 + 1 ? (this.ybase--, n2++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new o.BufferLine(e3, i3)));
              else for (let e4 = this._rows; e4 > t3; e4--) this.lines.length > t3 + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
              if (r2 < this.lines.maxLength) {
                const e4 = this.lines.length - r2;
                e4 > 0 && (this.lines.trimStart(e4), this.ybase = Math.max(this.ybase - e4, 0), this.ydisp = Math.max(this.ydisp - e4, 0), this.savedY = Math.max(this.savedY - e4, 0)), this.lines.maxLength = r2;
              }
              this.x = Math.min(this.x, e3 - 1), this.y = Math.min(this.y, t3 - 1), n2 && (this.y += n2), this.savedX = Math.min(this.savedX, e3 - 1), this.scrollTop = 0;
            }
            if (this.scrollBottom = t3 - 1, this._isReflowEnabled && (this._reflow(e3, t3), this._cols > e3)) for (let t4 = 0; t4 < this.lines.length; t4++) s3 += +this.lines.get(t4).resize(e3, i3);
            this._cols = e3, this._rows = t3, this._memoryCleanupQueue.clear(), s3 > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue((() => this._batchedMemoryCleanup())));
          }
          _batchedMemoryCleanup() {
            let e3 = true;
            this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, e3 = false);
            let t3 = 0;
            for (; this._memoryCleanupPosition < this.lines.length; ) if (t3 += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), t3 > 100) return true;
            return e3;
          }
          get _isReflowEnabled() {
            const e3 = this._optionsService.rawOptions.windowsPty;
            return e3 && e3.buildNumber ? this._hasScrollback && "conpty" === e3.backend && e3.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
          }
          _reflow(e3, t3) {
            this._cols !== e3 && (e3 > this._cols ? this._reflowLarger(e3, t3) : this._reflowSmaller(e3, t3));
          }
          _reflowLarger(e3, t3) {
            const i3 = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, e3, this.ybase + this.y, this.getNullCell(o.DEFAULT_ATTR_DATA));
            if (i3.length > 0) {
              const s3 = (0, a.reflowLargerCreateNewLayout)(this.lines, i3);
              (0, a.reflowLargerApplyNewLayout)(this.lines, s3.layout), this._reflowLargerAdjustViewport(e3, t3, s3.countRemoved);
            }
          }
          _reflowLargerAdjustViewport(e3, t3, i3) {
            const s3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
            let r2 = i3;
            for (; r2-- > 0; ) 0 === this.ybase ? (this.y > 0 && this.y--, this.lines.length < t3 && this.lines.push(new o.BufferLine(e3, s3))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
            this.savedY = Math.max(this.savedY - i3, 0);
          }
          _reflowSmaller(e3, t3) {
            const i3 = this.getNullCell(o.DEFAULT_ATTR_DATA), s3 = [];
            let r2 = 0;
            for (let n2 = this.lines.length - 1; n2 >= 0; n2--) {
              let h2 = this.lines.get(n2);
              if (!h2 || !h2.isWrapped && h2.getTrimmedLength() <= e3) continue;
              const c2 = [h2];
              for (; h2.isWrapped && n2 > 0; ) h2 = this.lines.get(--n2), c2.unshift(h2);
              const l2 = this.ybase + this.y;
              if (l2 >= n2 && l2 < n2 + c2.length) continue;
              const d2 = c2[c2.length - 1].getTrimmedLength(), _ = (0, a.reflowSmallerGetNewLineLengths)(c2, this._cols, e3), u = _.length - c2.length;
              let f;
              f = 0 === this.ybase && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + u) : Math.max(0, this.lines.length - this.lines.maxLength + u);
              const v = [];
              for (let e4 = 0; e4 < u; e4++) {
                const e5 = this.getBlankLine(o.DEFAULT_ATTR_DATA, true);
                v.push(e5);
              }
              v.length > 0 && (s3.push({ start: n2 + c2.length + r2, newLines: v }), r2 += v.length), c2.push(...v);
              let p = _.length - 1, g = _[p];
              0 === g && (p--, g = _[p]);
              let m = c2.length - u - 1, S = d2;
              for (; m >= 0; ) {
                const e4 = Math.min(S, g);
                if (void 0 === c2[p]) break;
                if (c2[p].copyCellsFrom(c2[m], S - e4, g - e4, e4, true), g -= e4, 0 === g && (p--, g = _[p]), S -= e4, 0 === S) {
                  m--;
                  const e5 = Math.max(m, 0);
                  S = (0, a.getWrappedLineTrimmedLength)(c2, e5, this._cols);
                }
              }
              for (let t4 = 0; t4 < c2.length; t4++) _[t4] < e3 && c2[t4].setCell(_[t4], i3);
              let C = u - f;
              for (; C-- > 0; ) 0 === this.ybase ? this.y < t3 - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + r2) - t3 && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
              this.savedY = Math.min(this.savedY + u, this.ybase + t3 - 1);
            }
            if (s3.length > 0) {
              const e4 = [], t4 = [];
              for (let e5 = 0; e5 < this.lines.length; e5++) t4.push(this.lines.get(e5));
              const i4 = this.lines.length;
              let n2 = i4 - 1, o2 = 0, a2 = s3[o2];
              this.lines.length = Math.min(this.lines.maxLength, this.lines.length + r2);
              let h2 = 0;
              for (let c3 = Math.min(this.lines.maxLength - 1, i4 + r2 - 1); c3 >= 0; c3--) if (a2 && a2.start > n2 + h2) {
                for (let e5 = a2.newLines.length - 1; e5 >= 0; e5--) this.lines.set(c3--, a2.newLines[e5]);
                c3++, e4.push({ index: n2 + 1, amount: a2.newLines.length }), h2 += a2.newLines.length, a2 = s3[++o2];
              } else this.lines.set(c3, t4[n2--]);
              let c2 = 0;
              for (let t5 = e4.length - 1; t5 >= 0; t5--) e4[t5].index += c2, this.lines.onInsertEmitter.fire(e4[t5]), c2 += e4[t5].amount;
              const l2 = Math.max(0, i4 + r2 - this.lines.maxLength);
              l2 > 0 && this.lines.onTrimEmitter.fire(l2);
            }
          }
          translateBufferLineToString(e3, t3, i3 = 0, s3) {
            const r2 = this.lines.get(e3);
            return r2 ? r2.translateToString(t3, i3, s3) : "";
          }
          getWrappedRangeForLine(e3) {
            let t3 = e3, i3 = e3;
            for (; t3 > 0 && this.lines.get(t3).isWrapped; ) t3--;
            for (; i3 + 1 < this.lines.length && this.lines.get(i3 + 1).isWrapped; ) i3++;
            return { first: t3, last: i3 };
          }
          setupTabStops(e3) {
            for (null != e3 ? this.tabs[e3] || (e3 = this.prevStop(e3)) : (this.tabs = {}, e3 = 0); e3 < this._cols; e3 += this._optionsService.rawOptions.tabStopWidth) this.tabs[e3] = true;
          }
          prevStop(e3) {
            for (null == e3 && (e3 = this.x); !this.tabs[--e3] && e3 > 0; ) ;
            return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
          }
          nextStop(e3) {
            for (null == e3 && (e3 = this.x); !this.tabs[++e3] && e3 < this._cols; ) ;
            return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
          }
          clearMarkers(e3) {
            this._isClearing = true;
            for (let t3 = 0; t3 < this.markers.length; t3++) this.markers[t3].line === e3 && (this.markers[t3].dispose(), this.markers.splice(t3--, 1));
            this._isClearing = false;
          }
          clearAllMarkers() {
            this._isClearing = true;
            for (let e3 = 0; e3 < this.markers.length; e3++) this.markers[e3].dispose(), this.markers.splice(e3--, 1);
            this._isClearing = false;
          }
          addMarker(e3) {
            const t3 = new l.Marker(e3);
            return this.markers.push(t3), t3.register(this.lines.onTrim(((e4) => {
              t3.line -= e4, t3.line < 0 && t3.dispose();
            }))), t3.register(this.lines.onInsert(((e4) => {
              t3.line >= e4.index && (t3.line += e4.amount);
            }))), t3.register(this.lines.onDelete(((e4) => {
              t3.line >= e4.index && t3.line < e4.index + e4.amount && t3.dispose(), t3.line > e4.index && (t3.line -= e4.amount);
            }))), t3.register(t3.onDispose((() => this._removeMarker(t3)))), t3;
          }
          _removeMarker(e3) {
            this._isClearing || this.markers.splice(this.markers.indexOf(e3), 1);
          }
        };
      }, 8437: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLine = t2.DEFAULT_ATTR_DATA = void 0;
        const s2 = i2(3734), r = i2(511), n = i2(643), o = i2(482);
        t2.DEFAULT_ATTR_DATA = Object.freeze(new s2.AttributeData());
        let a = 0;
        class h {
          constructor(e3, t3, i3 = false) {
            this.isWrapped = i3, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e3);
            const s3 = t3 || r.CellData.fromCharData([0, n.NULL_CELL_CHAR, n.NULL_CELL_WIDTH, n.NULL_CELL_CODE]);
            for (let t4 = 0; t4 < e3; ++t4) this.setCell(t4, s3);
            this.length = e3;
          }
          get(e3) {
            const t3 = this._data[3 * e3 + 0], i3 = 2097151 & t3;
            return [this._data[3 * e3 + 1], 2097152 & t3 ? this._combined[e3] : i3 ? (0, o.stringFromCodePoint)(i3) : "", t3 >> 22, 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : i3];
          }
          set(e3, t3) {
            this._data[3 * e3 + 1] = t3[n.CHAR_DATA_ATTR_INDEX], t3[n.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e3] = t3[1], this._data[3 * e3 + 0] = 2097152 | e3 | t3[n.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e3 + 0] = t3[n.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | t3[n.CHAR_DATA_WIDTH_INDEX] << 22;
          }
          getWidth(e3) {
            return this._data[3 * e3 + 0] >> 22;
          }
          hasWidth(e3) {
            return 12582912 & this._data[3 * e3 + 0];
          }
          getFg(e3) {
            return this._data[3 * e3 + 1];
          }
          getBg(e3) {
            return this._data[3 * e3 + 2];
          }
          hasContent(e3) {
            return 4194303 & this._data[3 * e3 + 0];
          }
          getCodePoint(e3) {
            const t3 = this._data[3 * e3 + 0];
            return 2097152 & t3 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : 2097151 & t3;
          }
          isCombined(e3) {
            return 2097152 & this._data[3 * e3 + 0];
          }
          getString(e3) {
            const t3 = this._data[3 * e3 + 0];
            return 2097152 & t3 ? this._combined[e3] : 2097151 & t3 ? (0, o.stringFromCodePoint)(2097151 & t3) : "";
          }
          isProtected(e3) {
            return 536870912 & this._data[3 * e3 + 2];
          }
          loadCell(e3, t3) {
            return a = 3 * e3, t3.content = this._data[a + 0], t3.fg = this._data[a + 1], t3.bg = this._data[a + 2], 2097152 & t3.content && (t3.combinedData = this._combined[e3]), 268435456 & t3.bg && (t3.extended = this._extendedAttrs[e3]), t3;
          }
          setCell(e3, t3) {
            2097152 & t3.content && (this._combined[e3] = t3.combinedData), 268435456 & t3.bg && (this._extendedAttrs[e3] = t3.extended), this._data[3 * e3 + 0] = t3.content, this._data[3 * e3 + 1] = t3.fg, this._data[3 * e3 + 2] = t3.bg;
          }
          setCellFromCodepoint(e3, t3, i3, s3) {
            268435456 & s3.bg && (this._extendedAttrs[e3] = s3.extended), this._data[3 * e3 + 0] = t3 | i3 << 22, this._data[3 * e3 + 1] = s3.fg, this._data[3 * e3 + 2] = s3.bg;
          }
          addCodepointToCell(e3, t3, i3) {
            let s3 = this._data[3 * e3 + 0];
            2097152 & s3 ? this._combined[e3] += (0, o.stringFromCodePoint)(t3) : 2097151 & s3 ? (this._combined[e3] = (0, o.stringFromCodePoint)(2097151 & s3) + (0, o.stringFromCodePoint)(t3), s3 &= -2097152, s3 |= 2097152) : s3 = t3 | 1 << 22, i3 && (s3 &= -12582913, s3 |= i3 << 22), this._data[3 * e3 + 0] = s3;
          }
          insertCells(e3, t3, i3) {
            if ((e3 %= this.length) && 2 === this.getWidth(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i3), t3 < this.length - e3) {
              const s3 = new r.CellData();
              for (let i4 = this.length - e3 - t3 - 1; i4 >= 0; --i4) this.setCell(e3 + t3 + i4, this.loadCell(e3 + i4, s3));
              for (let s4 = 0; s4 < t3; ++s4) this.setCell(e3 + s4, i3);
            } else for (let t4 = e3; t4 < this.length; ++t4) this.setCell(t4, i3);
            2 === this.getWidth(this.length - 1) && this.setCellFromCodepoint(this.length - 1, 0, 1, i3);
          }
          deleteCells(e3, t3, i3) {
            if (e3 %= this.length, t3 < this.length - e3) {
              const s3 = new r.CellData();
              for (let i4 = 0; i4 < this.length - e3 - t3; ++i4) this.setCell(e3 + i4, this.loadCell(e3 + t3 + i4, s3));
              for (let e4 = this.length - t3; e4 < this.length; ++e4) this.setCell(e4, i3);
            } else for (let t4 = e3; t4 < this.length; ++t4) this.setCell(t4, i3);
            e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i3), 0 !== this.getWidth(e3) || this.hasContent(e3) || this.setCellFromCodepoint(e3, 0, 1, i3);
          }
          replaceCells(e3, t3, i3, s3 = false) {
            if (s3) for (e3 && 2 === this.getWidth(e3 - 1) && !this.isProtected(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i3), t3 < this.length && 2 === this.getWidth(t3 - 1) && !this.isProtected(t3) && this.setCellFromCodepoint(t3, 0, 1, i3); e3 < t3 && e3 < this.length; ) this.isProtected(e3) || this.setCell(e3, i3), e3++;
            else for (e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i3), t3 < this.length && 2 === this.getWidth(t3 - 1) && this.setCellFromCodepoint(t3, 0, 1, i3); e3 < t3 && e3 < this.length; ) this.setCell(e3++, i3);
          }
          resize(e3, t3) {
            if (e3 === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength;
            const i3 = 3 * e3;
            if (e3 > this.length) {
              if (this._data.buffer.byteLength >= 4 * i3) this._data = new Uint32Array(this._data.buffer, 0, i3);
              else {
                const e4 = new Uint32Array(i3);
                e4.set(this._data), this._data = e4;
              }
              for (let i4 = this.length; i4 < e3; ++i4) this.setCell(i4, t3);
            } else {
              this._data = this._data.subarray(0, i3);
              const t4 = Object.keys(this._combined);
              for (let i4 = 0; i4 < t4.length; i4++) {
                const s4 = parseInt(t4[i4], 10);
                s4 >= e3 && delete this._combined[s4];
              }
              const s3 = Object.keys(this._extendedAttrs);
              for (let t5 = 0; t5 < s3.length; t5++) {
                const i4 = parseInt(s3[t5], 10);
                i4 >= e3 && delete this._extendedAttrs[i4];
              }
            }
            return this.length = e3, 4 * i3 * 2 < this._data.buffer.byteLength;
          }
          cleanupMemory() {
            if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
              const e3 = new Uint32Array(this._data.length);
              return e3.set(this._data), this._data = e3, 1;
            }
            return 0;
          }
          fill(e3, t3 = false) {
            if (t3) for (let t4 = 0; t4 < this.length; ++t4) this.isProtected(t4) || this.setCell(t4, e3);
            else {
              this._combined = {}, this._extendedAttrs = {};
              for (let t4 = 0; t4 < this.length; ++t4) this.setCell(t4, e3);
            }
          }
          copyFrom(e3) {
            this.length !== e3.length ? this._data = new Uint32Array(e3._data) : this._data.set(e3._data), this.length = e3.length, this._combined = {};
            for (const t3 in e3._combined) this._combined[t3] = e3._combined[t3];
            this._extendedAttrs = {};
            for (const t3 in e3._extendedAttrs) this._extendedAttrs[t3] = e3._extendedAttrs[t3];
            this.isWrapped = e3.isWrapped;
          }
          clone() {
            const e3 = new h(0);
            e3._data = new Uint32Array(this._data), e3.length = this.length;
            for (const t3 in this._combined) e3._combined[t3] = this._combined[t3];
            for (const t3 in this._extendedAttrs) e3._extendedAttrs[t3] = this._extendedAttrs[t3];
            return e3.isWrapped = this.isWrapped, e3;
          }
          getTrimmedLength() {
            for (let e3 = this.length - 1; e3 >= 0; --e3) if (4194303 & this._data[3 * e3 + 0]) return e3 + (this._data[3 * e3 + 0] >> 22);
            return 0;
          }
          getNoBgTrimmedLength() {
            for (let e3 = this.length - 1; e3 >= 0; --e3) if (4194303 & this._data[3 * e3 + 0] || 50331648 & this._data[3 * e3 + 2]) return e3 + (this._data[3 * e3 + 0] >> 22);
            return 0;
          }
          copyCellsFrom(e3, t3, i3, s3, r2) {
            const n2 = e3._data;
            if (r2) for (let r3 = s3 - 1; r3 >= 0; r3--) {
              for (let e4 = 0; e4 < 3; e4++) this._data[3 * (i3 + r3) + e4] = n2[3 * (t3 + r3) + e4];
              268435456 & n2[3 * (t3 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e3._extendedAttrs[t3 + r3]);
            }
            else for (let r3 = 0; r3 < s3; r3++) {
              for (let e4 = 0; e4 < 3; e4++) this._data[3 * (i3 + r3) + e4] = n2[3 * (t3 + r3) + e4];
              268435456 & n2[3 * (t3 + r3) + 2] && (this._extendedAttrs[i3 + r3] = e3._extendedAttrs[t3 + r3]);
            }
            const o2 = Object.keys(e3._combined);
            for (let s4 = 0; s4 < o2.length; s4++) {
              const r3 = parseInt(o2[s4], 10);
              r3 >= t3 && (this._combined[r3 - t3 + i3] = e3._combined[r3]);
            }
          }
          translateToString(e3, t3, i3, s3) {
            t3 = t3 ?? 0, i3 = i3 ?? this.length, e3 && (i3 = Math.min(i3, this.getTrimmedLength())), s3 && (s3.length = 0);
            let r2 = "";
            for (; t3 < i3; ) {
              const e4 = this._data[3 * t3 + 0], i4 = 2097151 & e4, a2 = 2097152 & e4 ? this._combined[t3] : i4 ? (0, o.stringFromCodePoint)(i4) : n.WHITESPACE_CELL_CHAR;
              if (r2 += a2, s3) for (let e5 = 0; e5 < a2.length; ++e5) s3.push(t3);
              t3 += e4 >> 22 || 1;
            }
            return s3 && s3.push(t3), r2;
          }
        }
        t2.BufferLine = h;
      }, 4841: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getRangeLength = void 0, t2.getRangeLength = function(e3, t3) {
          if (e3.start.y > e3.end.y) throw new Error(`Buffer range end (${e3.end.x}, ${e3.end.y}) cannot be before start (${e3.start.x}, ${e3.start.y})`);
          return t3 * (e3.end.y - e3.start.y) + (e3.end.x - e3.start.x + 1);
        };
      }, 4634: (e2, t2) => {
        function i2(e3, t3, i3) {
          if (t3 === e3.length - 1) return e3[t3].getTrimmedLength();
          const s2 = !e3[t3].hasContent(i3 - 1) && 1 === e3[t3].getWidth(i3 - 1), r = 2 === e3[t3 + 1].getWidth(0);
          return s2 && r ? i3 - 1 : i3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getWrappedLineTrimmedLength = t2.reflowSmallerGetNewLineLengths = t2.reflowLargerApplyNewLayout = t2.reflowLargerCreateNewLayout = t2.reflowLargerGetLinesToRemove = void 0, t2.reflowLargerGetLinesToRemove = function(e3, t3, s2, r, n) {
          const o = [];
          for (let a = 0; a < e3.length - 1; a++) {
            let h = a, c = e3.get(++h);
            if (!c.isWrapped) continue;
            const l = [e3.get(a)];
            for (; h < e3.length && c.isWrapped; ) l.push(c), c = e3.get(++h);
            if (r >= a && r < h) {
              a += l.length - 1;
              continue;
            }
            let d = 0, _ = i2(l, d, t3), u = 1, f = 0;
            for (; u < l.length; ) {
              const e4 = i2(l, u, t3), r2 = e4 - f, o2 = s2 - _, a2 = Math.min(r2, o2);
              l[d].copyCellsFrom(l[u], f, _, a2, false), _ += a2, _ === s2 && (d++, _ = 0), f += a2, f === e4 && (u++, f = 0), 0 === _ && 0 !== d && 2 === l[d - 1].getWidth(s2 - 1) && (l[d].copyCellsFrom(l[d - 1], s2 - 1, _++, 1, false), l[d - 1].setCell(s2 - 1, n));
            }
            l[d].replaceCells(_, s2, n);
            let v = 0;
            for (let e4 = l.length - 1; e4 > 0 && (e4 > d || 0 === l[e4].getTrimmedLength()); e4--) v++;
            v > 0 && (o.push(a + l.length - v), o.push(v)), a += l.length - 1;
          }
          return o;
        }, t2.reflowLargerCreateNewLayout = function(e3, t3) {
          const i3 = [];
          let s2 = 0, r = t3[s2], n = 0;
          for (let o = 0; o < e3.length; o++) if (r === o) {
            const i4 = t3[++s2];
            e3.onDeleteEmitter.fire({ index: o - n, amount: i4 }), o += i4 - 1, n += i4, r = t3[++s2];
          } else i3.push(o);
          return { layout: i3, countRemoved: n };
        }, t2.reflowLargerApplyNewLayout = function(e3, t3) {
          const i3 = [];
          for (let s2 = 0; s2 < t3.length; s2++) i3.push(e3.get(t3[s2]));
          for (let t4 = 0; t4 < i3.length; t4++) e3.set(t4, i3[t4]);
          e3.length = t3.length;
        }, t2.reflowSmallerGetNewLineLengths = function(e3, t3, s2) {
          const r = [], n = e3.map(((s3, r2) => i2(e3, r2, t3))).reduce(((e4, t4) => e4 + t4));
          let o = 0, a = 0, h = 0;
          for (; h < n; ) {
            if (n - h < s2) {
              r.push(n - h);
              break;
            }
            o += s2;
            const c = i2(e3, a, t3);
            o > c && (o -= c, a++);
            const l = 2 === e3[a].getWidth(o - 1);
            l && o--;
            const d = l ? s2 - 1 : s2;
            r.push(d), h += d;
          }
          return r;
        }, t2.getWrappedLineTrimmedLength = i2;
      }, 5295: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferSet = void 0;
        const s2 = i2(8460), r = i2(844), n = i2(9092);
        class o extends r.Disposable {
          constructor(e3, t3) {
            super(), this._optionsService = e3, this._bufferService = t3, this._onBufferActivate = this.register(new s2.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", (() => this.resize(this._bufferService.cols, this._bufferService.rows)))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", (() => this.setupTabStops())));
          }
          reset() {
            this._normal = new n.Buffer(true, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new n.Buffer(false, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }), this.setupTabStops();
          }
          get alt() {
            return this._alt;
          }
          get active() {
            return this._activeBuffer;
          }
          get normal() {
            return this._normal;
          }
          activateNormalBuffer() {
            this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({ activeBuffer: this._normal, inactiveBuffer: this._alt }));
          }
          activateAltBuffer(e3) {
            this._activeBuffer !== this._alt && (this._alt.fillViewportRows(e3), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({ activeBuffer: this._alt, inactiveBuffer: this._normal }));
          }
          resize(e3, t3) {
            this._normal.resize(e3, t3), this._alt.resize(e3, t3), this.setupTabStops(e3);
          }
          setupTabStops(e3) {
            this._normal.setupTabStops(e3), this._alt.setupTabStops(e3);
          }
        }
        t2.BufferSet = o;
      }, 511: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CellData = void 0;
        const s2 = i2(482), r = i2(643), n = i2(3734);
        class o extends n.AttributeData {
          constructor() {
            super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs(), this.combinedData = "";
          }
          static fromCharData(e3) {
            const t3 = new o();
            return t3.setFromCharData(e3), t3;
          }
          isCombined() {
            return 2097152 & this.content;
          }
          getWidth() {
            return this.content >> 22;
          }
          getChars() {
            return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s2.stringFromCodePoint)(2097151 & this.content) : "";
          }
          getCode() {
            return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
          }
          setFromCharData(e3) {
            this.fg = e3[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
            let t3 = false;
            if (e3[r.CHAR_DATA_CHAR_INDEX].length > 2) t3 = true;
            else if (2 === e3[r.CHAR_DATA_CHAR_INDEX].length) {
              const i3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
              if (55296 <= i3 && i3 <= 56319) {
                const s3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                56320 <= s3 && s3 <= 57343 ? this.content = 1024 * (i3 - 55296) + s3 - 56320 + 65536 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22 : t3 = true;
              } else t3 = true;
            } else this.content = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e3[r.CHAR_DATA_WIDTH_INDEX] << 22;
            t3 && (this.combinedData = e3[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22);
          }
          getAsCharData() {
            return [this.fg, this.getChars(), this.getWidth(), this.getCode()];
          }
        }
        t2.CellData = o;
      }, 643: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.WHITESPACE_CELL_CODE = t2.WHITESPACE_CELL_WIDTH = t2.WHITESPACE_CELL_CHAR = t2.NULL_CELL_CODE = t2.NULL_CELL_WIDTH = t2.NULL_CELL_CHAR = t2.CHAR_DATA_CODE_INDEX = t2.CHAR_DATA_WIDTH_INDEX = t2.CHAR_DATA_CHAR_INDEX = t2.CHAR_DATA_ATTR_INDEX = t2.DEFAULT_EXT = t2.DEFAULT_ATTR = t2.DEFAULT_COLOR = void 0, t2.DEFAULT_COLOR = 0, t2.DEFAULT_ATTR = 256 | t2.DEFAULT_COLOR << 9, t2.DEFAULT_EXT = 0, t2.CHAR_DATA_ATTR_INDEX = 0, t2.CHAR_DATA_CHAR_INDEX = 1, t2.CHAR_DATA_WIDTH_INDEX = 2, t2.CHAR_DATA_CODE_INDEX = 3, t2.NULL_CELL_CHAR = "", t2.NULL_CELL_WIDTH = 1, t2.NULL_CELL_CODE = 0, t2.WHITESPACE_CELL_CHAR = " ", t2.WHITESPACE_CELL_WIDTH = 1, t2.WHITESPACE_CELL_CODE = 32;
      }, 4863: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Marker = void 0;
        const s2 = i2(8460), r = i2(844);
        class n {
          get id() {
            return this._id;
          }
          constructor(e3) {
            this.line = e3, this.isDisposed = false, this._disposables = [], this._id = n._nextId++, this._onDispose = this.register(new s2.EventEmitter()), this.onDispose = this._onDispose.event;
          }
          dispose() {
            this.isDisposed || (this.isDisposed = true, this.line = -1, this._onDispose.fire(), (0, r.disposeArray)(this._disposables), this._disposables.length = 0);
          }
          register(e3) {
            return this._disposables.push(e3), e3;
          }
        }
        t2.Marker = n, n._nextId = 1;
      }, 7116: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DEFAULT_CHARSET = t2.CHARSETS = void 0, t2.CHARSETS = {}, t2.DEFAULT_CHARSET = t2.CHARSETS.B, t2.CHARSETS[0] = { "`": "", a: "", b: "", c: "", d: "", e: "", f: "", g: "", h: "", i: "", j: "", k: "", l: "", m: "", n: "", o: "", p: "", q: "", r: "", s: "", t: "", u: "", v: "", w: "", x: "", y: "", z: "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.A = { "#": "" }, t2.CHARSETS.B = void 0, t2.CHARSETS[4] = { "#": "", "@": "", "[": "ij", "\\": "", "]": "|", "{": "", "|": "f", "}": "", "~": "" }, t2.CHARSETS.C = t2.CHARSETS[5] = { "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.R = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.Q = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.K = { "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.Y = { "#": "", "@": "", "[": "", "\\": "", "]": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.E = t2.CHARSETS[6] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS.Z = { "#": "", "@": "", "[": "", "\\": "", "]": "", "{": "", "|": "", "}": "" }, t2.CHARSETS.H = t2.CHARSETS[7] = { "@": "", "[": "", "\\": "", "]": "", "^": "", "`": "", "{": "", "|": "", "}": "", "~": "" }, t2.CHARSETS["="] = { "#": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "" };
      }, 2584: (e2, t2) => {
        var i2, s2, r;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.C1_ESCAPED = t2.C1 = t2.C0 = void 0, (function(e3) {
          e3.NUL = "\0", e3.SOH = "", e3.STX = "", e3.ETX = "", e3.EOT = "", e3.ENQ = "", e3.ACK = "", e3.BEL = "\x07", e3.BS = "\b", e3.HT = "	", e3.LF = "\n", e3.VT = "\v", e3.FF = "\f", e3.CR = "\r", e3.SO = "", e3.SI = "", e3.DLE = "", e3.DC1 = "", e3.DC2 = "", e3.DC3 = "", e3.DC4 = "", e3.NAK = "", e3.SYN = "", e3.ETB = "", e3.CAN = "", e3.EM = "", e3.SUB = "", e3.ESC = "\x1B", e3.FS = "", e3.GS = "", e3.RS = "", e3.US = "", e3.SP = " ", e3.DEL = "";
        })(i2 || (t2.C0 = i2 = {})), (function(e3) {
          e3.PAD = "", e3.HOP = "", e3.BPH = "", e3.NBH = "", e3.IND = "", e3.NEL = "", e3.SSA = "", e3.ESA = "", e3.HTS = "", e3.HTJ = "", e3.VTS = "", e3.PLD = "", e3.PLU = "", e3.RI = "", e3.SS2 = "", e3.SS3 = "", e3.DCS = "", e3.PU1 = "", e3.PU2 = "", e3.STS = "", e3.CCH = "", e3.MW = "", e3.SPA = "", e3.EPA = "", e3.SOS = "", e3.SGCI = "", e3.SCI = "", e3.CSI = "", e3.ST = "", e3.OSC = "", e3.PM = "", e3.APC = "";
        })(s2 || (t2.C1 = s2 = {})), (function(e3) {
          e3.ST = `${i2.ESC}\\`;
        })(r || (t2.C1_ESCAPED = r = {}));
      }, 7399: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluateKeyboardEvent = void 0;
        const s2 = i2(2584), r = { 48: ["0", ")"], 49: ["1", "!"], 50: ["2", "@"], 51: ["3", "#"], 52: ["4", "$"], 53: ["5", "%"], 54: ["6", "^"], 55: ["7", "&"], 56: ["8", "*"], 57: ["9", "("], 186: [";", ":"], 187: ["=", "+"], 188: [",", "<"], 189: ["-", "_"], 190: [".", ">"], 191: ["/", "?"], 192: ["`", "~"], 219: ["[", "{"], 220: ["\\", "|"], 221: ["]", "}"], 222: ["'", '"'] };
        t2.evaluateKeyboardEvent = function(e3, t3, i3, n) {
          const o = { type: 0, cancel: false, key: void 0 }, a = (e3.shiftKey ? 1 : 0) | (e3.altKey ? 2 : 0) | (e3.ctrlKey ? 4 : 0) | (e3.metaKey ? 8 : 0);
          switch (e3.keyCode) {
            case 0:
              "UIKeyInputUpArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A" : "UIKeyInputLeftArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D" : "UIKeyInputRightArrow" === e3.key ? o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C" : "UIKeyInputDownArrow" === e3.key && (o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B");
              break;
            case 8:
              o.key = e3.ctrlKey ? "\b" : s2.C0.DEL, e3.altKey && (o.key = s2.C0.ESC + o.key);
              break;
            case 9:
              if (e3.shiftKey) {
                o.key = s2.C0.ESC + "[Z";
                break;
              }
              o.key = s2.C0.HT, o.cancel = true;
              break;
            case 13:
              o.key = e3.altKey ? s2.C0.ESC + s2.C0.CR : s2.C0.CR, o.cancel = true;
              break;
            case 27:
              o.key = s2.C0.ESC, e3.altKey && (o.key = s2.C0.ESC + s2.C0.ESC), o.cancel = true;
              break;
            case 37:
              if (e3.metaKey) break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "D", o.key === s2.C0.ESC + "[1;3D" && (o.key = s2.C0.ESC + (i3 ? "b" : "[1;5D"))) : o.key = t3 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D";
              break;
            case 39:
              if (e3.metaKey) break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "C", o.key === s2.C0.ESC + "[1;3C" && (o.key = s2.C0.ESC + (i3 ? "f" : "[1;5C"))) : o.key = t3 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C";
              break;
            case 38:
              if (e3.metaKey) break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "A", i3 || o.key !== s2.C0.ESC + "[1;3A" || (o.key = s2.C0.ESC + "[1;5A")) : o.key = t3 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A";
              break;
            case 40:
              if (e3.metaKey) break;
              a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "B", i3 || o.key !== s2.C0.ESC + "[1;3B" || (o.key = s2.C0.ESC + "[1;5B")) : o.key = t3 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B";
              break;
            case 45:
              e3.shiftKey || e3.ctrlKey || (o.key = s2.C0.ESC + "[2~");
              break;
            case 46:
              o.key = a ? s2.C0.ESC + "[3;" + (a + 1) + "~" : s2.C0.ESC + "[3~";
              break;
            case 36:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "H" : t3 ? s2.C0.ESC + "OH" : s2.C0.ESC + "[H";
              break;
            case 35:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "F" : t3 ? s2.C0.ESC + "OF" : s2.C0.ESC + "[F";
              break;
            case 33:
              e3.shiftKey ? o.type = 2 : e3.ctrlKey ? o.key = s2.C0.ESC + "[5;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[5~";
              break;
            case 34:
              e3.shiftKey ? o.type = 3 : e3.ctrlKey ? o.key = s2.C0.ESC + "[6;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[6~";
              break;
            case 112:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "P" : s2.C0.ESC + "OP";
              break;
            case 113:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "Q" : s2.C0.ESC + "OQ";
              break;
            case 114:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "R" : s2.C0.ESC + "OR";
              break;
            case 115:
              o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "S" : s2.C0.ESC + "OS";
              break;
            case 116:
              o.key = a ? s2.C0.ESC + "[15;" + (a + 1) + "~" : s2.C0.ESC + "[15~";
              break;
            case 117:
              o.key = a ? s2.C0.ESC + "[17;" + (a + 1) + "~" : s2.C0.ESC + "[17~";
              break;
            case 118:
              o.key = a ? s2.C0.ESC + "[18;" + (a + 1) + "~" : s2.C0.ESC + "[18~";
              break;
            case 119:
              o.key = a ? s2.C0.ESC + "[19;" + (a + 1) + "~" : s2.C0.ESC + "[19~";
              break;
            case 120:
              o.key = a ? s2.C0.ESC + "[20;" + (a + 1) + "~" : s2.C0.ESC + "[20~";
              break;
            case 121:
              o.key = a ? s2.C0.ESC + "[21;" + (a + 1) + "~" : s2.C0.ESC + "[21~";
              break;
            case 122:
              o.key = a ? s2.C0.ESC + "[23;" + (a + 1) + "~" : s2.C0.ESC + "[23~";
              break;
            case 123:
              o.key = a ? s2.C0.ESC + "[24;" + (a + 1) + "~" : s2.C0.ESC + "[24~";
              break;
            default:
              if (!e3.ctrlKey || e3.shiftKey || e3.altKey || e3.metaKey) if (i3 && !n || !e3.altKey || e3.metaKey) !i3 || e3.altKey || e3.ctrlKey || e3.shiftKey || !e3.metaKey ? e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && e3.keyCode >= 48 && 1 === e3.key.length ? o.key = e3.key : e3.key && e3.ctrlKey && ("_" === e3.key && (o.key = s2.C0.US), "@" === e3.key && (o.key = s2.C0.NUL)) : 65 === e3.keyCode && (o.type = 1);
              else {
                const t4 = r[e3.keyCode], i4 = t4?.[e3.shiftKey ? 1 : 0];
                if (i4) o.key = s2.C0.ESC + i4;
                else if (e3.keyCode >= 65 && e3.keyCode <= 90) {
                  const t5 = e3.ctrlKey ? e3.keyCode - 64 : e3.keyCode + 32;
                  let i5 = String.fromCharCode(t5);
                  e3.shiftKey && (i5 = i5.toUpperCase()), o.key = s2.C0.ESC + i5;
                } else if (32 === e3.keyCode) o.key = s2.C0.ESC + (e3.ctrlKey ? s2.C0.NUL : " ");
                else if ("Dead" === e3.key && e3.code.startsWith("Key")) {
                  let t5 = e3.code.slice(3, 4);
                  e3.shiftKey || (t5 = t5.toLowerCase()), o.key = s2.C0.ESC + t5, o.cancel = true;
                }
              }
              else e3.keyCode >= 65 && e3.keyCode <= 90 ? o.key = String.fromCharCode(e3.keyCode - 64) : 32 === e3.keyCode ? o.key = s2.C0.NUL : e3.keyCode >= 51 && e3.keyCode <= 55 ? o.key = String.fromCharCode(e3.keyCode - 51 + 27) : 56 === e3.keyCode ? o.key = s2.C0.DEL : 219 === e3.keyCode ? o.key = s2.C0.ESC : 220 === e3.keyCode ? o.key = s2.C0.FS : 221 === e3.keyCode && (o.key = s2.C0.GS);
          }
          return o;
        };
      }, 482: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Utf8ToUtf32 = t2.StringToUtf32 = t2.utf32ToString = t2.stringFromCodePoint = void 0, t2.stringFromCodePoint = function(e3) {
          return e3 > 65535 ? (e3 -= 65536, String.fromCharCode(55296 + (e3 >> 10)) + String.fromCharCode(e3 % 1024 + 56320)) : String.fromCharCode(e3);
        }, t2.utf32ToString = function(e3, t3 = 0, i2 = e3.length) {
          let s2 = "";
          for (let r = t3; r < i2; ++r) {
            let t4 = e3[r];
            t4 > 65535 ? (t4 -= 65536, s2 += String.fromCharCode(55296 + (t4 >> 10)) + String.fromCharCode(t4 % 1024 + 56320)) : s2 += String.fromCharCode(t4);
          }
          return s2;
        }, t2.StringToUtf32 = class {
          constructor() {
            this._interim = 0;
          }
          clear() {
            this._interim = 0;
          }
          decode(e3, t3) {
            const i2 = e3.length;
            if (!i2) return 0;
            let s2 = 0, r = 0;
            if (this._interim) {
              const i3 = e3.charCodeAt(r++);
              56320 <= i3 && i3 <= 57343 ? t3[s2++] = 1024 * (this._interim - 55296) + i3 - 56320 + 65536 : (t3[s2++] = this._interim, t3[s2++] = i3), this._interim = 0;
            }
            for (let n = r; n < i2; ++n) {
              const r2 = e3.charCodeAt(n);
              if (55296 <= r2 && r2 <= 56319) {
                if (++n >= i2) return this._interim = r2, s2;
                const o = e3.charCodeAt(n);
                56320 <= o && o <= 57343 ? t3[s2++] = 1024 * (r2 - 55296) + o - 56320 + 65536 : (t3[s2++] = r2, t3[s2++] = o);
              } else 65279 !== r2 && (t3[s2++] = r2);
            }
            return s2;
          }
        }, t2.Utf8ToUtf32 = class {
          constructor() {
            this.interim = new Uint8Array(3);
          }
          clear() {
            this.interim.fill(0);
          }
          decode(e3, t3) {
            const i2 = e3.length;
            if (!i2) return 0;
            let s2, r, n, o, a = 0, h = 0, c = 0;
            if (this.interim[0]) {
              let s3 = false, r2 = this.interim[0];
              r2 &= 192 == (224 & r2) ? 31 : 224 == (240 & r2) ? 15 : 7;
              let n2, o2 = 0;
              for (; (n2 = 63 & this.interim[++o2]) && o2 < 4; ) r2 <<= 6, r2 |= n2;
              const h2 = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4, l2 = h2 - o2;
              for (; c < l2; ) {
                if (c >= i2) return 0;
                if (n2 = e3[c++], 128 != (192 & n2)) {
                  c--, s3 = true;
                  break;
                }
                this.interim[o2++] = n2, r2 <<= 6, r2 |= 63 & n2;
              }
              s3 || (2 === h2 ? r2 < 128 ? c-- : t3[a++] = r2 : 3 === h2 ? r2 < 2048 || r2 >= 55296 && r2 <= 57343 || 65279 === r2 || (t3[a++] = r2) : r2 < 65536 || r2 > 1114111 || (t3[a++] = r2)), this.interim.fill(0);
            }
            const l = i2 - 4;
            let d = c;
            for (; d < i2; ) {
              for (; !(!(d < l) || 128 & (s2 = e3[d]) || 128 & (r = e3[d + 1]) || 128 & (n = e3[d + 2]) || 128 & (o = e3[d + 3])); ) t3[a++] = s2, t3[a++] = r, t3[a++] = n, t3[a++] = o, d += 4;
              if (s2 = e3[d++], s2 < 128) t3[a++] = s2;
              else if (192 == (224 & s2)) {
                if (d >= i2) return this.interim[0] = s2, a;
                if (r = e3[d++], 128 != (192 & r)) {
                  d--;
                  continue;
                }
                if (h = (31 & s2) << 6 | 63 & r, h < 128) {
                  d--;
                  continue;
                }
                t3[a++] = h;
              } else if (224 == (240 & s2)) {
                if (d >= i2) return this.interim[0] = s2, a;
                if (r = e3[d++], 128 != (192 & r)) {
                  d--;
                  continue;
                }
                if (d >= i2) return this.interim[0] = s2, this.interim[1] = r, a;
                if (n = e3[d++], 128 != (192 & n)) {
                  d--;
                  continue;
                }
                if (h = (15 & s2) << 12 | (63 & r) << 6 | 63 & n, h < 2048 || h >= 55296 && h <= 57343 || 65279 === h) continue;
                t3[a++] = h;
              } else if (240 == (248 & s2)) {
                if (d >= i2) return this.interim[0] = s2, a;
                if (r = e3[d++], 128 != (192 & r)) {
                  d--;
                  continue;
                }
                if (d >= i2) return this.interim[0] = s2, this.interim[1] = r, a;
                if (n = e3[d++], 128 != (192 & n)) {
                  d--;
                  continue;
                }
                if (d >= i2) return this.interim[0] = s2, this.interim[1] = r, this.interim[2] = n, a;
                if (o = e3[d++], 128 != (192 & o)) {
                  d--;
                  continue;
                }
                if (h = (7 & s2) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & o, h < 65536 || h > 1114111) continue;
                t3[a++] = h;
              }
            }
            return a;
          }
        };
      }, 225: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeV6 = void 0;
        const s2 = i2(1480), r = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531]], n = [[68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]];
        let o;
        t2.UnicodeV6 = class {
          constructor() {
            if (this.version = "6", !o) {
              o = new Uint8Array(65536), o.fill(1), o[0] = 0, o.fill(0, 1, 32), o.fill(0, 127, 160), o.fill(2, 4352, 4448), o[9001] = 2, o[9002] = 2, o.fill(2, 11904, 42192), o[12351] = 1, o.fill(2, 44032, 55204), o.fill(2, 63744, 64256), o.fill(2, 65040, 65050), o.fill(2, 65072, 65136), o.fill(2, 65280, 65377), o.fill(2, 65504, 65511);
              for (let e3 = 0; e3 < r.length; ++e3) o.fill(0, r[e3][0], r[e3][1] + 1);
            }
          }
          wcwidth(e3) {
            return e3 < 32 ? 0 : e3 < 127 ? 1 : e3 < 65536 ? o[e3] : (function(e4, t3) {
              let i3, s3 = 0, r2 = t3.length - 1;
              if (e4 < t3[0][0] || e4 > t3[r2][1]) return false;
              for (; r2 >= s3; ) if (i3 = s3 + r2 >> 1, e4 > t3[i3][1]) s3 = i3 + 1;
              else {
                if (!(e4 < t3[i3][0])) return true;
                r2 = i3 - 1;
              }
              return false;
            })(e3, n) ? 0 : e3 >= 131072 && e3 <= 196605 || e3 >= 196608 && e3 <= 262141 ? 2 : 1;
          }
          charProperties(e3, t3) {
            let i3 = this.wcwidth(e3), r2 = 0 === i3 && 0 !== t3;
            if (r2) {
              const e4 = s2.UnicodeService.extractWidth(t3);
              0 === e4 ? r2 = false : e4 > i3 && (i3 = e4);
            }
            return s2.UnicodeService.createPropertyValue(0, i3, r2);
          }
        };
      }, 5981: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.WriteBuffer = void 0;
        const s2 = i2(8460), r = i2(844);
        class n extends r.Disposable {
          constructor(e3) {
            super(), this._action = e3, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = false, this._syncCalls = 0, this._didUserInput = false, this._onWriteParsed = this.register(new s2.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
          }
          handleUserInput() {
            this._didUserInput = true;
          }
          writeSync(e3, t3) {
            if (void 0 !== t3 && this._syncCalls > t3) return void (this._syncCalls = 0);
            if (this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;
            let i3;
            for (this._isSyncWriting = true; i3 = this._writeBuffer.shift(); ) {
              this._action(i3);
              const e4 = this._callbacks.shift();
              e4 && e4();
            }
            this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = false, this._syncCalls = 0;
          }
          write(e3, t3) {
            if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data");
            if (!this._writeBuffer.length) {
              if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = false, this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3), void this._innerWrite();
              setTimeout((() => this._innerWrite()));
            }
            this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t3);
          }
          _innerWrite(e3 = 0, t3 = true) {
            const i3 = e3 || Date.now();
            for (; this._writeBuffer.length > this._bufferOffset; ) {
              const e4 = this._writeBuffer[this._bufferOffset], s3 = this._action(e4, t3);
              if (s3) {
                const e5 = (e6) => Date.now() - i3 >= 12 ? setTimeout((() => this._innerWrite(0, e6))) : this._innerWrite(i3, e6);
                return void s3.catch(((e6) => (queueMicrotask((() => {
                  throw e6;
                })), Promise.resolve(false)))).then(e5);
              }
              const r2 = this._callbacks[this._bufferOffset];
              if (r2 && r2(), this._bufferOffset++, this._pendingData -= e4.length, Date.now() - i3 >= 12) break;
            }
            this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout((() => this._innerWrite()))) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
          }
        }
        t2.WriteBuffer = n;
      }, 5941: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.toRgbString = t2.parseColor = void 0;
        const i2 = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, s2 = /^[\da-f]+$/;
        function r(e3, t3) {
          const i3 = e3.toString(16), s3 = i3.length < 2 ? "0" + i3 : i3;
          switch (t3) {
            case 4:
              return i3[0];
            case 8:
              return s3;
            case 12:
              return (s3 + s3).slice(0, 3);
            default:
              return s3 + s3;
          }
        }
        t2.parseColor = function(e3) {
          if (!e3) return;
          let t3 = e3.toLowerCase();
          if (0 === t3.indexOf("rgb:")) {
            t3 = t3.slice(4);
            const e4 = i2.exec(t3);
            if (e4) {
              const t4 = e4[1] ? 15 : e4[4] ? 255 : e4[7] ? 4095 : 65535;
              return [Math.round(parseInt(e4[1] || e4[4] || e4[7] || e4[10], 16) / t4 * 255), Math.round(parseInt(e4[2] || e4[5] || e4[8] || e4[11], 16) / t4 * 255), Math.round(parseInt(e4[3] || e4[6] || e4[9] || e4[12], 16) / t4 * 255)];
            }
          } else if (0 === t3.indexOf("#") && (t3 = t3.slice(1), s2.exec(t3) && [3, 6, 9, 12].includes(t3.length))) {
            const e4 = t3.length / 3, i3 = [0, 0, 0];
            for (let s3 = 0; s3 < 3; ++s3) {
              const r2 = parseInt(t3.slice(e4 * s3, e4 * s3 + e4), 16);
              i3[s3] = 1 === e4 ? r2 << 4 : 2 === e4 ? r2 : 3 === e4 ? r2 >> 4 : r2 >> 8;
            }
            return i3;
          }
        }, t2.toRgbString = function(e3, t3 = 16) {
          const [i3, s3, n] = e3;
          return `rgb:${r(i3, t3)}/${r(s3, t3)}/${r(n, t3)}`;
        };
      }, 5770: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.PAYLOAD_LIMIT = void 0, t2.PAYLOAD_LIMIT = 1e7;
      }, 6351: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DcsHandler = t2.DcsParser = void 0;
        const s2 = i2(482), r = i2(8742), n = i2(5770), o = [];
        t2.DcsParser = class {
          constructor() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._active = o, this._ident = 0, this._handlerFb = () => {
            }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = o;
          }
          registerHandler(e3, t3) {
            void 0 === this._handlers[e3] && (this._handlers[e3] = []);
            const i3 = this._handlers[e3];
            return i3.push(t3), { dispose: () => {
              const e4 = i3.indexOf(t3);
              -1 !== e4 && i3.splice(e4, 1);
            } };
          }
          clearHandler(e3) {
            this._handlers[e3] && delete this._handlers[e3];
          }
          setHandlerFallback(e3) {
            this._handlerFb = e3;
          }
          reset() {
            if (this._active.length) for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3) this._active[e3].unhook(false);
            this._stack.paused = false, this._active = o, this._ident = 0;
          }
          hook(e3, t3) {
            if (this.reset(), this._ident = e3, this._active = this._handlers[e3] || o, this._active.length) for (let e4 = this._active.length - 1; e4 >= 0; e4--) this._active[e4].hook(t3);
            else this._handlerFb(this._ident, "HOOK", t3);
          }
          put(e3, t3, i3) {
            if (this._active.length) for (let s3 = this._active.length - 1; s3 >= 0; s3--) this._active[s3].put(e3, t3, i3);
            else this._handlerFb(this._ident, "PUT", (0, s2.utf32ToString)(e3, t3, i3));
          }
          unhook(e3, t3 = true) {
            if (this._active.length) {
              let i3 = false, s3 = this._active.length - 1, r2 = false;
              if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i3) {
                for (; s3 >= 0 && (i3 = this._active[s3].unhook(e3), true !== i3); s3--) if (i3 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                s3--;
              }
              for (; s3 >= 0; s3--) if (i3 = this._active[s3].unhook(false), i3 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
            } else this._handlerFb(this._ident, "UNHOOK", e3);
            this._active = o, this._ident = 0;
          }
        };
        const a = new r.Params();
        a.addParam(0), t2.DcsHandler = class {
          constructor(e3) {
            this._handler = e3, this._data = "", this._params = a, this._hitLimit = false;
          }
          hook(e3) {
            this._params = e3.length > 1 || e3.params[0] ? e3.clone() : a, this._data = "", this._hitLimit = false;
          }
          put(e3, t3, i3) {
            this._hitLimit || (this._data += (0, s2.utf32ToString)(e3, t3, i3), this._data.length > n.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
          }
          unhook(e3) {
            let t3 = false;
            if (this._hitLimit) t3 = false;
            else if (e3 && (t3 = this._handler(this._data, this._params), t3 instanceof Promise)) return t3.then(((e4) => (this._params = a, this._data = "", this._hitLimit = false, e4)));
            return this._params = a, this._data = "", this._hitLimit = false, t3;
          }
        };
      }, 2015: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.EscapeSequenceParser = t2.VT500_TRANSITION_TABLE = t2.TransitionTable = void 0;
        const s2 = i2(844), r = i2(8742), n = i2(6242), o = i2(6351);
        class a {
          constructor(e3) {
            this.table = new Uint8Array(e3);
          }
          setDefault(e3, t3) {
            this.table.fill(e3 << 4 | t3);
          }
          add(e3, t3, i3, s3) {
            this.table[t3 << 8 | e3] = i3 << 4 | s3;
          }
          addMany(e3, t3, i3, s3) {
            for (let r2 = 0; r2 < e3.length; r2++) this.table[t3 << 8 | e3[r2]] = i3 << 4 | s3;
          }
        }
        t2.TransitionTable = a;
        const h = 160;
        t2.VT500_TRANSITION_TABLE = (function() {
          const e3 = new a(4095), t3 = Array.apply(null, Array(256)).map(((e4, t4) => t4)), i3 = (e4, i4) => t3.slice(e4, i4), s3 = i3(32, 127), r2 = i3(0, 24);
          r2.push(25), r2.push.apply(r2, i3(28, 32));
          const n2 = i3(0, 14);
          let o2;
          for (o2 in e3.setDefault(1, 0), e3.addMany(s3, 0, 2, 0), n2) e3.addMany([24, 26, 153, 154], o2, 3, 0), e3.addMany(i3(128, 144), o2, 3, 0), e3.addMany(i3(144, 152), o2, 3, 0), e3.add(156, o2, 0, 0), e3.add(27, o2, 11, 1), e3.add(157, o2, 4, 8), e3.addMany([152, 158, 159], o2, 0, 7), e3.add(155, o2, 11, 3), e3.add(144, o2, 11, 9);
          return e3.addMany(r2, 0, 3, 0), e3.addMany(r2, 1, 3, 1), e3.add(127, 1, 0, 1), e3.addMany(r2, 8, 0, 8), e3.addMany(r2, 3, 3, 3), e3.add(127, 3, 0, 3), e3.addMany(r2, 4, 3, 4), e3.add(127, 4, 0, 4), e3.addMany(r2, 6, 3, 6), e3.addMany(r2, 5, 3, 5), e3.add(127, 5, 0, 5), e3.addMany(r2, 2, 3, 2), e3.add(127, 2, 0, 2), e3.add(93, 1, 4, 8), e3.addMany(s3, 8, 5, 8), e3.add(127, 8, 5, 8), e3.addMany([156, 27, 24, 26, 7], 8, 6, 0), e3.addMany(i3(28, 32), 8, 0, 8), e3.addMany([88, 94, 95], 1, 0, 7), e3.addMany(s3, 7, 0, 7), e3.addMany(r2, 7, 0, 7), e3.add(156, 7, 0, 0), e3.add(127, 7, 0, 7), e3.add(91, 1, 11, 3), e3.addMany(i3(64, 127), 3, 7, 0), e3.addMany(i3(48, 60), 3, 8, 4), e3.addMany([60, 61, 62, 63], 3, 9, 4), e3.addMany(i3(48, 60), 4, 8, 4), e3.addMany(i3(64, 127), 4, 7, 0), e3.addMany([60, 61, 62, 63], 4, 0, 6), e3.addMany(i3(32, 64), 6, 0, 6), e3.add(127, 6, 0, 6), e3.addMany(i3(64, 127), 6, 0, 0), e3.addMany(i3(32, 48), 3, 9, 5), e3.addMany(i3(32, 48), 5, 9, 5), e3.addMany(i3(48, 64), 5, 0, 6), e3.addMany(i3(64, 127), 5, 7, 0), e3.addMany(i3(32, 48), 4, 9, 5), e3.addMany(i3(32, 48), 1, 9, 2), e3.addMany(i3(32, 48), 2, 9, 2), e3.addMany(i3(48, 127), 2, 10, 0), e3.addMany(i3(48, 80), 1, 10, 0), e3.addMany(i3(81, 88), 1, 10, 0), e3.addMany([89, 90, 92], 1, 10, 0), e3.addMany(i3(96, 127), 1, 10, 0), e3.add(80, 1, 11, 9), e3.addMany(r2, 9, 0, 9), e3.add(127, 9, 0, 9), e3.addMany(i3(28, 32), 9, 0, 9), e3.addMany(i3(32, 48), 9, 9, 12), e3.addMany(i3(48, 60), 9, 8, 10), e3.addMany([60, 61, 62, 63], 9, 9, 10), e3.addMany(r2, 11, 0, 11), e3.addMany(i3(32, 128), 11, 0, 11), e3.addMany(i3(28, 32), 11, 0, 11), e3.addMany(r2, 10, 0, 10), e3.add(127, 10, 0, 10), e3.addMany(i3(28, 32), 10, 0, 10), e3.addMany(i3(48, 60), 10, 8, 10), e3.addMany([60, 61, 62, 63], 10, 0, 11), e3.addMany(i3(32, 48), 10, 9, 12), e3.addMany(r2, 12, 0, 12), e3.add(127, 12, 0, 12), e3.addMany(i3(28, 32), 12, 0, 12), e3.addMany(i3(32, 48), 12, 9, 12), e3.addMany(i3(48, 64), 12, 0, 11), e3.addMany(i3(64, 127), 12, 12, 13), e3.addMany(i3(64, 127), 10, 12, 13), e3.addMany(i3(64, 127), 9, 12, 13), e3.addMany(r2, 13, 13, 13), e3.addMany(s3, 13, 13, 13), e3.add(127, 13, 0, 13), e3.addMany([27, 156, 24, 26], 13, 14, 0), e3.add(h, 0, 2, 0), e3.add(h, 8, 5, 8), e3.add(h, 6, 0, 6), e3.add(h, 11, 0, 11), e3.add(h, 13, 13, 13), e3;
        })();
        class c extends s2.Disposable {
          constructor(e3 = t2.VT500_TRANSITION_TABLE) {
            super(), this._transitions = e3, this._parseStack = { state: 0, handlers: [], handlerPos: 0, transition: 0, chunkPos: 0 }, this.initialState = 0, this.currentState = this.initialState, this._params = new r.Params(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, this._printHandlerFb = (e4, t3, i3) => {
            }, this._executeHandlerFb = (e4) => {
            }, this._csiHandlerFb = (e4, t3) => {
            }, this._escHandlerFb = (e4) => {
            }, this._errorHandlerFb = (e4) => e4, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, s2.toDisposable)((() => {
              this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
            }))), this._oscParser = this.register(new n.OscParser()), this._dcsParser = this.register(new o.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({ final: "\\" }, (() => true));
          }
          _identifier(e3, t3 = [64, 126]) {
            let i3 = 0;
            if (e3.prefix) {
              if (e3.prefix.length > 1) throw new Error("only one byte as prefix supported");
              if (i3 = e3.prefix.charCodeAt(0), i3 && 60 > i3 || i3 > 63) throw new Error("prefix must be in range 0x3c .. 0x3f");
            }
            if (e3.intermediates) {
              if (e3.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported");
              for (let t4 = 0; t4 < e3.intermediates.length; ++t4) {
                const s4 = e3.intermediates.charCodeAt(t4);
                if (32 > s4 || s4 > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f");
                i3 <<= 8, i3 |= s4;
              }
            }
            if (1 !== e3.final.length) throw new Error("final must be a single byte");
            const s3 = e3.final.charCodeAt(0);
            if (t3[0] > s3 || s3 > t3[1]) throw new Error(`final must be in range ${t3[0]} .. ${t3[1]}`);
            return i3 <<= 8, i3 |= s3, i3;
          }
          identToString(e3) {
            const t3 = [];
            for (; e3; ) t3.push(String.fromCharCode(255 & e3)), e3 >>= 8;
            return t3.reverse().join("");
          }
          setPrintHandler(e3) {
            this._printHandler = e3;
          }
          clearPrintHandler() {
            this._printHandler = this._printHandlerFb;
          }
          registerEscHandler(e3, t3) {
            const i3 = this._identifier(e3, [48, 126]);
            void 0 === this._escHandlers[i3] && (this._escHandlers[i3] = []);
            const s3 = this._escHandlers[i3];
            return s3.push(t3), { dispose: () => {
              const e4 = s3.indexOf(t3);
              -1 !== e4 && s3.splice(e4, 1);
            } };
          }
          clearEscHandler(e3) {
            this._escHandlers[this._identifier(e3, [48, 126])] && delete this._escHandlers[this._identifier(e3, [48, 126])];
          }
          setEscHandlerFallback(e3) {
            this._escHandlerFb = e3;
          }
          setExecuteHandler(e3, t3) {
            this._executeHandlers[e3.charCodeAt(0)] = t3;
          }
          clearExecuteHandler(e3) {
            this._executeHandlers[e3.charCodeAt(0)] && delete this._executeHandlers[e3.charCodeAt(0)];
          }
          setExecuteHandlerFallback(e3) {
            this._executeHandlerFb = e3;
          }
          registerCsiHandler(e3, t3) {
            const i3 = this._identifier(e3);
            void 0 === this._csiHandlers[i3] && (this._csiHandlers[i3] = []);
            const s3 = this._csiHandlers[i3];
            return s3.push(t3), { dispose: () => {
              const e4 = s3.indexOf(t3);
              -1 !== e4 && s3.splice(e4, 1);
            } };
          }
          clearCsiHandler(e3) {
            this._csiHandlers[this._identifier(e3)] && delete this._csiHandlers[this._identifier(e3)];
          }
          setCsiHandlerFallback(e3) {
            this._csiHandlerFb = e3;
          }
          registerDcsHandler(e3, t3) {
            return this._dcsParser.registerHandler(this._identifier(e3), t3);
          }
          clearDcsHandler(e3) {
            this._dcsParser.clearHandler(this._identifier(e3));
          }
          setDcsHandlerFallback(e3) {
            this._dcsParser.setHandlerFallback(e3);
          }
          registerOscHandler(e3, t3) {
            return this._oscParser.registerHandler(e3, t3);
          }
          clearOscHandler(e3) {
            this._oscParser.clearHandler(e3);
          }
          setOscHandlerFallback(e3) {
            this._oscParser.setHandlerFallback(e3);
          }
          setErrorHandler(e3) {
            this._errorHandler = e3;
          }
          clearErrorHandler() {
            this._errorHandler = this._errorHandlerFb;
          }
          reset() {
            this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, 0 !== this._parseStack.state && (this._parseStack.state = 2, this._parseStack.handlers = []);
          }
          _preserveStack(e3, t3, i3, s3, r2) {
            this._parseStack.state = e3, this._parseStack.handlers = t3, this._parseStack.handlerPos = i3, this._parseStack.transition = s3, this._parseStack.chunkPos = r2;
          }
          parse(e3, t3, i3) {
            let s3, r2 = 0, n2 = 0, o2 = 0;
            if (this._parseStack.state) if (2 === this._parseStack.state) this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1;
            else {
              if (void 0 === i3 || 1 === this._parseStack.state) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
              const t4 = this._parseStack.handlers;
              let n3 = this._parseStack.handlerPos - 1;
              switch (this._parseStack.state) {
                case 3:
                  if (false === i3 && n3 > -1) {
                    for (; n3 >= 0 && (s3 = t4[n3](this._params), true !== s3); n3--) if (s3 instanceof Promise) return this._parseStack.handlerPos = n3, s3;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 4:
                  if (false === i3 && n3 > -1) {
                    for (; n3 >= 0 && (s3 = t4[n3](), true !== s3); n3--) if (s3 instanceof Promise) return this._parseStack.handlerPos = n3, s3;
                  }
                  this._parseStack.handlers = [];
                  break;
                case 6:
                  if (r2 = e3[this._parseStack.chunkPos], s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2, i3), s3) return s3;
                  27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 5:
                  if (r2 = e3[this._parseStack.chunkPos], s3 = this._oscParser.end(24 !== r2 && 26 !== r2, i3), s3) return s3;
                  27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
              }
              this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1, this.precedingJoinState = 0, this.currentState = 15 & this._parseStack.transition;
            }
            for (let i4 = o2; i4 < t3; ++i4) {
              switch (r2 = e3[i4], n2 = this._transitions.table[this.currentState << 8 | (r2 < 160 ? r2 : h)], n2 >> 4) {
                case 2:
                  for (let s4 = i4 + 1; ; ++s4) {
                    if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e3, i4, s4), i4 = s4 - 1;
                      break;
                    }
                    if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e3, i4, s4), i4 = s4 - 1;
                      break;
                    }
                    if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e3, i4, s4), i4 = s4 - 1;
                      break;
                    }
                    if (++s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                      this._printHandler(e3, i4, s4), i4 = s4 - 1;
                      break;
                    }
                  }
                  break;
                case 3:
                  this._executeHandlers[r2] ? this._executeHandlers[r2]() : this._executeHandlerFb(r2), this.precedingJoinState = 0;
                  break;
                case 0:
                  break;
                case 1:
                  if (this._errorHandler({ position: i4, code: r2, currentState: this.currentState, collect: this._collect, params: this._params, abort: false }).abort) return;
                  break;
                case 7:
                  const o3 = this._csiHandlers[this._collect << 8 | r2];
                  let a2 = o3 ? o3.length - 1 : -1;
                  for (; a2 >= 0 && (s3 = o3[a2](this._params), true !== s3); a2--) if (s3 instanceof Promise) return this._preserveStack(3, o3, a2, n2, i4), s3;
                  a2 < 0 && this._csiHandlerFb(this._collect << 8 | r2, this._params), this.precedingJoinState = 0;
                  break;
                case 8:
                  do {
                    switch (r2) {
                      case 59:
                        this._params.addParam(0);
                        break;
                      case 58:
                        this._params.addSubParam(-1);
                        break;
                      default:
                        this._params.addDigit(r2 - 48);
                    }
                  } while (++i4 < t3 && (r2 = e3[i4]) > 47 && r2 < 60);
                  i4--;
                  break;
                case 9:
                  this._collect <<= 8, this._collect |= r2;
                  break;
                case 10:
                  const c2 = this._escHandlers[this._collect << 8 | r2];
                  let l = c2 ? c2.length - 1 : -1;
                  for (; l >= 0 && (s3 = c2[l](), true !== s3); l--) if (s3 instanceof Promise) return this._preserveStack(4, c2, l, n2, i4), s3;
                  l < 0 && this._escHandlerFb(this._collect << 8 | r2), this.precedingJoinState = 0;
                  break;
                case 11:
                  this._params.reset(), this._params.addParam(0), this._collect = 0;
                  break;
                case 12:
                  this._dcsParser.hook(this._collect << 8 | r2, this._params);
                  break;
                case 13:
                  for (let s4 = i4 + 1; ; ++s4) if (s4 >= t3 || 24 === (r2 = e3[s4]) || 26 === r2 || 27 === r2 || r2 > 127 && r2 < h) {
                    this._dcsParser.put(e3, i4, s4), i4 = s4 - 1;
                    break;
                  }
                  break;
                case 14:
                  if (s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2), s3) return this._preserveStack(6, [], 0, n2, i4), s3;
                  27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
                  break;
                case 4:
                  this._oscParser.start();
                  break;
                case 5:
                  for (let s4 = i4 + 1; ; s4++) if (s4 >= t3 || (r2 = e3[s4]) < 32 || r2 > 127 && r2 < h) {
                    this._oscParser.put(e3, i4, s4), i4 = s4 - 1;
                    break;
                  }
                  break;
                case 6:
                  if (s3 = this._oscParser.end(24 !== r2 && 26 !== r2), s3) return this._preserveStack(5, [], 0, n2, i4), s3;
                  27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
              }
              this.currentState = 15 & n2;
            }
          }
        }
        t2.EscapeSequenceParser = c;
      }, 6242: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OscHandler = t2.OscParser = void 0;
        const s2 = i2(5770), r = i2(482), n = [];
        t2.OscParser = class {
          constructor() {
            this._state = 0, this._active = n, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._stack = { paused: false, loopPosition: 0, fallThrough: false };
          }
          registerHandler(e3, t3) {
            void 0 === this._handlers[e3] && (this._handlers[e3] = []);
            const i3 = this._handlers[e3];
            return i3.push(t3), { dispose: () => {
              const e4 = i3.indexOf(t3);
              -1 !== e4 && i3.splice(e4, 1);
            } };
          }
          clearHandler(e3) {
            this._handlers[e3] && delete this._handlers[e3];
          }
          setHandlerFallback(e3) {
            this._handlerFb = e3;
          }
          dispose() {
            this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
            }, this._active = n;
          }
          reset() {
            if (2 === this._state) for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3) this._active[e3].end(false);
            this._stack.paused = false, this._active = n, this._id = -1, this._state = 0;
          }
          _start() {
            if (this._active = this._handlers[this._id] || n, this._active.length) for (let e3 = this._active.length - 1; e3 >= 0; e3--) this._active[e3].start();
            else this._handlerFb(this._id, "START");
          }
          _put(e3, t3, i3) {
            if (this._active.length) for (let s3 = this._active.length - 1; s3 >= 0; s3--) this._active[s3].put(e3, t3, i3);
            else this._handlerFb(this._id, "PUT", (0, r.utf32ToString)(e3, t3, i3));
          }
          start() {
            this.reset(), this._state = 1;
          }
          put(e3, t3, i3) {
            if (3 !== this._state) {
              if (1 === this._state) for (; t3 < i3; ) {
                const i4 = e3[t3++];
                if (59 === i4) {
                  this._state = 2, this._start();
                  break;
                }
                if (i4 < 48 || 57 < i4) return void (this._state = 3);
                -1 === this._id && (this._id = 0), this._id = 10 * this._id + i4 - 48;
              }
              2 === this._state && i3 - t3 > 0 && this._put(e3, t3, i3);
            }
          }
          end(e3, t3 = true) {
            if (0 !== this._state) {
              if (3 !== this._state) if (1 === this._state && this._start(), this._active.length) {
                let i3 = false, s3 = this._active.length - 1, r2 = false;
                if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i3 = t3, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i3) {
                  for (; s3 >= 0 && (i3 = this._active[s3].end(e3), true !== i3); s3--) if (i3 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i3;
                  s3--;
                }
                for (; s3 >= 0; s3--) if (i3 = this._active[s3].end(false), i3 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i3;
              } else this._handlerFb(this._id, "END", e3);
              this._active = n, this._id = -1, this._state = 0;
            }
          }
        }, t2.OscHandler = class {
          constructor(e3) {
            this._handler = e3, this._data = "", this._hitLimit = false;
          }
          start() {
            this._data = "", this._hitLimit = false;
          }
          put(e3, t3, i3) {
            this._hitLimit || (this._data += (0, r.utf32ToString)(e3, t3, i3), this._data.length > s2.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
          }
          end(e3) {
            let t3 = false;
            if (this._hitLimit) t3 = false;
            else if (e3 && (t3 = this._handler(this._data), t3 instanceof Promise)) return t3.then(((e4) => (this._data = "", this._hitLimit = false, e4)));
            return this._data = "", this._hitLimit = false, t3;
          }
        };
      }, 8742: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Params = void 0;
        const i2 = 2147483647;
        class s2 {
          static fromArray(e3) {
            const t3 = new s2();
            if (!e3.length) return t3;
            for (let i3 = Array.isArray(e3[0]) ? 1 : 0; i3 < e3.length; ++i3) {
              const s3 = e3[i3];
              if (Array.isArray(s3)) for (let e4 = 0; e4 < s3.length; ++e4) t3.addSubParam(s3[e4]);
              else t3.addParam(s3);
            }
            return t3;
          }
          constructor(e3 = 32, t3 = 32) {
            if (this.maxLength = e3, this.maxSubParamsLength = t3, t3 > 256) throw new Error("maxSubParamsLength must not be greater than 256");
            this.params = new Int32Array(e3), this.length = 0, this._subParams = new Int32Array(t3), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(e3), this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
          }
          clone() {
            const e3 = new s2(this.maxLength, this.maxSubParamsLength);
            return e3.params.set(this.params), e3.length = this.length, e3._subParams.set(this._subParams), e3._subParamsLength = this._subParamsLength, e3._subParamsIdx.set(this._subParamsIdx), e3._rejectDigits = this._rejectDigits, e3._rejectSubDigits = this._rejectSubDigits, e3._digitIsSub = this._digitIsSub, e3;
          }
          toArray() {
            const e3 = [];
            for (let t3 = 0; t3 < this.length; ++t3) {
              e3.push(this.params[t3]);
              const i3 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
              s3 - i3 > 0 && e3.push(Array.prototype.slice.call(this._subParams, i3, s3));
            }
            return e3;
          }
          reset() {
            this.length = 0, this._subParamsLength = 0, this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
          }
          addParam(e3) {
            if (this._digitIsSub = false, this.length >= this.maxLength) this._rejectDigits = true;
            else {
              if (e3 < -1) throw new Error("values lesser than -1 are not allowed");
              this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = e3 > i2 ? i2 : e3;
            }
          }
          addSubParam(e3) {
            if (this._digitIsSub = true, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = true;
            else {
              if (e3 < -1) throw new Error("values lesser than -1 are not allowed");
              this._subParams[this._subParamsLength++] = e3 > i2 ? i2 : e3, this._subParamsIdx[this.length - 1]++;
            }
          }
          hasSubParams(e3) {
            return (255 & this._subParamsIdx[e3]) - (this._subParamsIdx[e3] >> 8) > 0;
          }
          getSubParams(e3) {
            const t3 = this._subParamsIdx[e3] >> 8, i3 = 255 & this._subParamsIdx[e3];
            return i3 - t3 > 0 ? this._subParams.subarray(t3, i3) : null;
          }
          getSubParamsAll() {
            const e3 = {};
            for (let t3 = 0; t3 < this.length; ++t3) {
              const i3 = this._subParamsIdx[t3] >> 8, s3 = 255 & this._subParamsIdx[t3];
              s3 - i3 > 0 && (e3[t3] = this._subParams.slice(i3, s3));
            }
            return e3;
          }
          addDigit(e3) {
            let t3;
            if (this._rejectDigits || !(t3 = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;
            const s3 = this._digitIsSub ? this._subParams : this.params, r = s3[t3 - 1];
            s3[t3 - 1] = ~r ? Math.min(10 * r + e3, i2) : e3;
          }
        }
        t2.Params = s2;
      }, 5741: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.AddonManager = void 0, t2.AddonManager = class {
          constructor() {
            this._addons = [];
          }
          dispose() {
            for (let e3 = this._addons.length - 1; e3 >= 0; e3--) this._addons[e3].instance.dispose();
          }
          loadAddon(e3, t3) {
            const i2 = { instance: t3, dispose: t3.dispose, isDisposed: false };
            this._addons.push(i2), t3.dispose = () => this._wrappedAddonDispose(i2), t3.activate(e3);
          }
          _wrappedAddonDispose(e3) {
            if (e3.isDisposed) return;
            let t3 = -1;
            for (let i2 = 0; i2 < this._addons.length; i2++) if (this._addons[i2] === e3) {
              t3 = i2;
              break;
            }
            if (-1 === t3) throw new Error("Could not dispose an addon that has not been loaded");
            e3.isDisposed = true, e3.dispose.apply(e3.instance), this._addons.splice(t3, 1);
          }
        };
      }, 8771: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferApiView = void 0;
        const s2 = i2(3785), r = i2(511);
        t2.BufferApiView = class {
          constructor(e3, t3) {
            this._buffer = e3, this.type = t3;
          }
          init(e3) {
            return this._buffer = e3, this;
          }
          get cursorY() {
            return this._buffer.y;
          }
          get cursorX() {
            return this._buffer.x;
          }
          get viewportY() {
            return this._buffer.ydisp;
          }
          get baseY() {
            return this._buffer.ybase;
          }
          get length() {
            return this._buffer.lines.length;
          }
          getLine(e3) {
            const t3 = this._buffer.lines.get(e3);
            if (t3) return new s2.BufferLineApiView(t3);
          }
          getNullCell() {
            return new r.CellData();
          }
        };
      }, 3785: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferLineApiView = void 0;
        const s2 = i2(511);
        t2.BufferLineApiView = class {
          constructor(e3) {
            this._line = e3;
          }
          get isWrapped() {
            return this._line.isWrapped;
          }
          get length() {
            return this._line.length;
          }
          getCell(e3, t3) {
            if (!(e3 < 0 || e3 >= this._line.length)) return t3 ? (this._line.loadCell(e3, t3), t3) : this._line.loadCell(e3, new s2.CellData());
          }
          translateToString(e3, t3, i3) {
            return this._line.translateToString(e3, t3, i3);
          }
        };
      }, 8285: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferNamespaceApi = void 0;
        const s2 = i2(8771), r = i2(8460), n = i2(844);
        class o extends n.Disposable {
          constructor(e3) {
            super(), this._core = e3, this._onBufferChange = this.register(new r.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new s2.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new s2.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate((() => this._onBufferChange.fire(this.active)));
          }
          get active() {
            if (this._core.buffers.active === this._core.buffers.normal) return this.normal;
            if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;
            throw new Error("Active buffer is neither normal nor alternate");
          }
          get normal() {
            return this._normal.init(this._core.buffers.normal);
          }
          get alternate() {
            return this._alternate.init(this._core.buffers.alt);
          }
        }
        t2.BufferNamespaceApi = o;
      }, 7975: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ParserApi = void 0, t2.ParserApi = class {
          constructor(e3) {
            this._core = e3;
          }
          registerCsiHandler(e3, t3) {
            return this._core.registerCsiHandler(e3, ((e4) => t3(e4.toArray())));
          }
          addCsiHandler(e3, t3) {
            return this.registerCsiHandler(e3, t3);
          }
          registerDcsHandler(e3, t3) {
            return this._core.registerDcsHandler(e3, ((e4, i2) => t3(e4, i2.toArray())));
          }
          addDcsHandler(e3, t3) {
            return this.registerDcsHandler(e3, t3);
          }
          registerEscHandler(e3, t3) {
            return this._core.registerEscHandler(e3, t3);
          }
          addEscHandler(e3, t3) {
            return this.registerEscHandler(e3, t3);
          }
          registerOscHandler(e3, t3) {
            return this._core.registerOscHandler(e3, t3);
          }
          addOscHandler(e3, t3) {
            return this.registerOscHandler(e3, t3);
          }
        };
      }, 7090: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeApi = void 0, t2.UnicodeApi = class {
          constructor(e3) {
            this._core = e3;
          }
          register(e3) {
            this._core.unicodeService.register(e3);
          }
          get versions() {
            return this._core.unicodeService.versions;
          }
          get activeVersion() {
            return this._core.unicodeService.activeVersion;
          }
          set activeVersion(e3) {
            this._core.unicodeService.activeVersion = e3;
          }
        };
      }, 744: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BufferService = t2.MINIMUM_ROWS = t2.MINIMUM_COLS = void 0;
        const n = i2(8460), o = i2(844), a = i2(5295), h = i2(2585);
        t2.MINIMUM_COLS = 2, t2.MINIMUM_ROWS = 1;
        let c = t2.BufferService = class extends o.Disposable {
          get buffer() {
            return this.buffers.active;
          }
          constructor(e3) {
            super(), this.isUserScrolling = false, this._onResize = this.register(new n.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new n.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(e3.rawOptions.cols || 0, t2.MINIMUM_COLS), this.rows = Math.max(e3.rawOptions.rows || 0, t2.MINIMUM_ROWS), this.buffers = this.register(new a.BufferSet(e3, this));
          }
          resize(e3, t3) {
            this.cols = e3, this.rows = t3, this.buffers.resize(e3, t3), this._onResize.fire({ cols: e3, rows: t3 });
          }
          reset() {
            this.buffers.reset(), this.isUserScrolling = false;
          }
          scroll(e3, t3 = false) {
            const i3 = this.buffer;
            let s3;
            s3 = this._cachedBlankLine, s3 && s3.length === this.cols && s3.getFg(0) === e3.fg && s3.getBg(0) === e3.bg || (s3 = i3.getBlankLine(e3, t3), this._cachedBlankLine = s3), s3.isWrapped = t3;
            const r2 = i3.ybase + i3.scrollTop, n2 = i3.ybase + i3.scrollBottom;
            if (0 === i3.scrollTop) {
              const e4 = i3.lines.isFull;
              n2 === i3.lines.length - 1 ? e4 ? i3.lines.recycle().copyFrom(s3) : i3.lines.push(s3.clone()) : i3.lines.splice(n2 + 1, 0, s3.clone()), e4 ? this.isUserScrolling && (i3.ydisp = Math.max(i3.ydisp - 1, 0)) : (i3.ybase++, this.isUserScrolling || i3.ydisp++);
            } else {
              const e4 = n2 - r2 + 1;
              i3.lines.shiftElements(r2 + 1, e4 - 1, -1), i3.lines.set(n2, s3.clone());
            }
            this.isUserScrolling || (i3.ydisp = i3.ybase), this._onScroll.fire(i3.ydisp);
          }
          scrollLines(e3, t3, i3) {
            const s3 = this.buffer;
            if (e3 < 0) {
              if (0 === s3.ydisp) return;
              this.isUserScrolling = true;
            } else e3 + s3.ydisp >= s3.ybase && (this.isUserScrolling = false);
            const r2 = s3.ydisp;
            s3.ydisp = Math.max(Math.min(s3.ydisp + e3, s3.ybase), 0), r2 !== s3.ydisp && (t3 || this._onScroll.fire(s3.ydisp));
          }
        };
        t2.BufferService = c = s2([r(0, h.IOptionsService)], c);
      }, 7994: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CharsetService = void 0, t2.CharsetService = class {
          constructor() {
            this.glevel = 0, this._charsets = [];
          }
          reset() {
            this.charset = void 0, this._charsets = [], this.glevel = 0;
          }
          setgLevel(e3) {
            this.glevel = e3, this.charset = this._charsets[e3];
          }
          setgCharset(e3, t3) {
            this._charsets[e3] = t3, this.glevel === e3 && (this.charset = t3);
          }
        };
      }, 1753: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreMouseService = void 0;
        const n = i2(2585), o = i2(8460), a = i2(844), h = { NONE: { events: 0, restrict: () => false }, X10: { events: 1, restrict: (e3) => 4 !== e3.button && 1 === e3.action && (e3.ctrl = false, e3.alt = false, e3.shift = false, true) }, VT200: { events: 19, restrict: (e3) => 32 !== e3.action }, DRAG: { events: 23, restrict: (e3) => 32 !== e3.action || 3 !== e3.button }, ANY: { events: 31, restrict: (e3) => true } };
        function c(e3, t3) {
          let i3 = (e3.ctrl ? 16 : 0) | (e3.shift ? 4 : 0) | (e3.alt ? 8 : 0);
          return 4 === e3.button ? (i3 |= 64, i3 |= e3.action) : (i3 |= 3 & e3.button, 4 & e3.button && (i3 |= 64), 8 & e3.button && (i3 |= 128), 32 === e3.action ? i3 |= 32 : 0 !== e3.action || t3 || (i3 |= 3)), i3;
        }
        const l = String.fromCharCode, d = { DEFAULT: (e3) => {
          const t3 = [c(e3, false) + 32, e3.col + 32, e3.row + 32];
          return t3[0] > 255 || t3[1] > 255 || t3[2] > 255 ? "" : `\x1B[M${l(t3[0])}${l(t3[1])}${l(t3[2])}`;
        }, SGR: (e3) => {
          const t3 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
          return `\x1B[<${c(e3, true)};${e3.col};${e3.row}${t3}`;
        }, SGR_PIXELS: (e3) => {
          const t3 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
          return `\x1B[<${c(e3, true)};${e3.x};${e3.y}${t3}`;
        } };
        let _ = t2.CoreMouseService = class extends a.Disposable {
          constructor(e3, t3) {
            super(), this._bufferService = e3, this._coreService = t3, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new o.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
            for (const e4 of Object.keys(h)) this.addProtocol(e4, h[e4]);
            for (const e4 of Object.keys(d)) this.addEncoding(e4, d[e4]);
            this.reset();
          }
          addProtocol(e3, t3) {
            this._protocols[e3] = t3;
          }
          addEncoding(e3, t3) {
            this._encodings[e3] = t3;
          }
          get activeProtocol() {
            return this._activeProtocol;
          }
          get areMouseEventsActive() {
            return 0 !== this._protocols[this._activeProtocol].events;
          }
          set activeProtocol(e3) {
            if (!this._protocols[e3]) throw new Error(`unknown protocol "${e3}"`);
            this._activeProtocol = e3, this._onProtocolChange.fire(this._protocols[e3].events);
          }
          get activeEncoding() {
            return this._activeEncoding;
          }
          set activeEncoding(e3) {
            if (!this._encodings[e3]) throw new Error(`unknown encoding "${e3}"`);
            this._activeEncoding = e3;
          }
          reset() {
            this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
          }
          triggerMouseEvent(e3) {
            if (e3.col < 0 || e3.col >= this._bufferService.cols || e3.row < 0 || e3.row >= this._bufferService.rows) return false;
            if (4 === e3.button && 32 === e3.action) return false;
            if (3 === e3.button && 32 !== e3.action) return false;
            if (4 !== e3.button && (2 === e3.action || 3 === e3.action)) return false;
            if (e3.col++, e3.row++, 32 === e3.action && this._lastEvent && this._equalEvents(this._lastEvent, e3, "SGR_PIXELS" === this._activeEncoding)) return false;
            if (!this._protocols[this._activeProtocol].restrict(e3)) return false;
            const t3 = this._encodings[this._activeEncoding](e3);
            return t3 && ("DEFAULT" === this._activeEncoding ? this._coreService.triggerBinaryEvent(t3) : this._coreService.triggerDataEvent(t3, true)), this._lastEvent = e3, true;
          }
          explainEvents(e3) {
            return { down: !!(1 & e3), up: !!(2 & e3), drag: !!(4 & e3), move: !!(8 & e3), wheel: !!(16 & e3) };
          }
          _equalEvents(e3, t3, i3) {
            if (i3) {
              if (e3.x !== t3.x) return false;
              if (e3.y !== t3.y) return false;
            } else {
              if (e3.col !== t3.col) return false;
              if (e3.row !== t3.row) return false;
            }
            return e3.button === t3.button && e3.action === t3.action && e3.ctrl === t3.ctrl && e3.alt === t3.alt && e3.shift === t3.shift;
          }
        };
        t2.CoreMouseService = _ = s2([r(0, n.IBufferService), r(1, n.ICoreService)], _);
      }, 6975: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.CoreService = void 0;
        const n = i2(1439), o = i2(8460), a = i2(844), h = i2(2585), c = Object.freeze({ insertMode: false }), l = Object.freeze({ applicationCursorKeys: false, applicationKeypad: false, bracketedPasteMode: false, origin: false, reverseWraparound: false, sendFocus: false, wraparound: true });
        let d = t2.CoreService = class extends a.Disposable {
          constructor(e3, t3, i3) {
            super(), this._bufferService = e3, this._logService = t3, this._optionsService = i3, this.isCursorInitialized = false, this.isCursorHidden = false, this._onData = this.register(new o.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new o.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new o.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new o.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
          }
          reset() {
            this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
          }
          triggerDataEvent(e3, t3 = false) {
            if (this._optionsService.rawOptions.disableStdin) return;
            const i3 = this._bufferService.buffer;
            t3 && this._optionsService.rawOptions.scrollOnUserInput && i3.ybase !== i3.ydisp && this._onRequestScrollToBottom.fire(), t3 && this._onUserInput.fire(), this._logService.debug(`sending data "${e3}"`, (() => e3.split("").map(((e4) => e4.charCodeAt(0))))), this._onData.fire(e3);
          }
          triggerBinaryEvent(e3) {
            this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${e3}"`, (() => e3.split("").map(((e4) => e4.charCodeAt(0))))), this._onBinary.fire(e3));
          }
        };
        t2.CoreService = d = s2([r(0, h.IBufferService), r(1, h.ILogService), r(2, h.IOptionsService)], d);
      }, 9074: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DecorationService = void 0;
        const s2 = i2(8055), r = i2(8460), n = i2(844), o = i2(6106);
        let a = 0, h = 0;
        class c extends n.Disposable {
          get decorations() {
            return this._decorations.values();
          }
          constructor() {
            super(), this._decorations = new o.SortedList(((e3) => e3?.marker.line)), this._onDecorationRegistered = this.register(new r.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new r.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n.toDisposable)((() => this.reset())));
          }
          registerDecoration(e3) {
            if (e3.marker.isDisposed) return;
            const t3 = new l(e3);
            if (t3) {
              const e4 = t3.marker.onDispose((() => t3.dispose()));
              t3.onDispose((() => {
                t3 && (this._decorations.delete(t3) && this._onDecorationRemoved.fire(t3), e4.dispose());
              })), this._decorations.insert(t3), this._onDecorationRegistered.fire(t3);
            }
            return t3;
          }
          reset() {
            for (const e3 of this._decorations.values()) e3.dispose();
            this._decorations.clear();
          }
          *getDecorationsAtCell(e3, t3, i3) {
            let s3 = 0, r2 = 0;
            for (const n2 of this._decorations.getKeyIterator(t3)) s3 = n2.options.x ?? 0, r2 = s3 + (n2.options.width ?? 1), e3 >= s3 && e3 < r2 && (!i3 || (n2.options.layer ?? "bottom") === i3) && (yield n2);
          }
          forEachDecorationAtCell(e3, t3, i3, s3) {
            this._decorations.forEachByKey(t3, ((t4) => {
              a = t4.options.x ?? 0, h = a + (t4.options.width ?? 1), e3 >= a && e3 < h && (!i3 || (t4.options.layer ?? "bottom") === i3) && s3(t4);
            }));
          }
        }
        t2.DecorationService = c;
        class l extends n.Disposable {
          get isDisposed() {
            return this._isDisposed;
          }
          get backgroundColorRGB() {
            return null === this._cachedBg && (this.options.backgroundColor ? this._cachedBg = s2.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
          }
          get foregroundColorRGB() {
            return null === this._cachedFg && (this.options.foregroundColor ? this._cachedFg = s2.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
          }
          constructor(e3) {
            super(), this.options = e3, this.onRenderEmitter = this.register(new r.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new r.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = e3.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
          }
          dispose() {
            this._onDispose.fire(), super.dispose();
          }
        }
      }, 4348: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.InstantiationService = t2.ServiceCollection = void 0;
        const s2 = i2(2585), r = i2(8343);
        class n {
          constructor(...e3) {
            this._entries = /* @__PURE__ */ new Map();
            for (const [t3, i3] of e3) this.set(t3, i3);
          }
          set(e3, t3) {
            const i3 = this._entries.get(e3);
            return this._entries.set(e3, t3), i3;
          }
          forEach(e3) {
            for (const [t3, i3] of this._entries.entries()) e3(t3, i3);
          }
          has(e3) {
            return this._entries.has(e3);
          }
          get(e3) {
            return this._entries.get(e3);
          }
        }
        t2.ServiceCollection = n, t2.InstantiationService = class {
          constructor() {
            this._services = new n(), this._services.set(s2.IInstantiationService, this);
          }
          setService(e3, t3) {
            this._services.set(e3, t3);
          }
          getService(e3) {
            return this._services.get(e3);
          }
          createInstance(e3, ...t3) {
            const i3 = (0, r.getServiceDependencies)(e3).sort(((e4, t4) => e4.index - t4.index)), s3 = [];
            for (const t4 of i3) {
              const i4 = this._services.get(t4.id);
              if (!i4) throw new Error(`[createInstance] ${e3.name} depends on UNKNOWN service ${t4.id}.`);
              s3.push(i4);
            }
            const n2 = i3.length > 0 ? i3[0].index : t3.length;
            if (t3.length !== n2) throw new Error(`[createInstance] First service dependency of ${e3.name} at position ${n2 + 1} conflicts with ${t3.length} static arguments`);
            return new e3(...[...t3, ...s3]);
          }
        };
      }, 7866: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.traceCall = t2.setTraceLogger = t2.LogService = void 0;
        const n = i2(844), o = i2(2585), a = { trace: o.LogLevelEnum.TRACE, debug: o.LogLevelEnum.DEBUG, info: o.LogLevelEnum.INFO, warn: o.LogLevelEnum.WARN, error: o.LogLevelEnum.ERROR, off: o.LogLevelEnum.OFF };
        let h, c = t2.LogService = class extends n.Disposable {
          get logLevel() {
            return this._logLevel;
          }
          constructor(e3) {
            super(), this._optionsService = e3, this._logLevel = o.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", (() => this._updateLogLevel()))), h = this;
          }
          _updateLogLevel() {
            this._logLevel = a[this._optionsService.rawOptions.logLevel];
          }
          _evalLazyOptionalParams(e3) {
            for (let t3 = 0; t3 < e3.length; t3++) "function" == typeof e3[t3] && (e3[t3] = e3[t3]());
          }
          _log(e3, t3, i3) {
            this._evalLazyOptionalParams(i3), e3.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + t3, ...i3);
          }
          trace(e3, ...t3) {
            this._logLevel <= o.LogLevelEnum.TRACE && this._log(this._optionsService.options.logger?.trace.bind(this._optionsService.options.logger) ?? console.log, e3, t3);
          }
          debug(e3, ...t3) {
            this._logLevel <= o.LogLevelEnum.DEBUG && this._log(this._optionsService.options.logger?.debug.bind(this._optionsService.options.logger) ?? console.log, e3, t3);
          }
          info(e3, ...t3) {
            this._logLevel <= o.LogLevelEnum.INFO && this._log(this._optionsService.options.logger?.info.bind(this._optionsService.options.logger) ?? console.info, e3, t3);
          }
          warn(e3, ...t3) {
            this._logLevel <= o.LogLevelEnum.WARN && this._log(this._optionsService.options.logger?.warn.bind(this._optionsService.options.logger) ?? console.warn, e3, t3);
          }
          error(e3, ...t3) {
            this._logLevel <= o.LogLevelEnum.ERROR && this._log(this._optionsService.options.logger?.error.bind(this._optionsService.options.logger) ?? console.error, e3, t3);
          }
        };
        t2.LogService = c = s2([r(0, o.IOptionsService)], c), t2.setTraceLogger = function(e3) {
          h = e3;
        }, t2.traceCall = function(e3, t3, i3) {
          if ("function" != typeof i3.value) throw new Error("not supported");
          const s3 = i3.value;
          i3.value = function(...e4) {
            if (h.logLevel !== o.LogLevelEnum.TRACE) return s3.apply(this, e4);
            h.trace(`GlyphRenderer#${s3.name}(${e4.map(((e5) => JSON.stringify(e5))).join(", ")})`);
            const t4 = s3.apply(this, e4);
            return h.trace(`GlyphRenderer#${s3.name} return`, t4), t4;
          };
        };
      }, 7302: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OptionsService = t2.DEFAULT_OPTIONS = void 0;
        const s2 = i2(8460), r = i2(844), n = i2(6114);
        t2.DEFAULT_OPTIONS = { cols: 80, rows: 24, cursorBlink: false, cursorStyle: "block", cursorWidth: 1, cursorInactiveStyle: "outline", customGlyphs: true, drawBoldTextInBrightColors: true, documentOverride: null, fastScrollModifier: "alt", fastScrollSensitivity: 5, fontFamily: "courier-new, courier, monospace", fontSize: 15, fontWeight: "normal", fontWeightBold: "bold", ignoreBracketedPasteMode: false, lineHeight: 1, letterSpacing: 0, linkHandler: null, logLevel: "info", logger: null, scrollback: 1e3, scrollOnUserInput: true, scrollSensitivity: 1, screenReaderMode: false, smoothScrollDuration: 0, macOptionIsMeta: false, macOptionClickForcesSelection: false, minimumContrastRatio: 1, disableStdin: false, allowProposedApi: false, allowTransparency: false, tabStopWidth: 8, theme: {}, rescaleOverlappingGlyphs: false, rightClickSelectsWord: n.isMac, windowOptions: {}, windowsMode: false, windowsPty: {}, wordSeparator: " ()[]{}',\"`", altClickMovesCursor: true, convertEol: false, termName: "xterm", cancelEvents: false, overviewRulerWidth: 0 };
        const o = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"];
        class a extends r.Disposable {
          constructor(e3) {
            super(), this._onOptionChange = this.register(new s2.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
            const i3 = { ...t2.DEFAULT_OPTIONS };
            for (const t3 in e3) if (t3 in i3) try {
              const s3 = e3[t3];
              i3[t3] = this._sanitizeAndValidateOption(t3, s3);
            } catch (e4) {
              console.error(e4);
            }
            this.rawOptions = i3, this.options = { ...i3 }, this._setupOptions(), this.register((0, r.toDisposable)((() => {
              this.rawOptions.linkHandler = null, this.rawOptions.documentOverride = null;
            })));
          }
          onSpecificOptionChange(e3, t3) {
            return this.onOptionChange(((i3) => {
              i3 === e3 && t3(this.rawOptions[e3]);
            }));
          }
          onMultipleOptionChange(e3, t3) {
            return this.onOptionChange(((i3) => {
              -1 !== e3.indexOf(i3) && t3();
            }));
          }
          _setupOptions() {
            const e3 = (e4) => {
              if (!(e4 in t2.DEFAULT_OPTIONS)) throw new Error(`No option with key "${e4}"`);
              return this.rawOptions[e4];
            }, i3 = (e4, i4) => {
              if (!(e4 in t2.DEFAULT_OPTIONS)) throw new Error(`No option with key "${e4}"`);
              i4 = this._sanitizeAndValidateOption(e4, i4), this.rawOptions[e4] !== i4 && (this.rawOptions[e4] = i4, this._onOptionChange.fire(e4));
            };
            for (const t3 in this.rawOptions) {
              const s3 = { get: e3.bind(this, t3), set: i3.bind(this, t3) };
              Object.defineProperty(this.options, t3, s3);
            }
          }
          _sanitizeAndValidateOption(e3, i3) {
            switch (e3) {
              case "cursorStyle":
                if (i3 || (i3 = t2.DEFAULT_OPTIONS[e3]), !/* @__PURE__ */ (function(e4) {
                  return "block" === e4 || "underline" === e4 || "bar" === e4;
                })(i3)) throw new Error(`"${i3}" is not a valid value for ${e3}`);
                break;
              case "wordSeparator":
                i3 || (i3 = t2.DEFAULT_OPTIONS[e3]);
                break;
              case "fontWeight":
              case "fontWeightBold":
                if ("number" == typeof i3 && 1 <= i3 && i3 <= 1e3) break;
                i3 = o.includes(i3) ? i3 : t2.DEFAULT_OPTIONS[e3];
                break;
              case "cursorWidth":
                i3 = Math.floor(i3);
              case "lineHeight":
              case "tabStopWidth":
                if (i3 < 1) throw new Error(`${e3} cannot be less than 1, value: ${i3}`);
                break;
              case "minimumContrastRatio":
                i3 = Math.max(1, Math.min(21, Math.round(10 * i3) / 10));
                break;
              case "scrollback":
                if ((i3 = Math.min(i3, 4294967295)) < 0) throw new Error(`${e3} cannot be less than 0, value: ${i3}`);
                break;
              case "fastScrollSensitivity":
              case "scrollSensitivity":
                if (i3 <= 0) throw new Error(`${e3} cannot be less than or equal to 0, value: ${i3}`);
                break;
              case "rows":
              case "cols":
                if (!i3 && 0 !== i3) throw new Error(`${e3} must be numeric, value: ${i3}`);
                break;
              case "windowsPty":
                i3 = i3 ?? {};
            }
            return i3;
          }
        }
        t2.OptionsService = a;
      }, 2660: function(e2, t2, i2) {
        var s2 = this && this.__decorate || function(e3, t3, i3, s3) {
          var r2, n2 = arguments.length, o2 = n2 < 3 ? t3 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t3, i3) : s3;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t3, i3, s3);
          else for (var a = e3.length - 1; a >= 0; a--) (r2 = e3[a]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t3, i3, o2) : r2(t3, i3)) || o2);
          return n2 > 3 && o2 && Object.defineProperty(t3, i3, o2), o2;
        }, r = this && this.__param || function(e3, t3) {
          return function(i3, s3) {
            t3(i3, s3, e3);
          };
        };
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OscLinkService = void 0;
        const n = i2(2585);
        let o = t2.OscLinkService = class {
          constructor(e3) {
            this._bufferService = e3, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
          }
          registerLink(e3) {
            const t3 = this._bufferService.buffer;
            if (void 0 === e3.id) {
              const i4 = t3.addMarker(t3.ybase + t3.y), s4 = { data: e3, id: this._nextId++, lines: [i4] };
              return i4.onDispose((() => this._removeMarkerFromLink(s4, i4))), this._dataByLinkId.set(s4.id, s4), s4.id;
            }
            const i3 = e3, s3 = this._getEntryIdKey(i3), r2 = this._entriesWithId.get(s3);
            if (r2) return this.addLineToLink(r2.id, t3.ybase + t3.y), r2.id;
            const n2 = t3.addMarker(t3.ybase + t3.y), o2 = { id: this._nextId++, key: this._getEntryIdKey(i3), data: i3, lines: [n2] };
            return n2.onDispose((() => this._removeMarkerFromLink(o2, n2))), this._entriesWithId.set(o2.key, o2), this._dataByLinkId.set(o2.id, o2), o2.id;
          }
          addLineToLink(e3, t3) {
            const i3 = this._dataByLinkId.get(e3);
            if (i3 && i3.lines.every(((e4) => e4.line !== t3))) {
              const e4 = this._bufferService.buffer.addMarker(t3);
              i3.lines.push(e4), e4.onDispose((() => this._removeMarkerFromLink(i3, e4)));
            }
          }
          getLinkData(e3) {
            return this._dataByLinkId.get(e3)?.data;
          }
          _getEntryIdKey(e3) {
            return `${e3.id};;${e3.uri}`;
          }
          _removeMarkerFromLink(e3, t3) {
            const i3 = e3.lines.indexOf(t3);
            -1 !== i3 && (e3.lines.splice(i3, 1), 0 === e3.lines.length && (void 0 !== e3.data.id && this._entriesWithId.delete(e3.key), this._dataByLinkId.delete(e3.id)));
          }
        };
        t2.OscLinkService = o = s2([r(0, n.IBufferService)], o);
      }, 8343: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createDecorator = t2.getServiceDependencies = t2.serviceRegistry = void 0;
        const i2 = "di$target", s2 = "di$dependencies";
        t2.serviceRegistry = /* @__PURE__ */ new Map(), t2.getServiceDependencies = function(e3) {
          return e3[s2] || [];
        }, t2.createDecorator = function(e3) {
          if (t2.serviceRegistry.has(e3)) return t2.serviceRegistry.get(e3);
          const r = function(e4, t3, n) {
            if (3 !== arguments.length) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
            !(function(e5, t4, r2) {
              t4[i2] === t4 ? t4[s2].push({ id: e5, index: r2 }) : (t4[s2] = [{ id: e5, index: r2 }], t4[i2] = t4);
            })(r, e4, n);
          };
          return r.toString = () => e3, t2.serviceRegistry.set(e3, r), r;
        };
      }, 2585: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.IDecorationService = t2.IUnicodeService = t2.IOscLinkService = t2.IOptionsService = t2.ILogService = t2.LogLevelEnum = t2.IInstantiationService = t2.ICharsetService = t2.ICoreService = t2.ICoreMouseService = t2.IBufferService = void 0;
        const s2 = i2(8343);
        var r;
        t2.IBufferService = (0, s2.createDecorator)("BufferService"), t2.ICoreMouseService = (0, s2.createDecorator)("CoreMouseService"), t2.ICoreService = (0, s2.createDecorator)("CoreService"), t2.ICharsetService = (0, s2.createDecorator)("CharsetService"), t2.IInstantiationService = (0, s2.createDecorator)("InstantiationService"), (function(e3) {
          e3[e3.TRACE = 0] = "TRACE", e3[e3.DEBUG = 1] = "DEBUG", e3[e3.INFO = 2] = "INFO", e3[e3.WARN = 3] = "WARN", e3[e3.ERROR = 4] = "ERROR", e3[e3.OFF = 5] = "OFF";
        })(r || (t2.LogLevelEnum = r = {})), t2.ILogService = (0, s2.createDecorator)("LogService"), t2.IOptionsService = (0, s2.createDecorator)("OptionsService"), t2.IOscLinkService = (0, s2.createDecorator)("OscLinkService"), t2.IUnicodeService = (0, s2.createDecorator)("UnicodeService"), t2.IDecorationService = (0, s2.createDecorator)("DecorationService");
      }, 1480: (e2, t2, i2) => {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.UnicodeService = void 0;
        const s2 = i2(8460), r = i2(225);
        class n {
          static extractShouldJoin(e3) {
            return 0 != (1 & e3);
          }
          static extractWidth(e3) {
            return e3 >> 1 & 3;
          }
          static extractCharKind(e3) {
            return e3 >> 3;
          }
          static createPropertyValue(e3, t3, i3 = false) {
            return (16777215 & e3) << 3 | (3 & t3) << 1 | (i3 ? 1 : 0);
          }
          constructor() {
            this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new s2.EventEmitter(), this.onChange = this._onChange.event;
            const e3 = new r.UnicodeV6();
            this.register(e3), this._active = e3.version, this._activeProvider = e3;
          }
          dispose() {
            this._onChange.dispose();
          }
          get versions() {
            return Object.keys(this._providers);
          }
          get activeVersion() {
            return this._active;
          }
          set activeVersion(e3) {
            if (!this._providers[e3]) throw new Error(`unknown Unicode version "${e3}"`);
            this._active = e3, this._activeProvider = this._providers[e3], this._onChange.fire(e3);
          }
          register(e3) {
            this._providers[e3.version] = e3;
          }
          wcwidth(e3) {
            return this._activeProvider.wcwidth(e3);
          }
          getStringCellWidth(e3) {
            let t3 = 0, i3 = 0;
            const s3 = e3.length;
            for (let r2 = 0; r2 < s3; ++r2) {
              let o = e3.charCodeAt(r2);
              if (55296 <= o && o <= 56319) {
                if (++r2 >= s3) return t3 + this.wcwidth(o);
                const i4 = e3.charCodeAt(r2);
                56320 <= i4 && i4 <= 57343 ? o = 1024 * (o - 55296) + i4 - 56320 + 65536 : t3 += this.wcwidth(i4);
              }
              const a = this.charProperties(o, i3);
              let h = n.extractWidth(a);
              n.extractShouldJoin(a) && (h -= n.extractWidth(i3)), t3 += h, i3 = a;
            }
            return t3;
          }
          charProperties(e3, t3) {
            return this._activeProvider.charProperties(e3, t3);
          }
        }
        t2.UnicodeService = n;
      } }, t = {};
      function i(s2) {
        var r = t[s2];
        if (void 0 !== r) return r.exports;
        var n = t[s2] = { exports: {} };
        return e[s2].call(n.exports, n, n.exports, i), n.exports;
      }
      var s = {};
      return (() => {
        var e2 = s;
        Object.defineProperty(e2, "__esModule", { value: true }), e2.Terminal = void 0;
        const t2 = i(9042), r = i(3236), n = i(844), o = i(5741), a = i(8285), h = i(7975), c = i(7090), l = ["cols", "rows"];
        class d extends n.Disposable {
          constructor(e3) {
            super(), this._core = this.register(new r.Terminal(e3)), this._addonManager = this.register(new o.AddonManager()), this._publicOptions = { ...this._core.options };
            const t3 = (e4) => this._core.options[e4], i2 = (e4, t4) => {
              this._checkReadonlyOptions(e4), this._core.options[e4] = t4;
            };
            for (const e4 in this._core.options) {
              const s2 = { get: t3.bind(this, e4), set: i2.bind(this, e4) };
              Object.defineProperty(this._publicOptions, e4, s2);
            }
          }
          _checkReadonlyOptions(e3) {
            if (l.includes(e3)) throw new Error(`Option "${e3}" can only be set in the constructor`);
          }
          _checkProposedApi() {
            if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API");
          }
          get onBell() {
            return this._core.onBell;
          }
          get onBinary() {
            return this._core.onBinary;
          }
          get onCursorMove() {
            return this._core.onCursorMove;
          }
          get onData() {
            return this._core.onData;
          }
          get onKey() {
            return this._core.onKey;
          }
          get onLineFeed() {
            return this._core.onLineFeed;
          }
          get onRender() {
            return this._core.onRender;
          }
          get onResize() {
            return this._core.onResize;
          }
          get onScroll() {
            return this._core.onScroll;
          }
          get onSelectionChange() {
            return this._core.onSelectionChange;
          }
          get onTitleChange() {
            return this._core.onTitleChange;
          }
          get onWriteParsed() {
            return this._core.onWriteParsed;
          }
          get element() {
            return this._core.element;
          }
          get parser() {
            return this._parser || (this._parser = new h.ParserApi(this._core)), this._parser;
          }
          get unicode() {
            return this._checkProposedApi(), new c.UnicodeApi(this._core);
          }
          get textarea() {
            return this._core.textarea;
          }
          get rows() {
            return this._core.rows;
          }
          get cols() {
            return this._core.cols;
          }
          get buffer() {
            return this._buffer || (this._buffer = this.register(new a.BufferNamespaceApi(this._core))), this._buffer;
          }
          get markers() {
            return this._checkProposedApi(), this._core.markers;
          }
          get modes() {
            const e3 = this._core.coreService.decPrivateModes;
            let t3 = "none";
            switch (this._core.coreMouseService.activeProtocol) {
              case "X10":
                t3 = "x10";
                break;
              case "VT200":
                t3 = "vt200";
                break;
              case "DRAG":
                t3 = "drag";
                break;
              case "ANY":
                t3 = "any";
            }
            return { applicationCursorKeysMode: e3.applicationCursorKeys, applicationKeypadMode: e3.applicationKeypad, bracketedPasteMode: e3.bracketedPasteMode, insertMode: this._core.coreService.modes.insertMode, mouseTrackingMode: t3, originMode: e3.origin, reverseWraparoundMode: e3.reverseWraparound, sendFocusMode: e3.sendFocus, wraparoundMode: e3.wraparound };
          }
          get options() {
            return this._publicOptions;
          }
          set options(e3) {
            for (const t3 in e3) this._publicOptions[t3] = e3[t3];
          }
          blur() {
            this._core.blur();
          }
          focus() {
            this._core.focus();
          }
          input(e3, t3 = true) {
            this._core.input(e3, t3);
          }
          resize(e3, t3) {
            this._verifyIntegers(e3, t3), this._core.resize(e3, t3);
          }
          open(e3) {
            this._core.open(e3);
          }
          attachCustomKeyEventHandler(e3) {
            this._core.attachCustomKeyEventHandler(e3);
          }
          attachCustomWheelEventHandler(e3) {
            this._core.attachCustomWheelEventHandler(e3);
          }
          registerLinkProvider(e3) {
            return this._core.registerLinkProvider(e3);
          }
          registerCharacterJoiner(e3) {
            return this._checkProposedApi(), this._core.registerCharacterJoiner(e3);
          }
          deregisterCharacterJoiner(e3) {
            this._checkProposedApi(), this._core.deregisterCharacterJoiner(e3);
          }
          registerMarker(e3 = 0) {
            return this._verifyIntegers(e3), this._core.registerMarker(e3);
          }
          registerDecoration(e3) {
            return this._checkProposedApi(), this._verifyPositiveIntegers(e3.x ?? 0, e3.width ?? 0, e3.height ?? 0), this._core.registerDecoration(e3);
          }
          hasSelection() {
            return this._core.hasSelection();
          }
          select(e3, t3, i2) {
            this._verifyIntegers(e3, t3, i2), this._core.select(e3, t3, i2);
          }
          getSelection() {
            return this._core.getSelection();
          }
          getSelectionPosition() {
            return this._core.getSelectionPosition();
          }
          clearSelection() {
            this._core.clearSelection();
          }
          selectAll() {
            this._core.selectAll();
          }
          selectLines(e3, t3) {
            this._verifyIntegers(e3, t3), this._core.selectLines(e3, t3);
          }
          dispose() {
            super.dispose();
          }
          scrollLines(e3) {
            this._verifyIntegers(e3), this._core.scrollLines(e3);
          }
          scrollPages(e3) {
            this._verifyIntegers(e3), this._core.scrollPages(e3);
          }
          scrollToTop() {
            this._core.scrollToTop();
          }
          scrollToBottom() {
            this._core.scrollToBottom();
          }
          scrollToLine(e3) {
            this._verifyIntegers(e3), this._core.scrollToLine(e3);
          }
          clear() {
            this._core.clear();
          }
          write(e3, t3) {
            this._core.write(e3, t3);
          }
          writeln(e3, t3) {
            this._core.write(e3), this._core.write("\r\n", t3);
          }
          paste(e3) {
            this._core.paste(e3);
          }
          refresh(e3, t3) {
            this._verifyIntegers(e3, t3), this._core.refresh(e3, t3);
          }
          reset() {
            this._core.reset();
          }
          clearTextureAtlas() {
            this._core.clearTextureAtlas();
          }
          loadAddon(e3) {
            this._addonManager.loadAddon(this, e3);
          }
          static get strings() {
            return t2;
          }
          _verifyIntegers(...e3) {
            for (const t3 of e3) if (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0) throw new Error("This API only accepts integers");
          }
          _verifyPositiveIntegers(...e3) {
            for (const t3 of e3) if (t3 && (t3 === 1 / 0 || isNaN(t3) || t3 % 1 != 0 || t3 < 0)) throw new Error("This API only accepts positive integers");
          }
        }
        e2.Terminal = d;
      })(), s;
    })()));
  })(xterm$1);
  return xterm$1.exports;
}
var xtermExports = requireXterm();
class AddonManager {
  loadedAddons = /* @__PURE__ */ new Map();
  addonDisposables = /* @__PURE__ */ new Map();
  /**
   * Load addons into the terminal
   * Supports both constructor functions and instances
   */
  loadAddons(terminal, addons) {
    addons.forEach((addonDef, index) => {
      try {
        const addon = this.createAddonInstance(addonDef);
        const addonKey = this.getAddonKey(addon, index);
        terminal.loadAddon(addon);
        this.loadedAddons.set(addonKey, addon);
        if ("dispose" in addon && typeof addon.dispose === "function") {
          this.addonDisposables.set(addonKey, () => addon.dispose());
        }
      } catch (error) {
        console.error(`Failed to load addon at index ${index}:`, error);
      }
    });
  }
  /**
   * Get a loaded addon by its constructor name or index
   */
  getAddon(addonConstructor) {
    const addonName = addonConstructor.name;
    for (const [key, addon] of this.loadedAddons) {
      if (key.startsWith(addonName) || addon.constructor.name === addonName) {
        return addon;
      }
    }
    return void 0;
  }
  /**
   * Check if a specific addon type is loaded
   */
  hasAddon(addonConstructor) {
    return this.getAddon(addonConstructor) !== void 0;
  }
  /**
   * Get all loaded addons
   */
  getAllAddons() {
    return Array.from(this.loadedAddons.values());
  }
  /**
   * Clean up all loaded addons
   */
  dispose() {
    this.addonDisposables.forEach((dispose2) => {
      try {
        dispose2();
      } catch (error) {
        console.error("Error disposing addon:", error);
      }
    });
    this.loadedAddons.clear();
    this.addonDisposables.clear();
  }
  createAddonInstance(addonDef) {
    if (typeof addonDef === "function") {
      return new addonDef();
    }
    if (typeof addonDef === "object" && "addon" in addonDef) {
      const { addon, args = [] } = addonDef;
      if (typeof addon === "function") {
        return new addon(
          ...args
        );
      }
      return addon;
    }
    return addonDef;
  }
  getAddonKey(addon, index) {
    const name = addon.constructor.name || "UnknownAddon";
    return `${name}-${index}`;
  }
}
class EventManager {
  disposables = [];
  /**
   * Set up all event listeners on the terminal
   * Uses a single consolidated approach instead of multiple createEffect calls
   */
  setupEventListeners(terminal, handlers) {
    if (handlers.onBell) {
      this.addDisposable(
        terminal.onBell(() => {
          handlers.onBell?.();
        })
      );
    }
    if (handlers.onBinary) {
      this.addDisposable(
        terminal.onBinary((data) => {
          handlers.onBinary?.(data);
        })
      );
    }
    if (handlers.onCursorMove) {
      this.addDisposable(
        terminal.onCursorMove(() => {
          const buffer = terminal.buffer.active;
          const position = { x: buffer.cursorX, y: buffer.cursorY };
          handlers.onCursorMove?.(position);
        })
      );
    }
    if (handlers.onData) {
      this.addDisposable(
        terminal.onData((data) => {
          handlers.onData?.(data);
        })
      );
    }
    if (handlers.onKey) {
      this.addDisposable(
        terminal.onKey((event) => {
          handlers.onKey?.(event);
        })
      );
    }
    if (handlers.onLineFeed) {
      this.addDisposable(
        terminal.onLineFeed(() => {
          handlers.onLineFeed?.();
        })
      );
    }
    if (handlers.onRender) {
      this.addDisposable(
        terminal.onRender((event) => {
          handlers.onRender?.(event);
        })
      );
    }
    if (handlers.onResize) {
      this.addDisposable(
        terminal.onResize((size) => {
          handlers.onResize?.(size);
        })
      );
    }
    if (handlers.onScroll) {
      this.addDisposable(
        terminal.onScroll((yPos) => {
          handlers.onScroll?.(yPos);
        })
      );
    }
    if (handlers.onSelectionChange) {
      this.addDisposable(
        terminal.onSelectionChange(() => {
          handlers.onSelectionChange?.();
        })
      );
    }
    if (handlers.onTitleChange) {
      this.addDisposable(
        terminal.onTitleChange((title) => {
          handlers.onTitleChange?.(title);
        })
      );
    }
    if (handlers.onWriteParsed) {
      this.addDisposable(
        terminal.onWriteParsed(() => {
          handlers.onWriteParsed?.();
        })
      );
    }
  }
  /**
   * Update event handlers when props change
   * Only updates changed handlers to avoid unnecessary disposals
   */
  updateEventHandlers(terminal, newHandlers, _prevHandlers) {
    this.dispose();
    this.setupEventListeners(terminal, newHandlers);
  }
  /**
   * Add a disposable to our cleanup list
   */
  addDisposable(disposable) {
    this.disposables.push(disposable);
  }
  /**
   * Clean up all event listeners
   */
  dispose() {
    this.disposables.forEach((disposable) => {
      try {
        disposable.dispose();
      } catch (error) {
        console.error("Error disposing event listener:", error);
      }
    });
    this.disposables = [];
  }
}
var _tmpl$$6 = /* @__PURE__ */ template(`<div>`);
let stylesLoaded = false;
const loadDefaultStyles = () => {
  if (!stylesLoaded) {
    __vitePreload(() => Promise.resolve().then(() => xterm), true ? void 0 : void 0, import.meta.url);
    stylesLoaded = true;
  }
};
function XTerm(props) {
  const [terminal, setTerminal] = createSignal();
  const [containerRef, setContainerRef] = createSignal();
  let addonManager;
  let eventManager;
  let mountCleanup;
  const createTerminalRef = (term) => ({
    get terminal() {
      return term;
    },
    write: (data) => term.write(data),
    writeln: (data) => term.writeln(data),
    clear: () => term.clear(),
    reset: () => term.reset(),
    focus: () => term.focus(),
    blur: () => term.blur(),
    scrollToTop: () => term.scrollToTop(),
    scrollToBottom: () => term.scrollToBottom(),
    scrollToLine: (line) => term.scrollToLine(line),
    select: (col, row, length) => term.select(col, row, length),
    selectAll: () => term.selectAll(),
    selectLines: (start, end) => term.selectLines(start, end),
    clearSelection: () => term.clearSelection(),
    getSelection: () => term.getSelection(),
    hasSelection: () => term.hasSelection(),
    resize: (cols, rows) => term.resize(cols, rows),
    // Addon-specific methods (available only if addons are loaded)
    fit: () => {
      const addons = addonManager?.getAllAddons() || [];
      const fitAddon = addons.find((addon) => addon && addon.constructor.name === "FitAddon" && typeof addon.fit === "function");
      if (fitAddon) {
        fitAddon.fit();
      }
    },
    findNext: (term2) => {
      const searchAddon = addonManager?.getAddon(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        globalThis.SearchAddon || class SearchAddon {
          findNext() {
            return false;
          }
        }
      );
      if (searchAddon && "findNext" in searchAddon) {
        return searchAddon.findNext(term2);
      }
      return false;
    },
    findPrevious: (term2) => {
      const searchAddon = addonManager?.getAddon(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        globalThis.SearchAddon || class SearchAddon {
          findPrevious() {
            return false;
          }
        }
      );
      if (searchAddon && "findPrevious" in searchAddon) {
        return searchAddon.findPrevious(term2);
      }
      return false;
    }
  });
  createEffect(() => {
    const container = containerRef();
    if (!container) return;
    if (props.loadDefaultStyles !== false) {
      loadDefaultStyles();
    }
    const term = new xtermExports.Terminal(props.options);
    addonManager = new AddonManager();
    eventManager = new EventManager();
    if (props.addons && props.addons.length > 0) {
      addonManager.loadAddons(term, props.addons);
    }
    term.open(container);
    const eventHandlers = {};
    if (props.onBell) eventHandlers.onBell = props.onBell;
    if (props.onBinary) eventHandlers.onBinary = props.onBinary;
    if (props.onCursorMove) eventHandlers.onCursorMove = props.onCursorMove;
    if (props.onData) eventHandlers.onData = props.onData;
    if (props.onKey) eventHandlers.onKey = props.onKey;
    if (props.onLineFeed) eventHandlers.onLineFeed = props.onLineFeed;
    if (props.onRender) eventHandlers.onRender = props.onRender;
    if (props.onResize) eventHandlers.onResize = props.onResize;
    if (props.onScroll) eventHandlers.onScroll = props.onScroll;
    if (props.onSelectionChange) eventHandlers.onSelectionChange = props.onSelectionChange;
    if (props.onTitleChange) eventHandlers.onTitleChange = props.onTitleChange;
    if (props.onWriteParsed) eventHandlers.onWriteParsed = props.onWriteParsed;
    eventManager.setupEventListeners(term, eventHandlers);
    const terminalRef = createTerminalRef(term);
    if (props.onMount) {
      const cleanup = props.onMount(term, terminalRef);
      if (typeof cleanup === "function") {
        mountCleanup = cleanup;
      }
    }
    if (props.ref) {
      props.ref(terminalRef);
    }
    if (props.autoFocus) {
      setTimeout(() => term.focus(), 0);
    }
    setTerminal(term);
  });
  createEffect((prevHandlers) => {
    const term = terminal();
    if (!term || !eventManager) return;
    const currentHandlers = {};
    if (props.onBell) currentHandlers.onBell = props.onBell;
    if (props.onBinary) currentHandlers.onBinary = props.onBinary;
    if (props.onCursorMove) currentHandlers.onCursorMove = props.onCursorMove;
    if (props.onData) currentHandlers.onData = props.onData;
    if (props.onKey) currentHandlers.onKey = props.onKey;
    if (props.onLineFeed) currentHandlers.onLineFeed = props.onLineFeed;
    if (props.onRender) currentHandlers.onRender = props.onRender;
    if (props.onResize) currentHandlers.onResize = props.onResize;
    if (props.onScroll) currentHandlers.onScroll = props.onScroll;
    if (props.onSelectionChange) currentHandlers.onSelectionChange = props.onSelectionChange;
    if (props.onTitleChange) currentHandlers.onTitleChange = props.onTitleChange;
    if (props.onWriteParsed) currentHandlers.onWriteParsed = props.onWriteParsed;
    if (JSON.stringify(currentHandlers) !== JSON.stringify(prevHandlers)) {
      eventManager.updateEventHandlers(term, currentHandlers, prevHandlers);
    }
    return currentHandlers;
  });
  onCleanup(() => {
    const term = terminal();
    if (props.onUnmount && term) {
      props.onUnmount(term);
    }
    if (mountCleanup) {
      mountCleanup();
      mountCleanup = void 0;
    }
    if (eventManager) {
      eventManager.dispose();
    }
    if (addonManager) {
      addonManager.dispose();
    }
    if (term) {
      term.dispose();
    }
  });
  return (() => {
    var _el$ = _tmpl$$6();
    use(setContainerRef, _el$);
    createRenderEffect((_p$) => {
      var _v$ = props.class || "xterm-container", _v$2 = {
        width: "100%",
        height: "100%",
        ...props.style
      };
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _p$.t = style(_el$, _v$2, _p$.t);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$;
  })();
}
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
  lookup$1[chars.charCodeAt(i)] = i;
}
const decode$1 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1[base64.charCodeAt(i)];
    encoded2 = lookup$1[base64.charCodeAt(i + 1)];
    encoded3 = lookup$1[base64.charCodeAt(i + 2)];
    encoded4 = lookup$1[base64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$1(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i = 0; i < encodedPackets.length; i++) {
    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j = 0;
  for (let i = 0; i < size; i++) {
    buffer[i] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state2 = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state2 === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state2 = 3;
          } else if (expectedLength === 126) {
            state2 = 1;
          } else {
            state2 = 2;
          }
        } else if (state2 === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state2 = 3;
        } else if (state2 === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state2 = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state2 = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
const defaultBinaryType = "arraybuffer";
function createCookieJar() {
}
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 128) {
      length += 1;
    } else if (c < 2048) {
      length += 2;
    } else if (c < 55296 || c >= 57344) {
      length += 3;
    } else {
      i++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function encode(obj) {
  let str = "";
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i = 0, l = pairs.length; i < l; i++) {
    let pair = pairs[i].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}
class Polling extends Transport {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
const hasCORS = value;
function empty() {
}
class BaseXHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts.data ? opts.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i)) {
              xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a2;
        if (xhr.readyState === 3) {
          (_a2 = this._opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this._onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = Request.requestsCount++;
      Request.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
const hasXHR2 = (function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
})();
class XHR extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request(newRequest, this.uri(), opts);
  }
}
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {
      };
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
class WS extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b2 = str.indexOf("["), e = str.indexOf("]");
  if (b2 != -1 && e != -1) {
    str = str.substring(0, b2) + str.substring(b2, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || "";
  }
  if (b2 != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
const withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}
class SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t) => {
      const transportName = t.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$1;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new this._transportsByName[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const data = this.writeBuffer[i].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err) {
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol$1;
class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i = 0; i < this._upgrades.length; i++) {
        this._probe(this._upgrades[i]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i = 0; i < upgrades.length; i++) {
      if (~this.transports.indexOf(upgrades[i]))
        filteredUpgrades.push(upgrades[i]);
    }
    return filteredUpgrades;
  }
}
let Socket$1 = class Socket extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o = typeof uri === "object" ? uri : opts;
    if (!o.transports || o.transports && typeof o.transports[0] === "string") {
      o.transports = (o.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t) => !!t);
    }
    super(uri, o);
  }
};
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i = 0;
    const p = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p.type] === void 0) {
      throw new Error("unknown packet type " + p.type);
    }
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const start = i + 1;
      while (str.charAt(++i) !== "-" && i != str.length) {
      }
      const buf = str.substring(start, i);
      if (buf != Number(buf) || str.charAt(i) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf);
    }
    if ("/" === str.charAt(i + 1)) {
      const start = i + 1;
      while (++i) {
        const c = str.charAt(i);
        if ("," === c)
          break;
        if (i === str.length)
          break;
      }
      p.nsp = str.substring(start, i);
    } else {
      p.nsp = "/";
    }
    const next = str.charAt(i + 1);
    if ("" !== next && Number(next) == next) {
      const start = i + 1;
      while (++i) {
        const c = str.charAt(i);
        if (null == c || Number(c) != c) {
          --i;
          break;
        }
        if (i === str.length)
          break;
      }
      p.id = Number(str.substring(start, i + 1));
    }
    if (str.charAt(++i)) {
      const payload = this.tryParse(str.substr(i));
      if (Decoder.isPayloadValid(p.type, payload)) {
        p.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a, _b, _c;
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
    const isConnected2 = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) ;
    else if (isConnected2) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a;
    const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i = 0; i < this.sendBuffer.length; i++) {
        if (this.sendBuffer[i].id === id) {
          this.sendBuffer.splice(i, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn.withError = true;
    this.acks[id] = fn;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn.withError = true;
      args.push(fn);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
      if (!isBuffered) {
        const ack = this.acks[id];
        delete this.acks[id];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms2);
    ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
  }
  return Math.min(ms2, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    if (!v) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket2 = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket2, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket2, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket2.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket2 = this.engine;
    this.subs.push(
      on(socket2, "ping", this.onping.bind(this)),
      on(socket2, "data", this.ondata.bind(this)),
      on(socket2, "error", this.onerror.bind(this)),
      on(socket2, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket2 = this.nsps[nsp];
    if (!socket2) {
      socket2 = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket2;
    } else if (this._autoConnect && !socket2.active) {
      socket2.connect();
    }
    return socket2;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket2) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket3 = this.nsps[nsp];
      if (socket3.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i = 0; i < encodedPackets.length; i++) {
      this.engine.write(encodedPackets[i], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a;
    this.cleanup();
    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager,
  Socket: Socket2,
  io: lookup,
  connect: lookup
});
const debug$6 = createDebug("webssh2-client:socket-service");
const [socket, setSocket] = createSignal(null);
const [isConnected, setIsConnected] = createSignal(false);
const [connectionStatus, setConnectionStatus] = createSignal("Disconnected");
const [connectionStatusColor, setConnectionStatusColor] = createSignal("red");
let config = null;
let writeToTerminal = null;
let onConnectCallback = null;
let onDisconnectCallback = null;
let onDataCallback = null;
let focusTerminalCallback = null;
let storedFormData = null;
const [terminalDimensions, setTerminalDimensions] = createSignal({ cols: 80, rows: 24 });
class SocketService {
  cleanupFunctions = [];
  // Reactive effects will be set up when the service is initialized within a component
  // This should be called from within a SolidJS component
  setupReactiveEffects() {
    createEffect(() => {
      const dims = terminalDimensions();
      const currentSocket = socket();
      if (currentSocket && isConnected() && dims.cols > 0 && dims.rows > 0) {
        this.emitResize(dims);
      }
    });
    createEffect(() => {
      const status = connectionStatus();
      const color = connectionStatusColor();
      this.updateStatusElement(status, color);
    });
  }
  // Initialize socket with configuration
  initSocket(configObj, connectCallback, disconnectCallback, dataCallback, writeFunction, focusCallback) {
    config = configObj;
    onConnectCallback = connectCallback;
    onDisconnectCallback = disconnectCallback;
    onDataCallback = dataCallback;
    writeToTerminal = writeFunction;
    focusTerminalCallback = focusCallback;
    debug$6("Socket service initialized");
  }
  // Set form data for authentication
  setFormData(formData) {
    storedFormData = formData;
    debug$6("Form data stored", { port: formData.port });
  }
  // Initialize socket connection
  initializeSocketConnection() {
    debug$6("Initializing socket connection");
    this.closeConnection();
    const newSocket = lookup(this.getWebSocketUrl(), {
      path: this.getSocketIOPath(),
      withCredentials: true,
      reconnection: false,
      timeout: 2e4,
      transports: ["websocket", "polling"]
    });
    setSocket(newSocket);
    this.setupSocketListeners(newSocket);
    return newSocket;
  }
  // Close connection
  closeConnection() {
    const currentSocket = socket();
    if (currentSocket) {
      debug$6("Closing connection");
      currentSocket.close();
      setSocket(null);
      setIsConnected(false);
    }
  }
  // Emit data to server
  emitData(data) {
    const currentSocket = socket();
    if (currentSocket) {
      currentSocket.emit("data", data);
    }
  }
  // Emit resize event
  emitResize(dimensions) {
    const currentSocket = socket();
    if (currentSocket) {
      currentSocket.emit("resize", dimensions);
      debug$6("Resize emitted", dimensions);
    }
  }
  // Reauthenticate
  reauth() {
    if (state.allowReauth) {
      const currentSocket = socket();
      if (currentSocket) {
        debug$6("Reauthenticating");
        currentSocket.emit("control", "reauth");
      }
    } else {
      console.warn("Reauthentication not permitted");
      setErrorMessage("Reauthentication not permitted");
      setIsErrorDialogOpen(true);
    }
  }
  // Replay credentials
  replayCredentials() {
    if (state.allowReplay) {
      const currentSocket = socket();
      if (currentSocket) {
        debug$6("Replaying credentials");
        currentSocket.emit("control", "replayCredentials");
      }
    } else {
      console.warn("Credential replay not permitted");
      setErrorMessage("Credential replay not permitted");
      setIsErrorDialogOpen(true);
    }
  }
  // Handle keyboard-interactive prompt responses
  submitPromptResponses(responses) {
    const currentSocket = socket();
    if (currentSocket) {
      debug$6("Submitting prompt responses", responses.length);
      currentSocket.emit("data", responses.join("\n"));
      setPromptData(null);
    }
  }
  // Private methods
  getSocketIOPath() {
    return config?.socket?.path || "/ssh/socket.io";
  }
  getWebSocketUrl() {
    if (config?.socket?.url) {
      const url2 = new URL(config.socket.url);
      url2.protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      return url2.toString();
    }
    const protocol2 = window.location.protocol === "https:" ? "wss:" : "ws:";
    const host = window.location.hostname;
    const port = window.location.port || (protocol2 === "wss:" ? "443" : "80");
    return `${protocol2}//${host}:${port}`;
  }
  authenticate(formData = null) {
    const dims = terminalDimensions();
    const effectiveFormData = formData || storedFormData;
    const credentials = getCredentials(
      effectiveFormData,
      dims
    );
    if (effectiveFormData?.privateKey) {
      credentials.privateKey = effectiveFormData.privateKey;
      if (effectiveFormData.passphrase) {
        credentials.passphrase = effectiveFormData.passphrase;
      }
    }
    setState("term", credentials.term ?? null);
    const maskedContent = P(credentials);
    debug$6("Authenticating", maskedContent);
    const currentSocket = socket();
    if (credentials.host && credentials.username && currentSocket) {
      currentSocket.emit("authenticate", credentials);
      setConnectionStatus("Authenticating...");
      setConnectionStatusColor("orange");
    } else if (onDisconnectCallback) {
      onDisconnectCallback("auth_required");
    }
  }
  getTerminal() {
    const dims = terminalDimensions();
    const term = state.term ?? "xterm-color";
    const terminal = { cols: dims.cols ?? 0, rows: dims.rows ?? 0, term };
    debug$6("Getting terminal", terminal);
    const currentSocket = socket();
    if (currentSocket) currentSocket.emit("terminal", terminal);
  }
  updateStatusElement(status, color) {
    setConnectionStatus(status);
    setConnectionStatusColor(color);
  }
  // Socket event handlers
  setupSocketListeners(socketInstance) {
    debug$6("Setting up socket listeners");
    socketInstance.on("authentication", (data) => {
      debug$6("Authentication event", data);
      switch (data.action) {
        case "request_auth":
          this.authenticate();
          setConnectionStatus("Requesting authentication...");
          setConnectionStatusColor("orange");
          break;
        case "auth_result":
          this.handleAuthResult({
            success: Boolean(data.success),
            ...data.message && { message: data.message }
          });
          break;
        case "keyboard-interactive":
          if ("prompts" in data && data.prompts) {
            this.handleKeyboardInteractive({
              prompts: data.prompts,
              ..."name" in data && data.name ? { name: data.name } : {}
            });
          }
          break;
        case "reauth":
          if (onDisconnectCallback)
            onDisconnectCallback("reauth_required", socketInstance);
          break;
        case "dimensions":
          this.emitResize(terminalDimensions());
          break;
        default:
          debug$6(`Unhandled authentication action: ${data.action}`);
          break;
      }
    });
    socketInstance.on("permissions", (payload) => {
      debug$6("Permissions", payload);
      Object.entries(payload).forEach(([key, value2]) => {
        switch (key) {
          case "allowReauth": {
            setState("allowReauth", Boolean(value2));
            break;
          }
          case "allowReconnect": {
            setState("allowReconnect", Boolean(value2));
            break;
          }
          case "allowReplay": {
            setState("allowReplay", Boolean(value2));
            break;
          }
          default: {
            debug$6(`Unhandled permission key: ${key}`);
            break;
          }
        }
      });
    });
    socketInstance.on("getTerminal", () => this.getTerminal());
    socketInstance.on("data", (chunk) => {
      if (writeToTerminal) writeToTerminal(chunk);
      if (onDataCallback) onDataCallback(chunk);
    });
    socketInstance.on("ssherror", (msg) => {
      debug$6("SSH Error", msg);
      if (onDisconnectCallback) onDisconnectCallback("ssh_error", msg);
    });
    socketInstance.on("connect", () => {
      debug$6("Connected to server");
      setState("isConnecting", false);
      setIsConnected(true);
      setConnectionStatus("Connected");
      setConnectionStatusColor("green");
      if (onConnectCallback) onConnectCallback();
    });
    socketInstance.on("connect_error", (error) => {
      debug$6("Connection error", error);
      setIsConnected(false);
      if (onDisconnectCallback) onDisconnectCallback("connect_error", error);
    });
    socketInstance.on("disconnect", (reason) => {
      debug$6("Disconnected", reason);
      setState("isConnecting", false);
      setIsConnected(false);
      setConnectionStatus(`WEBSOCKET SERVER DISCONNECTED: ${reason}`);
      setConnectionStatusColor("red");
      if (onDisconnectCallback) onDisconnectCallback(reason);
    });
    socketInstance.on("updateUI", (data) => {
      debug$6("UI Update", data);
      const { element, value: value2 } = data;
      if (!element || value2 === void 0 || value2 === null) {
        console.warn(
          "updateUI: Received invalid data from updateUI event:",
          data
        );
        return;
      }
      switch (element) {
        case "footer": {
          const footerValue = typeof value2 === "object" && value2 !== null && "text" in value2 ? value2.text : String(value2);
          setSessionFooter$1(footerValue);
          break;
        }
        case "status":
          this.updateStatusElement(String(value2), "green");
          break;
        case "header":
          if (typeof value2 === "object" && value2 !== null) {
            const headerData = value2;
            setHeaderContent({
              text: headerData.text,
              background: headerData.background || "transparent"
            });
          } else {
            setHeaderContent({
              text: String(value2),
              background: "transparent"
            });
          }
          break;
        default:
          debug$6(`Unknown element update: ${element}`, value2);
          break;
      }
    });
  }
  handleAuthResult(result) {
    debug$6("Auth result", result);
    setState("isConnecting", false);
    if (result.success) {
      setConnectionStatus("Connected");
      setConnectionStatusColor("green");
      if (focusTerminalCallback) focusTerminalCallback();
    } else {
      setConnectionStatus(`Authentication failed: ${result.message ?? ""}`);
      setConnectionStatusColor("red");
      if (onDisconnectCallback)
        onDisconnectCallback("auth_failed", result.message);
    }
  }
  handleKeyboardInteractive(data) {
    debug$6("Keyboard interactive authentication", data);
    setPromptData({
      title: data.name || "Authentication Required",
      prompts: data.prompts
    });
  }
}
const socketService = new SocketService();
const emitData = (data) => socketService.emitData(data);
const emitResize = (dimensions) => socketService.emitResize(dimensions);
const submitPromptResponses = (responses) => socketService.submitPromptResponses(responses);
const debug$5 = createDebug("webssh2-client:settings");
const STORAGE_KEY = "webssh2.settings.global";
function getStoredSettings() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (raw) {
    try {
      const parsed = JSON.parse(raw);
      debug$5("getStoredSettings", parsed);
      return parsed;
    } catch (error) {
      console.error("getStoredSettings: Error parsing stored settings:", error);
    }
  }
  return {};
}
function saveTerminalSettings(settings) {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    debug$5("saveTerminalSettings", settings);
  } catch (error) {
    console.error("saveTerminalSettings", error);
  }
}
const debug$4 = createDebug("webssh2-client:terminal-component");
const TerminalComponent = (props) => {
  const [terminalRef, setTerminalRef] = createSignal();
  let fitAddonInstance = null;
  const getTerminalOptions = () => {
    debug$4("getTerminalOptions");
    const storedSettings = getStoredSettings();
    const terminalConfig = props.config?.terminal ?? {};
    const mergedOptions = {
      cursorBlink: storedSettings.cursorBlink ?? terminalConfig.cursorBlink ?? defaultSettings.cursorBlink,
      scrollback: validateNumber(storedSettings.scrollback ?? terminalConfig.scrollback, 1, 2e5, defaultSettings.scrollback),
      tabStopWidth: validateNumber(storedSettings.tabStopWidth ?? terminalConfig.tabStopWidth, 1, 100, defaultSettings.tabStopWidth),
      fontSize: validateNumber(storedSettings.fontSize ?? terminalConfig.fontSize, 1, 72, defaultSettings.fontSize),
      fontFamily: String(storedSettings.fontFamily ?? terminalConfig.fontFamily ?? defaultSettings.fontFamily),
      letterSpacing: storedSettings.letterSpacing ?? terminalConfig.letterSpacing ?? defaultSettings.letterSpacing,
      lineHeight: storedSettings.lineHeight ?? terminalConfig.lineHeight ?? defaultSettings.lineHeight
    };
    debug$4("getTerminalOptions", mergedOptions);
    return mergedOptions;
  };
  const handleTerminalData = (data) => {
    emitData(data);
  };
  const handleTitleChange = (title) => {
    document.title = title;
  };
  const handleTerminalMount = (terminal, ref) => {
    debug$4("Terminal mounted");
    setTerminalRef(ref);
    fitAddonInstance = new addonFitExports.FitAddon();
    terminal.loadAddon(fitAddonInstance);
    const fitTerminal = () => {
      if (fitAddonInstance && ref.terminal) {
        fitAddonInstance.fit();
        const dims = {
          cols: ref.terminal.cols,
          rows: ref.terminal.rows
        };
        debug$4("Terminal fitted, dimensions:", dims.cols, "x", dims.rows);
        if (props.onTerminalReady) {
          props.onTerminalReady(ref);
        }
      }
    };
    terminalManager.setTerminalRef(ref, fitAddonInstance);
    fitTerminal();
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined" && ref.terminal) {
      const container = ref.terminal.element?.parentElement;
      if (container) {
        resizeObserver = new ResizeObserver(() => {
          fitTerminal();
        });
        resizeObserver.observe(container);
      }
    }
    const handleWindowResize = () => {
      fitTerminal();
    };
    window.addEventListener("resize", handleWindowResize);
    onCleanup(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      window.removeEventListener("resize", handleWindowResize);
      debug$4("Terminal resize handlers cleaned up");
    });
    if (props.onTerminalReady) {
      props.onTerminalReady(ref);
    }
  };
  const terminalOptions = getTerminalOptions();
  const xtermProps = {
    options: terminalOptions,
    addons: [],
    // We load FitAddon directly in handleTerminalMount
    onData: handleTerminalData,
    onTitleChange: handleTitleChange,
    onMount: handleTerminalMount,
    class: props.class || "terminal-container",
    style: {
      width: "100%",
      height: "100%"
    },
    autoFocus: true
  };
  return createComponent(XTerm, xtermProps);
};
class SolidTerminalManager {
  terminalRef = null;
  fitAddon = null;
  setTerminalRef(ref, fitAddon) {
    this.terminalRef = ref;
    if (fitAddon) {
      this.fitAddon = fitAddon;
    }
  }
  writeToTerminal(data) {
    if (this.terminalRef) {
      this.terminalRef.write(data);
    }
  }
  resetTerminal() {
    debug$4("resetTerminal");
    if (this.terminalRef) {
      this.terminalRef.reset();
    }
  }
  resizeTerminal() {
    if (this.terminalRef && this.terminalRef.terminal && this.fitAddon) {
      this.fitAddon.fit();
      const dimensions = {
        cols: this.terminalRef.terminal.cols,
        rows: this.terminalRef.terminal.rows
      };
      debug$4("resizeTerminal", dimensions);
      emitResize(dimensions);
      return dimensions;
    }
    return null;
  }
  focusTerminal() {
    if (this.terminalRef) {
      this.terminalRef.focus();
    }
  }
  getTerminalDimensions() {
    if (this.terminalRef && this.terminalRef.terminal) {
      const {
        cols,
        rows
      } = this.terminalRef.terminal;
      debug$4("getTerminalDimensions", {
        cols,
        rows
      });
      return {
        cols,
        rows
      };
    }
    console.error("getTerminalDimensions: Terminal not initialized");
    return {
      cols: 0,
      rows: 0
    };
  }
  updateTerminalSettings(newOptions) {
    if (this.terminalRef && this.terminalRef.terminal) {
      Object.assign(this.terminalRef.terminal.options, newOptions);
      this.terminalRef.fit();
      debug$4("updateTerminalSettings", newOptions);
    }
  }
  applyTerminalSettings(options) {
    if (!this.terminalRef || !this.terminalRef.terminal) {
      console.error("applyTerminalSettings: Terminal not initialized");
      return;
    }
    debug$4("applyTerminalSettings", options);
    const terminalSettings = {
      cursorBlink: options.cursorBlink ?? defaultSettings.cursorBlink,
      scrollback: validateNumber(options.scrollback, 1, 2e5, defaultSettings.scrollback),
      tabStopWidth: validateNumber(options.tabStopWidth, 1, 100, defaultSettings.tabStopWidth),
      fontSize: validateNumber(options.fontSize, 1, 72, defaultSettings.fontSize),
      fontFamily: String(options.fontFamily ?? defaultSettings.fontFamily),
      letterSpacing: options.letterSpacing ?? defaultSettings.letterSpacing,
      lineHeight: options.lineHeight ?? defaultSettings.lineHeight
    };
    Object.assign(this.terminalRef.terminal.options, terminalSettings);
    this.terminalRef.fit();
  }
  getTerminalInstance() {
    return this.terminalRef?.terminal || null;
  }
}
const terminalManager = new SolidTerminalManager();
var _tmpl$$5 = /* @__PURE__ */ template(`<button type=button class="close-button absolute top-2 right-2 text-neutral-400 hover:text-neutral-600 text-xl leading-none p-0 bg-transparent border-0"aria-label=Close>&times;`), _tmpl$2$3 = /* @__PURE__ */ template(`<dialog><div class=modal-content>`), _tmpl$3$3 = /* @__PURE__ */ template(`<div class="relative error-modal bg-red-50 border border-red-400 rounded-md shadow-md p-5 w-80 sm:w-96"><h2 class="text-red-700 text-lg font-semibold mb-3">Error</h2><p class="text-red-600 mb-4"></p><div class="flex justify-end"><button type=button class="inline-flex items-center justify-center rounded-md border border-transparent px-3 py-2 text-sm font-medium bg-red-600 text-white hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"autofocus>Close`), _tmpl$4$3 = /* @__PURE__ */ template(`<div class="relative prompt-modal bg-white text-slate-800 border border-neutral-300 rounded-md shadow-md p-5 w-80 sm:w-96"><h2 class="text-lg font-semibold text-slate-900 mb-4"></h2><form><div class="mb-4 space-y-3"></div><div class="flex gap-2 justify-end"><button type=button class="inline-flex items-center justify-center rounded-md border border-transparent px-3 py-2 text-sm font-medium bg-slate-700 text-white hover:bg-slate-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500">Cancel</button><button type=submit class="inline-flex items-center justify-center rounded-md border border-transparent px-3 py-2 text-sm font-medium bg-blue-600 text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Submit`), _tmpl$5$3 = /* @__PURE__ */ template(`<div><label class="block text-sm font-medium text-slate-700 mb-1"></label><input class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"required>`);
const debug$3 = createDebug("webssh2-client:modal");
const Modal = (props) => {
  let dialogRef;
  createEffect(() => {
    debug$3("Modal createEffect triggered:", {
      isOpen: props.isOpen,
      hasDialog: !!dialogRef
    });
    if (props.isOpen) {
      const openDialog = () => {
        if (dialogRef) {
          debug$3("Opening modal dialog");
          dialogRef.showModal();
          const focusableElements = dialogRef.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
          const firstElement = focusableElements[0];
          if (firstElement) {
            setTimeout(() => firstElement.focus(), 50);
          }
        } else {
          setTimeout(openDialog, 10);
        }
      };
      setTimeout(openDialog, 0);
    } else if (dialogRef) {
      debug$3("Closing modal dialog");
      dialogRef.close();
    }
  });
  const handleKeyDown = (e) => {
    if (e.key === "Escape" && props.isOpen) {
      props.onClose();
    }
  };
  const handleDialogClick = (e) => {
    const rect = dialogRef?.getBoundingClientRect();
    if (rect && props.closeOnBackdropClick !== false && (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom)) {
      props.onClose();
    }
  };
  onMount(() => {
    document.addEventListener("keydown", handleKeyDown);
  });
  onCleanup(() => {
    document.removeEventListener("keydown", handleKeyDown);
  });
  return createComponent(Portal, {
    get children() {
      return createComponent(Show, {
        get when() {
          return props.isOpen;
        },
        get children() {
          var _el$ = _tmpl$2$3(), _el$2 = _el$.firstChild;
          _el$.$$click = handleDialogClick;
          var _ref$ = dialogRef;
          typeof _ref$ === "function" ? use(_ref$, _el$) : dialogRef = _el$;
          _el$2.$$click = (e) => e.stopPropagation();
          insert(_el$2, createComponent(Show, {
            get when() {
              return props.showCloseButton !== false;
            },
            get children() {
              var _el$3 = _tmpl$$5();
              addEventListener$1(_el$3, "click", props.onClose, true);
              return _el$3;
            }
          }), null);
          insert(_el$2, () => props.children, null);
          createRenderEffect(() => className(_el$, `modal ${props.class || ""}`));
          return _el$;
        }
      });
    }
  });
};
const ErrorModal = (props) => {
  return createComponent(Modal, {
    get isOpen() {
      return props.isOpen;
    },
    get onClose() {
      return props.onClose;
    },
    "class": "error-modal",
    get children() {
      var _el$4 = _tmpl$3$3(), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling, _el$7 = _el$6.nextSibling, _el$8 = _el$7.firstChild;
      insert(_el$6, () => props.message);
      addEventListener$1(_el$8, "click", props.onClose, true);
      return _el$4;
    }
  });
};
const PromptModal = (props) => {
  const [responses, setResponses] = createSignal([]);
  createEffect(() => {
    if (props.prompts) {
      setResponses(new Array(props.prompts.length).fill(""));
    }
  });
  const handleInputChange = (index, value2) => {
    const newResponses = [...responses()];
    newResponses[index] = value2;
    setResponses(newResponses);
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    props.onSubmit(responses());
    props.onClose();
  };
  return createComponent(Modal, {
    get isOpen() {
      return props.isOpen;
    },
    get onClose() {
      return props.onClose;
    },
    "class": "prompt-modal",
    get children() {
      var _el$9 = _tmpl$4$3(), _el$0 = _el$9.firstChild, _el$1 = _el$0.nextSibling, _el$10 = _el$1.firstChild, _el$11 = _el$10.nextSibling, _el$12 = _el$11.firstChild;
      insert(_el$0, () => props.title);
      _el$1.addEventListener("submit", handleSubmit);
      insert(_el$10, createComponent(For, {
        get each() {
          return props.prompts;
        },
        children: (prompt, index) => (() => {
          var _el$13 = _tmpl$5$3(), _el$14 = _el$13.firstChild, _el$15 = _el$14.nextSibling;
          insert(_el$14, () => prompt.prompt);
          _el$15.$$input = (e) => handleInputChange(index(), e.currentTarget.value);
          createRenderEffect(() => setAttribute(_el$15, "type", prompt.echo ? "text" : "password"));
          createRenderEffect(() => _el$15.value = responses()[index()] || "");
          return _el$13;
        })()
      }));
      addEventListener$1(_el$12, "click", props.onClose, true);
      return _el$9;
    }
  });
};
delegateEvents(["click", "input"]);
const Menu = '<!-- @license lucide-static v0.542.0 - ISC -->\n<svg\n  class="lucide lucide-menu"\n  xmlns="http://www.w3.org/2000/svg"\n  width="24"\n  height="24"\n  viewBox="0 0 24 24"\n  fill="none"\n  stroke="currentColor"\n  stroke-width="2"\n  stroke-linecap="round"\n  stroke-linejoin="round"\n>\n  <path d="M4 12h16" />\n  <path d="M4 18h16" />\n  <path d="M4 6h16" />\n</svg>\n';
const Clipboard = '<!-- @license lucide-static v0.542.0 - ISC -->\n<svg\n  class="lucide lucide-clipboard"\n  xmlns="http://www.w3.org/2000/svg"\n  width="24"\n  height="24"\n  viewBox="0 0 24 24"\n  fill="none"\n  stroke="currentColor"\n  stroke-width="2"\n  stroke-linecap="round"\n  stroke-linejoin="round"\n>\n  <rect width="8" height="4" x="8" y="2" rx="1" ry="1" />\n  <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />\n</svg>\n';
const Settings = '<!-- @license lucide-static v0.542.0 - ISC -->\n<svg\n  class="lucide lucide-settings"\n  xmlns="http://www.w3.org/2000/svg"\n  width="24"\n  height="24"\n  viewBox="0 0 24 24"\n  fill="none"\n  stroke="currentColor"\n  stroke-width="2"\n  stroke-linecap="round"\n  stroke-linejoin="round"\n>\n  <path d="M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915" />\n  <circle cx="12" cy="12" r="3" />\n</svg>\n';
const Download = '<!-- @license lucide-static v0.542.0 - ISC -->\n<svg\n  class="lucide lucide-download"\n  xmlns="http://www.w3.org/2000/svg"\n  width="24"\n  height="24"\n  viewBox="0 0 24 24"\n  fill="none"\n  stroke="currentColor"\n  stroke-width="2"\n  stroke-linecap="round"\n  stroke-linejoin="round"\n>\n  <path d="M12 15V3" />\n  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />\n  <path d="m7 10 5 5 5-5" />\n</svg>\n';
const Key = '<!-- @license lucide-static v0.542.0 - ISC -->\n<svg\n  class="lucide lucide-key"\n  xmlns="http://www.w3.org/2000/svg"\n  width="24"\n  height="24"\n  viewBox="0 0 24 24"\n  fill="none"\n  stroke="currentColor"\n  stroke-width="2"\n  stroke-linecap="round"\n  stroke-linejoin="round"\n>\n  <path d="m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4" />\n  <path d="m21 2-9.6 9.6" />\n  <circle cx="7.5" cy="15.5" r="5.5" />\n</svg>\n';
const Trash2 = '<!-- @license lucide-static v0.542.0 - ISC -->\n<svg\n  class="lucide lucide-trash-2"\n  xmlns="http://www.w3.org/2000/svg"\n  width="24"\n  height="24"\n  viewBox="0 0 24 24"\n  fill="none"\n  stroke="currentColor"\n  stroke-width="2"\n  stroke-linecap="round"\n  stroke-linejoin="round"\n>\n  <path d="M10 11v6" />\n  <path d="M14 11v6" />\n  <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />\n  <path d="M3 6h18" />\n  <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />\n</svg>\n';
const Upload = '<!-- @license lucide-static v0.542.0 - ISC -->\n<svg\n  class="lucide lucide-upload"\n  xmlns="http://www.w3.org/2000/svg"\n  width="24"\n  height="24"\n  viewBox="0 0 24 24"\n  fill="none"\n  stroke="currentColor"\n  stroke-width="2"\n  stroke-linecap="round"\n  stroke-linejoin="round"\n>\n  <path d="M12 3v12" />\n  <path d="m17 8-5-5-5 5" />\n  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />\n</svg>\n';
const ICONS = {
  menu: Menu,
  clipboard: Clipboard,
  settings: Settings,
  download: Download,
  key: Key,
  "trash-can": Trash2,
  trash: Trash2,
  upload: Upload
};
var _tmpl$$4 = /* @__PURE__ */ template(`<span>`);
const Icon = (props) => {
  const [local, others] = splitProps(props, ["name", "class"]);
  const svgRaw = ICONS[local.name] || "";
  if (!svgRaw) {
    console.warn(`Icon "${local.name}" not found in ICONS`);
    return null;
  }
  const parser2 = new DOMParser();
  const doc = parser2.parseFromString(svgRaw, "image/svg+xml");
  const svgEl = doc.querySelector("svg");
  if (!svgEl) {
    return null;
  }
  const tokens = (local.class || "").split(/\s+/).filter(Boolean);
  const svgClass = [];
  const wrapperClass = ["icon"];
  tokens.forEach((t) => {
    if (t.startsWith("w-") || t.startsWith("h-") || t.startsWith("animate-") || t.startsWith("origin-") || t.startsWith("inline-")) {
      svgClass.push(t);
    } else {
      wrapperClass.push(t);
    }
  });
  const existingSvgClass = svgEl.getAttribute("class") || "";
  const finalSvgClass = `${existingSvgClass} ${svgClass.join(" ")}`.trim();
  const svgWithClass = svgRaw.replace(/<svg([^>]*)class="([^"]*)"([^>]*)/, `<svg$1class="${finalSvgClass}"$3`).replace(/<svg([^>]*)(?!class=)([^>]*)/, `<svg$1class="${finalSvgClass}"$2`);
  return (() => {
    var _el$ = _tmpl$$4();
    spread(_el$, mergeProps({
      get ["class"]() {
        return wrapperClass.join(" ");
      }
    }, others, {
      "innerHTML": svgWithClass
    }), false);
    return _el$;
  })();
};
function usePrivateKeyValidation(key) {
  const [validationState, setValidationState] = createSignal({
    isValid: false,
    format: "unknown"
  });
  const validate = createMemo(() => {
    const keyValue = key();
    if (!keyValue || keyValue.trim() === "") {
      setValidationState({ isValid: true, format: "unknown" });
      return true;
    }
    if (keyValue.includes("ssh-rsa") || keyValue.includes("ssh-ed25519") || keyValue.includes("ecdsa-sha2")) {
      setValidationState({
        isValid: false,
        format: "unknown",
        error: "This appears to be a public key",
        suggestion: "Please use your private key file instead (usually id_rsa, not id_rsa.pub)"
      });
      return false;
    }
    if (!validatePrivateKey(keyValue)) {
      let error = "Invalid private key format";
      let suggestion = "";
      if (keyValue.includes("BEGIN") && !keyValue.includes("PRIVATE")) {
        error = "This is not a private key";
        suggestion = "Look for a file without .pub extension";
      } else if (!keyValue.includes("BEGIN")) {
        error = "Missing PEM headers";
        suggestion = "Key should start with -----BEGIN PRIVATE KEY-----";
      }
      setValidationState({
        isValid: false,
        format: "unknown",
        error,
        suggestion
      });
      return false;
    }
    const deepResult = validatePrivateKeyDeep(keyValue);
    if (!deepResult) {
      setValidationState({
        isValid: false,
        format: "unknown",
        error: "Key structure is invalid",
        suggestion: "The key appears corrupted or is in an unsupported format"
      });
      return false;
    }
    setValidationState({
      isValid: true,
      format: deepResult.format
    });
    return true;
  });
  return {
    validationState,
    validate,
    isValid: () => validationState().isValid,
    format: () => validationState().format,
    error: () => validationState().error,
    suggestion: () => validationState().suggestion
  };
}
function createFieldValidator(value2, rules = []) {
  const [validation, setValidation] = createSignal({
    isValid: true
  });
  const validate = () => {
    const currentValue = value2();
    for (const rule of rules) {
      if (!rule.validate(currentValue)) {
        setValidation({
          isValid: false,
          error: rule.message
        });
        return false;
      }
    }
    setValidation({ isValid: true });
    return true;
  };
  return {
    validation,
    validate,
    reset: () => setValidation({ isValid: true })
  };
}
const ValidationRules = {
  required: (message = "This field is required") => ({
    message,
    validate: (value2) => {
      if (typeof value2 === "string") {
        return value2.trim().length > 0;
      }
      return value2 != null && value2 !== "";
    }
  }),
  minLength: (min, message) => ({
    message: message || `Must be at least ${min} characters`,
    validate: (value2) => value2.length >= min
  }),
  maxLength: (max, message) => ({
    message: message || `Must be no more than ${max} characters`,
    validate: (value2) => value2.length <= max
  }),
  pattern: (regex, message = "Invalid format") => ({
    message,
    validate: (value2) => regex.test(value2)
  }),
  email: (message = "Invalid email address") => ({
    message,
    validate: (value2) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value2)
  }),
  port: (message = "Port must be between 1 and 65535") => ({
    message,
    validate: (value2) => {
      const num = Number(value2);
      return num >= 1 && num <= 65535;
    }
  }),
  hostname: (message = "Invalid hostname or IP address") => ({
    message,
    validate: (value2) => {
      if (!value2.trim()) return false;
      const hostnameRegex = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]))*$/;
      const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
      const ipv6Regex = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^::1$|^::$/;
      return hostnameRegex.test(value2) || ipv4Regex.test(value2) || ipv6Regex.test(value2);
    }
  }),
  custom: (validate, message = "Invalid value") => ({
    message,
    validate
  }),
  privateKey: (message = "Invalid private key format") => ({
    message,
    validate: (value2) => {
      if (!value2 || value2.trim() === "") return true;
      return validatePrivateKey(value2);
    }
  }),
  privateKeyDeep: (message = "Private key appears malformed or unsupported") => ({
    message,
    validate: (value2) => {
      if (!value2 || value2.trim() === "") return true;
      return validatePrivateKey(value2) && validatePrivateKeyDeep(value2) !== null;
    }
  }),
  privateKeyWithDetails: () => ({
    message: "Invalid private key",
    validate: (value2) => {
      if (!value2 || value2.trim() === "") return true;
      if (value2.includes("ssh-rsa") || value2.includes("ssh-ed25519") || value2.includes("ecdsa-sha2")) {
        return false;
      }
      return validatePrivateKey(value2) && validatePrivateKeyDeep(value2) !== null;
    }
  })
};
var _tmpl$$3 = /* @__PURE__ */ template(`<div class="relative bg-white text-slate-800 border border-neutral-300 rounded-md shadow-md p-6 w-80 sm:w-[28rem]"><h2 class="text-lg font-semibold text-slate-900 mb-4">WebSSH2 Login</h2><form class=space-y-3><div><label for=hostInput class=sr-only>Host</label><input type=text id=hostInput name=host placeholder=Host required autocomplete=off autocapitalize=off enterkeyhint=next class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></div><div><label for=portInput class=sr-only>Port</label><input type=text id=portInput name=port placeholder=Port autocomplete=off autocapitalize=off enterkeyhint=next inputmode=numeric pattern=[0-9]* class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></div><div><label for=usernameInput class=sr-only>Username</label><input type=text id=usernameInput name=username placeholder=Username required autocomplete=username autocapitalize=off enterkeyhint=next class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></div><div class="password-wrapper relative w-full"><label for=passwordInput class=sr-only>Password</label><input type=password id=passwordInput name=password placeholder=Password autocomplete=current-password autocapitalize=off enterkeyhint=go class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"><span></span></div><div class="flex items-center justify-between gap-2"><div class=private-key-toggle><button type=button class="inline-flex items-center justify-center rounded-md border border-transparent px-3 py-2 text-sm font-medium bg-slate-600 text-white hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500 disabled:opacity-50 disabled:pointer-events-none shadow-sm"> </button></div><div><button type=button class="inline-flex items-center justify-center rounded-md border border-transparent px-3 py-2 text-sm font-medium bg-slate-700 text-white hover:bg-slate-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500 disabled:opacity-50 disabled:pointer-events-none shadow-sm"aria-label=Options title=Options> Options</button></div></div><div><div class="private-key-input mt-2 p-3 rounded border border-neutral-300 bg-neutral-50 text-neutral-800"><label for=privateKeyText class=sr-only>Private Key</label><div class=relative><textarea id=privateKeyText name=privateKey autocomplete=off autocapitalize=off placeholder="Paste your private key here"rows=3 class="block w-full rounded-md border px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 mb-2"></textarea></div><div class="file-upload mb-2"><input type=file id=privateKeyFile class=sr-only><label for=privateKeyFile class="inline-flex items-center justify-center rounded-md border border-transparent px-3 py-2 text-sm font-medium bg-slate-600 text-white hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500 disabled:opacity-50 disabled:pointer-events-none shadow-sm cursor-pointer"> Upload Key File</label></div><label for=passphraseInput class=sr-only>Key Passphrase</label><input type=password id=passphraseInput name=passphrase autocomplete=off autocapitalize=off enterkeyhint=go placeholder="Key password (if encrypted)"class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></div></div><div class="login-buttons mt-4"><button type=submit class="inline-flex w-full items-center justify-center rounded-md border border-transparent px-3 py-2 text-sm font-medium bg-blue-600 text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed disabled:pointer-events-none">Connect`), _tmpl$2$2 = /* @__PURE__ */ template(`<div class="absolute right-2 top-2">`), _tmpl$3$2 = /* @__PURE__ */ template(`<span class=text-green-500>`), _tmpl$4$2 = /* @__PURE__ */ template(`<span class=text-red-500>`), _tmpl$5$2 = /* @__PURE__ */ template(`<div class="mb-2 text-sm"><p class=text-red-600>`), _tmpl$6$1 = /* @__PURE__ */ template(`<p class="text-gray-600 mt-1">`), _tmpl$7$1 = /* @__PURE__ */ template(`<div class=mb-2><span class="inline-flex items-center px-2 py-1 text-xs font-medium rounded-full bg-green-100 text-green-800"> format detected`);
const debug$2 = createDebug("webssh2-client:login-modal");
const LoginModal = (props) => {
  debug$2("LoginModal render", {
    isOpen: props.isOpen
  });
  createEffect(() => {
    debug$2("LoginModal isOpen changed:", props.isOpen);
  });
  const [formData, setFormData] = createSignal({
    host: "",
    port: 22,
    username: "",
    password: "",
    privateKey: "",
    passphrase: ""
  });
  const [showPrivateKeySection, setShowPrivateKeySection] = createSignal(false);
  const [capsLockActive, setCapsLockActive] = createSignal(false);
  const privateKeyValidation = usePrivateKeyValidation(() => formData().privateKey || "");
  const hostValidator = createFieldValidator(() => formData().host || "", [ValidationRules.required(), ValidationRules.hostname()]);
  const usernameValidator = createFieldValidator(() => formData().username || "", [ValidationRules.required()]);
  createEffect(() => {
    if (props.initialValues) {
      setFormData((prev) => ({
        ...prev,
        ...props.initialValues
      }));
    }
  });
  const handleKeyDown = (e) => {
    setCapsLockActive(e.getModifierState("CapsLock"));
  };
  const handleKeyUp = (e) => {
    setCapsLockActive(e.getModifierState("CapsLock"));
  };
  const updateFormData = (key, value2) => {
    setFormData((prev) => ({
      ...prev,
      [key]: value2
    }));
  };
  const handleFileUpload = async (e) => {
    const input = e.target;
    const file = input.files?.[0];
    if (file) {
      try {
        const content = await file.text();
        updateFormData("privateKey", content);
      } catch (error) {
        debug$2("Error reading private key file:", error);
        alert("Error reading private key file");
      }
    }
  };
  const isFormValid = () => {
    const hasCredentials = formData().password || formData().privateKey;
    return hostValidator.validate() && usernameValidator.validate() && hasCredentials && (formData().privateKey ? privateKeyValidation.isValid() : true);
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    if (!isFormValid()) {
      debug$2("Form validation failed");
      return;
    }
    props.onSubmit(formData());
    props.onClose();
  };
  return createComponent(Modal, {
    get isOpen() {
      return props.isOpen;
    },
    get onClose() {
      return props.onClose;
    },
    showCloseButton: false,
    closeOnBackdropClick: false,
    get children() {
      var _el$ = _tmpl$$3(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling, _el$7 = _el$4.nextSibling, _el$8 = _el$7.firstChild, _el$9 = _el$8.nextSibling, _el$0 = _el$7.nextSibling, _el$1 = _el$0.firstChild, _el$10 = _el$1.nextSibling, _el$11 = _el$0.nextSibling, _el$12 = _el$11.firstChild, _el$13 = _el$12.nextSibling, _el$14 = _el$13.nextSibling, _el$15 = _el$11.nextSibling, _el$16 = _el$15.firstChild, _el$17 = _el$16.firstChild, _el$18 = _el$17.firstChild, _el$19 = _el$16.nextSibling, _el$20 = _el$19.firstChild, _el$21 = _el$20.firstChild, _el$22 = _el$15.nextSibling, _el$23 = _el$22.firstChild, _el$24 = _el$23.firstChild, _el$25 = _el$24.nextSibling, _el$26 = _el$25.firstChild, _el$27 = _el$25.nextSibling, _el$28 = _el$27.firstChild, _el$29 = _el$28.nextSibling, _el$30 = _el$29.firstChild, _el$31 = _el$27.nextSibling, _el$32 = _el$31.nextSibling, _el$33 = _el$22.nextSibling, _el$34 = _el$33.firstChild;
      _el$3.addEventListener("submit", handleSubmit);
      _el$6.$$input = (e) => updateFormData("host", e.currentTarget.value);
      setAttribute(_el$6, "spellcheck", false);
      _el$9.$$input = (e) => updateFormData("port", parseInt(e.currentTarget.value) || 22);
      setAttribute(_el$9, "spellcheck", false);
      _el$10.$$input = (e) => updateFormData("username", e.currentTarget.value);
      setAttribute(_el$10, "spellcheck", false);
      _el$13.$$keyup = handleKeyUp;
      _el$13.$$keydown = handleKeyDown;
      _el$13.$$input = (e) => updateFormData("password", e.currentTarget.value);
      setAttribute(_el$13, "spellcheck", false);
      _el$17.$$click = () => setShowPrivateKeySection(!showPrivateKeySection());
      insert(_el$17, createComponent(Icon, {
        name: "key",
        "class": "icon-fw"
      }), _el$18);
      insert(_el$17, () => showPrivateKeySection() ? "Hide SSH Key" : "Add SSH Key", null);
      _el$20.$$click = () => props.onOptionsClick?.();
      insert(_el$20, createComponent(Icon, {
        name: "settings",
        "class": "icon-fw"
      }), _el$21);
      _el$26.$$input = (e) => updateFormData("privateKey", e.currentTarget.value);
      setAttribute(_el$26, "spellcheck", false);
      insert(_el$25, (() => {
        var _c$ = memo(() => !!formData().privateKey);
        return () => _c$() && (() => {
          var _el$35 = _tmpl$2$2();
          insert(_el$35, (() => {
            var _c$4 = memo(() => !!privateKeyValidation.isValid());
            return () => _c$4() ? (() => {
              var _el$36 = _tmpl$3$2();
              createRenderEffect(() => setAttribute(_el$36, "title", `Valid ${privateKeyValidation.format()} key`));
              return _el$36;
            })() : (() => {
              var _el$37 = _tmpl$4$2();
              createRenderEffect(() => setAttribute(_el$37, "title", privateKeyValidation.error()));
              return _el$37;
            })();
          })());
          return _el$35;
        })();
      })(), null);
      insert(_el$23, (() => {
        var _c$2 = memo(() => !!(formData().privateKey && !privateKeyValidation.isValid()));
        return () => _c$2() && (() => {
          var _el$38 = _tmpl$5$2(), _el$39 = _el$38.firstChild;
          insert(_el$39, () => privateKeyValidation.error());
          insert(_el$38, (() => {
            var _c$5 = memo(() => !!privateKeyValidation.suggestion());
            return () => _c$5() && (() => {
              var _el$40 = _tmpl$6$1();
              insert(_el$40, () => privateKeyValidation.suggestion());
              return _el$40;
            })();
          })(), null);
          return _el$38;
        })();
      })(), _el$27);
      insert(_el$23, (() => {
        var _c$3 = memo(() => !!(formData().privateKey && privateKeyValidation.isValid()));
        return () => _c$3() && (() => {
          var _el$41 = _tmpl$7$1(), _el$42 = _el$41.firstChild, _el$43 = _el$42.firstChild;
          insert(_el$42, () => privateKeyValidation.format(), _el$43);
          return _el$41;
        })();
      })(), _el$27);
      _el$28.addEventListener("change", handleFileUpload);
      insert(_el$29, createComponent(Icon, {
        name: "upload",
        "class": "icon-fw"
      }), _el$30);
      _el$32.$$input = (e) => updateFormData("passphrase", e.currentTarget.value);
      setAttribute(_el$32, "spellcheck", false);
      createRenderEffect((_p$) => {
        var _v$ = `${capsLockActive() ? "" : "hidden"} absolute right-2 top-1/2 -translate-y-1/2 text-red-500 pointer-events-none`, _v$2 = showPrivateKeySection() ? "" : "hidden", _v$3 = {
          "border-slate-300 bg-white text-slate-900 placeholder-slate-400": !formData().privateKey,
          "border-red-500 bg-red-50 text-slate-900 placeholder-slate-400": formData().privateKey && !privateKeyValidation.isValid(),
          "border-green-500 bg-green-50 text-slate-900 placeholder-slate-400": formData().privateKey && privateKeyValidation.isValid()
        }, _v$4 = !isFormValid();
        _v$ !== _p$.e && className(_el$14, _p$.e = _v$);
        _v$2 !== _p$.t && className(_el$22, _p$.t = _v$2);
        _p$.a = classList(_el$26, _v$3, _p$.a);
        _v$4 !== _p$.o && (_el$34.disabled = _p$.o = _v$4);
        return _p$;
      }, {
        e: void 0,
        t: void 0,
        a: void 0,
        o: void 0
      });
      createRenderEffect(() => _el$6.value = formData().host || "");
      createRenderEffect(() => _el$9.value = formData().port || "22");
      createRenderEffect(() => _el$10.value = formData().username || "");
      createRenderEffect(() => _el$13.value = formData().password || "");
      createRenderEffect(() => _el$26.value = formData().privateKey || "");
      createRenderEffect(() => _el$32.value = formData().passphrase || "");
      return _el$;
    }
  });
};
delegateEvents(["input", "keydown", "keyup", "click"]);
var _tmpl$$2 = /* @__PURE__ */ template(`<div class="relative bg-white text-slate-800 border border-neutral-300 rounded-md shadow-md p-6 w-80 sm:w-[36rem]"><h2 class="text-lg font-semibold text-slate-900 mb-4">Terminal Settings</h2><form class=space-y-4><fieldset class="grid grid-cols-1 sm:grid-cols-[auto,1fr] gap-x-4 gap-y-3 items-center"><legend class=sr-only>Terminal Options</legend><label for=fontSize class="text-sm font-medium text-slate-700 sm:text-right pr-3 whitespace-nowrap">Font Size</label><input type=number id=fontSize name=fontSize min=8 max=72 required class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"><label for=fontFamily class="text-sm font-medium text-slate-700 sm:text-right pr-3 whitespace-nowrap">Font Family</label><input type=text id=fontFamily name=fontFamily required class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"><label for=cursorBlink class="text-sm font-medium text-slate-700 sm:text-right pr-3 whitespace-nowrap">Cursor Blink</label><select id=cursorBlink name=cursorBlink class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"><option value=true>On</option><option value=false>Off</option></select><label for=scrollback class="text-sm font-medium text-slate-700 sm:text-right pr-3 whitespace-nowrap">Scrollback</label><input type=number id=scrollback name=scrollback min=1 max=200000 required class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"><label for=tabStopWidth class="text-sm font-medium text-slate-700 sm:text-right pr-3 whitespace-nowrap">Tab Stop Width</label><input type=number id=tabStopWidth name=tabStopWidth min=1 max=100 required class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 placeholder-slate-400 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"><label for=bellStyle class="text-sm font-medium text-slate-700 sm:text-right pr-3 whitespace-nowrap">Bell Style</label><select id=bellStyle name=bellStyle class="block w-full rounded-md border border-slate-300 bg-white text-slate-900 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"><option value=sound>Sound</option><option value=none>None</option></select></fieldset><div class="flex gap-2 pt-4 justify-end"><button type=submit class="inline-flex items-center justify-center rounded-md border border-transparent px-3 py-2 text-sm font-medium bg-blue-600 text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:pointer-events-none">Save</button><button type=button class="inline-flex items-center justify-center rounded-md border border-transparent px-3 py-2 text-sm font-medium bg-slate-700 text-white hover:bg-slate-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500 disabled:opacity-50 disabled:pointer-events-none">Cancel`);
const TerminalSettingsModal = (props) => {
  const [settings, setSettings] = createSignal({
    fontSize: defaultSettings.fontSize,
    fontFamily: defaultSettings.fontFamily,
    cursorBlink: defaultSettings.cursorBlink,
    scrollback: defaultSettings.scrollback,
    tabStopWidth: defaultSettings.tabStopWidth,
    bellStyle: "none"
  });
  createEffect(() => {
    if (props.isOpen) {
      const stored = getStoredSettings();
      setSettings({
        fontSize: stored.fontSize || defaultSettings.fontSize,
        fontFamily: stored.fontFamily || defaultSettings.fontFamily,
        cursorBlink: stored.cursorBlink ?? defaultSettings.cursorBlink,
        scrollback: stored.scrollback || defaultSettings.scrollback,
        tabStopWidth: stored.tabStopWidth || defaultSettings.tabStopWidth,
        bellStyle: stored.bellStyle || "none"
      });
    }
  });
  const updateSetting = (key, value2) => {
    setSettings((prev) => ({
      ...prev,
      [key]: value2
    }));
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    const currentSettings = settings();
    const terminalOptions = {
      fontSize: currentSettings.fontSize,
      fontFamily: currentSettings.fontFamily,
      cursorBlink: currentSettings.cursorBlink,
      scrollback: currentSettings.scrollback,
      tabStopWidth: currentSettings.tabStopWidth
    };
    saveTerminalSettings(currentSettings);
    props.onSave(terminalOptions);
    props.onClose();
  };
  const handleCancel = () => {
    props.onClose();
  };
  return createComponent(Modal, {
    get isOpen() {
      return props.isOpen;
    },
    get onClose() {
      return props.onClose;
    },
    showCloseButton: false,
    closeOnBackdropClick: false,
    get children() {
      var _el$ = _tmpl$$2(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling, _el$7 = _el$6.nextSibling, _el$8 = _el$7.nextSibling, _el$9 = _el$8.nextSibling, _el$0 = _el$9.nextSibling, _el$1 = _el$0.nextSibling, _el$10 = _el$1.nextSibling, _el$11 = _el$10.nextSibling, _el$12 = _el$11.nextSibling, _el$13 = _el$12.nextSibling, _el$14 = _el$13.nextSibling, _el$15 = _el$14.nextSibling, _el$16 = _el$4.nextSibling, _el$17 = _el$16.firstChild, _el$18 = _el$17.nextSibling;
      _el$3.addEventListener("submit", handleSubmit);
      _el$7.$$input = (e) => updateSetting("fontSize", parseInt(e.currentTarget.value) || defaultSettings.fontSize);
      _el$9.$$input = (e) => updateSetting("fontFamily", e.currentTarget.value);
      _el$1.addEventListener("change", (e) => updateSetting("cursorBlink", e.currentTarget.value === "true"));
      _el$11.$$input = (e) => updateSetting("scrollback", parseInt(e.currentTarget.value) || defaultSettings.scrollback);
      _el$13.$$input = (e) => updateSetting("tabStopWidth", parseInt(e.currentTarget.value) || defaultSettings.tabStopWidth);
      _el$15.addEventListener("change", (e) => updateSetting("bellStyle", e.currentTarget.value));
      _el$18.$$click = handleCancel;
      createRenderEffect(() => _el$7.value = settings().fontSize);
      createRenderEffect(() => _el$9.value = settings().fontFamily);
      createRenderEffect(() => _el$1.value = settings().cursorBlink ? "true" : "false");
      createRenderEffect(() => _el$11.value = settings().scrollback);
      createRenderEffect(() => _el$13.value = settings().tabStopWidth);
      createRenderEffect(() => _el$15.value = settings().bellStyle);
      return _el$;
    }
  });
};
delegateEvents(["input", "click"]);
var _tmpl$$1 = /* @__PURE__ */ template(`<button type=button class="w-full text-left px-4 py-3 hover:bg-neutral-200 whitespace-nowrap inline-flex items-center gap-3 focus:outline-none focus:bg-neutral-200"role=menuitem> Clear Log`), _tmpl$2$1 = /* @__PURE__ */ template(`<button type=button class="w-full text-left px-4 py-3 hover:bg-neutral-200 whitespace-nowrap inline-flex items-center gap-3 focus:outline-none focus:bg-neutral-200"role=menuitem> Stop Log`), _tmpl$3$1 = /* @__PURE__ */ template(`<button type=button class="w-full text-left px-4 py-3 hover:bg-neutral-200 whitespace-nowrap inline-flex items-center gap-3 focus:outline-none focus:bg-neutral-200"role=menuitem> Start Log`), _tmpl$4$1 = /* @__PURE__ */ template(`<button type=button class="w-full text-left px-4 py-3 hover:bg-neutral-200 whitespace-nowrap inline-flex items-center gap-3 focus:outline-none focus:bg-neutral-200"role=menuitem> Download Log`), _tmpl$5$1 = /* @__PURE__ */ template(`<button type=button class="w-full text-left px-4 py-3 hover:bg-neutral-200 whitespace-nowrap inline-flex items-center gap-3 focus:outline-none focus:bg-neutral-200"role=menuitem> Credentials`), _tmpl$6 = /* @__PURE__ */ template(`<button type=button class="w-full text-left px-4 py-3 hover:bg-neutral-200 whitespace-nowrap inline-flex items-center gap-3 focus:outline-none focus:bg-neutral-200"role=menuitem> Switch User`), _tmpl$7 = /* @__PURE__ */ template(`<div class="absolute bottom-full left-0 min-w-56 bg-neutral-50 text-neutral-700 text-base shadow-md border border-neutral-200 z-[101] rounded-md overflow-hidden"role=menu aria-orientation=vertical><button type=button class="w-full text-left px-4 py-3 hover:bg-neutral-200 whitespace-nowrap inline-flex items-center gap-3 focus:outline-none focus:bg-neutral-200"role=menuitem> Settings`), _tmpl$8 = /* @__PURE__ */ template(`<div class="relative group px-2"><button type=button aria-controls=dropupContent class="inline-flex items-center gap-1 select-none text-neutral-100 hover:text-white focus:outline-none focus:ring-2 focus:ring-blue-500 rounded px-1 py-1"> Menu`);
const MenuDropdown = (props) => {
  const [isOpen, setIsOpen] = createSignal(false);
  let menuRef;
  let buttonRef;
  const toggleMenu = () => {
    setIsOpen(!isOpen());
  };
  const openMenu = () => {
    setIsOpen(true);
  };
  const closeMenu = () => {
    setIsOpen(false);
  };
  const handleOutsideClick = (event) => {
    if (menuRef && !menuRef.contains(event.target) && buttonRef && !buttonRef.contains(event.target)) {
      closeMenu();
    }
  };
  const handleKeyDown = (event) => {
    if (event.key === "Escape") {
      closeMenu();
      buttonRef?.focus();
    }
  };
  onMount(() => {
    document.addEventListener("click", handleOutsideClick);
    document.addEventListener("keydown", handleKeyDown);
  });
  onCleanup(() => {
    document.removeEventListener("click", handleOutsideClick);
    document.removeEventListener("keydown", handleKeyDown);
  });
  const handleMenuItemClick = (action) => {
    return () => {
      action();
      closeMenu();
    };
  };
  return (() => {
    var _el$ = _tmpl$8(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;
    _el$.addEventListener("mouseleave", closeMenu);
    _el$2.addEventListener("mouseenter", openMenu);
    _el$2.$$click = toggleMenu;
    var _ref$ = buttonRef;
    typeof _ref$ === "function" ? use(_ref$, _el$2) : buttonRef = _el$2;
    insert(_el$2, createComponent(Icon, {
      name: "menu",
      "class": "w-5 h-5 inline-block"
    }), _el$3);
    insert(_el$, createComponent(Show, {
      get when() {
        return isOpen();
      },
      get children() {
        var _el$4 = _tmpl$7(), _el$15 = _el$4.firstChild, _el$16 = _el$15.firstChild;
        var _ref$2 = menuRef;
        typeof _ref$2 === "function" ? use(_ref$2, _el$4) : menuRef = _el$4;
        insert(_el$4, createComponent(Show, {
          get when() {
            return hasLogData();
          },
          get children() {
            var _el$5 = _tmpl$$1(), _el$6 = _el$5.firstChild;
            addEventListener$1(_el$5, "click", handleMenuItemClick(props.onClearLog || (() => {
            })), true);
            insert(_el$5, createComponent(Icon, {
              name: "trash-can",
              "class": "w-5 h-5 inline-block"
            }), _el$6);
            return _el$5;
          }
        }), _el$15);
        insert(_el$4, createComponent(Show, {
          get when() {
            return state.sessionLogEnable;
          },
          get children() {
            var _el$7 = _tmpl$2$1(), _el$8 = _el$7.firstChild;
            addEventListener$1(_el$7, "click", handleMenuItemClick(props.onStopLog || (() => {
            })), true);
            insert(_el$7, createComponent(Icon, {
              name: "settings",
              "class": "animate-spin origin-center w-5 h-5 inline-block"
            }), _el$8);
            return _el$7;
          }
        }), _el$15);
        insert(_el$4, createComponent(Show, {
          get when() {
            return !state.sessionLogEnable;
          },
          get children() {
            var _el$9 = _tmpl$3$1(), _el$0 = _el$9.firstChild;
            addEventListener$1(_el$9, "click", handleMenuItemClick(props.onStartLog || (() => {
            })), true);
            insert(_el$9, createComponent(Icon, {
              name: "clipboard",
              "class": "w-5 h-5 inline-block"
            }), _el$0);
            return _el$9;
          }
        }), _el$15);
        insert(_el$4, createComponent(Show, {
          get when() {
            return hasLogData();
          },
          get children() {
            var _el$1 = _tmpl$4$1(), _el$10 = _el$1.firstChild;
            addEventListener$1(_el$1, "click", handleMenuItemClick(props.onDownloadLog || (() => {
            })), true);
            insert(_el$1, createComponent(Icon, {
              name: "download",
              "class": "w-5 h-5 inline-block"
            }), _el$10);
            return _el$1;
          }
        }), _el$15);
        insert(_el$4, createComponent(Show, {
          get when() {
            return state.allowReplay;
          },
          get children() {
            var _el$11 = _tmpl$5$1(), _el$12 = _el$11.firstChild;
            addEventListener$1(_el$11, "click", handleMenuItemClick(props.onReplayCredentials || (() => {
            })), true);
            insert(_el$11, createComponent(Icon, {
              name: "key",
              "class": "w-5 h-5 inline-block"
            }), _el$12);
            return _el$11;
          }
        }), _el$15);
        insert(_el$4, createComponent(Show, {
          get when() {
            return state.allowReauth;
          },
          get children() {
            var _el$13 = _tmpl$6(), _el$14 = _el$13.firstChild;
            addEventListener$1(_el$13, "click", handleMenuItemClick(props.onReauth || (() => {
            })), true);
            insert(_el$13, createComponent(Icon, {
              name: "key",
              "class": "w-5 h-5 inline-block"
            }), _el$14);
            return _el$13;
          }
        }), _el$15);
        addEventListener$1(_el$15, "click", handleMenuItemClick(props.onTerminalSettings || (() => {
        })), true);
        insert(_el$15, createComponent(Icon, {
          name: "settings",
          "class": "w-5 h-5 inline-block"
        }), _el$16);
        return _el$4;
      }
    }), null);
    createRenderEffect(() => setAttribute(_el$2, "aria-expanded", isOpen()));
    return _el$;
  })();
};
delegateEvents(["click"]);
const xterm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var _tmpl$ = /* @__PURE__ */ template(`<button type=button class="fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 z-[1001] bg-blue-600 hover:bg-blue-700 text-white text-sm px-5 py-2 rounded shadow focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Reconnect`), _tmpl$2 = /* @__PURE__ */ template(`<div class="w-full text-center z-[99] h-6 leading-6 text-white border-b border-neutral-200 shrink-0">`), _tmpl$3 = /* @__PURE__ */ template(`<div class="terminal flex-1 min-h-0 w-full overflow-hidden">`), _tmpl$4 = /* @__PURE__ */ template(`<div class="overflow-hidden bg-black text-neutral-100 flex flex-col"style=height:100%;width:100%><div class="flex-1 flex flex-col min-h-0"><div class="z-[99] h-6 flex items-center bg-neutral-800 text-neutral-100 border-t border-neutral-200 shrink-0"><div class="inline-block text-left px-[10px] border-l border-neutral-200"></div><div id=status role=status aria-live=polite aria-atomic=true class="inline-block text-left px-[10px] z-[100] border-x border-neutral-200">`), _tmpl$5 = /* @__PURE__ */ template(`<div class="flex-1 flex items-center justify-center"><div class=text-neutral-400>Initializing...`);
const debug$1 = createDebug("webssh2-client:app");
const App = () => {
  const [config2, setConfig] = createSignal();
  const [isTerminalVisible, setIsTerminalVisible] = createSignal(false);
  let terminalRef;
  createEffect(() => {
    debug$1("LoginDialog state changed:", isLoginDialogOpen());
  });
  onMount(async () => {
    try {
      debug$1(`Initializing WebSSH2 client - ${globalThis.BANNER_STRING}`);
      let initialConfig = initializeConfig();
      const basicAuthCookie = getBasicAuthCookie();
      if (basicAuthCookie) {
        initialConfig.ssh.host = basicAuthCookie.host || initialConfig.ssh.host;
        initialConfig.ssh.port = basicAuthCookie.port || initialConfig.ssh.port;
        setState("isBasicAuthCookiePresent", true);
      } else {
        setState("isBasicAuthCookiePresent", false);
      }
      initialConfig = populateFormFromUrl(initialConfig);
      setConfig(initialConfig);
      const footer = initialConfig.ssh.host ? `ssh://${initialConfig.ssh.host}:${initialConfig.ssh.port}` : null;
      setSessionFooter$1(footer);
      setSessionFooter(footer);
      socketService.initSocket(initialConfig, onConnect, onDisconnect, onData, writeToTerminal2, focusTerminal);
      socketService.setupReactiveEffects();
      checkSavedLog();
      const hasSessionLog = window.localStorage.getItem("webssh2_session_log");
      setState("loggedData", !!hasSessionLog);
      debug$1("Initialized loggedData state:", !!hasSessionLog);
      initializeConnection(initialConfig);
      debug$1("WebSSH2 client initialized", {
        autoConnect: initialConfig.autoConnect,
        loginDialogOpen: isLoginDialogOpen()
      });
    } catch (error) {
      console.error("Initialization error:", error);
      handleError2("Initialization error:", error);
    }
  });
  onCleanup(() => {
    debug$1("App cleanup");
    socketService.closeConnection();
  });
  const handleTerminalReady = (ref) => {
    debug$1("Terminal ready");
    terminalRef = ref;
    terminalManager.setTerminalRef(ref);
    if (ref.terminal) {
      const dims = {
        cols: ref.terminal.cols,
        rows: ref.terminal.rows
      };
      setTerminalDimensions(dims);
      debug$1("Terminal dimensions set:", dims);
    }
    if (ref.terminal) {
      ref.terminal.onResize((dimensions) => {
        const dims = {
          cols: dimensions.cols,
          rows: dimensions.rows
        };
        setTerminalDimensions(dims);
        debug$1("Terminal resized:", dims);
        socketService.emitResize(dims);
      });
    }
    setIsTerminalVisible(true);
  };
  const onConnect = () => {
    setShowReconnectButton(false);
    setIsErrorDialogOpen(false);
    setState("sessionLogEnable", false);
    setState("loggedData", false);
    debug$1("Connected to server");
  };
  const onDisconnect = (reason, details) => {
    debug$1("Disconnected:", reason);
    switch (reason) {
      case "auth_required":
      case "auth_failed":
        setIsLoginDialogOpen(true);
        break;
      case "reauth_required":
        debug$1("Reauth required");
        setState("reauthRequired", true);
        setIsLoginDialogOpen(true);
        break;
      case "error":
      case "ssh_error":
        if (!state.reauthRequired) {
          setErrorMessage(`${String(details || reason)}`);
          setIsErrorDialogOpen(true);
          commonPostDisconnectTasks();
        } else {
          setState("reauthRequired", false);
        }
        break;
      default:
        setErrorMessage(`Disconnected: ${String(details || reason)}`);
        setIsErrorDialogOpen(true);
        commonPostDisconnectTasks();
        break;
    }
  };
  const onData = (data) => {
    addToLog(data);
  };
  const writeToTerminal2 = (data) => {
    terminalManager.writeToTerminal(data);
  };
  const focusTerminal = () => {
    terminalManager.focusTerminal();
  };
  const handleLogin = (formData) => {
    debug$1("Handling login", {
      host: formData.host,
      port: formData.port
    });
    connectToServer(formData);
  };
  const handleTerminalSettings = (settings) => {
    terminalManager.applyTerminalSettings(settings);
  };
  const handleReconnect = () => {
    setShowReconnectButton(false);
    setIsErrorDialogOpen(false);
    terminalManager.resetTerminal();
    connectToServer();
  };
  const handlePromptSubmit = (responses) => {
    debug$1("Prompt responses:", responses);
    submitPromptResponses(responses);
  };
  const handleStartLog = () => {
    startLogging();
  };
  const handleStopLog = () => {
    stopLogging();
  };
  const handleDownloadLog = () => {
    downloadLog();
  };
  const handleClearLog = () => {
    clearLog();
  };
  const handleReplayCredentials = () => {
    socketService.replayCredentials();
  };
  const handleReauth = () => {
    socketService.reauth();
  };
  const connectToServer = (formData) => {
    debug$1("Connecting to server");
    const currentConfig = config2();
    if (!currentConfig) return;
    if (state.isConnecting) return;
    if (state.reauthRequired) {
      setState("reauthRequired", false);
      terminalManager.resetTerminal();
    }
    setState("isConnecting", true);
    if (formData) socketService.setFormData(formData);
    socketService.initializeSocketConnection();
    if (terminalRef) {
      if (currentConfig?.header?.text && currentConfig?.header?.background) {
        setHeaderContent({
          text: currentConfig.header.text,
          background: currentConfig.header.background
        });
      }
      setIsTerminalVisible(true);
    }
  };
  const commonPostDisconnectTasks = () => {
    setState("isConnecting", false);
    if (state.sessionLogEnable) {
      downloadLog();
    }
    resetApplication();
    if (state.allowReconnect && !state.isBasicAuthCookiePresent) {
      setShowReconnectButton(true);
    }
  };
  const resetApplication = () => {
    setState("sessionLogEnable", false);
  };
  const handleError2 = (message, error) => {
    console.error("Error:", message, error);
    setState("isConnecting", false);
    setErrorMessage(message);
    setIsErrorDialogOpen(true);
  };
  const initializeConnection = (currentConfig) => {
    debug$1("Initializing connection", {
      autoConnect: currentConfig.autoConnect
    });
    try {
      if (currentConfig.autoConnect) {
        const loginInfo = {};
        if (currentConfig.ssh.host) loginInfo.host = currentConfig.ssh.host;
        loginInfo.port = currentConfig.ssh.port;
        if (currentConfig.ssh.username) loginInfo.username = currentConfig.ssh.username;
        connectToServer(loginInfo);
      } else {
        debug$1("Setting login dialog to open");
        setIsLoginDialogOpen(true);
      }
    } catch (error) {
      handleError2("Connection initialization failed", error);
    }
  };
  return (() => {
    var _el$ = _tmpl$4(), _el$3 = _el$.firstChild, _el$6 = _el$3.firstChild, _el$7 = _el$6.firstChild, _el$8 = _el$7.nextSibling;
    insert(_el$, createComponent(LoginModal, {
      get isOpen() {
        return isLoginDialogOpen();
      },
      onClose: () => {
        debug$1("Closing login dialog");
        setIsLoginDialogOpen(false);
      },
      onSubmit: handleLogin,
      onOptionsClick: () => setIsTerminalSettingsOpen(true),
      get initialValues() {
        return memo(() => !!config2())() ? Object.fromEntries(Object.entries({
          ...config2().ssh.host && {
            host: config2().ssh.host
          },
          ...config2().ssh.port && {
            port: config2().ssh.port
          },
          ...config2().ssh.username && {
            username: config2().ssh.username
          }
        }).filter(([_, value2]) => value2 != null)) : void 0;
      }
    }), _el$3);
    insert(_el$, createComponent(ErrorModal, {
      get isOpen() {
        return isErrorDialogOpen();
      },
      onClose: () => setIsErrorDialogOpen(false),
      get message() {
        return errorMessage() || "An error occurred";
      }
    }), _el$3);
    insert(_el$, createComponent(TerminalSettingsModal, {
      get isOpen() {
        return isTerminalSettingsOpen();
      },
      onClose: () => setIsTerminalSettingsOpen(false),
      onSave: handleTerminalSettings
    }), _el$3);
    insert(_el$, createComponent(Show, {
      get when() {
        return promptData();
      },
      get children() {
        return createComponent(PromptModal, {
          get isOpen() {
            return !!promptData();
          },
          onClose: () => setPromptData(null),
          get title() {
            return promptData()?.title || "Authentication Required";
          },
          get prompts() {
            return promptData()?.prompts || [];
          },
          onSubmit: handlePromptSubmit
        });
      }
    }), _el$3);
    insert(_el$, createComponent(Show, {
      get when() {
        return showReconnectButton();
      },
      get children() {
        var _el$2 = _tmpl$();
        _el$2.$$click = handleReconnect;
        return _el$2;
      }
    }), _el$3);
    insert(_el$3, createComponent(Show, {
      get when() {
        return headerContent();
      },
      get children() {
        var _el$4 = _tmpl$2();
        insert(_el$4, () => headerContent()?.text);
        createRenderEffect((_$p) => setStyleProperty(_el$4, "background-color", headerContent()?.background));
        return _el$4;
      }
    }), _el$6);
    insert(_el$3, createComponent(Show, {
      get when() {
        return config2();
      },
      get fallback() {
        return _tmpl$5();
      },
      get children() {
        var _el$5 = _tmpl$3();
        insert(_el$5, createComponent(TerminalComponent, {
          get config() {
            return config2();
          },
          onTerminalReady: handleTerminalReady,
          "class": "w-full h-full"
        }));
        return _el$5;
      }
    }), _el$6);
    insert(_el$6, createComponent(MenuDropdown, {
      onStartLog: handleStartLog,
      onStopLog: handleStopLog,
      onDownloadLog: handleDownloadLog,
      onClearLog: handleClearLog,
      onReplayCredentials: handleReplayCredentials,
      onReauth: handleReauth,
      onTerminalSettings: () => setIsTerminalSettingsOpen(true)
    }), _el$7);
    insert(_el$7, sessionFooter$1);
    insert(_el$8, connectionStatus);
    createRenderEffect((_$p) => setStyleProperty(_el$8, "color", connectionStatusColor()));
    return _el$;
  })();
};
delegateEvents(["click"]);
const debug = createDebug("webssh2-client:index");
debug("SolidJS entry point loading");
const appElement = document.createElement("div");
appElement.id = "app";
appElement.style.cssText = "height: 100vh; width: 100%; position: absolute; top: 0; left: 0;";
document.body.appendChild(appElement);
debug("Mounting SolidJS app");
render(() => createComponent(App, {}), appElement);
debug("SolidJS app mounted");


//# sourceMappingURL=data:application/json;base64,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QVU7QUFFcEMzYyxRQUFNLDRCQUFzQjtBQUM1QmdkLE9BQU8sUUFBQW5RLGNBQU82SztBQUNkMVgsTUFBTSxzQkFBcUIiLCJuYW1lcyI6WyJiIiwidmFsdWUiLCJzdGF0ZSIsImkiLCJzb3VyY2VzIiwiZGlzcG9zZSIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInVud3JhcCIsInBhcnNlIiwibXMiLCJjcmVhdGVEZWJ1ZyIsInJlcXVpcmUkJDAiLCJkZWJ1ZyIsInNlbGYiLCJ0ZW1wbGF0ZSIsImlzT2JqZWN0IiwiY29uZmlnIiwidGVybWluYWxEaW1lbnNpb25zIiwibWFza09iamVjdCIsInJlIiwidHlwZSIsInNlc3Npb25Gb290ZXIiLCJzZXRTZXNzaW9uRm9vdGVyIiwiaGFzTG9nRGF0YSIsImlzTG9nZ2luZyIsImUiLCJ0IiwicyIsInIiLCJuIiwibyIsImEiLCJQIiwiTCIsImgiLCJjIiwibCIsImQiLCJfIiwiZiIsIlMiLCJ1IiwidiIsImciLCJtIiwic3R5bGVzTG9hZGVkIiwibG9hZERlZmF1bHRTdHlsZXMiLCJ0ZXJtaW5hbCIsInNldFRlcm1pbmFsIiwiY29udGFpbmVyUmVmIiwic2V0Q29udGFpbmVyUmVmIiwiY3JlYXRlU2lnbmFsIiwiYWRkb25NYW5hZ2VyIiwiZXZlbnRNYW5hZ2VyIiwibW91bnRDbGVhbnVwIiwiY3JlYXRlVGVybWluYWxSZWYiLCJ0ZXJtIiwid3JpdGUiLCJ3cml0ZWxuIiwiZGF0YSIsImNsZWFyIiwicmVzZXQiLCJmb2N1cyIsImJsdXIiLCJzY3JvbGxUb1RvcCIsInNjcm9sbFRvQm90dG9tIiwic2Nyb2xsVG9MaW5lIiwibGluZSIsInNlbGVjdCIsImNvbCIsInJvdyIsImxlbmd0aCIsInNlbGVjdEFsbCIsInNlbGVjdExpbmVzIiwic3RhcnQiLCJlbmQiLCJjbGVhclNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsImhhc1NlbGVjdGlvbiIsInJlc2l6ZSIsImNvbHMiLCJyb3dzIiwiZml0IiwiYWRkb25zIiwiZml0QWRkb24iLCJmaW5kIiwiYWRkb24iLCJmaW5kTmV4dCIsInNlYXJjaEFkZG9uIiwiZ2V0QWRkb24iLCJnbG9iYWxUaGlzIiwiU2VhcmNoQWRkb24iLCJmaW5kUHJldmlvdXMiLCJjcmVhdGVFZmZlY3QiLCJjb250YWluZXIiLCJwcm9wcyIsIkFkZG9uTWFuYWdlciIsIkV2ZW50TWFuYWdlciIsImxvYWRBZGRvbnMiLCJldmVudEhhbmRsZXJzIiwib25CaW5hcnkiLCJvbkN1cnNvck1vdmUiLCJvbkRhdGEiLCJvbktleSIsIm9uTGluZUZlZWQiLCJvblJlbmRlciIsIm9uUmVzaXplIiwib25TY3JvbGwiLCJvblNlbGVjdGlvbkNoYW5nZSIsIm9uVGl0bGVDaGFuZ2UiLCJvbldyaXRlUGFyc2VkIiwic2V0dXBFdmVudExpc3RlbmVycyIsInRlcm1pbmFsUmVmIiwib25Nb3VudCIsImNsZWFudXAiLCJyZWYiLCJzZXRUaW1lb3V0IiwiY3VycmVudEhhbmRsZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXZIYW5kbGVycyIsInVwZGF0ZUV2ZW50SGFuZGxlcnMiLCJvbkNsZWFudXAiLCJvblVubW91bnQiLCJ1bmRlZmluZWQiLCJfZWwkIiwiX3RtcGwkIiwiXyR1c2UiLCJfJGVmZmVjdCIsIl9wJCIsImNsYXNzIiwid2lkdGgiLCJoZWlnaHQiLCJzdHlsZSIsIl92JCIsIl8kc3R5bGUiLCJ3aXRoTmF0aXZlQmxvYiIsIndpdGhOYXRpdmVBcnJheUJ1ZmZlciIsImlzVmlldyIsImxvb2t1cCIsImRlY29kZSIsImlzQmluYXJ5Iiwib24iLCJfYSIsInByb3RvY29sIiwiUGFja2V0VHlwZSIsImlzQ29ubmVjdGVkIiwic29ja2V0IiwiaW8iLCJ1cmwiLCJUZXJtaW5hbENvbXBvbmVudCIsInNldFRlcm1pbmFsUmVmIiwiZml0QWRkb25JbnN0YW5jZSIsImdldFRlcm1pbmFsT3B0aW9ucyIsInN0b3JlZFNldHRpbmdzIiwiZ2V0U3RvcmVkU2V0dGluZ3MiLCJ0ZXJtaW5hbENvbmZpZyIsIm1lcmdlZE9wdGlvbnMiLCJjdXJzb3JCbGluayIsInNjcm9sbGJhY2siLCJ2YWxpZGF0ZU51bWJlciIsImRlZmF1bHRTZXR0aW5ncyIsInRhYlN0b3BXaWR0aCIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImxldHRlclNwYWNpbmciLCJsaW5lSGVpZ2h0IiwiZW1pdERhdGEiLCJ0aXRsZSIsImxvYWRBZGRvbiIsImZpdFRlcm1pbmFsIiwib25UZXJtaW5hbFJlYWR5IiwidGVybWluYWxNYW5hZ2VyIiwicmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsImVsZW1lbnQiLCJwYXJlbnRFbGVtZW50Iiwid2luZG93IiwiZGlzY29ubmVjdCIsInh0ZXJtUHJvcHMiLCJvcHRpb25zIiwidGVybWluYWxPcHRpb25zIiwiaGFuZGxlVGVybWluYWxEYXRhIiwiaGFuZGxlVGl0bGVDaGFuZ2UiLCJoYW5kbGVUZXJtaW5hbE1vdW50IiwiYXV0b0ZvY3VzIiwid3JpdGVUb1Rlcm1pbmFsIiwicmVzZXRUZXJtaW5hbCIsInJlc2l6ZVRlcm1pbmFsIiwiZGltZW5zaW9ucyIsImVtaXRSZXNpemUiLCJmb2N1c1Rlcm1pbmFsIiwiZ2V0VGVybWluYWxEaW1lbnNpb25zIiwiY29uc29sZSIsInVwZGF0ZVRlcm1pbmFsU2V0dGluZ3MiLCJPYmplY3QiLCJhc3NpZ24iLCJuZXdPcHRpb25zIiwiYXBwbHlUZXJtaW5hbFNldHRpbmdzIiwiZXJyb3IiLCJ0ZXJtaW5hbFNldHRpbmdzIiwiZ2V0VGVybWluYWxJbnN0YW5jZSIsIk1vZGFsIiwiZGlhbG9nUmVmIiwiaXNPcGVuIiwiaGFzRGlhbG9nIiwib3BlbkRpYWxvZyIsInNob3dNb2RhbCIsImZvY3VzYWJsZUVsZW1lbnRzIiwiZmlyc3RFbGVtZW50IiwiY2xvc2UiLCJvbkNsb3NlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmVjdCIsImNsb3NlT25CYWNrZHJvcENsaWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNoaWxkcmVuIiwiXyRjcmVhdGVDb21wb25lbnQiLCJ3aGVuIiwiX3RtcGwkMiIsIiQkY2xpY2siLCJoYW5kbGVEaWFsb2dDbGljayIsIl9yZWYkIiwiX2VsJDIiLCJzdG9wUHJvcGFnYXRpb24iLCJfJGluc2VydCIsIl9lbCQzIiwiXyRhZGRFdmVudExpc3RlbmVyIiwiXyRjbGFzc05hbWUiLCJfZWwkNCIsIl90bXBsJDMiLCJfZWwkNiIsIm1lc3NhZ2UiLCJfZWwkOCIsInJlc3BvbnNlcyIsInNldFJlc3BvbnNlcyIsInByb21wdHMiLCJBcnJheSIsIm5ld1Jlc3BvbnNlcyIsInByZXZlbnREZWZhdWx0IiwiX2VsJDkiLCJfdG1wbCQ0IiwiX2VsJDAiLCJfZWwkMSIsIkZvciIsImVhY2giLCJfZWwkMTMiLCJfdG1wbCQ1IiwiX2VsJDE0IiwicHJvbXB0IiwiX2VsJDE1IiwiJCRpbnB1dCIsImhhbmRsZUlucHV0Q2hhbmdlIiwiZWNobyIsImluZGV4IiwiXyRkZWxlZ2F0ZUV2ZW50cyIsIkljb24iLCJsb2NhbCIsIm90aGVycyIsInN2Z1JhdyIsIklDT05TIiwid2FybiIsImRvYyIsInBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsInN2Z0VsIiwicXVlcnlTZWxlY3RvciIsInN2Z0NsYXNzIiwid3JhcHBlckNsYXNzIiwidG9rZW5zIiwic3RhcnRzV2l0aCIsImZpbmFsU3ZnQ2xhc3MiLCJleGlzdGluZ1N2Z0NsYXNzIiwiam9pbiIsInN2Z1dpdGhDbGFzcyIsIl8kc3ByZWFkIiwiXyRtZXJnZVByb3BzIiwiTG9naW5Nb2RhbCIsImhvc3QiLCJwb3J0IiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInByaXZhdGVLZXkiLCJwYXNzcGhyYXNlIiwiY2Fwc0xvY2tBY3RpdmUiLCJzZXRDYXBzTG9ja0FjdGl2ZSIsInByaXZhdGVLZXlWYWxpZGF0aW9uIiwidXNlUHJpdmF0ZUtleVZhbGlkYXRpb24iLCJmb3JtRGF0YSIsImhvc3RWYWxpZGF0b3IiLCJjcmVhdGVGaWVsZFZhbGlkYXRvciIsIlZhbGlkYXRpb25SdWxlcyIsInVzZXJuYW1lVmFsaWRhdG9yIiwicmVxdWlyZWQiLCJpbml0aWFsVmFsdWVzIiwic2V0Rm9ybURhdGEiLCJwcmV2IiwiZ2V0TW9kaWZpZXJTdGF0ZSIsImtleSIsInRhcmdldCIsImZpbGUiLCJpbnB1dCIsImZpbGVzIiwidXBkYXRlRm9ybURhdGEiLCJjb250ZW50IiwiYWxlcnQiLCJoYXNDcmVkZW50aWFscyIsInZhbGlkYXRlIiwiaXNGb3JtVmFsaWQiLCJzaG93Q2xvc2VCdXR0b24iLCJoYW5kbGVTdWJtaXQiLCJfJHNldEF0dHJpYnV0ZSIsIl9lbCQxMCIsIiQka2V5dXAiLCJoYW5kbGVLZXlVcCIsIiQka2V5ZG93biIsImhhbmRsZUtleURvd24iLCJfZWwkMTciLCJzZXRTaG93UHJpdmF0ZUtleVNlY3Rpb24iLCJuYW1lIiwiX2VsJDE4IiwiX2VsJDIwIiwib25PcHRpb25zQ2xpY2siLCJfZWwkMjEiLCJfZWwkMjYiLCJfZWwkMjUiLCJfYyQiLCJfJG1lbW8iLCJfZWwkMzUiLCJfYyQ0IiwiX2VsJDM2IiwiX2VsJDM3IiwiX2VsJDIzIiwiX2MkMiIsIl9lbCQzOCIsIl9lbCQzOSIsIl9jJDUiLCJfZWwkNDAiLCJfdG1wbCQ2IiwiX2VsJDI3IiwiX2MkMyIsIl9lbCQ0MSIsIl90bXBsJDciLCJfZWwkNDIiLCJmb3JtYXQiLCJfZWwkNDMiLCJfZWwkMjgiLCJfZWwkMjkiLCJfZWwkMzAiLCJfZWwkMzIiLCJpc1ZhbGlkIiwiX3YkNCIsIl92JDIiLCJfZWwkMjIiLCJfJGNsYXNzTGlzdCIsIl92JDMiLCJfZWwkMzQiLCJkaXNhYmxlZCIsIlRlcm1pbmFsU2V0dGluZ3NNb2RhbCIsInNldFNldHRpbmdzIiwiYmVsbFN0eWxlIiwic3RvcmVkIiwiY3VycmVudFNldHRpbmdzIiwic2F2ZVRlcm1pbmFsU2V0dGluZ3MiLCJfZWwkNyIsInVwZGF0ZVNldHRpbmciLCJjdXJyZW50VGFyZ2V0IiwiX2VsJDExIiwicGFyc2VJbnQiLCJoYW5kbGVDYW5jZWwiLCJzZXR0aW5ncyIsIk1lbnVEcm9wZG93biIsInNldElzT3BlbiIsIm1lbnVSZWYiLCJidXR0b25SZWYiLCJ0b2dnbGVNZW51IiwiY29udGFpbnMiLCJldmVudCIsImNsb3NlTWVudSIsImFjdGlvbiIsIl90bXBsJDgiLCJfcmVmJDIiLCJTaG93IiwiX2VsJDUiLCJoYW5kbGVNZW51SXRlbUNsaWNrIiwic2Vzc2lvbkxvZ0VuYWJsZSIsImFsbG93UmVwbGF5IiwiX2VsJDEyIiwiYWxsb3dSZWF1dGgiLCJfZWwkMTYiLCJBcHAiLCJzZXRDb25maWciLCJpc1Rlcm1pbmFsVmlzaWJsZSIsInNldElzVGVybWluYWxWaXNpYmxlIiwiaW5pdGlhbENvbmZpZyIsImluaXRpYWxpemVDb25maWciLCJiYXNpY0F1dGhDb29raWUiLCJnZXRCYXNpY0F1dGhDb29raWUiLCJzc2giLCJzZXRTdGF0ZSIsImZvb3RlciIsInNldEdsb2JhbFNlc3Npb25Gb290ZXIiLCJzb2NrZXRTZXJ2aWNlIiwiaW5pdFNvY2tldCIsInNldHVwUmVhY3RpdmVFZmZlY3RzIiwiY2hlY2tTYXZlZExvZyIsImhhc1Nlc3Npb25Mb2ciLCJpbml0aWFsaXplQ29ubmVjdGlvbiIsImF1dG9Db25uZWN0IiwibG9naW5EaWFsb2dPcGVuIiwiaXNMb2dpbkRpYWxvZ09wZW4iLCJoYW5kbGVFcnJvciIsImNsb3NlQ29ubmVjdGlvbiIsImRpbXMiLCJzZXRUZXJtaW5hbERpbWVuc2lvbnMiLCJzZXRTaG93UmVjb25uZWN0QnV0dG9uIiwic2V0SXNFcnJvckRpYWxvZ09wZW4iLCJyZWFzb24iLCJzZXRJc0xvZ2luRGlhbG9nT3BlbiIsInJlYXV0aFJlcXVpcmVkIiwic2V0RXJyb3JNZXNzYWdlIiwiU3RyaW5nIiwiY29tbW9uUG9zdERpc2Nvbm5lY3RUYXNrcyIsImFkZFRvTG9nIiwiY29ubmVjdFRvU2VydmVyIiwic3VibWl0UHJvbXB0UmVzcG9uc2VzIiwic3RhcnRMb2dnaW5nIiwic3RvcExvZ2dpbmciLCJkb3dubG9hZExvZyIsImNsZWFyTG9nIiwicmVwbGF5Q3JlZGVudGlhbHMiLCJyZWF1dGgiLCJjdXJyZW50Q29uZmlnIiwiaXNDb25uZWN0aW5nIiwiaW5pdGlhbGl6ZVNvY2tldENvbm5lY3Rpb24iLCJzZXRIZWFkZXJDb250ZW50IiwidGV4dCIsImJhY2tncm91bmQiLCJoZWFkZXIiLCJyZXNldEFwcGxpY2F0aW9uIiwiYWxsb3dSZWNvbm5lY3QiLCJsb2dpbkluZm8iLCJvblN1Ym1pdCIsImhhbmRsZUxvZ2luIiwiaXNFcnJvckRpYWxvZ09wZW4iLCJlcnJvck1lc3NhZ2UiLCJpc1Rlcm1pbmFsU2V0dGluZ3NPcGVuIiwib25TYXZlIiwiaGFuZGxlVGVybWluYWxTZXR0aW5ncyIsInByb21wdERhdGEiLCJoYW5kbGVQcm9tcHRTdWJtaXQiLCJzaG93UmVjb25uZWN0QnV0dG9uIiwiaGFuZGxlUmVjb25uZWN0IiwiaGVhZGVyQ29udGVudCIsIl8kcCIsIl8kc2V0U3R5bGVQcm9wZXJ0eSIsImhhbmRsZVRlcm1pbmFsUmVhZHkiLCJvblN0YXJ0TG9nIiwiaGFuZGxlU3RhcnRMb2ciLCJvblN0b3BMb2ciLCJoYW5kbGVTdG9wTG9nIiwib25Eb3dubG9hZExvZyIsImhhbmRsZURvd25sb2FkTG9nIiwib25DbGVhckxvZyIsImhhbmRsZUNsZWFyTG9nIiwib25SZXBsYXlDcmVkZW50aWFscyIsImhhbmRsZVJlcGxheUNyZWRlbnRpYWxzIiwib25SZWF1dGgiLCJoYW5kbGVSZWF1dGgiLCJvblRlcm1pbmFsU2V0dGluZ3MiLCJjb25uZWN0aW9uU3RhdHVzIiwiYXBwRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjc3NUZXh0IiwiYm9keSIsImFwcGVuZENoaWxkIiwicmVuZGVyIl0sImlnbm9yZUxpc3QiOlswLDEsMiwzLDQsNSw4LDEyLDEzLDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ4LDQ5LDUwLDUxLDUyLDUzLDU0XSwic291cmNlcyI6WyIuLi8uLi9ub2RlX21vZHVsZXMvc29saWQtanMvZGlzdC9zb2xpZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zb2xpZC1qcy93ZWIvZGlzdC93ZWIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9qc21hc2tlci9kaXN0L2luZGV4LmVzbS5qcyIsIi4uL3NyYy9qcy9pbnB1dC12YWxpZGF0b3IudHMiLCIuLi9zcmMvanMvdXRpbHMudHMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc29saWQtanMvc3RvcmUvZGlzdC9zdG9yZS5qcyIsIi4uL3NyYy9qcy9zdGF0ZS1zb2xpZC50cyIsIi4uL3NyYy9qcy91dGlscy9icm93c2VyLnRzIiwiLi4vc3JjL2pzL3NlcnZpY2VzL2xvZ2dpbmctc2VydmljZS50cyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AeHRlcm0vYWRkb24tZml0L2xpYi9hZGRvbi1maXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQHh0ZXJtL3h0ZXJtL2xpYi94dGVybS5qcyIsIi4uL3NyYy9qcy94dGVybS1zb2xpZC91dGlscy9hZGRvbi1tYW5hZ2VyLnRzIiwiLi4vc3JjL2pzL3h0ZXJtLXNvbGlkL3V0aWxzL2V2ZW50LW1hbmFnZXIudHMiLCIuLi9zcmMvanMveHRlcm0tc29saWQvY29tcG9uZW50cy9YVGVybS50c3giLCIuLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9lc20vY29tbW9ucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2VzbS9lbmNvZGVQYWNrZXQuYnJvd3Nlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2VzbS9jb250cmliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2VzbS9kZWNvZGVQYWNrZXQuYnJvd3Nlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2VzbS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ac29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyL2xpYi9lc20vaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20vZ2xvYmFscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS91dGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIvcGFyc2Vxcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20vdHJhbnNwb3J0cy9wb2xsaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIvaGFzLWNvcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20vdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnRzL3dlYnRyYW5zcG9ydC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnRzL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIvcGFyc2V1cmkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20vc29ja2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL3VybC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2J1aWxkL2VzbS9pcy1iaW5hcnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9idWlsZC9lc20vYmluYXJ5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYnVpbGQvZXNtL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL29uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL3NvY2tldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9jb250cmliL2JhY2tvMi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9tYW5hZ2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL2luZGV4LmpzIiwiLi4vc3JjL2pzL3NlcnZpY2VzL3NvY2tldC1zZXJ2aWNlLnRzIiwiLi4vc3JjL2pzL3NldHRpbmdzLnRzIiwiLi4vc3JjL2pzL2NvbXBvbmVudHMvVGVybWluYWwudHN4IiwiLi4vc3JjL2pzL2NvbXBvbmVudHMvTW9kYWwudHN4IiwiLi4vLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdGF0aWMvaWNvbnMvbWVudS5zdmc/cmF3IiwiLi4vLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdGF0aWMvaWNvbnMvY2xpcGJvYXJkLnN2Zz9yYXciLCIuLi8uLi9ub2RlX21vZHVsZXMvbHVjaWRlLXN0YXRpYy9pY29ucy9zZXR0aW5ncy5zdmc/cmF3IiwiLi4vLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdGF0aWMvaWNvbnMvZG93bmxvYWQuc3ZnP3JhdyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sdWNpZGUtc3RhdGljL2ljb25zL2tleS5zdmc/cmF3IiwiLi4vLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdGF0aWMvaWNvbnMvdHJhc2gtMi5zdmc/cmF3IiwiLi4vLi4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1zdGF0aWMvaWNvbnMvdXBsb2FkLnN2Zz9yYXciLCIuLi9zcmMvanMvaWNvbnMudHMiLCIuLi9zcmMvanMvY29tcG9uZW50cy9JY29uLnRzeCIsIi4uL3NyYy9qcy9ob29rcy91c2VQcml2YXRlS2V5VmFsaWRhdGlvbi50cyIsIi4uL3NyYy9qcy91dGlscy92YWxpZGF0aW9uLnRzIiwiLi4vc3JjL2pzL2NvbXBvbmVudHMvTG9naW5Nb2RhbC50c3giLCIuLi9zcmMvanMvY29tcG9uZW50cy9UZXJtaW5hbFNldHRpbmdzTW9kYWwudHN4IiwiLi4vc3JjL2pzL2NvbXBvbmVudHMvTWVudURyb3Bkb3duLnRzeCIsIi4uL3NyYy9qcy9BcHAudHN4IiwiLi4vc3JjL2pzL2luZGV4LXNvbGlkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgdGFza0lkQ291bnRlciA9IDEsXG4gIGlzQ2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZSxcbiAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlLFxuICB0YXNrUXVldWUgPSBbXSxcbiAgY3VycmVudFRhc2sgPSBudWxsLFxuICBzaG91bGRZaWVsZFRvSG9zdCA9IG51bGwsXG4gIHlpZWxkSW50ZXJ2YWwgPSA1LFxuICBkZWFkbGluZSA9IDAsXG4gIG1heFlpZWxkSW50ZXJ2YWwgPSAzMDAsXG4gIG1heERlYWRsaW5lID0gMCxcbiAgc2NoZWR1bGVDYWxsYmFjayA9IG51bGwsXG4gIHNjaGVkdWxlZENhbGxiYWNrID0gbnVsbDtcbmNvbnN0IG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMztcbmZ1bmN0aW9uIHNldHVwU2NoZWR1bGVyKCkge1xuICBjb25zdCBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCksXG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIHNjaGVkdWxlQ2FsbGJhY2sgPSAoKSA9PiBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9ICgpID0+IHtcbiAgICBpZiAoc2NoZWR1bGVkQ2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBkZWFkbGluZSA9IGN1cnJlbnRUaW1lICsgeWllbGRJbnRlcnZhbDtcbiAgICAgIG1heERlYWRsaW5lID0gY3VycmVudFRpbWUgKyBtYXhZaWVsZEludGVydmFsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGFzTW9yZVdvcmsgPSBzY2hlZHVsZWRDYWxsYmFjayhjdXJyZW50VGltZSk7XG4gICAgICAgIGlmICghaGFzTW9yZVdvcmspIHtcbiAgICAgICAgICBzY2hlZHVsZWRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBpZiAobmF2aWdhdG9yICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nKSB7XG4gICAgY29uc3Qgc2NoZWR1bGluZyA9IG5hdmlnYXRvci5zY2hlZHVsaW5nO1xuICAgIHNob3VsZFlpZWxkVG9Ib3N0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGlmIChjdXJyZW50VGltZSA+PSBkZWFkbGluZSkge1xuICAgICAgICBpZiAoc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZygpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lID49IG1heERlYWRsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkWWllbGRUb0hvc3QgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKSA+PSBkZWFkbGluZTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZSh0YXNrUXVldWUsIHRhc2spIHtcbiAgZnVuY3Rpb24gZmluZEluZGV4KCkge1xuICAgIGxldCBtID0gMDtcbiAgICBsZXQgbiA9IHRhc2tRdWV1ZS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChtIDw9IG4pIHtcbiAgICAgIGNvbnN0IGsgPSBuICsgbSA+PiAxO1xuICAgICAgY29uc3QgY21wID0gdGFzay5leHBpcmF0aW9uVGltZSAtIHRhc2tRdWV1ZVtrXS5leHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChjbXAgPiAwKSBtID0gayArIDE7ZWxzZSBpZiAoY21wIDwgMCkgbiA9IGsgLSAxO2Vsc2UgcmV0dXJuIGs7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9XG4gIHRhc2tRdWV1ZS5zcGxpY2UoZmluZEluZGV4KCksIDAsIHRhc2spO1xufVxuZnVuY3Rpb24gcmVxdWVzdENhbGxiYWNrKGZuLCBvcHRpb25zKSB7XG4gIGlmICghc2NoZWR1bGVDYWxsYmFjaykgc2V0dXBTY2hlZHVsZXIoKTtcbiAgbGV0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgIHRpbWVvdXQgPSBtYXhTaWduZWQzMUJpdEludDtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aW1lb3V0KSB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICBjb25zdCBuZXdUYXNrID0ge1xuICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgZm4sXG4gICAgc3RhcnRUaW1lLFxuICAgIGV4cGlyYXRpb25UaW1lOiBzdGFydFRpbWUgKyB0aW1lb3V0XG4gIH07XG4gIGVucXVldWUodGFza1F1ZXVlLCBuZXdUYXNrKTtcbiAgaWYgKCFpc0NhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgaXNDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgc2NoZWR1bGVkQ2FsbGJhY2sgPSBmbHVzaFdvcms7XG4gICAgc2NoZWR1bGVDYWxsYmFjaygpO1xuICB9XG4gIHJldHVybiBuZXdUYXNrO1xufVxuZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2sodGFzaykge1xuICB0YXNrLmZuID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGZsdXNoV29yayhpbml0aWFsVGltZSkge1xuICBpc0NhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiB3b3JrTG9vcChpbml0aWFsVGltZSk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFRhc2sgPSBudWxsO1xuICAgIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gd29ya0xvb3AoaW5pdGlhbFRpbWUpIHtcbiAgbGV0IGN1cnJlbnRUaW1lID0gaW5pdGlhbFRpbWU7XG4gIGN1cnJlbnRUYXNrID0gdGFza1F1ZXVlWzBdIHx8IG51bGw7XG4gIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA+IGN1cnJlbnRUaW1lICYmIHNob3VsZFlpZWxkVG9Ib3N0KCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmZuO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY3VycmVudFRhc2suZm4gPSBudWxsO1xuICAgICAgY29uc3QgZGlkVXNlckNhbGxiYWNrVGltZW91dCA9IGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lO1xuICAgICAgY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgaWYgKGN1cnJlbnRUYXNrID09PSB0YXNrUXVldWVbMF0pIHtcbiAgICAgICAgdGFza1F1ZXVlLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHRhc2tRdWV1ZS5zaGlmdCgpO1xuICAgIGN1cnJlbnRUYXNrID0gdGFza1F1ZXVlWzBdIHx8IG51bGw7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRUYXNrICE9PSBudWxsO1xufVxuXG5jb25zdCBzaGFyZWRDb25maWcgPSB7XG4gIGNvbnRleHQ6IHVuZGVmaW5lZCxcbiAgcmVnaXN0cnk6IHVuZGVmaW5lZCxcbiAgZWZmZWN0czogdW5kZWZpbmVkLFxuICBkb25lOiBmYWxzZSxcbiAgZ2V0Q29udGV4dElkKCkge1xuICAgIHJldHVybiBnZXRDb250ZXh0SWQodGhpcy5jb250ZXh0LmNvdW50KTtcbiAgfSxcbiAgZ2V0TmV4dENvbnRleHRJZCgpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dElkKHRoaXMuY29udGV4dC5jb3VudCsrKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldENvbnRleHRJZChjb3VudCkge1xuICBjb25zdCBudW0gPSBTdHJpbmcoY291bnQpLFxuICAgIGxlbiA9IG51bS5sZW5ndGggLSAxO1xuICByZXR1cm4gc2hhcmVkQ29uZmlnLmNvbnRleHQuaWQgKyAobGVuID8gU3RyaW5nLmZyb21DaGFyQ29kZSg5NiArIGxlbikgOiBcIlwiKSArIG51bTtcbn1cbmZ1bmN0aW9uIHNldEh5ZHJhdGVDb250ZXh0KGNvbnRleHQpIHtcbiAgc2hhcmVkQ29uZmlnLmNvbnRleHQgPSBjb250ZXh0O1xufVxuZnVuY3Rpb24gbmV4dEh5ZHJhdGVDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIC4uLnNoYXJlZENvbmZpZy5jb250ZXh0LFxuICAgIGlkOiBzaGFyZWRDb25maWcuZ2V0TmV4dENvbnRleHRJZCgpLFxuICAgIGNvdW50OiAwXG4gIH07XG59XG5cbmNvbnN0IElTX0RFViA9IGZhbHNlO1xuY29uc3QgZXF1YWxGbiA9IChhLCBiKSA9PiBhID09PSBiO1xuY29uc3QgJFBST1hZID0gU3ltYm9sKFwic29saWQtcHJveHlcIik7XG5jb25zdCBTVVBQT1JUU19QUk9YWSA9IHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgJFRSQUNLID0gU3ltYm9sKFwic29saWQtdHJhY2tcIik7XG5jb25zdCAkREVWQ09NUCA9IFN5bWJvbChcInNvbGlkLWRldi1jb21wb25lbnRcIik7XG5jb25zdCBzaWduYWxPcHRpb25zID0ge1xuICBlcXVhbHM6IGVxdWFsRm5cbn07XG5sZXQgRVJST1IgPSBudWxsO1xubGV0IHJ1bkVmZmVjdHMgPSBydW5RdWV1ZTtcbmNvbnN0IFNUQUxFID0gMTtcbmNvbnN0IFBFTkRJTkcgPSAyO1xuY29uc3QgVU5PV05FRCA9IHtcbiAgb3duZWQ6IG51bGwsXG4gIGNsZWFudXBzOiBudWxsLFxuICBjb250ZXh0OiBudWxsLFxuICBvd25lcjogbnVsbFxufTtcbmNvbnN0IE5PX0lOSVQgPSB7fTtcbnZhciBPd25lciA9IG51bGw7XG5sZXQgVHJhbnNpdGlvbiA9IG51bGw7XG5sZXQgU2NoZWR1bGVyID0gbnVsbDtcbmxldCBFeHRlcm5hbFNvdXJjZUNvbmZpZyA9IG51bGw7XG5sZXQgTGlzdGVuZXIgPSBudWxsO1xubGV0IFVwZGF0ZXMgPSBudWxsO1xubGV0IEVmZmVjdHMgPSBudWxsO1xubGV0IEV4ZWNDb3VudCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVSb290KGZuLCBkZXRhY2hlZE93bmVyKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gTGlzdGVuZXIsXG4gICAgb3duZXIgPSBPd25lcixcbiAgICB1bm93bmVkID0gZm4ubGVuZ3RoID09PSAwLFxuICAgIGN1cnJlbnQgPSBkZXRhY2hlZE93bmVyID09PSB1bmRlZmluZWQgPyBvd25lciA6IGRldGFjaGVkT3duZXIsXG4gICAgcm9vdCA9IHVub3duZWQgPyBVTk9XTkVEIDoge1xuICAgICAgb3duZWQ6IG51bGwsXG4gICAgICBjbGVhbnVwczogbnVsbCxcbiAgICAgIGNvbnRleHQ6IGN1cnJlbnQgPyBjdXJyZW50LmNvbnRleHQgOiBudWxsLFxuICAgICAgb3duZXI6IGN1cnJlbnRcbiAgICB9LFxuICAgIHVwZGF0ZUZuID0gdW5vd25lZCA/IGZuIDogKCkgPT4gZm4oKCkgPT4gdW50cmFjaygoKSA9PiBjbGVhbk5vZGUocm9vdCkpKTtcbiAgT3duZXIgPSByb290O1xuICBMaXN0ZW5lciA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJ1blVwZGF0ZXModXBkYXRlRm4sIHRydWUpO1xuICB9IGZpbmFsbHkge1xuICAgIExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgT3duZXIgPSBvd25lcjtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU2lnbmFsKHZhbHVlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgc2lnbmFsT3B0aW9ucywgb3B0aW9ucykgOiBzaWduYWxPcHRpb25zO1xuICBjb25zdCBzID0ge1xuICAgIHZhbHVlLFxuICAgIG9ic2VydmVyczogbnVsbCxcbiAgICBvYnNlcnZlclNsb3RzOiBudWxsLFxuICAgIGNvbXBhcmF0b3I6IG9wdGlvbnMuZXF1YWxzIHx8IHVuZGVmaW5lZFxuICB9O1xuICBjb25zdCBzZXR0ZXIgPSB2YWx1ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoVHJhbnNpdGlvbiAmJiBUcmFuc2l0aW9uLnJ1bm5pbmcgJiYgVHJhbnNpdGlvbi5zb3VyY2VzLmhhcyhzKSkgdmFsdWUgPSB2YWx1ZShzLnRWYWx1ZSk7ZWxzZSB2YWx1ZSA9IHZhbHVlKHMudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVTaWduYWwocywgdmFsdWUpO1xuICB9O1xuICByZXR1cm4gW3JlYWRTaWduYWwuYmluZChzKSwgc2V0dGVyXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkKGZuLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBjID0gY3JlYXRlQ29tcHV0YXRpb24oZm4sIHZhbHVlLCB0cnVlLCBTVEFMRSk7XG4gIGlmIChTY2hlZHVsZXIgJiYgVHJhbnNpdGlvbiAmJiBUcmFuc2l0aW9uLnJ1bm5pbmcpIFVwZGF0ZXMucHVzaChjKTtlbHNlIHVwZGF0ZUNvbXB1dGF0aW9uKGMpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyRWZmZWN0KGZuLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBjID0gY3JlYXRlQ29tcHV0YXRpb24oZm4sIHZhbHVlLCBmYWxzZSwgU1RBTEUpO1xuICBpZiAoU2NoZWR1bGVyICYmIFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nKSBVcGRhdGVzLnB1c2goYyk7ZWxzZSB1cGRhdGVDb21wdXRhdGlvbihjKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVmZmVjdChmbiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgcnVuRWZmZWN0cyA9IHJ1blVzZXJFZmZlY3RzO1xuICBjb25zdCBjID0gY3JlYXRlQ29tcHV0YXRpb24oZm4sIHZhbHVlLCBmYWxzZSwgU1RBTEUpLFxuICAgIHMgPSBTdXNwZW5zZUNvbnRleHQgJiYgdXNlQ29udGV4dChTdXNwZW5zZUNvbnRleHQpO1xuICBpZiAocykgYy5zdXNwZW5zZSA9IHM7XG4gIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yZW5kZXIpIGMudXNlciA9IHRydWU7XG4gIEVmZmVjdHMgPyBFZmZlY3RzLnB1c2goYykgOiB1cGRhdGVDb21wdXRhdGlvbihjKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aW9uKG9uSW52YWxpZGF0ZSwgb3B0aW9ucykge1xuICBsZXQgZm47XG4gIGNvbnN0IGMgPSBjcmVhdGVDb21wdXRhdGlvbigoKSA9PiB7XG4gICAgICBmbiA/IGZuKCkgOiB1bnRyYWNrKG9uSW52YWxpZGF0ZSk7XG4gICAgICBmbiA9IHVuZGVmaW5lZDtcbiAgICB9LCB1bmRlZmluZWQsIGZhbHNlLCAwKSxcbiAgICBzID0gU3VzcGVuc2VDb250ZXh0ICYmIHVzZUNvbnRleHQoU3VzcGVuc2VDb250ZXh0KTtcbiAgaWYgKHMpIGMuc3VzcGVuc2UgPSBzO1xuICBjLnVzZXIgPSB0cnVlO1xuICByZXR1cm4gdHJhY2tpbmcgPT4ge1xuICAgIGZuID0gdHJhY2tpbmc7XG4gICAgdXBkYXRlQ29tcHV0YXRpb24oYyk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVNZW1vKGZuLCB2YWx1ZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIHNpZ25hbE9wdGlvbnMsIG9wdGlvbnMpIDogc2lnbmFsT3B0aW9ucztcbiAgY29uc3QgYyA9IGNyZWF0ZUNvbXB1dGF0aW9uKGZuLCB2YWx1ZSwgdHJ1ZSwgMCk7XG4gIGMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgYy5vYnNlcnZlclNsb3RzID0gbnVsbDtcbiAgYy5jb21wYXJhdG9yID0gb3B0aW9ucy5lcXVhbHMgfHwgdW5kZWZpbmVkO1xuICBpZiAoU2NoZWR1bGVyICYmIFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nKSB7XG4gICAgYy50U3RhdGUgPSBTVEFMRTtcbiAgICBVcGRhdGVzLnB1c2goYyk7XG4gIH0gZWxzZSB1cGRhdGVDb21wdXRhdGlvbihjKTtcbiAgcmV0dXJuIHJlYWRTaWduYWwuYmluZChjKTtcbn1cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2KSB7XG4gIHJldHVybiB2ICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHY7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNvdXJjZShwU291cmNlLCBwRmV0Y2hlciwgcE9wdGlvbnMpIHtcbiAgbGV0IHNvdXJjZTtcbiAgbGV0IGZldGNoZXI7XG4gIGxldCBvcHRpb25zO1xuICBpZiAodHlwZW9mIHBGZXRjaGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBzb3VyY2UgPSBwU291cmNlO1xuICAgIGZldGNoZXIgPSBwRmV0Y2hlcjtcbiAgICBvcHRpb25zID0gcE9wdGlvbnMgfHwge307XG4gIH0gZWxzZSB7XG4gICAgc291cmNlID0gdHJ1ZTtcbiAgICBmZXRjaGVyID0gcFNvdXJjZTtcbiAgICBvcHRpb25zID0gcEZldGNoZXIgfHwge307XG4gIH1cbiAgbGV0IHByID0gbnVsbCxcbiAgICBpbml0UCA9IE5PX0lOSVQsXG4gICAgaWQgPSBudWxsLFxuICAgIGxvYWRlZFVuZGVyVHJhbnNpdGlvbiA9IGZhbHNlLFxuICAgIHNjaGVkdWxlZCA9IGZhbHNlLFxuICAgIHJlc29sdmVkID0gXCJpbml0aWFsVmFsdWVcIiBpbiBvcHRpb25zLFxuICAgIGR5bmFtaWMgPSB0eXBlb2Ygc291cmNlID09PSBcImZ1bmN0aW9uXCIgJiYgY3JlYXRlTWVtbyhzb3VyY2UpO1xuICBjb25zdCBjb250ZXh0cyA9IG5ldyBTZXQoKSxcbiAgICBbdmFsdWUsIHNldFZhbHVlXSA9IChvcHRpb25zLnN0b3JhZ2UgfHwgY3JlYXRlU2lnbmFsKShvcHRpb25zLmluaXRpYWxWYWx1ZSksXG4gICAgW2Vycm9yLCBzZXRFcnJvcl0gPSBjcmVhdGVTaWduYWwodW5kZWZpbmVkKSxcbiAgICBbdHJhY2ssIHRyaWdnZXJdID0gY3JlYXRlU2lnbmFsKHVuZGVmaW5lZCwge1xuICAgICAgZXF1YWxzOiBmYWxzZVxuICAgIH0pLFxuICAgIFtzdGF0ZSwgc2V0U3RhdGVdID0gY3JlYXRlU2lnbmFsKHJlc29sdmVkID8gXCJyZWFkeVwiIDogXCJ1bnJlc29sdmVkXCIpO1xuICBpZiAoc2hhcmVkQ29uZmlnLmNvbnRleHQpIHtcbiAgICBpZCA9IHNoYXJlZENvbmZpZy5nZXROZXh0Q29udGV4dElkKCk7XG4gICAgaWYgKG9wdGlvbnMuc3NyTG9hZEZyb20gPT09IFwiaW5pdGlhbFwiKSBpbml0UCA9IG9wdGlvbnMuaW5pdGlhbFZhbHVlO2Vsc2UgaWYgKHNoYXJlZENvbmZpZy5sb2FkICYmIHNoYXJlZENvbmZpZy5oYXMoaWQpKSBpbml0UCA9IHNoYXJlZENvbmZpZy5sb2FkKGlkKTtcbiAgfVxuICBmdW5jdGlvbiBsb2FkRW5kKHAsIHYsIGVycm9yLCBrZXkpIHtcbiAgICBpZiAocHIgPT09IHApIHtcbiAgICAgIHByID0gbnVsbDtcbiAgICAgIGtleSAhPT0gdW5kZWZpbmVkICYmIChyZXNvbHZlZCA9IHRydWUpO1xuICAgICAgaWYgKChwID09PSBpbml0UCB8fCB2ID09PSBpbml0UCkgJiYgb3B0aW9ucy5vbkh5ZHJhdGVkKSBxdWV1ZU1pY3JvdGFzaygoKSA9PiBvcHRpb25zLm9uSHlkcmF0ZWQoa2V5LCB7XG4gICAgICAgIHZhbHVlOiB2XG4gICAgICB9KSk7XG4gICAgICBpbml0UCA9IE5PX0lOSVQ7XG4gICAgICBpZiAoVHJhbnNpdGlvbiAmJiBwICYmIGxvYWRlZFVuZGVyVHJhbnNpdGlvbikge1xuICAgICAgICBUcmFuc2l0aW9uLnByb21pc2VzLmRlbGV0ZShwKTtcbiAgICAgICAgbG9hZGVkVW5kZXJUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIHJ1blVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIFRyYW5zaXRpb24ucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgY29tcGxldGVMb2FkKHYsIGVycm9yKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGNvbXBsZXRlTG9hZCh2LCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBsZXRlTG9hZCh2LCBlcnIpIHtcbiAgICBydW5VcGRhdGVzKCgpID0+IHtcbiAgICAgIGlmIChlcnIgPT09IHVuZGVmaW5lZCkgc2V0VmFsdWUoKCkgPT4gdik7XG4gICAgICBzZXRTdGF0ZShlcnIgIT09IHVuZGVmaW5lZCA/IFwiZXJyb3JlZFwiIDogcmVzb2x2ZWQgPyBcInJlYWR5XCIgOiBcInVucmVzb2x2ZWRcIik7XG4gICAgICBzZXRFcnJvcihlcnIpO1xuICAgICAgZm9yIChjb25zdCBjIG9mIGNvbnRleHRzLmtleXMoKSkgYy5kZWNyZW1lbnQoKTtcbiAgICAgIGNvbnRleHRzLmNsZWFyKCk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgY29uc3QgYyA9IFN1c3BlbnNlQ29udGV4dCAmJiB1c2VDb250ZXh0KFN1c3BlbnNlQ29udGV4dCksXG4gICAgICB2ID0gdmFsdWUoKSxcbiAgICAgIGVyciA9IGVycm9yKCk7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkICYmICFwcikgdGhyb3cgZXJyO1xuICAgIGlmIChMaXN0ZW5lciAmJiAhTGlzdGVuZXIudXNlciAmJiBjKSB7XG4gICAgICBjcmVhdGVDb21wdXRlZCgoKSA9PiB7XG4gICAgICAgIHRyYWNrKCk7XG4gICAgICAgIGlmIChwcikge1xuICAgICAgICAgIGlmIChjLnJlc29sdmVkICYmIFRyYW5zaXRpb24gJiYgbG9hZGVkVW5kZXJUcmFuc2l0aW9uKSBUcmFuc2l0aW9uLnByb21pc2VzLmFkZChwcik7ZWxzZSBpZiAoIWNvbnRleHRzLmhhcyhjKSkge1xuICAgICAgICAgICAgYy5pbmNyZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnRleHRzLmFkZChjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuICBmdW5jdGlvbiBsb2FkKHJlZmV0Y2hpbmcgPSB0cnVlKSB7XG4gICAgaWYgKHJlZmV0Y2hpbmcgIT09IGZhbHNlICYmIHNjaGVkdWxlZCkgcmV0dXJuO1xuICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGxvb2t1cCA9IGR5bmFtaWMgPyBkeW5hbWljKCkgOiBzb3VyY2U7XG4gICAgbG9hZGVkVW5kZXJUcmFuc2l0aW9uID0gVHJhbnNpdGlvbiAmJiBUcmFuc2l0aW9uLnJ1bm5pbmc7XG4gICAgaWYgKGxvb2t1cCA9PSBudWxsIHx8IGxvb2t1cCA9PT0gZmFsc2UpIHtcbiAgICAgIGxvYWRFbmQocHIsIHVudHJhY2sodmFsdWUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFRyYW5zaXRpb24gJiYgcHIpIFRyYW5zaXRpb24ucHJvbWlzZXMuZGVsZXRlKHByKTtcbiAgICBsZXQgZXJyb3I7XG4gICAgY29uc3QgcCA9IGluaXRQICE9PSBOT19JTklUID8gaW5pdFAgOiB1bnRyYWNrKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmZXRjaGVyKGxvb2t1cCwge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSgpLFxuICAgICAgICAgIHJlZmV0Y2hpbmdcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChmZXRjaGVyRXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBmZXRjaGVyRXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvYWRFbmQocHIsIHVuZGVmaW5lZCwgY2FzdEVycm9yKGVycm9yKSwgbG9va3VwKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKCFpc1Byb21pc2UocCkpIHtcbiAgICAgIGxvYWRFbmQocHIsIHAsIHVuZGVmaW5lZCwgbG9va3VwKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBwciA9IHA7XG4gICAgaWYgKFwidlwiIGluIHApIHtcbiAgICAgIGlmIChwLnMgPT09IDEpIGxvYWRFbmQocHIsIHAudiwgdW5kZWZpbmVkLCBsb29rdXApO2Vsc2UgbG9hZEVuZChwciwgdW5kZWZpbmVkLCBjYXN0RXJyb3IocC52KSwgbG9va3VwKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHNjaGVkdWxlZCA9IGZhbHNlKTtcbiAgICBydW5VcGRhdGVzKCgpID0+IHtcbiAgICAgIHNldFN0YXRlKHJlc29sdmVkID8gXCJyZWZyZXNoaW5nXCIgOiBcInBlbmRpbmdcIik7XG4gICAgICB0cmlnZ2VyKCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHJldHVybiBwLnRoZW4odiA9PiBsb2FkRW5kKHAsIHYsIHVuZGVmaW5lZCwgbG9va3VwKSwgZSA9PiBsb2FkRW5kKHAsIHVuZGVmaW5lZCwgY2FzdEVycm9yKGUpLCBsb29rdXApKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhyZWFkLCB7XG4gICAgc3RhdGU6IHtcbiAgICAgIGdldDogKCkgPT4gc3RhdGUoKVxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIGdldDogKCkgPT4gZXJyb3IoKVxuICAgIH0sXG4gICAgbG9hZGluZzoge1xuICAgICAgZ2V0KCkge1xuICAgICAgICBjb25zdCBzID0gc3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIHMgPT09IFwicGVuZGluZ1wiIHx8IHMgPT09IFwicmVmcmVzaGluZ1wiO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGF0ZXN0OiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpIHJldHVybiByZWFkKCk7XG4gICAgICAgIGNvbnN0IGVyciA9IGVycm9yKCk7XG4gICAgICAgIGlmIChlcnIgJiYgIXByKSB0aHJvdyBlcnI7XG4gICAgICAgIHJldHVybiB2YWx1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGxldCBvd25lciA9IE93bmVyO1xuICBpZiAoZHluYW1pYykgY3JlYXRlQ29tcHV0ZWQoKCkgPT4gKG93bmVyID0gT3duZXIsIGxvYWQoZmFsc2UpKSk7ZWxzZSBsb2FkKGZhbHNlKTtcbiAgcmV0dXJuIFtyZWFkLCB7XG4gICAgcmVmZXRjaDogaW5mbyA9PiBydW5XaXRoT3duZXIob3duZXIsICgpID0+IGxvYWQoaW5mbykpLFxuICAgIG11dGF0ZTogc2V0VmFsdWVcbiAgfV07XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgbGV0IHQsXG4gICAgdGltZW91dCA9IG9wdGlvbnMgPyBvcHRpb25zLnRpbWVvdXRNcyA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZUNvbXB1dGF0aW9uKCgpID0+IHtcbiAgICBpZiAoIXQgfHwgIXQuZm4pIHQgPSByZXF1ZXN0Q2FsbGJhY2soKCkgPT4gc2V0RGVmZXJyZWQoKCkgPT4gbm9kZS52YWx1ZSksIHRpbWVvdXQgIT09IHVuZGVmaW5lZCA/IHtcbiAgICAgIHRpbWVvdXRcbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gc291cmNlKCk7XG4gIH0sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIGNvbnN0IFtkZWZlcnJlZCwgc2V0RGVmZXJyZWRdID0gY3JlYXRlU2lnbmFsKFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nICYmIFRyYW5zaXRpb24uc291cmNlcy5oYXMobm9kZSkgPyBub2RlLnRWYWx1ZSA6IG5vZGUudmFsdWUsIG9wdGlvbnMpO1xuICB1cGRhdGVDb21wdXRhdGlvbihub2RlKTtcbiAgc2V0RGVmZXJyZWQoKCkgPT4gVHJhbnNpdGlvbiAmJiBUcmFuc2l0aW9uLnJ1bm5pbmcgJiYgVHJhbnNpdGlvbi5zb3VyY2VzLmhhcyhub2RlKSA/IG5vZGUudFZhbHVlIDogbm9kZS52YWx1ZSk7XG4gIHJldHVybiBkZWZlcnJlZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yKHNvdXJjZSwgZm4gPSBlcXVhbEZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN1YnMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG5vZGUgPSBjcmVhdGVDb21wdXRhdGlvbihwID0+IHtcbiAgICBjb25zdCB2ID0gc291cmNlKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHN1YnMuZW50cmllcygpKSBpZiAoZm4oa2V5LCB2KSAhPT0gZm4oa2V5LCBwKSkge1xuICAgICAgZm9yIChjb25zdCBjIG9mIHZhbC52YWx1ZXMoKSkge1xuICAgICAgICBjLnN0YXRlID0gU1RBTEU7XG4gICAgICAgIGlmIChjLnB1cmUpIFVwZGF0ZXMucHVzaChjKTtlbHNlIEVmZmVjdHMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH0sIHVuZGVmaW5lZCwgdHJ1ZSwgU1RBTEUpO1xuICB1cGRhdGVDb21wdXRhdGlvbihub2RlKTtcbiAgcmV0dXJuIGtleSA9PiB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBMaXN0ZW5lcjtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGxldCBsO1xuICAgICAgaWYgKGwgPSBzdWJzLmdldChrZXkpKSBsLmFkZChsaXN0ZW5lcik7ZWxzZSBzdWJzLnNldChrZXksIGwgPSBuZXcgU2V0KFtsaXN0ZW5lcl0pKTtcbiAgICAgIG9uQ2xlYW51cCgoKSA9PiB7XG4gICAgICAgIGwuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgIWwuc2l6ZSAmJiBzdWJzLmRlbGV0ZShrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmbihrZXksIFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nICYmIFRyYW5zaXRpb24uc291cmNlcy5oYXMobm9kZSkgPyBub2RlLnRWYWx1ZSA6IG5vZGUudmFsdWUpO1xuICB9O1xufVxuZnVuY3Rpb24gYmF0Y2goZm4pIHtcbiAgcmV0dXJuIHJ1blVwZGF0ZXMoZm4sIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHVudHJhY2soZm4pIHtcbiAgaWYgKCFFeHRlcm5hbFNvdXJjZUNvbmZpZyAmJiBMaXN0ZW5lciA9PT0gbnVsbCkgcmV0dXJuIGZuKCk7XG4gIGNvbnN0IGxpc3RlbmVyID0gTGlzdGVuZXI7XG4gIExpc3RlbmVyID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBpZiAoRXh0ZXJuYWxTb3VyY2VDb25maWcpIHJldHVybiBFeHRlcm5hbFNvdXJjZUNvbmZpZy51bnRyYWNrKGZuKTtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICB9XG59XG5mdW5jdGlvbiBvbihkZXBzLCBmbiwgb3B0aW9ucykge1xuICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShkZXBzKTtcbiAgbGV0IHByZXZJbnB1dDtcbiAgbGV0IGRlZmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlZmVyO1xuICByZXR1cm4gcHJldlZhbHVlID0+IHtcbiAgICBsZXQgaW5wdXQ7XG4gICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgIGlucHV0ID0gQXJyYXkoZGVwcy5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSBpbnB1dFtpXSA9IGRlcHNbaV0oKTtcbiAgICB9IGVsc2UgaW5wdXQgPSBkZXBzKCk7XG4gICAgaWYgKGRlZmVyKSB7XG4gICAgICBkZWZlciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdW50cmFjaygoKSA9PiBmbihpbnB1dCwgcHJldklucHV0LCBwcmV2VmFsdWUpKTtcbiAgICBwcmV2SW5wdXQgPSBpbnB1dDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICBjcmVhdGVFZmZlY3QoKCkgPT4gdW50cmFjayhmbikpO1xufVxuZnVuY3Rpb24gb25DbGVhbnVwKGZuKSB7XG4gIGlmIChPd25lciA9PT0gbnVsbCkgO2Vsc2UgaWYgKE93bmVyLmNsZWFudXBzID09PSBudWxsKSBPd25lci5jbGVhbnVwcyA9IFtmbl07ZWxzZSBPd25lci5jbGVhbnVwcy5wdXNoKGZuKTtcbiAgcmV0dXJuIGZuO1xufVxuZnVuY3Rpb24gY2F0Y2hFcnJvcihmbiwgaGFuZGxlcikge1xuICBFUlJPUiB8fCAoRVJST1IgPSBTeW1ib2woXCJlcnJvclwiKSk7XG4gIE93bmVyID0gY3JlYXRlQ29tcHV0YXRpb24odW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xuICBPd25lci5jb250ZXh0ID0ge1xuICAgIC4uLk93bmVyLmNvbnRleHQsXG4gICAgW0VSUk9SXTogW2hhbmRsZXJdXG4gIH07XG4gIGlmIChUcmFuc2l0aW9uICYmIFRyYW5zaXRpb24ucnVubmluZykgVHJhbnNpdGlvbi5zb3VyY2VzLmFkZChPd25lcik7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGhhbmRsZUVycm9yKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgT3duZXIgPSBPd25lci5vd25lcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoKSB7XG4gIHJldHVybiBMaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIGdldE93bmVyKCkge1xuICByZXR1cm4gT3duZXI7XG59XG5mdW5jdGlvbiBydW5XaXRoT3duZXIobywgZm4pIHtcbiAgY29uc3QgcHJldiA9IE93bmVyO1xuICBjb25zdCBwcmV2TGlzdGVuZXIgPSBMaXN0ZW5lcjtcbiAgT3duZXIgPSBvO1xuICBMaXN0ZW5lciA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJ1blVwZGF0ZXMoZm4sIHRydWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBoYW5kbGVFcnJvcihlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIE93bmVyID0gcHJldjtcbiAgICBMaXN0ZW5lciA9IHByZXZMaXN0ZW5lcjtcbiAgfVxufVxuZnVuY3Rpb24gZW5hYmxlU2NoZWR1bGluZyhzY2hlZHVsZXIgPSByZXF1ZXN0Q2FsbGJhY2spIHtcbiAgU2NoZWR1bGVyID0gc2NoZWR1bGVyO1xufVxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKGZuKSB7XG4gIGlmIChUcmFuc2l0aW9uICYmIFRyYW5zaXRpb24ucnVubmluZykge1xuICAgIGZuKCk7XG4gICAgcmV0dXJuIFRyYW5zaXRpb24uZG9uZTtcbiAgfVxuICBjb25zdCBsID0gTGlzdGVuZXI7XG4gIGNvbnN0IG8gPSBPd25lcjtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIExpc3RlbmVyID0gbDtcbiAgICBPd25lciA9IG87XG4gICAgbGV0IHQ7XG4gICAgaWYgKFNjaGVkdWxlciB8fCBTdXNwZW5zZUNvbnRleHQpIHtcbiAgICAgIHQgPSBUcmFuc2l0aW9uIHx8IChUcmFuc2l0aW9uID0ge1xuICAgICAgICBzb3VyY2VzOiBuZXcgU2V0KCksXG4gICAgICAgIGVmZmVjdHM6IFtdLFxuICAgICAgICBwcm9taXNlczogbmV3IFNldCgpLFxuICAgICAgICBkaXNwb3NlZDogbmV3IFNldCgpLFxuICAgICAgICBxdWV1ZTogbmV3IFNldCgpLFxuICAgICAgICBydW5uaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHQuZG9uZSB8fCAodC5kb25lID0gbmV3IFByb21pc2UocmVzID0+IHQucmVzb2x2ZSA9IHJlcykpO1xuICAgICAgdC5ydW5uaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgcnVuVXBkYXRlcyhmbiwgZmFsc2UpO1xuICAgIExpc3RlbmVyID0gT3duZXIgPSBudWxsO1xuICAgIHJldHVybiB0ID8gdC5kb25lIDogdW5kZWZpbmVkO1xuICB9KTtcbn1cbmNvbnN0IFt0cmFuc1BlbmRpbmcsIHNldFRyYW5zUGVuZGluZ10gPSAvKkBfX1BVUkVfXyovY3JlYXRlU2lnbmFsKGZhbHNlKTtcbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIHJldHVybiBbdHJhbnNQZW5kaW5nLCBzdGFydFRyYW5zaXRpb25dO1xufVxuZnVuY3Rpb24gcmVzdW1lRWZmZWN0cyhlKSB7XG4gIEVmZmVjdHMucHVzaC5hcHBseShFZmZlY3RzLCBlKTtcbiAgZS5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgaWQgPSBTeW1ib2woXCJjb250ZXh0XCIpO1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIFByb3ZpZGVyOiBjcmVhdGVQcm92aWRlcihpZCksXG4gICAgZGVmYXVsdFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQpIHtcbiAgbGV0IHZhbHVlO1xuICByZXR1cm4gT3duZXIgJiYgT3duZXIuY29udGV4dCAmJiAodmFsdWUgPSBPd25lci5jb250ZXh0W2NvbnRleHQuaWRdKSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBjb250ZXh0LmRlZmF1bHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGNoaWxkcmVuKGZuKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gY3JlYXRlTWVtbyhmbik7XG4gIGNvbnN0IG1lbW8gPSBjcmVhdGVNZW1vKCgpID0+IHJlc29sdmVDaGlsZHJlbihjaGlsZHJlbigpKSk7XG4gIG1lbW8udG9BcnJheSA9ICgpID0+IHtcbiAgICBjb25zdCBjID0gbWVtbygpO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGMpID8gYyA6IGMgIT0gbnVsbCA/IFtjXSA6IFtdO1xuICB9O1xuICByZXR1cm4gbWVtbztcbn1cbmxldCBTdXNwZW5zZUNvbnRleHQ7XG5mdW5jdGlvbiBnZXRTdXNwZW5zZUNvbnRleHQoKSB7XG4gIHJldHVybiBTdXNwZW5zZUNvbnRleHQgfHwgKFN1c3BlbnNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKSk7XG59XG5mdW5jdGlvbiBlbmFibGVFeHRlcm5hbFNvdXJjZShmYWN0b3J5LCB1bnRyYWNrID0gZm4gPT4gZm4oKSkge1xuICBpZiAoRXh0ZXJuYWxTb3VyY2VDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBmYWN0b3J5OiBvbGRGYWN0b3J5LFxuICAgICAgdW50cmFjazogb2xkVW50cmFja1xuICAgIH0gPSBFeHRlcm5hbFNvdXJjZUNvbmZpZztcbiAgICBFeHRlcm5hbFNvdXJjZUNvbmZpZyA9IHtcbiAgICAgIGZhY3Rvcnk6IChmbiwgdHJpZ2dlcikgPT4ge1xuICAgICAgICBjb25zdCBvbGRTb3VyY2UgPSBvbGRGYWN0b3J5KGZuLCB0cmlnZ2VyKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gZmFjdG9yeSh4ID0+IG9sZFNvdXJjZS50cmFjayh4KSwgdHJpZ2dlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhY2s6IHggPT4gc291cmNlLnRyYWNrKHgpLFxuICAgICAgICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICBzb3VyY2UuZGlzcG9zZSgpO1xuICAgICAgICAgICAgb2xkU291cmNlLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdW50cmFjazogZm4gPT4gb2xkVW50cmFjaygoKSA9PiB1bnRyYWNrKGZuKSlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEV4dGVybmFsU291cmNlQ29uZmlnID0ge1xuICAgICAgZmFjdG9yeSxcbiAgICAgIHVudHJhY2tcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiByZWFkU2lnbmFsKCkge1xuICBjb25zdCBydW5uaW5nVHJhbnNpdGlvbiA9IFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nO1xuICBpZiAodGhpcy5zb3VyY2VzICYmIChydW5uaW5nVHJhbnNpdGlvbiA/IHRoaXMudFN0YXRlIDogdGhpcy5zdGF0ZSkpIHtcbiAgICBpZiAoKHJ1bm5pbmdUcmFuc2l0aW9uID8gdGhpcy50U3RhdGUgOiB0aGlzLnN0YXRlKSA9PT0gU1RBTEUpIHVwZGF0ZUNvbXB1dGF0aW9uKHRoaXMpO2Vsc2Uge1xuICAgICAgY29uc3QgdXBkYXRlcyA9IFVwZGF0ZXM7XG4gICAgICBVcGRhdGVzID0gbnVsbDtcbiAgICAgIHJ1blVwZGF0ZXMoKCkgPT4gbG9va1Vwc3RyZWFtKHRoaXMpLCBmYWxzZSk7XG4gICAgICBVcGRhdGVzID0gdXBkYXRlcztcbiAgICB9XG4gIH1cbiAgaWYgKExpc3RlbmVyKSB7XG4gICAgY29uc3Qgc1Nsb3QgPSB0aGlzLm9ic2VydmVycyA/IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA6IDA7XG4gICAgaWYgKCFMaXN0ZW5lci5zb3VyY2VzKSB7XG4gICAgICBMaXN0ZW5lci5zb3VyY2VzID0gW3RoaXNdO1xuICAgICAgTGlzdGVuZXIuc291cmNlU2xvdHMgPSBbc1Nsb3RdO1xuICAgIH0gZWxzZSB7XG4gICAgICBMaXN0ZW5lci5zb3VyY2VzLnB1c2godGhpcyk7XG4gICAgICBMaXN0ZW5lci5zb3VyY2VTbG90cy5wdXNoKHNTbG90KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycykge1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbTGlzdGVuZXJdO1xuICAgICAgdGhpcy5vYnNlcnZlclNsb3RzID0gW0xpc3RlbmVyLnNvdXJjZXMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goTGlzdGVuZXIpO1xuICAgICAgdGhpcy5vYnNlcnZlclNsb3RzLnB1c2goTGlzdGVuZXIuc291cmNlcy5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJ1bm5pbmdUcmFuc2l0aW9uICYmIFRyYW5zaXRpb24uc291cmNlcy5oYXModGhpcykpIHJldHVybiB0aGlzLnRWYWx1ZTtcbiAgcmV0dXJuIHRoaXMudmFsdWU7XG59XG5mdW5jdGlvbiB3cml0ZVNpZ25hbChub2RlLCB2YWx1ZSwgaXNDb21wKSB7XG4gIGxldCBjdXJyZW50ID0gVHJhbnNpdGlvbiAmJiBUcmFuc2l0aW9uLnJ1bm5pbmcgJiYgVHJhbnNpdGlvbi5zb3VyY2VzLmhhcyhub2RlKSA/IG5vZGUudFZhbHVlIDogbm9kZS52YWx1ZTtcbiAgaWYgKCFub2RlLmNvbXBhcmF0b3IgfHwgIW5vZGUuY29tcGFyYXRvcihjdXJyZW50LCB2YWx1ZSkpIHtcbiAgICBpZiAoVHJhbnNpdGlvbikge1xuICAgICAgY29uc3QgVHJhbnNpdGlvblJ1bm5pbmcgPSBUcmFuc2l0aW9uLnJ1bm5pbmc7XG4gICAgICBpZiAoVHJhbnNpdGlvblJ1bm5pbmcgfHwgIWlzQ29tcCAmJiBUcmFuc2l0aW9uLnNvdXJjZXMuaGFzKG5vZGUpKSB7XG4gICAgICAgIFRyYW5zaXRpb24uc291cmNlcy5hZGQobm9kZSk7XG4gICAgICAgIG5vZGUudFZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoIVRyYW5zaXRpb25SdW5uaW5nKSBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAobm9kZS5vYnNlcnZlcnMgJiYgbm9kZS5vYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICBydW5VcGRhdGVzKCgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm9ic2VydmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGNvbnN0IG8gPSBub2RlLm9ic2VydmVyc1tpXTtcbiAgICAgICAgICBjb25zdCBUcmFuc2l0aW9uUnVubmluZyA9IFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nO1xuICAgICAgICAgIGlmIChUcmFuc2l0aW9uUnVubmluZyAmJiBUcmFuc2l0aW9uLmRpc3Bvc2VkLmhhcyhvKSkgY29udGludWU7XG4gICAgICAgICAgaWYgKFRyYW5zaXRpb25SdW5uaW5nID8gIW8udFN0YXRlIDogIW8uc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChvLnB1cmUpIFVwZGF0ZXMucHVzaChvKTtlbHNlIEVmZmVjdHMucHVzaChvKTtcbiAgICAgICAgICAgIGlmIChvLm9ic2VydmVycykgbWFya0Rvd25zdHJlYW0obyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghVHJhbnNpdGlvblJ1bm5pbmcpIG8uc3RhdGUgPSBTVEFMRTtlbHNlIG8udFN0YXRlID0gU1RBTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFVwZGF0ZXMubGVuZ3RoID4gMTBlNSkge1xuICAgICAgICAgIFVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICBpZiAoSVNfREVWKSA7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcHV0YXRpb24obm9kZSkge1xuICBpZiAoIW5vZGUuZm4pIHJldHVybjtcbiAgY2xlYW5Ob2RlKG5vZGUpO1xuICBjb25zdCB0aW1lID0gRXhlY0NvdW50O1xuICBydW5Db21wdXRhdGlvbihub2RlLCBUcmFuc2l0aW9uICYmIFRyYW5zaXRpb24ucnVubmluZyAmJiBUcmFuc2l0aW9uLnNvdXJjZXMuaGFzKG5vZGUpID8gbm9kZS50VmFsdWUgOiBub2RlLnZhbHVlLCB0aW1lKTtcbiAgaWYgKFRyYW5zaXRpb24gJiYgIVRyYW5zaXRpb24ucnVubmluZyAmJiBUcmFuc2l0aW9uLnNvdXJjZXMuaGFzKG5vZGUpKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgcnVuVXBkYXRlcygoKSA9PiB7XG4gICAgICAgIFRyYW5zaXRpb24gJiYgKFRyYW5zaXRpb24ucnVubmluZyA9IHRydWUpO1xuICAgICAgICBMaXN0ZW5lciA9IE93bmVyID0gbm9kZTtcbiAgICAgICAgcnVuQ29tcHV0YXRpb24obm9kZSwgbm9kZS50VmFsdWUsIHRpbWUpO1xuICAgICAgICBMaXN0ZW5lciA9IE93bmVyID0gbnVsbDtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcnVuQ29tcHV0YXRpb24obm9kZSwgdmFsdWUsIHRpbWUpIHtcbiAgbGV0IG5leHRWYWx1ZTtcbiAgY29uc3Qgb3duZXIgPSBPd25lcixcbiAgICBsaXN0ZW5lciA9IExpc3RlbmVyO1xuICBMaXN0ZW5lciA9IE93bmVyID0gbm9kZTtcbiAgdHJ5IHtcbiAgICBuZXh0VmFsdWUgPSBub2RlLmZuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKG5vZGUucHVyZSkge1xuICAgICAgaWYgKFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nKSB7XG4gICAgICAgIG5vZGUudFN0YXRlID0gU1RBTEU7XG4gICAgICAgIG5vZGUudE93bmVkICYmIG5vZGUudE93bmVkLmZvckVhY2goY2xlYW5Ob2RlKTtcbiAgICAgICAgbm9kZS50T3duZWQgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnN0YXRlID0gU1RBTEU7XG4gICAgICAgIG5vZGUub3duZWQgJiYgbm9kZS5vd25lZC5mb3JFYWNoKGNsZWFuTm9kZSk7XG4gICAgICAgIG5vZGUub3duZWQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnVwZGF0ZWRBdCA9IHRpbWUgKyAxO1xuICAgIHJldHVybiBoYW5kbGVFcnJvcihlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIExpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgT3duZXIgPSBvd25lcjtcbiAgfVxuICBpZiAoIW5vZGUudXBkYXRlZEF0IHx8IG5vZGUudXBkYXRlZEF0IDw9IHRpbWUpIHtcbiAgICBpZiAobm9kZS51cGRhdGVkQXQgIT0gbnVsbCAmJiBcIm9ic2VydmVyc1wiIGluIG5vZGUpIHtcbiAgICAgIHdyaXRlU2lnbmFsKG5vZGUsIG5leHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChUcmFuc2l0aW9uICYmIFRyYW5zaXRpb24ucnVubmluZyAmJiBub2RlLnB1cmUpIHtcbiAgICAgIFRyYW5zaXRpb24uc291cmNlcy5hZGQobm9kZSk7XG4gICAgICBub2RlLnRWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9IGVsc2Ugbm9kZS52YWx1ZSA9IG5leHRWYWx1ZTtcbiAgICBub2RlLnVwZGF0ZWRBdCA9IHRpbWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGF0aW9uKGZuLCBpbml0LCBwdXJlLCBzdGF0ZSA9IFNUQUxFLCBvcHRpb25zKSB7XG4gIGNvbnN0IGMgPSB7XG4gICAgZm4sXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIHVwZGF0ZWRBdDogbnVsbCxcbiAgICBvd25lZDogbnVsbCxcbiAgICBzb3VyY2VzOiBudWxsLFxuICAgIHNvdXJjZVNsb3RzOiBudWxsLFxuICAgIGNsZWFudXBzOiBudWxsLFxuICAgIHZhbHVlOiBpbml0LFxuICAgIG93bmVyOiBPd25lcixcbiAgICBjb250ZXh0OiBPd25lciA/IE93bmVyLmNvbnRleHQgOiBudWxsLFxuICAgIHB1cmVcbiAgfTtcbiAgaWYgKFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nKSB7XG4gICAgYy5zdGF0ZSA9IDA7XG4gICAgYy50U3RhdGUgPSBzdGF0ZTtcbiAgfVxuICBpZiAoT3duZXIgPT09IG51bGwpIDtlbHNlIGlmIChPd25lciAhPT0gVU5PV05FRCkge1xuICAgIGlmIChUcmFuc2l0aW9uICYmIFRyYW5zaXRpb24ucnVubmluZyAmJiBPd25lci5wdXJlKSB7XG4gICAgICBpZiAoIU93bmVyLnRPd25lZCkgT3duZXIudE93bmVkID0gW2NdO2Vsc2UgT3duZXIudE93bmVkLnB1c2goYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghT3duZXIub3duZWQpIE93bmVyLm93bmVkID0gW2NdO2Vsc2UgT3duZXIub3duZWQucHVzaChjKTtcbiAgICB9XG4gIH1cbiAgaWYgKEV4dGVybmFsU291cmNlQ29uZmlnICYmIGMuZm4pIHtcbiAgICBjb25zdCBbdHJhY2ssIHRyaWdnZXJdID0gY3JlYXRlU2lnbmFsKHVuZGVmaW5lZCwge1xuICAgICAgZXF1YWxzOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IG9yZGluYXJ5ID0gRXh0ZXJuYWxTb3VyY2VDb25maWcuZmFjdG9yeShjLmZuLCB0cmlnZ2VyKTtcbiAgICBvbkNsZWFudXAoKCkgPT4gb3JkaW5hcnkuZGlzcG9zZSgpKTtcbiAgICBjb25zdCB0cmlnZ2VySW5UcmFuc2l0aW9uID0gKCkgPT4gc3RhcnRUcmFuc2l0aW9uKHRyaWdnZXIpLnRoZW4oKCkgPT4gaW5UcmFuc2l0aW9uLmRpc3Bvc2UoKSk7XG4gICAgY29uc3QgaW5UcmFuc2l0aW9uID0gRXh0ZXJuYWxTb3VyY2VDb25maWcuZmFjdG9yeShjLmZuLCB0cmlnZ2VySW5UcmFuc2l0aW9uKTtcbiAgICBjLmZuID0geCA9PiB7XG4gICAgICB0cmFjaygpO1xuICAgICAgcmV0dXJuIFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nID8gaW5UcmFuc2l0aW9uLnRyYWNrKHgpIDogb3JkaW5hcnkudHJhY2soeCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIHJ1blRvcChub2RlKSB7XG4gIGNvbnN0IHJ1bm5pbmdUcmFuc2l0aW9uID0gVHJhbnNpdGlvbiAmJiBUcmFuc2l0aW9uLnJ1bm5pbmc7XG4gIGlmICgocnVubmluZ1RyYW5zaXRpb24gPyBub2RlLnRTdGF0ZSA6IG5vZGUuc3RhdGUpID09PSAwKSByZXR1cm47XG4gIGlmICgocnVubmluZ1RyYW5zaXRpb24gPyBub2RlLnRTdGF0ZSA6IG5vZGUuc3RhdGUpID09PSBQRU5ESU5HKSByZXR1cm4gbG9va1Vwc3RyZWFtKG5vZGUpO1xuICBpZiAobm9kZS5zdXNwZW5zZSAmJiB1bnRyYWNrKG5vZGUuc3VzcGVuc2UuaW5GYWxsYmFjaykpIHJldHVybiBub2RlLnN1c3BlbnNlLmVmZmVjdHMucHVzaChub2RlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gW25vZGVdO1xuICB3aGlsZSAoKG5vZGUgPSBub2RlLm93bmVyKSAmJiAoIW5vZGUudXBkYXRlZEF0IHx8IG5vZGUudXBkYXRlZEF0IDwgRXhlY0NvdW50KSkge1xuICAgIGlmIChydW5uaW5nVHJhbnNpdGlvbiAmJiBUcmFuc2l0aW9uLmRpc3Bvc2VkLmhhcyhub2RlKSkgcmV0dXJuO1xuICAgIGlmIChydW5uaW5nVHJhbnNpdGlvbiA/IG5vZGUudFN0YXRlIDogbm9kZS5zdGF0ZSkgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG5vZGUgPSBhbmNlc3RvcnNbaV07XG4gICAgaWYgKHJ1bm5pbmdUcmFuc2l0aW9uKSB7XG4gICAgICBsZXQgdG9wID0gbm9kZSxcbiAgICAgICAgcHJldiA9IGFuY2VzdG9yc1tpICsgMV07XG4gICAgICB3aGlsZSAoKHRvcCA9IHRvcC5vd25lcikgJiYgdG9wICE9PSBwcmV2KSB7XG4gICAgICAgIGlmIChUcmFuc2l0aW9uLmRpc3Bvc2VkLmhhcyh0b3ApKSByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgocnVubmluZ1RyYW5zaXRpb24gPyBub2RlLnRTdGF0ZSA6IG5vZGUuc3RhdGUpID09PSBTVEFMRSkge1xuICAgICAgdXBkYXRlQ29tcHV0YXRpb24obm9kZSk7XG4gICAgfSBlbHNlIGlmICgocnVubmluZ1RyYW5zaXRpb24gPyBub2RlLnRTdGF0ZSA6IG5vZGUuc3RhdGUpID09PSBQRU5ESU5HKSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gVXBkYXRlcztcbiAgICAgIFVwZGF0ZXMgPSBudWxsO1xuICAgICAgcnVuVXBkYXRlcygoKSA9PiBsb29rVXBzdHJlYW0obm9kZSwgYW5jZXN0b3JzWzBdKSwgZmFsc2UpO1xuICAgICAgVXBkYXRlcyA9IHVwZGF0ZXM7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBydW5VcGRhdGVzKGZuLCBpbml0KSB7XG4gIGlmIChVcGRhdGVzKSByZXR1cm4gZm4oKTtcbiAgbGV0IHdhaXQgPSBmYWxzZTtcbiAgaWYgKCFpbml0KSBVcGRhdGVzID0gW107XG4gIGlmIChFZmZlY3RzKSB3YWl0ID0gdHJ1ZTtlbHNlIEVmZmVjdHMgPSBbXTtcbiAgRXhlY0NvdW50Kys7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gZm4oKTtcbiAgICBjb21wbGV0ZVVwZGF0ZXMod2FpdCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCF3YWl0KSBFZmZlY3RzID0gbnVsbDtcbiAgICBVcGRhdGVzID0gbnVsbDtcbiAgICBoYW5kbGVFcnJvcihlcnIpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wbGV0ZVVwZGF0ZXMod2FpdCkge1xuICBpZiAoVXBkYXRlcykge1xuICAgIGlmIChTY2hlZHVsZXIgJiYgVHJhbnNpdGlvbiAmJiBUcmFuc2l0aW9uLnJ1bm5pbmcpIHNjaGVkdWxlUXVldWUoVXBkYXRlcyk7ZWxzZSBydW5RdWV1ZShVcGRhdGVzKTtcbiAgICBVcGRhdGVzID0gbnVsbDtcbiAgfVxuICBpZiAod2FpdCkgcmV0dXJuO1xuICBsZXQgcmVzO1xuICBpZiAoVHJhbnNpdGlvbikge1xuICAgIGlmICghVHJhbnNpdGlvbi5wcm9taXNlcy5zaXplICYmICFUcmFuc2l0aW9uLnF1ZXVlLnNpemUpIHtcbiAgICAgIGNvbnN0IHNvdXJjZXMgPSBUcmFuc2l0aW9uLnNvdXJjZXM7XG4gICAgICBjb25zdCBkaXNwb3NlZCA9IFRyYW5zaXRpb24uZGlzcG9zZWQ7XG4gICAgICBFZmZlY3RzLnB1c2guYXBwbHkoRWZmZWN0cywgVHJhbnNpdGlvbi5lZmZlY3RzKTtcbiAgICAgIHJlcyA9IFRyYW5zaXRpb24ucmVzb2x2ZTtcbiAgICAgIGZvciAoY29uc3QgZSBvZiBFZmZlY3RzKSB7XG4gICAgICAgIFwidFN0YXRlXCIgaW4gZSAmJiAoZS5zdGF0ZSA9IGUudFN0YXRlKTtcbiAgICAgICAgZGVsZXRlIGUudFN0YXRlO1xuICAgICAgfVxuICAgICAgVHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICBydW5VcGRhdGVzKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIGRpc3Bvc2VkKSBjbGVhbk5vZGUoZCk7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgdi52YWx1ZSA9IHYudFZhbHVlO1xuICAgICAgICAgIGlmICh2Lm93bmVkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdi5vd25lZC5sZW5ndGg7IGkgPCBsZW47IGkrKykgY2xlYW5Ob2RlKHYub3duZWRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodi50T3duZWQpIHYub3duZWQgPSB2LnRPd25lZDtcbiAgICAgICAgICBkZWxldGUgdi50VmFsdWU7XG4gICAgICAgICAgZGVsZXRlIHYudE93bmVkO1xuICAgICAgICAgIHYudFN0YXRlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzZXRUcmFuc1BlbmRpbmcoZmFsc2UpO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoVHJhbnNpdGlvbi5ydW5uaW5nKSB7XG4gICAgICBUcmFuc2l0aW9uLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIFRyYW5zaXRpb24uZWZmZWN0cy5wdXNoLmFwcGx5KFRyYW5zaXRpb24uZWZmZWN0cywgRWZmZWN0cyk7XG4gICAgICBFZmZlY3RzID0gbnVsbDtcbiAgICAgIHNldFRyYW5zUGVuZGluZyh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgZSA9IEVmZmVjdHM7XG4gIEVmZmVjdHMgPSBudWxsO1xuICBpZiAoZS5sZW5ndGgpIHJ1blVwZGF0ZXMoKCkgPT4gcnVuRWZmZWN0cyhlKSwgZmFsc2UpO1xuICBpZiAocmVzKSByZXMoKTtcbn1cbmZ1bmN0aW9uIHJ1blF1ZXVlKHF1ZXVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHJ1blRvcChxdWV1ZVtpXSk7XG59XG5mdW5jdGlvbiBzY2hlZHVsZVF1ZXVlKHF1ZXVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gcXVldWVbaV07XG4gICAgY29uc3QgdGFza3MgPSBUcmFuc2l0aW9uLnF1ZXVlO1xuICAgIGlmICghdGFza3MuaGFzKGl0ZW0pKSB7XG4gICAgICB0YXNrcy5hZGQoaXRlbSk7XG4gICAgICBTY2hlZHVsZXIoKCkgPT4ge1xuICAgICAgICB0YXNrcy5kZWxldGUoaXRlbSk7XG4gICAgICAgIHJ1blVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIFRyYW5zaXRpb24ucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgcnVuVG9wKGl0ZW0pO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIFRyYW5zaXRpb24gJiYgKFRyYW5zaXRpb24ucnVubmluZyA9IGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcnVuVXNlckVmZmVjdHMocXVldWUpIHtcbiAgbGV0IGksXG4gICAgdXNlckxlbmd0aCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGUgPSBxdWV1ZVtpXTtcbiAgICBpZiAoIWUudXNlcikgcnVuVG9wKGUpO2Vsc2UgcXVldWVbdXNlckxlbmd0aCsrXSA9IGU7XG4gIH1cbiAgaWYgKHNoYXJlZENvbmZpZy5jb250ZXh0KSB7XG4gICAgaWYgKHNoYXJlZENvbmZpZy5jb3VudCkge1xuICAgICAgc2hhcmVkQ29uZmlnLmVmZmVjdHMgfHwgKHNoYXJlZENvbmZpZy5lZmZlY3RzID0gW10pO1xuICAgICAgc2hhcmVkQ29uZmlnLmVmZmVjdHMucHVzaCguLi5xdWV1ZS5zbGljZSgwLCB1c2VyTGVuZ3RoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldEh5ZHJhdGVDb250ZXh0KCk7XG4gIH1cbiAgaWYgKHNoYXJlZENvbmZpZy5lZmZlY3RzICYmIChzaGFyZWRDb25maWcuZG9uZSB8fCAhc2hhcmVkQ29uZmlnLmNvdW50KSkge1xuICAgIHF1ZXVlID0gWy4uLnNoYXJlZENvbmZpZy5lZmZlY3RzLCAuLi5xdWV1ZV07XG4gICAgdXNlckxlbmd0aCArPSBzaGFyZWRDb25maWcuZWZmZWN0cy5sZW5ndGg7XG4gICAgZGVsZXRlIHNoYXJlZENvbmZpZy5lZmZlY3RzO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCB1c2VyTGVuZ3RoOyBpKyspIHJ1blRvcChxdWV1ZVtpXSk7XG59XG5mdW5jdGlvbiBsb29rVXBzdHJlYW0obm9kZSwgaWdub3JlKSB7XG4gIGNvbnN0IHJ1bm5pbmdUcmFuc2l0aW9uID0gVHJhbnNpdGlvbiAmJiBUcmFuc2l0aW9uLnJ1bm5pbmc7XG4gIGlmIChydW5uaW5nVHJhbnNpdGlvbikgbm9kZS50U3RhdGUgPSAwO2Vsc2Ugbm9kZS5zdGF0ZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5zb3VyY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qgc291cmNlID0gbm9kZS5zb3VyY2VzW2ldO1xuICAgIGlmIChzb3VyY2Uuc291cmNlcykge1xuICAgICAgY29uc3Qgc3RhdGUgPSBydW5uaW5nVHJhbnNpdGlvbiA/IHNvdXJjZS50U3RhdGUgOiBzb3VyY2Uuc3RhdGU7XG4gICAgICBpZiAoc3RhdGUgPT09IFNUQUxFKSB7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IGlnbm9yZSAmJiAoIXNvdXJjZS51cGRhdGVkQXQgfHwgc291cmNlLnVwZGF0ZWRBdCA8IEV4ZWNDb3VudCkpIHJ1blRvcChzb3VyY2UpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gUEVORElORykgbG9va1Vwc3RyZWFtKHNvdXJjZSwgaWdub3JlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtEb3duc3RyZWFtKG5vZGUpIHtcbiAgY29uc3QgcnVubmluZ1RyYW5zaXRpb24gPSBUcmFuc2l0aW9uICYmIFRyYW5zaXRpb24ucnVubmluZztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm9ic2VydmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IG8gPSBub2RlLm9ic2VydmVyc1tpXTtcbiAgICBpZiAocnVubmluZ1RyYW5zaXRpb24gPyAhby50U3RhdGUgOiAhby5zdGF0ZSkge1xuICAgICAgaWYgKHJ1bm5pbmdUcmFuc2l0aW9uKSBvLnRTdGF0ZSA9IFBFTkRJTkc7ZWxzZSBvLnN0YXRlID0gUEVORElORztcbiAgICAgIGlmIChvLnB1cmUpIFVwZGF0ZXMucHVzaChvKTtlbHNlIEVmZmVjdHMucHVzaChvKTtcbiAgICAgIG8ub2JzZXJ2ZXJzICYmIG1hcmtEb3duc3RyZWFtKG8pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2xlYW5Ob2RlKG5vZGUpIHtcbiAgbGV0IGk7XG4gIGlmIChub2RlLnNvdXJjZXMpIHtcbiAgICB3aGlsZSAobm9kZS5zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc291cmNlID0gbm9kZS5zb3VyY2VzLnBvcCgpLFxuICAgICAgICBpbmRleCA9IG5vZGUuc291cmNlU2xvdHMucG9wKCksXG4gICAgICAgIG9icyA9IHNvdXJjZS5vYnNlcnZlcnM7XG4gICAgICBpZiAob2JzICYmIG9icy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbiA9IG9icy5wb3AoKSxcbiAgICAgICAgICBzID0gc291cmNlLm9ic2VydmVyU2xvdHMucG9wKCk7XG4gICAgICAgIGlmIChpbmRleCA8IG9icy5sZW5ndGgpIHtcbiAgICAgICAgICBuLnNvdXJjZVNsb3RzW3NdID0gaW5kZXg7XG4gICAgICAgICAgb2JzW2luZGV4XSA9IG47XG4gICAgICAgICAgc291cmNlLm9ic2VydmVyU2xvdHNbaW5kZXhdID0gcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobm9kZS50T3duZWQpIHtcbiAgICBmb3IgKGkgPSBub2RlLnRPd25lZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgY2xlYW5Ob2RlKG5vZGUudE93bmVkW2ldKTtcbiAgICBkZWxldGUgbm9kZS50T3duZWQ7XG4gIH1cbiAgaWYgKFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nICYmIG5vZGUucHVyZSkge1xuICAgIHJlc2V0KG5vZGUsIHRydWUpO1xuICB9IGVsc2UgaWYgKG5vZGUub3duZWQpIHtcbiAgICBmb3IgKGkgPSBub2RlLm93bmVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjbGVhbk5vZGUobm9kZS5vd25lZFtpXSk7XG4gICAgbm9kZS5vd25lZCA9IG51bGw7XG4gIH1cbiAgaWYgKG5vZGUuY2xlYW51cHMpIHtcbiAgICBmb3IgKGkgPSBub2RlLmNsZWFudXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBub2RlLmNsZWFudXBzW2ldKCk7XG4gICAgbm9kZS5jbGVhbnVwcyA9IG51bGw7XG4gIH1cbiAgaWYgKFRyYW5zaXRpb24gJiYgVHJhbnNpdGlvbi5ydW5uaW5nKSBub2RlLnRTdGF0ZSA9IDA7ZWxzZSBub2RlLnN0YXRlID0gMDtcbn1cbmZ1bmN0aW9uIHJlc2V0KG5vZGUsIHRvcCkge1xuICBpZiAoIXRvcCkge1xuICAgIG5vZGUudFN0YXRlID0gMDtcbiAgICBUcmFuc2l0aW9uLmRpc3Bvc2VkLmFkZChub2RlKTtcbiAgfVxuICBpZiAobm9kZS5vd25lZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5vd25lZC5sZW5ndGg7IGkrKykgcmVzZXQobm9kZS5vd25lZFtpXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhc3RFcnJvcihlcnIpIHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gZXJyO1xuICByZXR1cm4gbmV3IEVycm9yKHR5cGVvZiBlcnIgPT09IFwic3RyaW5nXCIgPyBlcnIgOiBcIlVua25vd24gZXJyb3JcIiwge1xuICAgIGNhdXNlOiBlcnJcbiAgfSk7XG59XG5mdW5jdGlvbiBydW5FcnJvcnMoZXJyLCBmbnMsIG93bmVyKSB7XG4gIHRyeSB7XG4gICAgZm9yIChjb25zdCBmIG9mIGZucykgZihlcnIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgb3duZXIgJiYgb3duZXIub3duZXIgfHwgbnVsbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgb3duZXIgPSBPd25lcikge1xuICBjb25zdCBmbnMgPSBFUlJPUiAmJiBvd25lciAmJiBvd25lci5jb250ZXh0ICYmIG93bmVyLmNvbnRleHRbRVJST1JdO1xuICBjb25zdCBlcnJvciA9IGNhc3RFcnJvcihlcnIpO1xuICBpZiAoIWZucykgdGhyb3cgZXJyb3I7XG4gIGlmIChFZmZlY3RzKSBFZmZlY3RzLnB1c2goe1xuICAgIGZuKCkge1xuICAgICAgcnVuRXJyb3JzKGVycm9yLCBmbnMsIG93bmVyKTtcbiAgICB9LFxuICAgIHN0YXRlOiBTVEFMRVxuICB9KTtlbHNlIHJ1bkVycm9ycyhlcnJvciwgZm5zLCBvd25lcik7XG59XG5mdW5jdGlvbiByZXNvbHZlQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiICYmICFjaGlsZHJlbi5sZW5ndGgpIHJldHVybiByZXNvbHZlQ2hpbGRyZW4oY2hpbGRyZW4oKSk7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlQ2hpbGRyZW4oY2hpbGRyZW5baV0pO1xuICAgICAgQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0cy5wdXNoLmFwcGx5KHJlc3VsdHMsIHJlc3VsdCkgOiByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXIoaWQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3ZpZGVyKHByb3BzKSB7XG4gICAgbGV0IHJlcztcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gcmVzID0gdW50cmFjaygoKSA9PiB7XG4gICAgICBPd25lci5jb250ZXh0ID0ge1xuICAgICAgICAuLi5Pd25lci5jb250ZXh0LFxuICAgICAgICBbaWRdOiBwcm9wcy52YWx1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjaGlsZHJlbigoKSA9PiBwcm9wcy5jaGlsZHJlbik7XG4gICAgfSksIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cbmZ1bmN0aW9uIG9uRXJyb3IoZm4pIHtcbiAgRVJST1IgfHwgKEVSUk9SID0gU3ltYm9sKFwiZXJyb3JcIikpO1xuICBpZiAoT3duZXIgPT09IG51bGwpIDtlbHNlIGlmIChPd25lci5jb250ZXh0ID09PSBudWxsIHx8ICFPd25lci5jb250ZXh0W0VSUk9SXSkge1xuICAgIE93bmVyLmNvbnRleHQgPSB7XG4gICAgICAuLi5Pd25lci5jb250ZXh0LFxuICAgICAgW0VSUk9SXTogW2ZuXVxuICAgIH07XG4gICAgbXV0YXRlQ29udGV4dChPd25lciwgRVJST1IsIFtmbl0pO1xuICB9IGVsc2UgT3duZXIuY29udGV4dFtFUlJPUl0ucHVzaChmbik7XG59XG5mdW5jdGlvbiBtdXRhdGVDb250ZXh0KG8sIGtleSwgdmFsdWUpIHtcbiAgaWYgKG8ub3duZWQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG8ub3duZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvLm93bmVkW2ldLmNvbnRleHQgPT09IG8uY29udGV4dCkgbXV0YXRlQ29udGV4dChvLm93bmVkW2ldLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghby5vd25lZFtpXS5jb250ZXh0KSB7XG4gICAgICAgIG8ub3duZWRbaV0uY29udGV4dCA9IG8uY29udGV4dDtcbiAgICAgICAgbXV0YXRlQ29udGV4dChvLm93bmVkW2ldLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIW8ub3duZWRbaV0uY29udGV4dFtrZXldKSB7XG4gICAgICAgIG8ub3duZWRbaV0uY29udGV4dFtrZXldID0gdmFsdWU7XG4gICAgICAgIG11dGF0ZUNvbnRleHQoby5vd25lZFtpXSwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9ic2VydmFibGUoaW5wdXQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgIGlmICghKG9ic2VydmVyIGluc3RhbmNlb2YgT2JqZWN0KSB8fCBvYnNlcnZlciA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0eXBlb2Ygb2JzZXJ2ZXIgPT09IFwiZnVuY3Rpb25cIiA/IG9ic2VydmVyIDogb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIpO1xuICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKSB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzcG9zZSA9IGNyZWF0ZVJvb3QoZGlzcG9zZXIgPT4ge1xuICAgICAgICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHYgPSBpbnB1dCgpO1xuICAgICAgICAgIHVudHJhY2soKCkgPT4gaGFuZGxlcih2KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGlzcG9zZXI7XG4gICAgICB9KTtcbiAgICAgIGlmIChnZXRPd25lcigpKSBvbkNsZWFudXAoZGlzcG9zZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBbU3ltYm9sLm9ic2VydmFibGUgfHwgXCJAQG9ic2VydmFibGVcIl0oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmcm9tKHByb2R1Y2VyLCBpbml0YWxWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICBjb25zdCBbcywgc2V0XSA9IGNyZWF0ZVNpZ25hbChpbml0YWxWYWx1ZSwge1xuICAgIGVxdWFsczogZmFsc2VcbiAgfSk7XG4gIGlmIChcInN1YnNjcmliZVwiIGluIHByb2R1Y2VyKSB7XG4gICAgY29uc3QgdW5zdWIgPSBwcm9kdWNlci5zdWJzY3JpYmUodiA9PiBzZXQoKCkgPT4gdikpO1xuICAgIG9uQ2xlYW51cCgoKSA9PiBcInVuc3Vic2NyaWJlXCIgaW4gdW5zdWIgPyB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWIoKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2xlYW4gPSBwcm9kdWNlcihzZXQpO1xuICAgIG9uQ2xlYW51cChjbGVhbik7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmNvbnN0IEZBTExCQUNLID0gU3ltYm9sKFwiZmFsbGJhY2tcIik7XG5mdW5jdGlvbiBkaXNwb3NlKGQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkLmxlbmd0aDsgaSsrKSBkW2ldKCk7XG59XG5mdW5jdGlvbiBtYXBBcnJheShsaXN0LCBtYXBGbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBpdGVtcyA9IFtdLFxuICAgIG1hcHBlZCA9IFtdLFxuICAgIGRpc3Bvc2VycyA9IFtdLFxuICAgIGxlbiA9IDAsXG4gICAgaW5kZXhlcyA9IG1hcEZuLmxlbmd0aCA+IDEgPyBbXSA6IG51bGw7XG4gIG9uQ2xlYW51cCgoKSA9PiBkaXNwb3NlKGRpc3Bvc2VycykpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBuZXdJdGVtcyA9IGxpc3QoKSB8fCBbXSxcbiAgICAgIG5ld0xlbiA9IG5ld0l0ZW1zLmxlbmd0aCxcbiAgICAgIGksXG4gICAgICBqO1xuICAgIG5ld0l0ZW1zWyRUUkFDS107XG4gICAgcmV0dXJuIHVudHJhY2soKCkgPT4ge1xuICAgICAgbGV0IG5ld0luZGljZXMsIG5ld0luZGljZXNOZXh0LCB0ZW1wLCB0ZW1wZGlzcG9zZXJzLCB0ZW1wSW5kZXhlcywgc3RhcnQsIGVuZCwgbmV3RW5kLCBpdGVtO1xuICAgICAgaWYgKG5ld0xlbiA9PT0gMCkge1xuICAgICAgICBpZiAobGVuICE9PSAwKSB7XG4gICAgICAgICAgZGlzcG9zZShkaXNwb3NlcnMpO1xuICAgICAgICAgIGRpc3Bvc2VycyA9IFtdO1xuICAgICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgICAgbWFwcGVkID0gW107XG4gICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICBpbmRleGVzICYmIChpbmRleGVzID0gW10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZhbGxiYWNrKSB7XG4gICAgICAgICAgaXRlbXMgPSBbRkFMTEJBQ0tdO1xuICAgICAgICAgIG1hcHBlZFswXSA9IGNyZWF0ZVJvb3QoZGlzcG9zZXIgPT4ge1xuICAgICAgICAgICAgZGlzcG9zZXJzWzBdID0gZGlzcG9zZXI7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5mYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxlbiA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICBtYXBwZWQgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG5ld0xlbjsgaisrKSB7XG4gICAgICAgICAgaXRlbXNbal0gPSBuZXdJdGVtc1tqXTtcbiAgICAgICAgICBtYXBwZWRbal0gPSBjcmVhdGVSb290KG1hcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gbmV3TGVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IG5ldyBBcnJheShuZXdMZW4pO1xuICAgICAgICB0ZW1wZGlzcG9zZXJzID0gbmV3IEFycmF5KG5ld0xlbik7XG4gICAgICAgIGluZGV4ZXMgJiYgKHRlbXBJbmRleGVzID0gbmV3IEFycmF5KG5ld0xlbikpO1xuICAgICAgICBmb3IgKHN0YXJ0ID0gMCwgZW5kID0gTWF0aC5taW4obGVuLCBuZXdMZW4pOyBzdGFydCA8IGVuZCAmJiBpdGVtc1tzdGFydF0gPT09IG5ld0l0ZW1zW3N0YXJ0XTsgc3RhcnQrKyk7XG4gICAgICAgIGZvciAoZW5kID0gbGVuIC0gMSwgbmV3RW5kID0gbmV3TGVuIC0gMTsgZW5kID49IHN0YXJ0ICYmIG5ld0VuZCA+PSBzdGFydCAmJiBpdGVtc1tlbmRdID09PSBuZXdJdGVtc1tuZXdFbmRdOyBlbmQtLSwgbmV3RW5kLS0pIHtcbiAgICAgICAgICB0ZW1wW25ld0VuZF0gPSBtYXBwZWRbZW5kXTtcbiAgICAgICAgICB0ZW1wZGlzcG9zZXJzW25ld0VuZF0gPSBkaXNwb3NlcnNbZW5kXTtcbiAgICAgICAgICBpbmRleGVzICYmICh0ZW1wSW5kZXhlc1tuZXdFbmRdID0gaW5kZXhlc1tlbmRdKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdJbmRpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICBuZXdJbmRpY2VzTmV4dCA9IG5ldyBBcnJheShuZXdFbmQgKyAxKTtcbiAgICAgICAgZm9yIChqID0gbmV3RW5kOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgICAgICBpdGVtID0gbmV3SXRlbXNbal07XG4gICAgICAgICAgaSA9IG5ld0luZGljZXMuZ2V0KGl0ZW0pO1xuICAgICAgICAgIG5ld0luZGljZXNOZXh0W2pdID0gaSA9PT0gdW5kZWZpbmVkID8gLTEgOiBpO1xuICAgICAgICAgIG5ld0luZGljZXMuc2V0KGl0ZW0sIGopO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgIGogPSBuZXdJbmRpY2VzLmdldChpdGVtKTtcbiAgICAgICAgICBpZiAoaiAhPT0gdW5kZWZpbmVkICYmIGogIT09IC0xKSB7XG4gICAgICAgICAgICB0ZW1wW2pdID0gbWFwcGVkW2ldO1xuICAgICAgICAgICAgdGVtcGRpc3Bvc2Vyc1tqXSA9IGRpc3Bvc2Vyc1tpXTtcbiAgICAgICAgICAgIGluZGV4ZXMgJiYgKHRlbXBJbmRleGVzW2pdID0gaW5kZXhlc1tpXSk7XG4gICAgICAgICAgICBqID0gbmV3SW5kaWNlc05leHRbal07XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnNldChpdGVtLCBqKTtcbiAgICAgICAgICB9IGVsc2UgZGlzcG9zZXJzW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0gc3RhcnQ7IGogPCBuZXdMZW47IGorKykge1xuICAgICAgICAgIGlmIChqIGluIHRlbXApIHtcbiAgICAgICAgICAgIG1hcHBlZFtqXSA9IHRlbXBbal07XG4gICAgICAgICAgICBkaXNwb3NlcnNbal0gPSB0ZW1wZGlzcG9zZXJzW2pdO1xuICAgICAgICAgICAgaWYgKGluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgaW5kZXhlc1tqXSA9IHRlbXBJbmRleGVzW2pdO1xuICAgICAgICAgICAgICBpbmRleGVzW2pdKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBtYXBwZWRbal0gPSBjcmVhdGVSb290KG1hcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgbWFwcGVkID0gbWFwcGVkLnNsaWNlKDAsIGxlbiA9IG5ld0xlbik7XG4gICAgICAgIGl0ZW1zID0gbmV3SXRlbXMuc2xpY2UoMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG1hcHBlcihkaXNwb3Nlcikge1xuICAgICAgZGlzcG9zZXJzW2pdID0gZGlzcG9zZXI7XG4gICAgICBpZiAoaW5kZXhlcykge1xuICAgICAgICBjb25zdCBbcywgc2V0XSA9IGNyZWF0ZVNpZ25hbChqKTtcbiAgICAgICAgaW5kZXhlc1tqXSA9IHNldDtcbiAgICAgICAgcmV0dXJuIG1hcEZuKG5ld0l0ZW1zW2pdLCBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBGbihuZXdJdGVtc1tqXSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaW5kZXhBcnJheShsaXN0LCBtYXBGbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBpdGVtcyA9IFtdLFxuICAgIG1hcHBlZCA9IFtdLFxuICAgIGRpc3Bvc2VycyA9IFtdLFxuICAgIHNpZ25hbHMgPSBbXSxcbiAgICBsZW4gPSAwLFxuICAgIGk7XG4gIG9uQ2xlYW51cCgoKSA9PiBkaXNwb3NlKGRpc3Bvc2VycykpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0l0ZW1zID0gbGlzdCgpIHx8IFtdLFxuICAgICAgbmV3TGVuID0gbmV3SXRlbXMubGVuZ3RoO1xuICAgIG5ld0l0ZW1zWyRUUkFDS107XG4gICAgcmV0dXJuIHVudHJhY2soKCkgPT4ge1xuICAgICAgaWYgKG5ld0xlbiA9PT0gMCkge1xuICAgICAgICBpZiAobGVuICE9PSAwKSB7XG4gICAgICAgICAgZGlzcG9zZShkaXNwb3NlcnMpO1xuICAgICAgICAgIGRpc3Bvc2VycyA9IFtdO1xuICAgICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgICAgbWFwcGVkID0gW107XG4gICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICBzaWduYWxzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZmFsbGJhY2spIHtcbiAgICAgICAgICBpdGVtcyA9IFtGQUxMQkFDS107XG4gICAgICAgICAgbWFwcGVkWzBdID0gY3JlYXRlUm9vdChkaXNwb3NlciA9PiB7XG4gICAgICAgICAgICBkaXNwb3NlcnNbMF0gPSBkaXNwb3NlcjtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZhbGxiYWNrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGVuID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1zWzBdID09PSBGQUxMQkFDSykge1xuICAgICAgICBkaXNwb3NlcnNbMF0oKTtcbiAgICAgICAgZGlzcG9zZXJzID0gW107XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIG1hcHBlZCA9IFtdO1xuICAgICAgICBsZW4gPSAwO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG5ld0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgaXRlbXMubGVuZ3RoICYmIGl0ZW1zW2ldICE9PSBuZXdJdGVtc1tpXSkge1xuICAgICAgICAgIHNpZ25hbHNbaV0oKCkgPT4gbmV3SXRlbXNbaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgbWFwcGVkW2ldID0gY3JlYXRlUm9vdChtYXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRpc3Bvc2Vyc1tpXSgpO1xuICAgICAgfVxuICAgICAgbGVuID0gc2lnbmFscy5sZW5ndGggPSBkaXNwb3NlcnMubGVuZ3RoID0gbmV3TGVuO1xuICAgICAgaXRlbXMgPSBuZXdJdGVtcy5zbGljZSgwKTtcbiAgICAgIHJldHVybiBtYXBwZWQgPSBtYXBwZWQuc2xpY2UoMCwgbGVuKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBtYXBwZXIoZGlzcG9zZXIpIHtcbiAgICAgIGRpc3Bvc2Vyc1tpXSA9IGRpc3Bvc2VyO1xuICAgICAgY29uc3QgW3MsIHNldF0gPSBjcmVhdGVTaWduYWwobmV3SXRlbXNbaV0pO1xuICAgICAgc2lnbmFsc1tpXSA9IHNldDtcbiAgICAgIHJldHVybiBtYXBGbihzLCBpKTtcbiAgICB9XG4gIH07XG59XG5cbmxldCBoeWRyYXRpb25FbmFibGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbmFibGVIeWRyYXRpb24oKSB7XG4gIGh5ZHJhdGlvbkVuYWJsZWQgPSB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KENvbXAsIHByb3BzKSB7XG4gIGlmIChoeWRyYXRpb25FbmFibGVkKSB7XG4gICAgaWYgKHNoYXJlZENvbmZpZy5jb250ZXh0KSB7XG4gICAgICBjb25zdCBjID0gc2hhcmVkQ29uZmlnLmNvbnRleHQ7XG4gICAgICBzZXRIeWRyYXRlQ29udGV4dChuZXh0SHlkcmF0ZUNvbnRleHQoKSk7XG4gICAgICBjb25zdCByID0gdW50cmFjaygoKSA9PiBDb21wKHByb3BzIHx8IHt9KSk7XG4gICAgICBzZXRIeWRyYXRlQ29udGV4dChjKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW50cmFjaygoKSA9PiBDb21wKHByb3BzIHx8IHt9KSk7XG59XG5mdW5jdGlvbiB0cnVlRm4oKSB7XG4gIHJldHVybiB0cnVlO1xufVxuY29uc3QgcHJvcFRyYXBzID0ge1xuICBnZXQoXywgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkUFJPWFkpIHJldHVybiByZWNlaXZlcjtcbiAgICByZXR1cm4gXy5nZXQocHJvcGVydHkpO1xuICB9LFxuICBoYXMoXywgcHJvcGVydHkpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICRQUk9YWSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIF8uaGFzKHByb3BlcnR5KTtcbiAgfSxcbiAgc2V0OiB0cnVlRm4sXG4gIGRlbGV0ZVByb3BlcnR5OiB0cnVlRm4sXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihfLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gXy5nZXQocHJvcGVydHkpO1xuICAgICAgfSxcbiAgICAgIHNldDogdHJ1ZUZuLFxuICAgICAgZGVsZXRlUHJvcGVydHk6IHRydWVGblxuICAgIH07XG4gIH0sXG4gIG93bktleXMoXykge1xuICAgIHJldHVybiBfLmtleXMoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVTb3VyY2Uocykge1xuICByZXR1cm4gIShzID0gdHlwZW9mIHMgPT09IFwiZnVuY3Rpb25cIiA/IHMoKSA6IHMpID8ge30gOiBzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZXMoKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSB0aGlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgdiA9IHRoaXNbaV0oKTtcbiAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdjtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5zb3VyY2VzKSB7XG4gIGxldCBwcm94eSA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzID0gc291cmNlc1tpXTtcbiAgICBwcm94eSA9IHByb3h5IHx8ICEhcyAmJiAkUFJPWFkgaW4gcztcbiAgICBzb3VyY2VzW2ldID0gdHlwZW9mIHMgPT09IFwiZnVuY3Rpb25cIiA/IChwcm94eSA9IHRydWUsIGNyZWF0ZU1lbW8ocykpIDogcztcbiAgfVxuICBpZiAoU1VQUE9SVFNfUFJPWFkgJiYgcHJveHkpIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KHtcbiAgICAgIGdldChwcm9wZXJ0eSkge1xuICAgICAgICBmb3IgKGxldCBpID0gc291cmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHYgPSByZXNvbHZlU291cmNlKHNvdXJjZXNbaV0pW3Byb3BlcnR5XTtcbiAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhcyhwcm9wZXJ0eSkge1xuICAgICAgICBmb3IgKGxldCBpID0gc291cmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0eSBpbiByZXNvbHZlU291cmNlKHNvdXJjZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAga2V5cygpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIGtleXMucHVzaCguLi5PYmplY3Qua2V5cyhyZXNvbHZlU291cmNlKHNvdXJjZXNbaV0pKSk7XG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChrZXlzKV07XG4gICAgICB9XG4gICAgfSwgcHJvcFRyYXBzKTtcbiAgfVxuICBjb25zdCBzb3VyY2VzTWFwID0ge307XG4gIGNvbnN0IGRlZmluZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGxldCBpID0gc291cmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFzb3VyY2UpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHNvdXJjZUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpO1xuICAgIGZvciAobGV0IGkgPSBzb3VyY2VLZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIiB8fCBrZXkgPT09IFwiY29uc3RydWN0b3JcIikgY29udGludWU7XG4gICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG4gICAgICBpZiAoIWRlZmluZWRba2V5XSkge1xuICAgICAgICBkZWZpbmVkW2tleV0gPSBkZXNjLmdldCA/IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IHJlc29sdmVTb3VyY2VzLmJpbmQoc291cmNlc01hcFtrZXldID0gW2Rlc2MuZ2V0LmJpbmQoc291cmNlKV0pXG4gICAgICAgIH0gOiBkZXNjLnZhbHVlICE9PSB1bmRlZmluZWQgPyBkZXNjIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc291cmNlcyA9IHNvdXJjZXNNYXBba2V5XTtcbiAgICAgICAgaWYgKHNvdXJjZXMpIHtcbiAgICAgICAgICBpZiAoZGVzYy5nZXQpIHNvdXJjZXMucHVzaChkZXNjLmdldC5iaW5kKHNvdXJjZSkpO2Vsc2UgaWYgKGRlc2MudmFsdWUgIT09IHVuZGVmaW5lZCkgc291cmNlcy5wdXNoKCgpID0+IGRlc2MudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBjb25zdCBkZWZpbmVkS2V5cyA9IE9iamVjdC5rZXlzKGRlZmluZWQpO1xuICBmb3IgKGxldCBpID0gZGVmaW5lZEtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBrZXkgPSBkZWZpbmVkS2V5c1tpXSxcbiAgICAgIGRlc2MgPSBkZWZpbmVkW2tleV07XG4gICAgaWYgKGRlc2MgJiYgZGVzYy5nZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSB0YXJnZXRba2V5XSA9IGRlc2MgPyBkZXNjLnZhbHVlIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzcGxpdFByb3BzKHByb3BzLCAuLi5rZXlzKSB7XG4gIGlmIChTVVBQT1JUU19QUk9YWSAmJiAkUFJPWFkgaW4gcHJvcHMpIHtcbiAgICBjb25zdCBibG9ja2VkID0gbmV3IFNldChrZXlzLmxlbmd0aCA+IDEgPyBrZXlzLmZsYXQoKSA6IGtleXNbMF0pO1xuICAgIGNvbnN0IHJlcyA9IGtleXMubWFwKGsgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm94eSh7XG4gICAgICAgIGdldChwcm9wZXJ0eSkge1xuICAgICAgICAgIHJldHVybiBrLmluY2x1ZGVzKHByb3BlcnR5KSA/IHByb3BzW3Byb3BlcnR5XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzKHByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0dXJuIGsuaW5jbHVkZXMocHJvcGVydHkpICYmIHByb3BlcnR5IGluIHByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBrZXlzKCkge1xuICAgICAgICAgIHJldHVybiBrLmZpbHRlcihwcm9wZXJ0eSA9PiBwcm9wZXJ0eSBpbiBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHByb3BUcmFwcyk7XG4gICAgfSk7XG4gICAgcmVzLnB1c2gobmV3IFByb3h5KHtcbiAgICAgIGdldChwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gYmxvY2tlZC5oYXMocHJvcGVydHkpID8gdW5kZWZpbmVkIDogcHJvcHNbcHJvcGVydHldO1xuICAgICAgfSxcbiAgICAgIGhhcyhwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gYmxvY2tlZC5oYXMocHJvcGVydHkpID8gZmFsc2UgOiBwcm9wZXJ0eSBpbiBwcm9wcztcbiAgICAgIH0sXG4gICAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihrID0+ICFibG9ja2VkLmhhcyhrKSk7XG4gICAgICB9XG4gICAgfSwgcHJvcFRyYXBzKSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBjb25zdCBvdGhlck9iamVjdCA9IHt9O1xuICBjb25zdCBvYmplY3RzID0ga2V5cy5tYXAoKCkgPT4gKHt9KSk7XG4gIGZvciAoY29uc3QgcHJvcE5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcHMpKSB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvcHMsIHByb3BOYW1lKTtcbiAgICBjb25zdCBpc0RlZmF1bHREZXNjID0gIWRlc2MuZ2V0ICYmICFkZXNjLnNldCAmJiBkZXNjLmVudW1lcmFibGUgJiYgZGVzYy53cml0YWJsZSAmJiBkZXNjLmNvbmZpZ3VyYWJsZTtcbiAgICBsZXQgYmxvY2tlZCA9IGZhbHNlO1xuICAgIGxldCBvYmplY3RJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgIGlmIChrLmluY2x1ZGVzKHByb3BOYW1lKSkge1xuICAgICAgICBibG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgaXNEZWZhdWx0RGVzYyA/IG9iamVjdHNbb2JqZWN0SW5kZXhdW3Byb3BOYW1lXSA9IGRlc2MudmFsdWUgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0c1tvYmplY3RJbmRleF0sIHByb3BOYW1lLCBkZXNjKTtcbiAgICAgIH1cbiAgICAgICsrb2JqZWN0SW5kZXg7XG4gICAgfVxuICAgIGlmICghYmxvY2tlZCkge1xuICAgICAgaXNEZWZhdWx0RGVzYyA/IG90aGVyT2JqZWN0W3Byb3BOYW1lXSA9IGRlc2MudmFsdWUgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3RoZXJPYmplY3QsIHByb3BOYW1lLCBkZXNjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5vYmplY3RzLCBvdGhlck9iamVjdF07XG59XG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gIGxldCBjb21wO1xuICBsZXQgcDtcbiAgY29uc3Qgd3JhcCA9IHByb3BzID0+IHtcbiAgICBjb25zdCBjdHggPSBzaGFyZWRDb25maWcuY29udGV4dDtcbiAgICBpZiAoY3R4KSB7XG4gICAgICBjb25zdCBbcywgc2V0XSA9IGNyZWF0ZVNpZ25hbCgpO1xuICAgICAgc2hhcmVkQ29uZmlnLmNvdW50IHx8IChzaGFyZWRDb25maWcuY291bnQgPSAwKTtcbiAgICAgIHNoYXJlZENvbmZpZy5jb3VudCsrO1xuICAgICAgKHAgfHwgKHAgPSBmbigpKSkudGhlbihtb2QgPT4ge1xuICAgICAgICAhc2hhcmVkQ29uZmlnLmRvbmUgJiYgc2V0SHlkcmF0ZUNvbnRleHQoY3R4KTtcbiAgICAgICAgc2hhcmVkQ29uZmlnLmNvdW50LS07XG4gICAgICAgIHNldCgoKSA9PiBtb2QuZGVmYXVsdCk7XG4gICAgICAgIHNldEh5ZHJhdGVDb250ZXh0KCk7XG4gICAgICB9KTtcbiAgICAgIGNvbXAgPSBzO1xuICAgIH0gZWxzZSBpZiAoIWNvbXApIHtcbiAgICAgIGNvbnN0IFtzXSA9IGNyZWF0ZVJlc291cmNlKCgpID0+IChwIHx8IChwID0gZm4oKSkpLnRoZW4obW9kID0+IG1vZC5kZWZhdWx0KSk7XG4gICAgICBjb21wID0gcztcbiAgICB9XG4gICAgbGV0IENvbXA7XG4gICAgcmV0dXJuIGNyZWF0ZU1lbW8oKCkgPT4gKENvbXAgPSBjb21wKCkpID8gdW50cmFjaygoKSA9PiB7XG4gICAgICBpZiAoSVNfREVWKSA7XG4gICAgICBpZiAoIWN0eCB8fCBzaGFyZWRDb25maWcuZG9uZSkgcmV0dXJuIENvbXAocHJvcHMpO1xuICAgICAgY29uc3QgYyA9IHNoYXJlZENvbmZpZy5jb250ZXh0O1xuICAgICAgc2V0SHlkcmF0ZUNvbnRleHQoY3R4KTtcbiAgICAgIGNvbnN0IHIgPSBDb21wKHByb3BzKTtcbiAgICAgIHNldEh5ZHJhdGVDb250ZXh0KGMpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSkgOiBcIlwiKTtcbiAgfTtcbiAgd3JhcC5wcmVsb2FkID0gKCkgPT4gcCB8fCAoKHAgPSBmbigpKS50aGVuKG1vZCA9PiBjb21wID0gKCkgPT4gbW9kLmRlZmF1bHQpLCBwKTtcbiAgcmV0dXJuIHdyYXA7XG59XG5sZXQgY291bnRlciA9IDA7XG5mdW5jdGlvbiBjcmVhdGVVbmlxdWVJZCgpIHtcbiAgY29uc3QgY3R4ID0gc2hhcmVkQ29uZmlnLmNvbnRleHQ7XG4gIHJldHVybiBjdHggPyBzaGFyZWRDb25maWcuZ2V0TmV4dENvbnRleHRJZCgpIDogYGNsLSR7Y291bnRlcisrfWA7XG59XG5cbmNvbnN0IG5hcnJvd2VkRXJyb3IgPSBuYW1lID0+IGBTdGFsZSByZWFkIGZyb20gPCR7bmFtZX0+LmA7XG5mdW5jdGlvbiBGb3IocHJvcHMpIHtcbiAgY29uc3QgZmFsbGJhY2sgPSBcImZhbGxiYWNrXCIgaW4gcHJvcHMgJiYge1xuICAgIGZhbGxiYWNrOiAoKSA9PiBwcm9wcy5mYWxsYmFja1xuICB9O1xuICByZXR1cm4gY3JlYXRlTWVtbyhtYXBBcnJheSgoKSA9PiBwcm9wcy5lYWNoLCBwcm9wcy5jaGlsZHJlbiwgZmFsbGJhY2sgfHwgdW5kZWZpbmVkKSk7XG59XG5mdW5jdGlvbiBJbmRleChwcm9wcykge1xuICBjb25zdCBmYWxsYmFjayA9IFwiZmFsbGJhY2tcIiBpbiBwcm9wcyAmJiB7XG4gICAgZmFsbGJhY2s6ICgpID0+IHByb3BzLmZhbGxiYWNrXG4gIH07XG4gIHJldHVybiBjcmVhdGVNZW1vKGluZGV4QXJyYXkoKCkgPT4gcHJvcHMuZWFjaCwgcHJvcHMuY2hpbGRyZW4sIGZhbGxiYWNrIHx8IHVuZGVmaW5lZCkpO1xufVxuZnVuY3Rpb24gU2hvdyhwcm9wcykge1xuICBjb25zdCBrZXllZCA9IHByb3BzLmtleWVkO1xuICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IGNyZWF0ZU1lbW8oKCkgPT4gcHJvcHMud2hlbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICBjb25zdCBjb25kaXRpb24gPSBrZXllZCA/IGNvbmRpdGlvblZhbHVlIDogY3JlYXRlTWVtbyhjb25kaXRpb25WYWx1ZSwgdW5kZWZpbmVkLCB7XG4gICAgZXF1YWxzOiAoYSwgYikgPT4gIWEgPT09ICFiXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgYyA9IGNvbmRpdGlvbigpO1xuICAgIGlmIChjKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgY29uc3QgZm4gPSB0eXBlb2YgY2hpbGQgPT09IFwiZnVuY3Rpb25cIiAmJiBjaGlsZC5sZW5ndGggPiAwO1xuICAgICAgcmV0dXJuIGZuID8gdW50cmFjaygoKSA9PiBjaGlsZChrZXllZCA/IGMgOiAoKSA9PiB7XG4gICAgICAgIGlmICghdW50cmFjayhjb25kaXRpb24pKSB0aHJvdyBuYXJyb3dlZEVycm9yKFwiU2hvd1wiKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvblZhbHVlKCk7XG4gICAgICB9KSkgOiBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzLmZhbGxiYWNrO1xuICB9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBTd2l0Y2gocHJvcHMpIHtcbiAgY29uc3QgY2hzID0gY2hpbGRyZW4oKCkgPT4gcHJvcHMuY2hpbGRyZW4pO1xuICBjb25zdCBzd2l0Y2hGdW5jID0gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgY2ggPSBjaHMoKTtcbiAgICBjb25zdCBtcHMgPSBBcnJheS5pc0FycmF5KGNoKSA/IGNoIDogW2NoXTtcbiAgICBsZXQgZnVuYyA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBpO1xuICAgICAgY29uc3QgbXAgPSBtcHNbaV07XG4gICAgICBjb25zdCBwcmV2RnVuYyA9IGZ1bmM7XG4gICAgICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IGNyZWF0ZU1lbW8oKCkgPT4gcHJldkZ1bmMoKSA/IHVuZGVmaW5lZCA6IG1wLndoZW4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IG1wLmtleWVkID8gY29uZGl0aW9uVmFsdWUgOiBjcmVhdGVNZW1vKGNvbmRpdGlvblZhbHVlLCB1bmRlZmluZWQsIHtcbiAgICAgICAgZXF1YWxzOiAoYSwgYikgPT4gIWEgPT09ICFiXG4gICAgICB9KTtcbiAgICAgIGZ1bmMgPSAoKSA9PiBwcmV2RnVuYygpIHx8IChjb25kaXRpb24oKSA/IFtpbmRleCwgY29uZGl0aW9uVmFsdWUsIG1wXSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jO1xuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHNlbCA9IHN3aXRjaEZ1bmMoKSgpO1xuICAgIGlmICghc2VsKSByZXR1cm4gcHJvcHMuZmFsbGJhY2s7XG4gICAgY29uc3QgW2luZGV4LCBjb25kaXRpb25WYWx1ZSwgbXBdID0gc2VsO1xuICAgIGNvbnN0IGNoaWxkID0gbXAuY2hpbGRyZW47XG4gICAgY29uc3QgZm4gPSB0eXBlb2YgY2hpbGQgPT09IFwiZnVuY3Rpb25cIiAmJiBjaGlsZC5sZW5ndGggPiAwO1xuICAgIHJldHVybiBmbiA/IHVudHJhY2soKCkgPT4gY2hpbGQobXAua2V5ZWQgPyBjb25kaXRpb25WYWx1ZSgpIDogKCkgPT4ge1xuICAgICAgaWYgKHVudHJhY2soc3dpdGNoRnVuYykoKT8uWzBdICE9PSBpbmRleCkgdGhyb3cgbmFycm93ZWRFcnJvcihcIk1hdGNoXCIpO1xuICAgICAgcmV0dXJuIGNvbmRpdGlvblZhbHVlKCk7XG4gICAgfSkpIDogY2hpbGQ7XG4gIH0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIE1hdGNoKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcztcbn1cbmxldCBFcnJvcnM7XG5mdW5jdGlvbiByZXNldEVycm9yQm91bmRhcmllcygpIHtcbiAgRXJyb3JzICYmIFsuLi5FcnJvcnNdLmZvckVhY2goZm4gPT4gZm4oKSk7XG59XG5mdW5jdGlvbiBFcnJvckJvdW5kYXJ5KHByb3BzKSB7XG4gIGxldCBlcnI7XG4gIGlmIChzaGFyZWRDb25maWcuY29udGV4dCAmJiBzaGFyZWRDb25maWcubG9hZCkgZXJyID0gc2hhcmVkQ29uZmlnLmxvYWQoc2hhcmVkQ29uZmlnLmdldENvbnRleHRJZCgpKTtcbiAgY29uc3QgW2Vycm9yZWQsIHNldEVycm9yZWRdID0gY3JlYXRlU2lnbmFsKGVyciwgdW5kZWZpbmVkKTtcbiAgRXJyb3JzIHx8IChFcnJvcnMgPSBuZXcgU2V0KCkpO1xuICBFcnJvcnMuYWRkKHNldEVycm9yZWQpO1xuICBvbkNsZWFudXAoKCkgPT4gRXJyb3JzLmRlbGV0ZShzZXRFcnJvcmVkKSk7XG4gIHJldHVybiBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICBsZXQgZTtcbiAgICBpZiAoZSA9IGVycm9yZWQoKSkge1xuICAgICAgY29uc3QgZiA9IHByb3BzLmZhbGxiYWNrO1xuICAgICAgcmV0dXJuIHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCIgJiYgZi5sZW5ndGggPyB1bnRyYWNrKCgpID0+IGYoZSwgKCkgPT4gc2V0RXJyb3JlZCgpKSkgOiBmO1xuICAgIH1cbiAgICByZXR1cm4gY2F0Y2hFcnJvcigoKSA9PiBwcm9wcy5jaGlsZHJlbiwgc2V0RXJyb3JlZCk7XG4gIH0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn1cblxuY29uc3Qgc3VzcGVuc2VMaXN0RXF1YWxzID0gKGEsIGIpID0+IGEuc2hvd0NvbnRlbnQgPT09IGIuc2hvd0NvbnRlbnQgJiYgYS5zaG93RmFsbGJhY2sgPT09IGIuc2hvd0ZhbGxiYWNrO1xuY29uc3QgU3VzcGVuc2VMaXN0Q29udGV4dCA9IC8qICNfX1BVUkVfXyAqL2NyZWF0ZUNvbnRleHQoKTtcbmZ1bmN0aW9uIFN1c3BlbnNlTGlzdChwcm9wcykge1xuICBsZXQgW3dyYXBwZXIsIHNldFdyYXBwZXJdID0gY3JlYXRlU2lnbmFsKCgpID0+ICh7XG4gICAgICBpbkZhbGxiYWNrOiBmYWxzZVxuICAgIH0pKSxcbiAgICBzaG93O1xuICBjb25zdCBsaXN0Q29udGV4dCA9IHVzZUNvbnRleHQoU3VzcGVuc2VMaXN0Q29udGV4dCk7XG4gIGNvbnN0IFtyZWdpc3RyeSwgc2V0UmVnaXN0cnldID0gY3JlYXRlU2lnbmFsKFtdKTtcbiAgaWYgKGxpc3RDb250ZXh0KSB7XG4gICAgc2hvdyA9IGxpc3RDb250ZXh0LnJlZ2lzdGVyKGNyZWF0ZU1lbW8oKCkgPT4gd3JhcHBlcigpKCkuaW5GYWxsYmFjaykpO1xuICB9XG4gIGNvbnN0IHJlc29sdmVkID0gY3JlYXRlTWVtbyhwcmV2ID0+IHtcbiAgICBjb25zdCByZXZlYWwgPSBwcm9wcy5yZXZlYWxPcmRlcixcbiAgICAgIHRhaWwgPSBwcm9wcy50YWlsLFxuICAgICAge1xuICAgICAgICBzaG93Q29udGVudCA9IHRydWUsXG4gICAgICAgIHNob3dGYWxsYmFjayA9IHRydWVcbiAgICAgIH0gPSBzaG93ID8gc2hvdygpIDoge30sXG4gICAgICByZWcgPSByZWdpc3RyeSgpLFxuICAgICAgcmV2ZXJzZSA9IHJldmVhbCA9PT0gXCJiYWNrd2FyZHNcIjtcbiAgICBpZiAocmV2ZWFsID09PSBcInRvZ2V0aGVyXCIpIHtcbiAgICAgIGNvbnN0IGFsbCA9IHJlZy5ldmVyeShpbkZhbGxiYWNrID0+ICFpbkZhbGxiYWNrKCkpO1xuICAgICAgY29uc3QgcmVzID0gcmVnLm1hcCgoKSA9PiAoe1xuICAgICAgICBzaG93Q29udGVudDogYWxsICYmIHNob3dDb250ZW50LFxuICAgICAgICBzaG93RmFsbGJhY2tcbiAgICAgIH0pKTtcbiAgICAgIHJlcy5pbkZhbGxiYWNrID0gIWFsbDtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGxldCBzdG9wID0gZmFsc2U7XG4gICAgbGV0IGluRmFsbGJhY2sgPSBwcmV2LmluRmFsbGJhY2s7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJlZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgbiA9IHJldmVyc2UgPyBsZW4gLSBpIC0gMSA6IGksXG4gICAgICAgIHMgPSByZWdbbl0oKTtcbiAgICAgIGlmICghc3RvcCAmJiAhcykge1xuICAgICAgICByZXNbbl0gPSB7XG4gICAgICAgICAgc2hvd0NvbnRlbnQsXG4gICAgICAgICAgc2hvd0ZhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXh0ID0gIXN0b3A7XG4gICAgICAgIGlmIChuZXh0KSBpbkZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgcmVzW25dID0ge1xuICAgICAgICAgIHNob3dDb250ZW50OiBuZXh0LFxuICAgICAgICAgIHNob3dGYWxsYmFjazogIXRhaWwgfHwgbmV4dCAmJiB0YWlsID09PSBcImNvbGxhcHNlZFwiID8gc2hvd0ZhbGxiYWNrIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RvcCkgaW5GYWxsYmFjayA9IGZhbHNlO1xuICAgIHJlcy5pbkZhbGxiYWNrID0gaW5GYWxsYmFjaztcbiAgICByZXR1cm4gcmVzO1xuICB9LCB7XG4gICAgaW5GYWxsYmFjazogZmFsc2VcbiAgfSk7XG4gIHNldFdyYXBwZXIoKCkgPT4gcmVzb2x2ZWQpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN1c3BlbnNlTGlzdENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgcmVnaXN0ZXI6IGluRmFsbGJhY2sgPT4ge1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIHNldFJlZ2lzdHJ5KHJlZ2lzdHJ5ID0+IHtcbiAgICAgICAgICBpbmRleCA9IHJlZ2lzdHJ5Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gWy4uLnJlZ2lzdHJ5LCBpbkZhbGxiYWNrXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVNZW1vKCgpID0+IHJlc29sdmVkKClbaW5kZXhdLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICBlcXVhbHM6IHN1c3BlbnNlTGlzdEVxdWFsc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gU3VzcGVuc2UocHJvcHMpIHtcbiAgbGV0IGNvdW50ZXIgPSAwLFxuICAgIHNob3csXG4gICAgY3R4LFxuICAgIHAsXG4gICAgZmxpY2tlcixcbiAgICBlcnJvcjtcbiAgY29uc3QgW2luRmFsbGJhY2ssIHNldEZhbGxiYWNrXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSksXG4gICAgU3VzcGVuc2VDb250ZXh0ID0gZ2V0U3VzcGVuc2VDb250ZXh0KCksXG4gICAgc3RvcmUgPSB7XG4gICAgICBpbmNyZW1lbnQ6ICgpID0+IHtcbiAgICAgICAgaWYgKCsrY291bnRlciA9PT0gMSkgc2V0RmFsbGJhY2sodHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZGVjcmVtZW50OiAoKSA9PiB7XG4gICAgICAgIGlmICgtLWNvdW50ZXIgPT09IDApIHNldEZhbGxiYWNrKGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBpbkZhbGxiYWNrLFxuICAgICAgZWZmZWN0czogW10sXG4gICAgICByZXNvbHZlZDogZmFsc2VcbiAgICB9LFxuICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgaWYgKHNoYXJlZENvbmZpZy5jb250ZXh0ICYmIHNoYXJlZENvbmZpZy5sb2FkKSB7XG4gICAgY29uc3Qga2V5ID0gc2hhcmVkQ29uZmlnLmdldENvbnRleHRJZCgpO1xuICAgIGxldCByZWYgPSBzaGFyZWRDb25maWcubG9hZChrZXkpO1xuICAgIGlmIChyZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVmICE9PSBcIm9iamVjdFwiIHx8IHJlZi5zICE9PSAxKSBwID0gcmVmO2Vsc2Ugc2hhcmVkQ29uZmlnLmdhdGhlcihrZXkpO1xuICAgIH1cbiAgICBpZiAocCAmJiBwICE9PSBcIiQkZlwiKSB7XG4gICAgICBjb25zdCBbcywgc2V0XSA9IGNyZWF0ZVNpZ25hbCh1bmRlZmluZWQsIHtcbiAgICAgICAgZXF1YWxzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBmbGlja2VyID0gcztcbiAgICAgIHAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChzaGFyZWRDb25maWcuZG9uZSkgcmV0dXJuIHNldCgpO1xuICAgICAgICBzaGFyZWRDb25maWcuZ2F0aGVyKGtleSk7XG4gICAgICAgIHNldEh5ZHJhdGVDb250ZXh0KGN0eCk7XG4gICAgICAgIHNldCgpO1xuICAgICAgICBzZXRIeWRyYXRlQ29udGV4dCgpO1xuICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgIHNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGxpc3RDb250ZXh0ID0gdXNlQ29udGV4dChTdXNwZW5zZUxpc3RDb250ZXh0KTtcbiAgaWYgKGxpc3RDb250ZXh0KSBzaG93ID0gbGlzdENvbnRleHQucmVnaXN0ZXIoc3RvcmUuaW5GYWxsYmFjayk7XG4gIGxldCBkaXNwb3NlO1xuICBvbkNsZWFudXAoKCkgPT4gZGlzcG9zZSAmJiBkaXNwb3NlKCkpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN1c3BlbnNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdG9yZSxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICAgIGN0eCA9IHNoYXJlZENvbmZpZy5jb250ZXh0O1xuICAgICAgICBpZiAoZmxpY2tlcikge1xuICAgICAgICAgIGZsaWNrZXIoKTtcbiAgICAgICAgICByZXR1cm4gZmxpY2tlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4ICYmIHAgPT09IFwiJCRmXCIpIHNldEh5ZHJhdGVDb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlTWVtbygoKSA9PiBwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybiBjcmVhdGVNZW1vKHByZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IGluRmFsbGJhY2sgPSBzdG9yZS5pbkZhbGxiYWNrKCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNob3dDb250ZW50ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgc2hvd0ZhbGxiYWNrID0gdHJ1ZVxuICAgICAgICAgICAgfSA9IHNob3cgPyBzaG93KCkgOiB7fTtcbiAgICAgICAgICBpZiAoKCFpbkZhbGxiYWNrIHx8IHAgJiYgcCAhPT0gXCIkJGZcIikgJiYgc2hvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHN0b3JlLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpc3Bvc2UgJiYgZGlzcG9zZSgpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IGN0eCA9IHAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXN1bWVFZmZlY3RzKHN0b3JlLmVmZmVjdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2hvd0ZhbGxiYWNrKSByZXR1cm47XG4gICAgICAgICAgaWYgKGRpc3Bvc2UpIHJldHVybiBwcmV2O1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSb290KGRpc3Bvc2VyID0+IHtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSBkaXNwb3NlcjtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgc2V0SHlkcmF0ZUNvbnRleHQoe1xuICAgICAgICAgICAgICAgIGlkOiBjdHguaWQgKyBcIkZcIixcbiAgICAgICAgICAgICAgICBjb3VudDogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmZhbGxiYWNrO1xuICAgICAgICAgIH0sIG93bmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBERVYgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCB7ICRERVZDT01QLCAkUFJPWFksICRUUkFDSywgREVWLCBFcnJvckJvdW5kYXJ5LCBGb3IsIEluZGV4LCBNYXRjaCwgU2hvdywgU3VzcGVuc2UsIFN1c3BlbnNlTGlzdCwgU3dpdGNoLCBiYXRjaCwgY2FuY2VsQ2FsbGJhY2ssIGNhdGNoRXJyb3IsIGNoaWxkcmVuLCBjcmVhdGVDb21wb25lbnQsIGNyZWF0ZUNvbXB1dGVkLCBjcmVhdGVDb250ZXh0LCBjcmVhdGVEZWZlcnJlZCwgY3JlYXRlRWZmZWN0LCBjcmVhdGVNZW1vLCBjcmVhdGVSZWFjdGlvbiwgY3JlYXRlUmVuZGVyRWZmZWN0LCBjcmVhdGVSZXNvdXJjZSwgY3JlYXRlUm9vdCwgY3JlYXRlU2VsZWN0b3IsIGNyZWF0ZVNpZ25hbCwgY3JlYXRlVW5pcXVlSWQsIGVuYWJsZUV4dGVybmFsU291cmNlLCBlbmFibGVIeWRyYXRpb24sIGVuYWJsZVNjaGVkdWxpbmcsIGVxdWFsRm4sIGZyb20sIGdldExpc3RlbmVyLCBnZXRPd25lciwgaW5kZXhBcnJheSwgbGF6eSwgbWFwQXJyYXksIG1lcmdlUHJvcHMsIG9ic2VydmFibGUsIG9uLCBvbkNsZWFudXAsIG9uRXJyb3IsIG9uTW91bnQsIHJlcXVlc3RDYWxsYmFjaywgcmVzZXRFcnJvckJvdW5kYXJpZXMsIHJ1bldpdGhPd25lciwgc2hhcmVkQ29uZmlnLCBzcGxpdFByb3BzLCBzdGFydFRyYW5zaXRpb24sIHVudHJhY2ssIHVzZUNvbnRleHQsIHVzZVRyYW5zaXRpb24gfTtcbiIsImltcG9ydCB7IGNyZWF0ZU1lbW8sIGNyZWF0ZVJvb3QsIGNyZWF0ZVJlbmRlckVmZmVjdCwgdW50cmFjaywgc2hhcmVkQ29uZmlnLCBlbmFibGVIeWRyYXRpb24sIGdldE93bmVyLCBjcmVhdGVFZmZlY3QsIHJ1bldpdGhPd25lciwgY3JlYXRlU2lnbmFsLCBvbkNsZWFudXAsIHNwbGl0UHJvcHMgfSBmcm9tICdzb2xpZC1qcyc7XG5leHBvcnQgeyBFcnJvckJvdW5kYXJ5LCBGb3IsIEluZGV4LCBNYXRjaCwgU2hvdywgU3VzcGVuc2UsIFN1c3BlbnNlTGlzdCwgU3dpdGNoLCBjcmVhdGVDb21wb25lbnQsIGNyZWF0ZVJlbmRlckVmZmVjdCBhcyBlZmZlY3QsIGdldE93bmVyLCBtZXJnZVByb3BzLCB1bnRyYWNrIH0gZnJvbSAnc29saWQtanMnO1xuXG5jb25zdCBib29sZWFucyA9IFtcImFsbG93ZnVsbHNjcmVlblwiLCBcImFzeW5jXCIsIFwiYWxwaGFcIixcblwiYXV0b2ZvY3VzXCIsXG5cImF1dG9wbGF5XCIsIFwiY2hlY2tlZFwiLCBcImNvbnRyb2xzXCIsIFwiZGVmYXVsdFwiLCBcImRpc2FibGVkXCIsIFwiZm9ybW5vdmFsaWRhdGVcIiwgXCJoaWRkZW5cIixcblwiaW5kZXRlcm1pbmF0ZVwiLCBcImluZXJ0XCIsXG5cImlzbWFwXCIsIFwibG9vcFwiLCBcIm11bHRpcGxlXCIsIFwibXV0ZWRcIiwgXCJub21vZHVsZVwiLCBcIm5vdmFsaWRhdGVcIiwgXCJvcGVuXCIsIFwicGxheXNpbmxpbmVcIiwgXCJyZWFkb25seVwiLCBcInJlcXVpcmVkXCIsIFwicmV2ZXJzZWRcIiwgXCJzZWFtbGVzc1wiLFxuXCJzZWxlY3RlZFwiLCBcImFkYXVjdGlvbmhlYWRlcnNcIixcblwiYnJvd3Npbmd0b3BpY3NcIixcblwiY3JlZGVudGlhbGxlc3NcIixcblwiZGVmYXVsdGNoZWNrZWRcIiwgXCJkZWZhdWx0bXV0ZWRcIiwgXCJkZWZhdWx0c2VsZWN0ZWRcIiwgXCJkZWZlclwiLCBcImRpc2FibGVwaWN0dXJlaW5waWN0dXJlXCIsIFwiZGlzYWJsZXJlbW90ZXBsYXliYWNrXCIsIFwicHJlc2VydmVzcGl0Y2hcIixcblwic2hhZG93cm9vdGNsb25hYmxlXCIsIFwic2hhZG93cm9vdGN1c3RvbWVsZW1lbnRyZWdpc3RyeVwiLFxuXCJzaGFkb3dyb290ZGVsZWdhdGVzZm9jdXNcIiwgXCJzaGFkb3dyb290c2VyaWFsaXphYmxlXCIsXG5cInNoYXJlZHN0b3JhZ2V3cml0YWJsZVwiXG5dO1xuY29uc3QgUHJvcGVydGllcyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFtcblwiY2xhc3NOYW1lXCIsIFwidmFsdWVcIixcblwicmVhZE9ubHlcIiwgXCJub1ZhbGlkYXRlXCIsIFwiZm9ybU5vVmFsaWRhdGVcIiwgXCJpc01hcFwiLCBcIm5vTW9kdWxlXCIsIFwicGxheXNJbmxpbmVcIiwgXCJhZEF1Y3Rpb25IZWFkZXJzXCIsXG5cImFsbG93RnVsbHNjcmVlblwiLCBcImJyb3dzaW5nVG9waWNzXCIsXG5cImRlZmF1bHRDaGVja2VkXCIsIFwiZGVmYXVsdE11dGVkXCIsIFwiZGVmYXVsdFNlbGVjdGVkXCIsIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIiwgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIiwgXCJwcmVzZXJ2ZXNQaXRjaFwiLCBcInNoYWRvd1Jvb3RDbG9uYWJsZVwiLCBcInNoYWRvd1Jvb3RDdXN0b21FbGVtZW50UmVnaXN0cnlcIixcblwic2hhZG93Um9vdERlbGVnYXRlc0ZvY3VzXCIsIFwic2hhZG93Um9vdFNlcmlhbGl6YWJsZVwiLFxuXCJzaGFyZWRTdG9yYWdlV3JpdGFibGVcIixcbi4uLmJvb2xlYW5zXSk7XG5jb25zdCBDaGlsZFByb3BlcnRpZXMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbXCJpbm5lckhUTUxcIiwgXCJ0ZXh0Q29udGVudFwiLCBcImlubmVyVGV4dFwiLCBcImNoaWxkcmVuXCJdKTtcbmNvbnN0IEFsaWFzZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIGNsYXNzTmFtZTogXCJjbGFzc1wiLFxuICBodG1sRm9yOiBcImZvclwiXG59KTtcbmNvbnN0IFByb3BBbGlhc2VzID0gLyojX19QVVJFX18qL09iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBjbGFzczogXCJjbGFzc05hbWVcIixcbiAgbm92YWxpZGF0ZToge1xuICAgICQ6IFwibm9WYWxpZGF0ZVwiLFxuICAgIEZPUk06IDFcbiAgfSxcbiAgZm9ybW5vdmFsaWRhdGU6IHtcbiAgICAkOiBcImZvcm1Ob1ZhbGlkYXRlXCIsXG4gICAgQlVUVE9OOiAxLFxuICAgIElOUFVUOiAxXG4gIH0sXG4gIGlzbWFwOiB7XG4gICAgJDogXCJpc01hcFwiLFxuICAgIElNRzogMVxuICB9LFxuICBub21vZHVsZToge1xuICAgICQ6IFwibm9Nb2R1bGVcIixcbiAgICBTQ1JJUFQ6IDFcbiAgfSxcbiAgcGxheXNpbmxpbmU6IHtcbiAgICAkOiBcInBsYXlzSW5saW5lXCIsXG4gICAgVklERU86IDFcbiAgfSxcbiAgcmVhZG9ubHk6IHtcbiAgICAkOiBcInJlYWRPbmx5XCIsXG4gICAgSU5QVVQ6IDEsXG4gICAgVEVYVEFSRUE6IDFcbiAgfSxcbiAgYWRhdWN0aW9uaGVhZGVyczoge1xuICAgICQ6IFwiYWRBdWN0aW9uSGVhZGVyc1wiLFxuICAgIElGUkFNRTogMVxuICB9LFxuICBhbGxvd2Z1bGxzY3JlZW46IHtcbiAgICAkOiBcImFsbG93RnVsbHNjcmVlblwiLFxuICAgIElGUkFNRTogMVxuICB9LFxuICBicm93c2luZ3RvcGljczoge1xuICAgICQ6IFwiYnJvd3NpbmdUb3BpY3NcIixcbiAgICBJTUc6IDFcbiAgfSxcbiAgZGVmYXVsdGNoZWNrZWQ6IHtcbiAgICAkOiBcImRlZmF1bHRDaGVja2VkXCIsXG4gICAgSU5QVVQ6IDFcbiAgfSxcbiAgZGVmYXVsdG11dGVkOiB7XG4gICAgJDogXCJkZWZhdWx0TXV0ZWRcIixcbiAgICBBVURJTzogMSxcbiAgICBWSURFTzogMVxuICB9LFxuICBkZWZhdWx0c2VsZWN0ZWQ6IHtcbiAgICAkOiBcImRlZmF1bHRTZWxlY3RlZFwiLFxuICAgIE9QVElPTjogMVxuICB9LFxuICBkaXNhYmxlcGljdHVyZWlucGljdHVyZToge1xuICAgICQ6IFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIixcbiAgICBWSURFTzogMVxuICB9LFxuICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6IHtcbiAgICAkOiBcImRpc2FibGVSZW1vdGVQbGF5YmFja1wiLFxuICAgIEFVRElPOiAxLFxuICAgIFZJREVPOiAxXG4gIH0sXG4gIHByZXNlcnZlc3BpdGNoOiB7XG4gICAgJDogXCJwcmVzZXJ2ZXNQaXRjaFwiLFxuICAgIEFVRElPOiAxLFxuICAgIFZJREVPOiAxXG4gIH0sXG4gIHNoYWRvd3Jvb3RjbG9uYWJsZToge1xuICAgICQ6IFwic2hhZG93Um9vdENsb25hYmxlXCIsXG4gICAgVEVNUExBVEU6IDFcbiAgfSxcbiAgc2hhZG93cm9vdGRlbGVnYXRlc2ZvY3VzOiB7XG4gICAgJDogXCJzaGFkb3dSb290RGVsZWdhdGVzRm9jdXNcIixcbiAgICBURU1QTEFURTogMVxuICB9LFxuICBzaGFkb3dyb290c2VyaWFsaXphYmxlOiB7XG4gICAgJDogXCJzaGFkb3dSb290U2VyaWFsaXphYmxlXCIsXG4gICAgVEVNUExBVEU6IDFcbiAgfSxcbiAgc2hhcmVkc3RvcmFnZXdyaXRhYmxlOiB7XG4gICAgJDogXCJzaGFyZWRTdG9yYWdlV3JpdGFibGVcIixcbiAgICBJRlJBTUU6IDEsXG4gICAgSU1HOiAxXG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0UHJvcEFsaWFzKHByb3AsIHRhZ05hbWUpIHtcbiAgY29uc3QgYSA9IFByb3BBbGlhc2VzW3Byb3BdO1xuICByZXR1cm4gdHlwZW9mIGEgPT09IFwib2JqZWN0XCIgPyBhW3RhZ05hbWVdID8gYVtcIiRcIl0gOiB1bmRlZmluZWQgOiBhO1xufVxuY29uc3QgRGVsZWdhdGVkRXZlbnRzID0gLyojX19QVVJFX18qL25ldyBTZXQoW1wiYmVmb3JlaW5wdXRcIiwgXCJjbGlja1wiLCBcImRibGNsaWNrXCIsIFwiY29udGV4dG1lbnVcIiwgXCJmb2N1c2luXCIsIFwiZm9jdXNvdXRcIiwgXCJpbnB1dFwiLCBcImtleWRvd25cIiwgXCJrZXl1cFwiLCBcIm1vdXNlZG93blwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNlb3V0XCIsIFwibW91c2VvdmVyXCIsIFwibW91c2V1cFwiLCBcInBvaW50ZXJkb3duXCIsIFwicG9pbnRlcm1vdmVcIiwgXCJwb2ludGVyb3V0XCIsIFwicG9pbnRlcm92ZXJcIiwgXCJwb2ludGVydXBcIiwgXCJ0b3VjaGVuZFwiLCBcInRvdWNobW92ZVwiLCBcInRvdWNoc3RhcnRcIl0pO1xuY29uc3QgU1ZHRWxlbWVudHMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbXG5cImFsdEdseXBoXCIsIFwiYWx0R2x5cGhEZWZcIiwgXCJhbHRHbHlwaEl0ZW1cIiwgXCJhbmltYXRlXCIsIFwiYW5pbWF0ZUNvbG9yXCIsIFwiYW5pbWF0ZU1vdGlvblwiLCBcImFuaW1hdGVUcmFuc2Zvcm1cIiwgXCJjaXJjbGVcIiwgXCJjbGlwUGF0aFwiLCBcImNvbG9yLXByb2ZpbGVcIiwgXCJjdXJzb3JcIiwgXCJkZWZzXCIsIFwiZGVzY1wiLCBcImVsbGlwc2VcIiwgXCJmZUJsZW5kXCIsIFwiZmVDb2xvck1hdHJpeFwiLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIiwgXCJmZUNvbXBvc2l0ZVwiLCBcImZlQ29udm9sdmVNYXRyaXhcIiwgXCJmZURpZmZ1c2VMaWdodGluZ1wiLCBcImZlRGlzcGxhY2VtZW50TWFwXCIsIFwiZmVEaXN0YW50TGlnaHRcIiwgXCJmZURyb3BTaGFkb3dcIiwgXCJmZUZsb29kXCIsIFwiZmVGdW5jQVwiLCBcImZlRnVuY0JcIiwgXCJmZUZ1bmNHXCIsIFwiZmVGdW5jUlwiLCBcImZlR2F1c3NpYW5CbHVyXCIsIFwiZmVJbWFnZVwiLCBcImZlTWVyZ2VcIiwgXCJmZU1lcmdlTm9kZVwiLCBcImZlTW9ycGhvbG9neVwiLCBcImZlT2Zmc2V0XCIsIFwiZmVQb2ludExpZ2h0XCIsIFwiZmVTcGVjdWxhckxpZ2h0aW5nXCIsIFwiZmVTcG90TGlnaHRcIiwgXCJmZVRpbGVcIiwgXCJmZVR1cmJ1bGVuY2VcIiwgXCJmaWx0ZXJcIiwgXCJmb250XCIsIFwiZm9udC1mYWNlXCIsIFwiZm9udC1mYWNlLWZvcm1hdFwiLCBcImZvbnQtZmFjZS1uYW1lXCIsIFwiZm9udC1mYWNlLXNyY1wiLCBcImZvbnQtZmFjZS11cmlcIiwgXCJmb3JlaWduT2JqZWN0XCIsIFwiZ1wiLCBcImdseXBoXCIsIFwiZ2x5cGhSZWZcIiwgXCJoa2VyblwiLCBcImltYWdlXCIsIFwibGluZVwiLCBcImxpbmVhckdyYWRpZW50XCIsIFwibWFya2VyXCIsIFwibWFza1wiLCBcIm1ldGFkYXRhXCIsIFwibWlzc2luZy1nbHlwaFwiLCBcIm1wYXRoXCIsIFwicGF0aFwiLCBcInBhdHRlcm5cIiwgXCJwb2x5Z29uXCIsIFwicG9seWxpbmVcIiwgXCJyYWRpYWxHcmFkaWVudFwiLCBcInJlY3RcIixcblwic2V0XCIsIFwic3RvcFwiLFxuXCJzdmdcIiwgXCJzd2l0Y2hcIiwgXCJzeW1ib2xcIiwgXCJ0ZXh0XCIsIFwidGV4dFBhdGhcIixcblwidHJlZlwiLCBcInRzcGFuXCIsIFwidXNlXCIsIFwidmlld1wiLCBcInZrZXJuXCJdKTtcbmNvbnN0IFNWR05hbWVzcGFjZSA9IHtcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCJcbn07XG5jb25zdCBET01FbGVtZW50cyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFtcImh0bWxcIiwgXCJiYXNlXCIsIFwiaGVhZFwiLCBcImxpbmtcIiwgXCJtZXRhXCIsIFwic3R5bGVcIiwgXCJ0aXRsZVwiLCBcImJvZHlcIiwgXCJhZGRyZXNzXCIsIFwiYXJ0aWNsZVwiLCBcImFzaWRlXCIsIFwiZm9vdGVyXCIsIFwiaGVhZGVyXCIsIFwibWFpblwiLCBcIm5hdlwiLCBcInNlY3Rpb25cIiwgXCJib2R5XCIsIFwiYmxvY2txdW90ZVwiLCBcImRkXCIsIFwiZGl2XCIsIFwiZGxcIiwgXCJkdFwiLCBcImZpZ2NhcHRpb25cIiwgXCJmaWd1cmVcIiwgXCJoclwiLCBcImxpXCIsIFwib2xcIiwgXCJwXCIsIFwicHJlXCIsIFwidWxcIiwgXCJhXCIsIFwiYWJiclwiLCBcImJcIiwgXCJiZGlcIiwgXCJiZG9cIiwgXCJiclwiLCBcImNpdGVcIiwgXCJjb2RlXCIsIFwiZGF0YVwiLCBcImRmblwiLCBcImVtXCIsIFwiaVwiLCBcImtiZFwiLCBcIm1hcmtcIiwgXCJxXCIsIFwicnBcIiwgXCJydFwiLCBcInJ1YnlcIiwgXCJzXCIsIFwic2FtcFwiLCBcInNtYWxsXCIsIFwic3BhblwiLCBcInN0cm9uZ1wiLCBcInN1YlwiLCBcInN1cFwiLCBcInRpbWVcIiwgXCJ1XCIsIFwidmFyXCIsIFwid2JyXCIsIFwiYXJlYVwiLCBcImF1ZGlvXCIsIFwiaW1nXCIsIFwibWFwXCIsIFwidHJhY2tcIiwgXCJ2aWRlb1wiLCBcImVtYmVkXCIsIFwiaWZyYW1lXCIsIFwib2JqZWN0XCIsIFwicGFyYW1cIiwgXCJwaWN0dXJlXCIsIFwicG9ydGFsXCIsIFwic291cmNlXCIsIFwic3ZnXCIsIFwibWF0aFwiLCBcImNhbnZhc1wiLCBcIm5vc2NyaXB0XCIsIFwic2NyaXB0XCIsIFwiZGVsXCIsIFwiaW5zXCIsIFwiY2FwdGlvblwiLCBcImNvbFwiLCBcImNvbGdyb3VwXCIsIFwidGFibGVcIiwgXCJ0Ym9keVwiLCBcInRkXCIsIFwidGZvb3RcIiwgXCJ0aFwiLCBcInRoZWFkXCIsIFwidHJcIiwgXCJidXR0b25cIiwgXCJkYXRhbGlzdFwiLCBcImZpZWxkc2V0XCIsIFwiZm9ybVwiLCBcImlucHV0XCIsIFwibGFiZWxcIiwgXCJsZWdlbmRcIiwgXCJtZXRlclwiLCBcIm9wdGdyb3VwXCIsIFwib3B0aW9uXCIsIFwib3V0cHV0XCIsIFwicHJvZ3Jlc3NcIiwgXCJzZWxlY3RcIiwgXCJ0ZXh0YXJlYVwiLCBcImRldGFpbHNcIiwgXCJkaWFsb2dcIiwgXCJtZW51XCIsIFwic3VtbWFyeVwiLCBcImRldGFpbHNcIiwgXCJzbG90XCIsIFwidGVtcGxhdGVcIiwgXCJhY3JvbnltXCIsIFwiYXBwbGV0XCIsIFwiYmFzZWZvbnRcIiwgXCJiZ3NvdW5kXCIsIFwiYmlnXCIsIFwiYmxpbmtcIiwgXCJjZW50ZXJcIiwgXCJjb250ZW50XCIsIFwiZGlyXCIsIFwiZm9udFwiLCBcImZyYW1lXCIsIFwiZnJhbWVzZXRcIiwgXCJoZ3JvdXBcIiwgXCJpbWFnZVwiLCBcImtleWdlblwiLCBcIm1hcnF1ZWVcIiwgXCJtZW51aXRlbVwiLCBcIm5vYnJcIiwgXCJub2VtYmVkXCIsIFwibm9mcmFtZXNcIiwgXCJwbGFpbnRleHRcIiwgXCJyYlwiLCBcInJ0Y1wiLCBcInNoYWRvd1wiLCBcInNwYWNlclwiLCBcInN0cmlrZVwiLCBcInR0XCIsIFwieG1wXCIsIFwiYVwiLCBcImFiYnJcIiwgXCJhY3JvbnltXCIsIFwiYWRkcmVzc1wiLCBcImFwcGxldFwiLCBcImFyZWFcIiwgXCJhcnRpY2xlXCIsIFwiYXNpZGVcIiwgXCJhdWRpb1wiLCBcImJcIiwgXCJiYXNlXCIsIFwiYmFzZWZvbnRcIiwgXCJiZGlcIiwgXCJiZG9cIiwgXCJiZ3NvdW5kXCIsIFwiYmlnXCIsIFwiYmxpbmtcIiwgXCJibG9ja3F1b3RlXCIsIFwiYm9keVwiLCBcImJyXCIsIFwiYnV0dG9uXCIsIFwiY2FudmFzXCIsIFwiY2FwdGlvblwiLCBcImNlbnRlclwiLCBcImNpdGVcIiwgXCJjb2RlXCIsIFwiY29sXCIsIFwiY29sZ3JvdXBcIiwgXCJjb250ZW50XCIsIFwiZGF0YVwiLCBcImRhdGFsaXN0XCIsIFwiZGRcIiwgXCJkZWxcIiwgXCJkZXRhaWxzXCIsIFwiZGZuXCIsIFwiZGlhbG9nXCIsIFwiZGlyXCIsIFwiZGl2XCIsIFwiZGxcIiwgXCJkdFwiLCBcImVtXCIsIFwiZW1iZWRcIiwgXCJmaWVsZHNldFwiLCBcImZpZ2NhcHRpb25cIiwgXCJmaWd1cmVcIiwgXCJmb250XCIsIFwiZm9vdGVyXCIsIFwiZm9ybVwiLCBcImZyYW1lXCIsIFwiZnJhbWVzZXRcIiwgXCJoZWFkXCIsIFwiaGVhZGVyXCIsIFwiaGdyb3VwXCIsIFwiaHJcIiwgXCJodG1sXCIsIFwiaVwiLCBcImlmcmFtZVwiLCBcImltYWdlXCIsIFwiaW1nXCIsIFwiaW5wdXRcIiwgXCJpbnNcIiwgXCJrYmRcIiwgXCJrZXlnZW5cIiwgXCJsYWJlbFwiLCBcImxlZ2VuZFwiLCBcImxpXCIsIFwibGlua1wiLCBcIm1haW5cIiwgXCJtYXBcIiwgXCJtYXJrXCIsIFwibWFycXVlZVwiLCBcIm1lbnVcIiwgXCJtZW51aXRlbVwiLCBcIm1ldGFcIiwgXCJtZXRlclwiLCBcIm5hdlwiLCBcIm5vYnJcIiwgXCJub2VtYmVkXCIsIFwibm9mcmFtZXNcIiwgXCJub3NjcmlwdFwiLCBcIm9iamVjdFwiLCBcIm9sXCIsIFwib3B0Z3JvdXBcIiwgXCJvcHRpb25cIiwgXCJvdXRwdXRcIiwgXCJwXCIsIFwicGFyYW1cIiwgXCJwaWN0dXJlXCIsIFwicGxhaW50ZXh0XCIsIFwicG9ydGFsXCIsIFwicHJlXCIsIFwicHJvZ3Jlc3NcIiwgXCJxXCIsIFwicmJcIiwgXCJycFwiLCBcInJ0XCIsIFwicnRjXCIsIFwicnVieVwiLCBcInNcIiwgXCJzYW1wXCIsIFwic2NyaXB0XCIsIFwic2VjdGlvblwiLCBcInNlbGVjdFwiLCBcInNoYWRvd1wiLCBcInNsb3RcIiwgXCJzbWFsbFwiLCBcInNvdXJjZVwiLCBcInNwYWNlclwiLCBcInNwYW5cIiwgXCJzdHJpa2VcIiwgXCJzdHJvbmdcIiwgXCJzdHlsZVwiLCBcInN1YlwiLCBcInN1bW1hcnlcIiwgXCJzdXBcIiwgXCJ0YWJsZVwiLCBcInRib2R5XCIsIFwidGRcIiwgXCJ0ZW1wbGF0ZVwiLCBcInRleHRhcmVhXCIsIFwidGZvb3RcIiwgXCJ0aFwiLCBcInRoZWFkXCIsIFwidGltZVwiLCBcInRpdGxlXCIsIFwidHJcIiwgXCJ0cmFja1wiLCBcInR0XCIsIFwidVwiLCBcInVsXCIsIFwidmFyXCIsIFwidmlkZW9cIiwgXCJ3YnJcIiwgXCJ4bXBcIiwgXCJpbnB1dFwiLCBcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiLFxuXCJ3ZWJ2aWV3XCIsXG5cImlzaW5kZXhcIiwgXCJsaXN0aW5nXCIsIFwibXVsdGljb2xcIiwgXCJuZXh0aWRcIiwgXCJub2luZGV4XCIsIFwic2VhcmNoXCJdKTtcblxuY29uc3QgbWVtbyA9IGZuID0+IGNyZWF0ZU1lbW8oKCkgPT4gZm4oKSk7XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUFycmF5cyhwYXJlbnROb2RlLCBhLCBiKSB7XG4gIGxldCBiTGVuZ3RoID0gYi5sZW5ndGgsXG4gICAgYUVuZCA9IGEubGVuZ3RoLFxuICAgIGJFbmQgPSBiTGVuZ3RoLFxuICAgIGFTdGFydCA9IDAsXG4gICAgYlN0YXJ0ID0gMCxcbiAgICBhZnRlciA9IGFbYUVuZCAtIDFdLm5leHRTaWJsaW5nLFxuICAgIG1hcCA9IG51bGw7XG4gIHdoaWxlIChhU3RhcnQgPCBhRW5kIHx8IGJTdGFydCA8IGJFbmQpIHtcbiAgICBpZiAoYVthU3RhcnRdID09PSBiW2JTdGFydF0pIHtcbiAgICAgIGFTdGFydCsrO1xuICAgICAgYlN0YXJ0Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgd2hpbGUgKGFbYUVuZCAtIDFdID09PSBiW2JFbmQgLSAxXSkge1xuICAgICAgYUVuZC0tO1xuICAgICAgYkVuZC0tO1xuICAgIH1cbiAgICBpZiAoYUVuZCA9PT0gYVN0YXJ0KSB7XG4gICAgICBjb25zdCBub2RlID0gYkVuZCA8IGJMZW5ndGggPyBiU3RhcnQgPyBiW2JTdGFydCAtIDFdLm5leHRTaWJsaW5nIDogYltiRW5kIC0gYlN0YXJ0XSA6IGFmdGVyO1xuICAgICAgd2hpbGUgKGJTdGFydCA8IGJFbmQpIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJbYlN0YXJ0KytdLCBub2RlKTtcbiAgICB9IGVsc2UgaWYgKGJFbmQgPT09IGJTdGFydCkge1xuICAgICAgd2hpbGUgKGFTdGFydCA8IGFFbmQpIHtcbiAgICAgICAgaWYgKCFtYXAgfHwgIW1hcC5oYXMoYVthU3RhcnRdKSkgYVthU3RhcnRdLnJlbW92ZSgpO1xuICAgICAgICBhU3RhcnQrKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFbYVN0YXJ0XSA9PT0gYltiRW5kIC0gMV0gJiYgYltiU3RhcnRdID09PSBhW2FFbmQgLSAxXSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGFbLS1hRW5kXS5uZXh0U2libGluZztcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJbYlN0YXJ0KytdLCBhW2FTdGFydCsrXS5uZXh0U2libGluZyk7XG4gICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShiWy0tYkVuZF0sIG5vZGUpO1xuICAgICAgYVthRW5kXSA9IGJbYkVuZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbWFwKSB7XG4gICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGkgPSBiU3RhcnQ7XG4gICAgICAgIHdoaWxlIChpIDwgYkVuZCkgbWFwLnNldChiW2ldLCBpKyspO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5kZXggPSBtYXAuZ2V0KGFbYVN0YXJ0XSk7XG4gICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBpZiAoYlN0YXJ0IDwgaW5kZXggJiYgaW5kZXggPCBiRW5kKSB7XG4gICAgICAgICAgbGV0IGkgPSBhU3RhcnQsXG4gICAgICAgICAgICBzZXF1ZW5jZSA9IDEsXG4gICAgICAgICAgICB0O1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBhRW5kICYmIGkgPCBiRW5kKSB7XG4gICAgICAgICAgICBpZiAoKHQgPSBtYXAuZ2V0KGFbaV0pKSA9PSBudWxsIHx8IHQgIT09IGluZGV4ICsgc2VxdWVuY2UpIGJyZWFrO1xuICAgICAgICAgICAgc2VxdWVuY2UrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlcXVlbmNlID4gaW5kZXggLSBiU3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBhW2FTdGFydF07XG4gICAgICAgICAgICB3aGlsZSAoYlN0YXJ0IDwgaW5kZXgpIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJbYlN0YXJ0KytdLCBub2RlKTtcbiAgICAgICAgICB9IGVsc2UgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYltiU3RhcnQrK10sIGFbYVN0YXJ0KytdKTtcbiAgICAgICAgfSBlbHNlIGFTdGFydCsrO1xuICAgICAgfSBlbHNlIGFbYVN0YXJ0KytdLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCAkJEVWRU5UUyA9IFwiXyREWF9ERUxFR0FURVwiO1xuZnVuY3Rpb24gcmVuZGVyKGNvZGUsIGVsZW1lbnQsIGluaXQsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZGlzcG9zZXI7XG4gIGNyZWF0ZVJvb3QoZGlzcG9zZSA9PiB7XG4gICAgZGlzcG9zZXIgPSBkaXNwb3NlO1xuICAgIGVsZW1lbnQgPT09IGRvY3VtZW50ID8gY29kZSgpIDogaW5zZXJ0KGVsZW1lbnQsIGNvZGUoKSwgZWxlbWVudC5maXJzdENoaWxkID8gbnVsbCA6IHVuZGVmaW5lZCwgaW5pdCk7XG4gIH0sIG9wdGlvbnMub3duZXIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGRpc3Bvc2VyKCk7XG4gICAgZWxlbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG4gIH07XG59XG5mdW5jdGlvbiB0ZW1wbGF0ZShodG1sLCBpc0ltcG9ydE5vZGUsIGlzU1ZHLCBpc01hdGhNTCkge1xuICBsZXQgbm9kZTtcbiAgY29uc3QgY3JlYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHQgPSBpc01hdGhNTCA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgXCJ0ZW1wbGF0ZVwiKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICB0LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGlzU1ZHID8gdC5jb250ZW50LmZpcnN0Q2hpbGQuZmlyc3RDaGlsZCA6IGlzTWF0aE1MID8gdC5maXJzdENoaWxkIDogdC5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gIH07XG4gIGNvbnN0IGZuID0gaXNJbXBvcnROb2RlID8gKCkgPT4gdW50cmFjaygoKSA9PiBkb2N1bWVudC5pbXBvcnROb2RlKG5vZGUgfHwgKG5vZGUgPSBjcmVhdGUoKSksIHRydWUpKSA6ICgpID0+IChub2RlIHx8IChub2RlID0gY3JlYXRlKCkpKS5jbG9uZU5vZGUodHJ1ZSk7XG4gIGZuLmNsb25lTm9kZSA9IGZuO1xuICByZXR1cm4gZm47XG59XG5mdW5jdGlvbiBkZWxlZ2F0ZUV2ZW50cyhldmVudE5hbWVzLCBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkge1xuICBjb25zdCBlID0gZG9jdW1lbnRbJCRFVkVOVFNdIHx8IChkb2N1bWVudFskJEVWRU5UU10gPSBuZXcgU2V0KCkpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50TmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGV2ZW50TmFtZXNbaV07XG4gICAgaWYgKCFlLmhhcyhuYW1lKSkge1xuICAgICAgZS5hZGQobmFtZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjbGVhckRlbGVnYXRlZEV2ZW50cyhkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkge1xuICBpZiAoZG9jdW1lbnRbJCRFVkVOVFNdKSB7XG4gICAgZm9yIChsZXQgbmFtZSBvZiBkb2N1bWVudFskJEVWRU5UU10ua2V5cygpKSBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgZGVsZXRlIGRvY3VtZW50WyQkRVZFTlRTXTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKGlzSHlkcmF0aW5nKG5vZGUpKSByZXR1cm47XG4gIG5vZGVbbmFtZV0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNIeWRyYXRpbmcobm9kZSkpIHJldHVybjtcbiAgaWYgKHZhbHVlID09IG51bGwpIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO2Vsc2Ugbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0QXR0cmlidXRlTlMobm9kZSwgbmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNIeWRyYXRpbmcobm9kZSkpIHJldHVybjtcbiAgaWYgKHZhbHVlID09IG51bGwpIG5vZGUucmVtb3ZlQXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lKTtlbHNlIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRCb29sQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChpc0h5ZHJhdGluZyhub2RlKSkgcmV0dXJuO1xuICB2YWx1ZSA/IG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIFwiXCIpIDogbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG59XG5mdW5jdGlvbiBjbGFzc05hbWUobm9kZSwgdmFsdWUpIHtcbiAgaWYgKGlzSHlkcmF0aW5nKG5vZGUpKSByZXR1cm47XG4gIGlmICh2YWx1ZSA9PSBudWxsKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO2Vsc2Ugbm9kZS5jbGFzc05hbWUgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgbmFtZSwgaGFuZGxlciwgZGVsZWdhdGUpIHtcbiAgaWYgKGRlbGVnYXRlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIG5vZGVbYCQkJHtuYW1lfWBdID0gaGFuZGxlclswXTtcbiAgICAgIG5vZGVbYCQkJHtuYW1lfURhdGFgXSA9IGhhbmRsZXJbMV07XG4gICAgfSBlbHNlIG5vZGVbYCQkJHtuYW1lfWBdID0gaGFuZGxlcjtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgY29uc3QgaGFuZGxlckZuID0gaGFuZGxlclswXTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlclswXSA9IGUgPT4gaGFuZGxlckZuLmNhbGwobm9kZSwgaGFuZGxlclsxXSwgZSkpO1xuICB9IGVsc2Ugbm9kZS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIgJiYgaGFuZGxlcik7XG59XG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSwgdmFsdWUsIHByZXYgPSB7fSkge1xuICBjb25zdCBjbGFzc0tleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSB8fCB7fSksXG4gICAgcHJldktleXMgPSBPYmplY3Qua2V5cyhwcmV2KTtcbiAgbGV0IGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gcHJldktleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBwcmV2S2V5c1tpXTtcbiAgICBpZiAoIWtleSB8fCBrZXkgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWVba2V5XSkgY29udGludWU7XG4gICAgdG9nZ2xlQ2xhc3NLZXkobm9kZSwga2V5LCBmYWxzZSk7XG4gICAgZGVsZXRlIHByZXZba2V5XTtcbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBjbGFzc0tleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBjbGFzc0tleXNbaV0sXG4gICAgICBjbGFzc1ZhbHVlID0gISF2YWx1ZVtrZXldO1xuICAgIGlmICgha2V5IHx8IGtleSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcmV2W2tleV0gPT09IGNsYXNzVmFsdWUgfHwgIWNsYXNzVmFsdWUpIGNvbnRpbnVlO1xuICAgIHRvZ2dsZUNsYXNzS2V5KG5vZGUsIGtleSwgdHJ1ZSk7XG4gICAgcHJldltrZXldID0gY2xhc3NWYWx1ZTtcbiAgfVxuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHN0eWxlKG5vZGUsIHZhbHVlLCBwcmV2KSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBwcmV2ID8gc2V0QXR0cmlidXRlKG5vZGUsIFwic3R5bGVcIikgOiB2YWx1ZTtcbiAgY29uc3Qgbm9kZVN0eWxlID0gbm9kZS5zdHlsZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIG5vZGVTdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG4gIHR5cGVvZiBwcmV2ID09PSBcInN0cmluZ1wiICYmIChub2RlU3R5bGUuY3NzVGV4dCA9IHByZXYgPSB1bmRlZmluZWQpO1xuICBwcmV2IHx8IChwcmV2ID0ge30pO1xuICB2YWx1ZSB8fCAodmFsdWUgPSB7fSk7XG4gIGxldCB2LCBzO1xuICBmb3IgKHMgaW4gcHJldikge1xuICAgIHZhbHVlW3NdID09IG51bGwgJiYgbm9kZVN0eWxlLnJlbW92ZVByb3BlcnR5KHMpO1xuICAgIGRlbGV0ZSBwcmV2W3NdO1xuICB9XG4gIGZvciAocyBpbiB2YWx1ZSkge1xuICAgIHYgPSB2YWx1ZVtzXTtcbiAgICBpZiAodiAhPT0gcHJldltzXSkge1xuICAgICAgbm9kZVN0eWxlLnNldFByb3BlcnR5KHMsIHYpO1xuICAgICAgcHJldltzXSA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gc2V0U3R5bGVQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICB2YWx1ZSAhPSBudWxsID8gbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSkgOiBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xufVxuZnVuY3Rpb24gc3ByZWFkKG5vZGUsIHByb3BzID0ge30sIGlzU1ZHLCBza2lwQ2hpbGRyZW4pIHtcbiAgY29uc3QgcHJldlByb3BzID0ge307XG4gIGlmICghc2tpcENoaWxkcmVuKSB7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHByZXZQcm9wcy5jaGlsZHJlbiA9IGluc2VydEV4cHJlc3Npb24obm9kZSwgcHJvcHMuY2hpbGRyZW4sIHByZXZQcm9wcy5jaGlsZHJlbikpO1xuICB9XG4gIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiB0eXBlb2YgcHJvcHMucmVmID09PSBcImZ1bmN0aW9uXCIgJiYgdXNlKHByb3BzLnJlZiwgbm9kZSkpO1xuICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gYXNzaWduKG5vZGUsIHByb3BzLCBpc1NWRywgdHJ1ZSwgcHJldlByb3BzLCB0cnVlKSk7XG4gIHJldHVybiBwcmV2UHJvcHM7XG59XG5mdW5jdGlvbiBkeW5hbWljUHJvcGVydHkocHJvcHMsIGtleSkge1xuICBjb25zdCBzcmMgPSBwcm9wc1trZXldO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIGtleSwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBzcmMoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIHVzZShmbiwgZWxlbWVudCwgYXJnKSB7XG4gIHJldHVybiB1bnRyYWNrKCgpID0+IGZuKGVsZW1lbnQsIGFyZykpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KHBhcmVudCwgYWNjZXNzb3IsIG1hcmtlciwgaW5pdGlhbCkge1xuICBpZiAobWFya2VyICE9PSB1bmRlZmluZWQgJiYgIWluaXRpYWwpIGluaXRpYWwgPSBbXTtcbiAgaWYgKHR5cGVvZiBhY2Nlc3NvciAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gaW5zZXJ0RXhwcmVzc2lvbihwYXJlbnQsIGFjY2Vzc29yLCBpbml0aWFsLCBtYXJrZXIpO1xuICBjcmVhdGVSZW5kZXJFZmZlY3QoY3VycmVudCA9PiBpbnNlcnRFeHByZXNzaW9uKHBhcmVudCwgYWNjZXNzb3IoKSwgY3VycmVudCwgbWFya2VyKSwgaW5pdGlhbCk7XG59XG5mdW5jdGlvbiBhc3NpZ24obm9kZSwgcHJvcHMsIGlzU1ZHLCBza2lwQ2hpbGRyZW4sIHByZXZQcm9wcyA9IHt9LCBza2lwUmVmID0gZmFsc2UpIHtcbiAgcHJvcHMgfHwgKHByb3BzID0ge30pO1xuICBmb3IgKGNvbnN0IHByb3AgaW4gcHJldlByb3BzKSB7XG4gICAgaWYgKCEocHJvcCBpbiBwcm9wcykpIHtcbiAgICAgIGlmIChwcm9wID09PSBcImNoaWxkcmVuXCIpIGNvbnRpbnVlO1xuICAgICAgcHJldlByb3BzW3Byb3BdID0gYXNzaWduUHJvcChub2RlLCBwcm9wLCBudWxsLCBwcmV2UHJvcHNbcHJvcF0sIGlzU1ZHLCBza2lwUmVmLCBwcm9wcyk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgIGlmIChwcm9wID09PSBcImNoaWxkcmVuXCIpIHtcbiAgICAgIGlmICghc2tpcENoaWxkcmVuKSBpbnNlcnRFeHByZXNzaW9uKG5vZGUsIHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgIHByZXZQcm9wc1twcm9wXSA9IGFzc2lnblByb3Aobm9kZSwgcHJvcCwgdmFsdWUsIHByZXZQcm9wc1twcm9wXSwgaXNTVkcsIHNraXBSZWYsIHByb3BzKTtcbiAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZSQxKGNvZGUsIGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoZ2xvYmFsVGhpcy5fJEhZLmRvbmUpIHJldHVybiByZW5kZXIoY29kZSwgZWxlbWVudCwgWy4uLmVsZW1lbnQuY2hpbGROb2Rlc10sIG9wdGlvbnMpO1xuICBzaGFyZWRDb25maWcuY29tcGxldGVkID0gZ2xvYmFsVGhpcy5fJEhZLmNvbXBsZXRlZDtcbiAgc2hhcmVkQ29uZmlnLmV2ZW50cyA9IGdsb2JhbFRoaXMuXyRIWS5ldmVudHM7XG4gIHNoYXJlZENvbmZpZy5sb2FkID0gaWQgPT4gZ2xvYmFsVGhpcy5fJEhZLnJbaWRdO1xuICBzaGFyZWRDb25maWcuaGFzID0gaWQgPT4gaWQgaW4gZ2xvYmFsVGhpcy5fJEhZLnI7XG4gIHNoYXJlZENvbmZpZy5nYXRoZXIgPSByb290ID0+IGdhdGhlckh5ZHJhdGFibGUoZWxlbWVudCwgcm9vdCk7XG4gIHNoYXJlZENvbmZpZy5yZWdpc3RyeSA9IG5ldyBNYXAoKTtcbiAgc2hhcmVkQ29uZmlnLmNvbnRleHQgPSB7XG4gICAgaWQ6IG9wdGlvbnMucmVuZGVySWQgfHwgXCJcIixcbiAgICBjb3VudDogMFxuICB9O1xuICB0cnkge1xuICAgIGdhdGhlckh5ZHJhdGFibGUoZWxlbWVudCwgb3B0aW9ucy5yZW5kZXJJZCk7XG4gICAgcmV0dXJuIHJlbmRlcihjb2RlLCBlbGVtZW50LCBbLi4uZWxlbWVudC5jaGlsZE5vZGVzXSwgb3B0aW9ucyk7XG4gIH0gZmluYWxseSB7XG4gICAgc2hhcmVkQ29uZmlnLmNvbnRleHQgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXROZXh0RWxlbWVudCh0ZW1wbGF0ZSkge1xuICBsZXQgbm9kZSxcbiAgICBrZXksXG4gICAgaHlkcmF0aW5nID0gaXNIeWRyYXRpbmcoKTtcbiAgaWYgKCFoeWRyYXRpbmcgfHwgIShub2RlID0gc2hhcmVkQ29uZmlnLnJlZ2lzdHJ5LmdldChrZXkgPSBnZXRIeWRyYXRpb25LZXkoKSkpKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlKCk7XG4gIH1cbiAgaWYgKHNoYXJlZENvbmZpZy5jb21wbGV0ZWQpIHNoYXJlZENvbmZpZy5jb21wbGV0ZWQuYWRkKG5vZGUpO1xuICBzaGFyZWRDb25maWcucmVnaXN0cnkuZGVsZXRlKGtleSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZ2V0TmV4dE1hdGNoKGVsLCBub2RlTmFtZSkge1xuICB3aGlsZSAoZWwgJiYgZWwubG9jYWxOYW1lICE9PSBub2RlTmFtZSkgZWwgPSBlbC5uZXh0U2libGluZztcbiAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gZ2V0TmV4dE1hcmtlcihzdGFydCkge1xuICBsZXQgZW5kID0gc3RhcnQsXG4gICAgY291bnQgPSAwLFxuICAgIGN1cnJlbnQgPSBbXTtcbiAgaWYgKGlzSHlkcmF0aW5nKHN0YXJ0KSkge1xuICAgIHdoaWxlIChlbmQpIHtcbiAgICAgIGlmIChlbmQubm9kZVR5cGUgPT09IDgpIHtcbiAgICAgICAgY29uc3QgdiA9IGVuZC5ub2RlVmFsdWU7XG4gICAgICAgIGlmICh2ID09PSBcIiRcIikgY291bnQrKztlbHNlIGlmICh2ID09PSBcIi9cIikge1xuICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkgcmV0dXJuIFtlbmQsIGN1cnJlbnRdO1xuICAgICAgICAgIGNvdW50LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnQucHVzaChlbmQpO1xuICAgICAgZW5kID0gZW5kLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2VuZCwgY3VycmVudF07XG59XG5mdW5jdGlvbiBydW5IeWRyYXRpb25FdmVudHMoKSB7XG4gIGlmIChzaGFyZWRDb25maWcuZXZlbnRzICYmICFzaGFyZWRDb25maWcuZXZlbnRzLnF1ZXVlZCkge1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29tcGxldGVkLFxuICAgICAgICBldmVudHNcbiAgICAgIH0gPSBzaGFyZWRDb25maWc7XG4gICAgICBpZiAoIWV2ZW50cykgcmV0dXJuO1xuICAgICAgZXZlbnRzLnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgW2VsLCBlXSA9IGV2ZW50c1swXTtcbiAgICAgICAgaWYgKCFjb21wbGV0ZWQuaGFzKGVsKSkgcmV0dXJuO1xuICAgICAgICBldmVudHMuc2hpZnQoKTtcbiAgICAgICAgZXZlbnRIYW5kbGVyKGUpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXJlZENvbmZpZy5kb25lKSB7XG4gICAgICAgIHNoYXJlZENvbmZpZy5ldmVudHMgPSBfJEhZLmV2ZW50cyA9IG51bGw7XG4gICAgICAgIHNoYXJlZENvbmZpZy5jb21wbGV0ZWQgPSBfJEhZLmNvbXBsZXRlZCA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2hhcmVkQ29uZmlnLmV2ZW50cy5xdWV1ZWQgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBpc0h5ZHJhdGluZyhub2RlKSB7XG4gIHJldHVybiAhIXNoYXJlZENvbmZpZy5jb250ZXh0ICYmICFzaGFyZWRDb25maWcuZG9uZSAmJiAoIW5vZGUgfHwgbm9kZS5pc0Nvbm5lY3RlZCk7XG59XG5mdW5jdGlvbiB0b1Byb3BlcnR5TmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShbYS16XSkvZywgKF8sIHcpID0+IHcudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiB0b2dnbGVDbGFzc0tleShub2RlLCBrZXksIHZhbHVlKSB7XG4gIGNvbnN0IGNsYXNzTmFtZXMgPSBrZXkudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gIGZvciAobGV0IGkgPSAwLCBuYW1lTGVuID0gY2xhc3NOYW1lcy5sZW5ndGg7IGkgPCBuYW1lTGVuOyBpKyspIG5vZGUuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWVzW2ldLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBhc3NpZ25Qcm9wKG5vZGUsIHByb3AsIHZhbHVlLCBwcmV2LCBpc1NWRywgc2tpcFJlZiwgcHJvcHMpIHtcbiAgbGV0IGlzQ0UsIGlzUHJvcCwgaXNDaGlsZFByb3AsIHByb3BBbGlhcywgZm9yY2VQcm9wO1xuICBpZiAocHJvcCA9PT0gXCJzdHlsZVwiKSByZXR1cm4gc3R5bGUobm9kZSwgdmFsdWUsIHByZXYpO1xuICBpZiAocHJvcCA9PT0gXCJjbGFzc0xpc3RcIikgcmV0dXJuIGNsYXNzTGlzdChub2RlLCB2YWx1ZSwgcHJldik7XG4gIGlmICh2YWx1ZSA9PT0gcHJldikgcmV0dXJuIHByZXY7XG4gIGlmIChwcm9wID09PSBcInJlZlwiKSB7XG4gICAgaWYgKCFza2lwUmVmKSB2YWx1ZShub2RlKTtcbiAgfSBlbHNlIGlmIChwcm9wLnNsaWNlKDAsIDMpID09PSBcIm9uOlwiKSB7XG4gICAgY29uc3QgZSA9IHByb3Auc2xpY2UoMyk7XG4gICAgcHJldiAmJiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgcHJldiwgdHlwZW9mIHByZXYgIT09IFwiZnVuY3Rpb25cIiAmJiBwcmV2KTtcbiAgICB2YWx1ZSAmJiBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZSwgdmFsdWUsIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiICYmIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChwcm9wLnNsaWNlKDAsIDEwKSA9PT0gXCJvbmNhcHR1cmU6XCIpIHtcbiAgICBjb25zdCBlID0gcHJvcC5zbGljZSgxMCk7XG4gICAgcHJldiAmJiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgcHJldiwgdHJ1ZSk7XG4gICAgdmFsdWUgJiYgbm9kZS5hZGRFdmVudExpc3RlbmVyKGUsIHZhbHVlLCB0cnVlKTtcbiAgfSBlbHNlIGlmIChwcm9wLnNsaWNlKDAsIDIpID09PSBcIm9uXCIpIHtcbiAgICBjb25zdCBuYW1lID0gcHJvcC5zbGljZSgyKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGRlbGVnYXRlID0gRGVsZWdhdGVkRXZlbnRzLmhhcyhuYW1lKTtcbiAgICBpZiAoIWRlbGVnYXRlICYmIHByZXYpIHtcbiAgICAgIGNvbnN0IGggPSBBcnJheS5pc0FycmF5KHByZXYpID8gcHJldlswXSA6IHByZXY7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaCk7XG4gICAgfVxuICAgIGlmIChkZWxlZ2F0ZSB8fCB2YWx1ZSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBuYW1lLCB2YWx1ZSwgZGVsZWdhdGUpO1xuICAgICAgZGVsZWdhdGUgJiYgZGVsZWdhdGVFdmVudHMoW25hbWVdKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvcC5zbGljZSgwLCA1KSA9PT0gXCJhdHRyOlwiKSB7XG4gICAgc2V0QXR0cmlidXRlKG5vZGUsIHByb3Auc2xpY2UoNSksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChwcm9wLnNsaWNlKDAsIDUpID09PSBcImJvb2w6XCIpIHtcbiAgICBzZXRCb29sQXR0cmlidXRlKG5vZGUsIHByb3Auc2xpY2UoNSksIHZhbHVlKTtcbiAgfSBlbHNlIGlmICgoZm9yY2VQcm9wID0gcHJvcC5zbGljZSgwLCA1KSA9PT0gXCJwcm9wOlwiKSB8fCAoaXNDaGlsZFByb3AgPSBDaGlsZFByb3BlcnRpZXMuaGFzKHByb3ApKSB8fCAhaXNTVkcgJiYgKChwcm9wQWxpYXMgPSBnZXRQcm9wQWxpYXMocHJvcCwgbm9kZS50YWdOYW1lKSkgfHwgKGlzUHJvcCA9IFByb3BlcnRpZXMuaGFzKHByb3ApKSkgfHwgKGlzQ0UgPSBub2RlLm5vZGVOYW1lLmluY2x1ZGVzKFwiLVwiKSB8fCBcImlzXCIgaW4gcHJvcHMpKSB7XG4gICAgaWYgKGZvcmNlUHJvcCkge1xuICAgICAgcHJvcCA9IHByb3Auc2xpY2UoNSk7XG4gICAgICBpc1Byb3AgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNIeWRyYXRpbmcobm9kZSkpIHJldHVybiB2YWx1ZTtcbiAgICBpZiAocHJvcCA9PT0gXCJjbGFzc1wiIHx8IHByb3AgPT09IFwiY2xhc3NOYW1lXCIpIGNsYXNzTmFtZShub2RlLCB2YWx1ZSk7ZWxzZSBpZiAoaXNDRSAmJiAhaXNQcm9wICYmICFpc0NoaWxkUHJvcCkgbm9kZVt0b1Byb3BlcnR5TmFtZShwcm9wKV0gPSB2YWx1ZTtlbHNlIG5vZGVbcHJvcEFsaWFzIHx8IHByb3BdID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbnMgPSBpc1NWRyAmJiBwcm9wLmluZGV4T2YoXCI6XCIpID4gLTEgJiYgU1ZHTmFtZXNwYWNlW3Byb3Auc3BsaXQoXCI6XCIpWzBdXTtcbiAgICBpZiAobnMpIHNldEF0dHJpYnV0ZU5TKG5vZGUsIG5zLCBwcm9wLCB2YWx1ZSk7ZWxzZSBzZXRBdHRyaWJ1dGUobm9kZSwgQWxpYXNlc1twcm9wXSB8fCBwcm9wLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGUpIHtcbiAgaWYgKHNoYXJlZENvbmZpZy5yZWdpc3RyeSAmJiBzaGFyZWRDb25maWcuZXZlbnRzKSB7XG4gICAgaWYgKHNoYXJlZENvbmZpZy5ldmVudHMuZmluZCgoW2VsLCBldl0pID0+IGV2ID09PSBlKSkgcmV0dXJuO1xuICB9XG4gIGxldCBub2RlID0gZS50YXJnZXQ7XG4gIGNvbnN0IGtleSA9IGAkJCR7ZS50eXBlfWA7XG4gIGNvbnN0IG9yaVRhcmdldCA9IGUudGFyZ2V0O1xuICBjb25zdCBvcmlDdXJyZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuICBjb25zdCByZXRhcmdldCA9IHZhbHVlID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInRhcmdldFwiLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlXG4gIH0pO1xuICBjb25zdCBoYW5kbGVOb2RlID0gKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBub2RlW2tleV07XG4gICAgaWYgKGhhbmRsZXIgJiYgIW5vZGUuZGlzYWJsZWQpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBub2RlW2Ake2tleX1EYXRhYF07XG4gICAgICBkYXRhICE9PSB1bmRlZmluZWQgPyBoYW5kbGVyLmNhbGwobm9kZSwgZGF0YSwgZSkgOiBoYW5kbGVyLmNhbGwobm9kZSwgZSk7XG4gICAgICBpZiAoZS5jYW5jZWxCdWJibGUpIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5ob3N0ICYmIHR5cGVvZiBub2RlLmhvc3QgIT09IFwic3RyaW5nXCIgJiYgIW5vZGUuaG9zdC5fJGhvc3QgJiYgbm9kZS5jb250YWlucyhlLnRhcmdldCkgJiYgcmV0YXJnZXQobm9kZS5ob3N0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3Qgd2Fsa1VwVHJlZSA9ICgpID0+IHtcbiAgICB3aGlsZSAoaGFuZGxlTm9kZSgpICYmIChub2RlID0gbm9kZS5fJGhvc3QgfHwgbm9kZS5wYXJlbnROb2RlIHx8IG5vZGUuaG9zdCkpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjdXJyZW50VGFyZ2V0XCIsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIG5vZGUgfHwgZG9jdW1lbnQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKHNoYXJlZENvbmZpZy5yZWdpc3RyeSAmJiAhc2hhcmVkQ29uZmlnLmRvbmUpIHNoYXJlZENvbmZpZy5kb25lID0gXyRIWS5kb25lID0gdHJ1ZTtcbiAgaWYgKGUuY29tcG9zZWRQYXRoKSB7XG4gICAgY29uc3QgcGF0aCA9IGUuY29tcG9zZWRQYXRoKCk7XG4gICAgcmV0YXJnZXQocGF0aFswXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgbm9kZSA9IHBhdGhbaV07XG4gICAgICBpZiAoIWhhbmRsZU5vZGUoKSkgYnJlYWs7XG4gICAgICBpZiAobm9kZS5fJGhvc3QpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuXyRob3N0O1xuICAgICAgICB3YWxrVXBUcmVlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSA9PT0gb3JpQ3VycmVudFRhcmdldCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB3YWxrVXBUcmVlKCk7XG4gIHJldGFyZ2V0KG9yaVRhcmdldCk7XG59XG5mdW5jdGlvbiBpbnNlcnRFeHByZXNzaW9uKHBhcmVudCwgdmFsdWUsIGN1cnJlbnQsIG1hcmtlciwgdW53cmFwQXJyYXkpIHtcbiAgY29uc3QgaHlkcmF0aW5nID0gaXNIeWRyYXRpbmcocGFyZW50KTtcbiAgaWYgKGh5ZHJhdGluZykge1xuICAgICFjdXJyZW50ICYmIChjdXJyZW50ID0gWy4uLnBhcmVudC5jaGlsZE5vZGVzXSk7XG4gICAgbGV0IGNsZWFuZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBjdXJyZW50W2ldO1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5kYXRhLnNsaWNlKDAsIDIpID09PSBcIiEkXCIpIG5vZGUucmVtb3ZlKCk7ZWxzZSBjbGVhbmVkLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIGN1cnJlbnQgPSBjbGVhbmVkO1xuICB9XG4gIHdoaWxlICh0eXBlb2YgY3VycmVudCA9PT0gXCJmdW5jdGlvblwiKSBjdXJyZW50ID0gY3VycmVudCgpO1xuICBpZiAodmFsdWUgPT09IGN1cnJlbnQpIHJldHVybiBjdXJyZW50O1xuICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlLFxuICAgIG11bHRpID0gbWFya2VyICE9PSB1bmRlZmluZWQ7XG4gIHBhcmVudCA9IG11bHRpICYmIGN1cnJlbnRbMF0gJiYgY3VycmVudFswXS5wYXJlbnROb2RlIHx8IHBhcmVudDtcbiAgaWYgKHQgPT09IFwic3RyaW5nXCIgfHwgdCA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChoeWRyYXRpbmcpIHJldHVybiBjdXJyZW50O1xuICAgIGlmICh0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAodmFsdWUgPT09IGN1cnJlbnQpIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBpZiAobXVsdGkpIHtcbiAgICAgIGxldCBub2RlID0gY3VycmVudFswXTtcbiAgICAgIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgbm9kZS5kYXRhICE9PSB2YWx1ZSAmJiAobm9kZS5kYXRhID0gdmFsdWUpO1xuICAgICAgfSBlbHNlIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgICBjdXJyZW50ID0gY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG1hcmtlciwgbm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50ICE9PSBcIlwiICYmIHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGN1cnJlbnQgPSBwYXJlbnQuZmlyc3RDaGlsZC5kYXRhID0gdmFsdWU7XG4gICAgICB9IGVsc2UgY3VycmVudCA9IHBhcmVudC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsIHx8IHQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgaWYgKGh5ZHJhdGluZykgcmV0dXJuIGN1cnJlbnQ7XG4gICAgY3VycmVudCA9IGNsZWFuQ2hpbGRyZW4ocGFyZW50LCBjdXJyZW50LCBtYXJrZXIpO1xuICB9IGVsc2UgaWYgKHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgdiA9IHZhbHVlKCk7XG4gICAgICB3aGlsZSAodHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIikgdiA9IHYoKTtcbiAgICAgIGN1cnJlbnQgPSBpbnNlcnRFeHByZXNzaW9uKHBhcmVudCwgdiwgY3VycmVudCwgbWFya2VyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gY3VycmVudDtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgY29uc3QgY3VycmVudEFycmF5ID0gY3VycmVudCAmJiBBcnJheS5pc0FycmF5KGN1cnJlbnQpO1xuICAgIGlmIChub3JtYWxpemVJbmNvbWluZ0FycmF5KGFycmF5LCB2YWx1ZSwgY3VycmVudCwgdW53cmFwQXJyYXkpKSB7XG4gICAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gY3VycmVudCA9IGluc2VydEV4cHJlc3Npb24ocGFyZW50LCBhcnJheSwgY3VycmVudCwgbWFya2VyLCB0cnVlKSk7XG4gICAgICByZXR1cm4gKCkgPT4gY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGh5ZHJhdGluZykge1xuICAgICAgaWYgKCFhcnJheS5sZW5ndGgpIHJldHVybiBjdXJyZW50O1xuICAgICAgaWYgKG1hcmtlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY3VycmVudCA9IFsuLi5wYXJlbnQuY2hpbGROb2Rlc107XG4gICAgICBsZXQgbm9kZSA9IGFycmF5WzBdO1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gcGFyZW50KSByZXR1cm4gY3VycmVudDtcbiAgICAgIGNvbnN0IG5vZGVzID0gW25vZGVdO1xuICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5uZXh0U2libGluZykgIT09IG1hcmtlcikgbm9kZXMucHVzaChub2RlKTtcbiAgICAgIHJldHVybiBjdXJyZW50ID0gbm9kZXM7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGN1cnJlbnQgPSBjbGVhbkNoaWxkcmVuKHBhcmVudCwgY3VycmVudCwgbWFya2VyKTtcbiAgICAgIGlmIChtdWx0aSkgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50QXJyYXkpIHtcbiAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhcHBlbmROb2RlcyhwYXJlbnQsIGFycmF5LCBtYXJrZXIpO1xuICAgICAgfSBlbHNlIHJlY29uY2lsZUFycmF5cyhwYXJlbnQsIGN1cnJlbnQsIGFycmF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudCAmJiBjbGVhbkNoaWxkcmVuKHBhcmVudCk7XG4gICAgICBhcHBlbmROb2RlcyhwYXJlbnQsIGFycmF5KTtcbiAgICB9XG4gICAgY3VycmVudCA9IGFycmF5O1xuICB9IGVsc2UgaWYgKHZhbHVlLm5vZGVUeXBlKSB7XG4gICAgaWYgKGh5ZHJhdGluZyAmJiB2YWx1ZS5wYXJlbnROb2RlKSByZXR1cm4gY3VycmVudCA9IG11bHRpID8gW3ZhbHVlXSA6IHZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICBpZiAobXVsdGkpIHJldHVybiBjdXJyZW50ID0gY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG1hcmtlciwgdmFsdWUpO1xuICAgICAgY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG51bGwsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPT0gbnVsbCB8fCBjdXJyZW50ID09PSBcIlwiIHx8ICFwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICB9IGVsc2UgcGFyZW50LnJlcGxhY2VDaGlsZCh2YWx1ZSwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgIGN1cnJlbnQgPSB2YWx1ZTtcbiAgfSBlbHNlIDtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmNvbWluZ0FycmF5KG5vcm1hbGl6ZWQsIGFycmF5LCBjdXJyZW50LCB1bndyYXApIHtcbiAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IGl0ZW0gPSBhcnJheVtpXSxcbiAgICAgIHByZXYgPSBjdXJyZW50ICYmIGN1cnJlbnRbbm9ybWFsaXplZC5sZW5ndGhdLFxuICAgICAgdDtcbiAgICBpZiAoaXRlbSA9PSBudWxsIHx8IGl0ZW0gPT09IHRydWUgfHwgaXRlbSA9PT0gZmFsc2UpIDsgZWxzZSBpZiAoKHQgPSB0eXBlb2YgaXRlbSkgPT09IFwib2JqZWN0XCIgJiYgaXRlbS5ub2RlVHlwZSkge1xuICAgICAgbm9ybWFsaXplZC5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgZHluYW1pYyA9IG5vcm1hbGl6ZUluY29taW5nQXJyYXkobm9ybWFsaXplZCwgaXRlbSwgcHJldikgfHwgZHluYW1pYztcbiAgICB9IGVsc2UgaWYgKHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKHVud3JhcCkge1xuICAgICAgICB3aGlsZSAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikgaXRlbSA9IGl0ZW0oKTtcbiAgICAgICAgZHluYW1pYyA9IG5vcm1hbGl6ZUluY29taW5nQXJyYXkobm9ybWFsaXplZCwgQXJyYXkuaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBbaXRlbV0sIEFycmF5LmlzQXJyYXkocHJldikgPyBwcmV2IDogW3ByZXZdKSB8fCBkeW5hbWljO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKGl0ZW0pO1xuICAgICAgICBkeW5hbWljID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsdWUgPSBTdHJpbmcoaXRlbSk7XG4gICAgICBpZiAocHJldiAmJiBwcmV2Lm5vZGVUeXBlID09PSAzICYmIHByZXYuZGF0YSA9PT0gdmFsdWUpIG5vcm1hbGl6ZWQucHVzaChwcmV2KTtlbHNlIG5vcm1hbGl6ZWQucHVzaChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pYztcbn1cbmZ1bmN0aW9uIGFwcGVuZE5vZGVzKHBhcmVudCwgYXJyYXksIG1hcmtlciA9IG51bGwpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGFycmF5W2ldLCBtYXJrZXIpO1xufVxuZnVuY3Rpb24gY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG1hcmtlciwgcmVwbGFjZW1lbnQpIHtcbiAgaWYgKG1hcmtlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gcGFyZW50LnRleHRDb250ZW50ID0gXCJcIjtcbiAgY29uc3Qgbm9kZSA9IHJlcGxhY2VtZW50IHx8IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICBpZiAoY3VycmVudC5sZW5ndGgpIHtcbiAgICBsZXQgaW5zZXJ0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gY3VycmVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgZWwgPSBjdXJyZW50W2ldO1xuICAgICAgaWYgKG5vZGUgIT09IGVsKSB7XG4gICAgICAgIGNvbnN0IGlzUGFyZW50ID0gZWwucGFyZW50Tm9kZSA9PT0gcGFyZW50O1xuICAgICAgICBpZiAoIWluc2VydGVkICYmICFpKSBpc1BhcmVudCA/IHBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZSwgZWwpIDogcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBtYXJrZXIpO2Vsc2UgaXNQYXJlbnQgJiYgZWwucmVtb3ZlKCk7XG4gICAgICB9IGVsc2UgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbWFya2VyKTtcbiAgcmV0dXJuIFtub2RlXTtcbn1cbmZ1bmN0aW9uIGdhdGhlckh5ZHJhdGFibGUoZWxlbWVudCwgcm9vdCkge1xuICBjb25zdCB0ZW1wbGF0ZXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCpbZGF0YS1oa11gKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wbGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gdGVtcGxhdGVzW2ldO1xuICAgIGNvbnN0IGtleSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1oa1wiKTtcbiAgICBpZiAoKCFyb290IHx8IGtleS5zdGFydHNXaXRoKHJvb3QpKSAmJiAhc2hhcmVkQ29uZmlnLnJlZ2lzdHJ5LmhhcyhrZXkpKSBzaGFyZWRDb25maWcucmVnaXN0cnkuc2V0KGtleSwgbm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEh5ZHJhdGlvbktleSgpIHtcbiAgcmV0dXJuIHNoYXJlZENvbmZpZy5nZXROZXh0Q29udGV4dElkKCk7XG59XG5mdW5jdGlvbiBOb0h5ZHJhdGlvbihwcm9wcykge1xuICByZXR1cm4gc2hhcmVkQ29uZmlnLmNvbnRleHQgPyB1bmRlZmluZWQgOiBwcm9wcy5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIEh5ZHJhdGlvbihwcm9wcykge1xuICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5jb25zdCB2b2lkRm4gPSAoKSA9PiB1bmRlZmluZWQ7XG5jb25zdCBSZXF1ZXN0Q29udGV4dCA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gaW5uZXJIVE1MKHBhcmVudCwgY29udGVudCkge1xuICAhc2hhcmVkQ29uZmlnLmNvbnRleHQgJiYgKHBhcmVudC5pbm5lckhUTUwgPSBjb250ZW50KTtcbn1cblxuZnVuY3Rpb24gdGhyb3dJbkJyb3dzZXIoZnVuYykge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYCR7ZnVuYy5uYW1lfSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBicm93c2VyLCByZXR1cm5pbmcgdW5kZWZpbmVkYCk7XG4gIGNvbnNvbGUuZXJyb3IoZXJyKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKGZuLCBvcHRpb25zKSB7XG4gIHRocm93SW5Ccm93c2VyKHJlbmRlclRvU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nQXN5bmMoZm4sIG9wdGlvbnMpIHtcbiAgdGhyb3dJbkJyb3dzZXIocmVuZGVyVG9TdHJpbmdBc3luYyk7XG59XG5mdW5jdGlvbiByZW5kZXJUb1N0cmVhbShmbiwgb3B0aW9ucykge1xuICB0aHJvd0luQnJvd3NlcihyZW5kZXJUb1N0cmVhbSk7XG59XG5mdW5jdGlvbiBzc3IodGVtcGxhdGUsIC4uLm5vZGVzKSB7fVxuZnVuY3Rpb24gc3NyRWxlbWVudChuYW1lLCBwcm9wcywgY2hpbGRyZW4sIG5lZWRzSWQpIHt9XG5mdW5jdGlvbiBzc3JDbGFzc0xpc3QodmFsdWUpIHt9XG5mdW5jdGlvbiBzc3JTdHlsZSh2YWx1ZSkge31cbmZ1bmN0aW9uIHNzckF0dHJpYnV0ZShrZXksIHZhbHVlKSB7fVxuZnVuY3Rpb24gc3NySHlkcmF0aW9uS2V5KCkge31cbmZ1bmN0aW9uIHJlc29sdmVTU1JOb2RlKG5vZGUpIHt9XG5mdW5jdGlvbiBlc2NhcGUoaHRtbCkge31cbmZ1bmN0aW9uIHNzclNwcmVhZChwcm9wcywgaXNTVkcsIHNraXBDaGlsZHJlbikge31cblxuY29uc3QgaXNTZXJ2ZXIgPSBmYWxzZTtcbmNvbnN0IGlzRGV2ID0gZmFsc2U7XG5jb25zdCBTVkdfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBpc1NWRyA9IGZhbHNlLCBpcyA9IHVuZGVmaW5lZCkge1xuICByZXR1cm4gaXNTVkcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgdGFnTmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUsIHtcbiAgICBpc1xuICB9KTtcbn1cbmNvbnN0IGh5ZHJhdGUgPSAoLi4uYXJncykgPT4ge1xuICBlbmFibGVIeWRyYXRpb24oKTtcbiAgcmV0dXJuIGh5ZHJhdGUkMSguLi5hcmdzKTtcbn07XG5mdW5jdGlvbiBQb3J0YWwocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgICAgdXNlU2hhZG93XG4gICAgfSA9IHByb3BzLFxuICAgIG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpLFxuICAgIG1vdW50ID0gKCkgPT4gcHJvcHMubW91bnQgfHwgZG9jdW1lbnQuYm9keSxcbiAgICBvd25lciA9IGdldE93bmVyKCk7XG4gIGxldCBjb250ZW50O1xuICBsZXQgaHlkcmF0aW5nID0gISFzaGFyZWRDb25maWcuY29udGV4dDtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaHlkcmF0aW5nKSBnZXRPd25lcigpLnVzZXIgPSBoeWRyYXRpbmcgPSBmYWxzZTtcbiAgICBjb250ZW50IHx8IChjb250ZW50ID0gcnVuV2l0aE93bmVyKG93bmVyLCAoKSA9PiBjcmVhdGVNZW1vKCgpID0+IHByb3BzLmNoaWxkcmVuKSkpO1xuICAgIGNvbnN0IGVsID0gbW91bnQoKTtcbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSGVhZEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IFtjbGVhbiwgc2V0Q2xlYW5dID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBzZXRDbGVhbih0cnVlKTtcbiAgICAgIGNyZWF0ZVJvb3QoZGlzcG9zZSA9PiBpbnNlcnQoZWwsICgpID0+ICFjbGVhbigpID8gY29udGVudCgpIDogZGlzcG9zZSgpLCBudWxsKSk7XG4gICAgICBvbkNsZWFudXAoY2xlYW51cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQocHJvcHMuaXNTVkcgPyBcImdcIiA6IFwiZGl2XCIsIHByb3BzLmlzU1ZHKSxcbiAgICAgICAgcmVuZGVyUm9vdCA9IHVzZVNoYWRvdyAmJiBjb250YWluZXIuYXR0YWNoU2hhZG93ID8gY29udGFpbmVyLmF0dGFjaFNoYWRvdyh7XG4gICAgICAgICAgbW9kZTogXCJvcGVuXCJcbiAgICAgICAgfSkgOiBjb250YWluZXI7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGFpbmVyLCBcIl8kaG9zdFwiLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbWFya2VyLnBhcmVudE5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpbnNlcnQocmVuZGVyUm9vdCwgY29udGVudCk7XG4gICAgICBlbC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgcHJvcHMucmVmICYmIHByb3BzLnJlZihjb250YWluZXIpO1xuICAgICAgb25DbGVhbnVwKCgpID0+IGVsLnJlbW92ZUNoaWxkKGNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwgdW5kZWZpbmVkLCB7XG4gICAgcmVuZGVyOiAhaHlkcmF0aW5nXG4gIH0pO1xuICByZXR1cm4gbWFya2VyO1xufVxuZnVuY3Rpb24gY3JlYXRlRHluYW1pYyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGNvbnN0IGNhY2hlZCA9IGNyZWF0ZU1lbW8oY29tcG9uZW50KTtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGNhY2hlZCgpO1xuICAgIHN3aXRjaCAodHlwZW9mIGNvbXBvbmVudCkge1xuICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgIHJldHVybiB1bnRyYWNrKCgpID0+IGNvbXBvbmVudChwcm9wcykpO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjb25zdCBpc1N2ZyA9IFNWR0VsZW1lbnRzLmhhcyhjb21wb25lbnQpO1xuICAgICAgICBjb25zdCBlbCA9IHNoYXJlZENvbmZpZy5jb250ZXh0ID8gZ2V0TmV4dEVsZW1lbnQoKSA6IGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBpc1N2ZywgdW50cmFjaygoKSA9PiBwcm9wcy5pcykpO1xuICAgICAgICBzcHJlYWQoZWwsIHByb3BzLCBpc1N2Zyk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gRHluYW1pYyhwcm9wcykge1xuICBjb25zdCBbLCBvdGhlcnNdID0gc3BsaXRQcm9wcyhwcm9wcywgW1wiY29tcG9uZW50XCJdKTtcbiAgcmV0dXJuIGNyZWF0ZUR5bmFtaWMoKCkgPT4gcHJvcHMuY29tcG9uZW50LCBvdGhlcnMpO1xufVxuXG5leHBvcnQgeyBBbGlhc2VzLCB2b2lkRm4gYXMgQXNzZXRzLCBDaGlsZFByb3BlcnRpZXMsIERPTUVsZW1lbnRzLCBEZWxlZ2F0ZWRFdmVudHMsIER5bmFtaWMsIEh5ZHJhdGlvbiwgdm9pZEZuIGFzIEh5ZHJhdGlvblNjcmlwdCwgTm9IeWRyYXRpb24sIFBvcnRhbCwgUHJvcGVydGllcywgUmVxdWVzdENvbnRleHQsIFNWR0VsZW1lbnRzLCBTVkdOYW1lc3BhY2UsIGFkZEV2ZW50TGlzdGVuZXIsIGFzc2lnbiwgY2xhc3NMaXN0LCBjbGFzc05hbWUsIGNsZWFyRGVsZWdhdGVkRXZlbnRzLCBjcmVhdGVEeW5hbWljLCBkZWxlZ2F0ZUV2ZW50cywgZHluYW1pY1Byb3BlcnR5LCBlc2NhcGUsIHZvaWRGbiBhcyBnZW5lcmF0ZUh5ZHJhdGlvblNjcmlwdCwgdm9pZEZuIGFzIGdldEFzc2V0cywgZ2V0SHlkcmF0aW9uS2V5LCBnZXROZXh0RWxlbWVudCwgZ2V0TmV4dE1hcmtlciwgZ2V0TmV4dE1hdGNoLCBnZXRQcm9wQWxpYXMsIHZvaWRGbiBhcyBnZXRSZXF1ZXN0RXZlbnQsIGh5ZHJhdGUsIGlubmVySFRNTCwgaW5zZXJ0LCBpc0RldiwgaXNTZXJ2ZXIsIG1lbW8sIHJlbmRlciwgcmVuZGVyVG9TdHJlYW0sIHJlbmRlclRvU3RyaW5nLCByZW5kZXJUb1N0cmluZ0FzeW5jLCByZXNvbHZlU1NSTm9kZSwgcnVuSHlkcmF0aW9uRXZlbnRzLCBzZXRBdHRyaWJ1dGUsIHNldEF0dHJpYnV0ZU5TLCBzZXRCb29sQXR0cmlidXRlLCBzZXRQcm9wZXJ0eSwgc2V0U3R5bGVQcm9wZXJ0eSwgc3ByZWFkLCBzc3IsIHNzckF0dHJpYnV0ZSwgc3NyQ2xhc3NMaXN0LCBzc3JFbGVtZW50LCBzc3JIeWRyYXRpb25LZXksIHNzclNwcmVhZCwgc3NyU3R5bGUsIHN0eWxlLCB0ZW1wbGF0ZSwgdXNlLCB2b2lkRm4gYXMgdXNlQXNzZXRzIH07XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXFxzKy9nLCAnLCcpXG5cdFx0XHQuc3BsaXQoJywnKVxuXHRcdFx0LmZpbHRlcihCb29sZWFuKTtcblxuXHRcdGZvciAoY29uc3QgbnMgb2Ygc3BsaXQpIHtcblx0XHRcdGlmIChuc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobnMuc2xpY2UoMSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIG1hdGNoZXMgYSBuYW1lc3BhY2UgdGVtcGxhdGUsIGhvbm9yaW5nXG5cdCAqIGFzdGVyaXNrcyBhcyB3aWxkY2FyZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaGVzVGVtcGxhdGUoc2VhcmNoLCB0ZW1wbGF0ZSkge1xuXHRcdGxldCBzZWFyY2hJbmRleCA9IDA7XG5cdFx0bGV0IHRlbXBsYXRlSW5kZXggPSAwO1xuXHRcdGxldCBzdGFySW5kZXggPSAtMTtcblx0XHRsZXQgbWF0Y2hJbmRleCA9IDA7XG5cblx0XHR3aGlsZSAoc2VhcmNoSW5kZXggPCBzZWFyY2gubGVuZ3RoKSB7XG5cdFx0XHRpZiAodGVtcGxhdGVJbmRleCA8IHRlbXBsYXRlLmxlbmd0aCAmJiAodGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09IHNlYXJjaFtzZWFyY2hJbmRleF0gfHwgdGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09ICcqJykpIHtcblx0XHRcdFx0Ly8gTWF0Y2ggY2hhcmFjdGVyIG9yIHByb2NlZWQgd2l0aCB3aWxkY2FyZFxuXHRcdFx0XHRpZiAodGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09ICcqJykge1xuXHRcdFx0XHRcdHN0YXJJbmRleCA9IHRlbXBsYXRlSW5kZXg7XG5cdFx0XHRcdFx0bWF0Y2hJbmRleCA9IHNlYXJjaEluZGV4O1xuXHRcdFx0XHRcdHRlbXBsYXRlSW5kZXgrKzsgLy8gU2tpcCB0aGUgJyonXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VhcmNoSW5kZXgrKztcblx0XHRcdFx0XHR0ZW1wbGF0ZUluZGV4Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoc3RhckluZGV4ICE9PSAtMSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG5cdFx0XHRcdC8vIEJhY2t0cmFjayB0byB0aGUgbGFzdCAnKicgYW5kIHRyeSB0byBtYXRjaCBtb3JlIGNoYXJhY3RlcnNcblx0XHRcdFx0dGVtcGxhdGVJbmRleCA9IHN0YXJJbmRleCArIDE7XG5cdFx0XHRcdG1hdGNoSW5kZXgrKztcblx0XHRcdFx0c2VhcmNoSW5kZXggPSBtYXRjaEluZGV4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBObyBtYXRjaFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSB0cmFpbGluZyAnKicgaW4gdGVtcGxhdGVcblx0XHR3aGlsZSAodGVtcGxhdGVJbmRleCA8IHRlbXBsYXRlLmxlbmd0aCAmJiB0ZW1wbGF0ZVt0ZW1wbGF0ZUluZGV4XSA9PT0gJyonKSB7XG5cdFx0XHR0ZW1wbGF0ZUluZGV4Kys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRlbXBsYXRlSW5kZXggPT09IHRlbXBsYXRlLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMsXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGZvciAoY29uc3Qgc2tpcCBvZiBjcmVhdGVEZWJ1Zy5za2lwcykge1xuXHRcdFx0aWYgKG1hdGNoZXNUZW1wbGF0ZShuYW1lLCBza2lwKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBucyBvZiBjcmVhdGVEZWJ1Zy5uYW1lcykge1xuXHRcdFx0aWYgKG1hdGNoZXNUZW1wbGF0ZShuYW1lLCBucykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpIHx8IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdERUJVRycpIDtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsImZ1bmN0aW9uIEwociwgYSwgbywgeSA9IFwiKlwiKSB7XG4gIGxldCB1ID0gcjtcbiAgcmV0dXJuIHUgPT09IFwicmFuZG9tXCIgJiYgKHUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobyAtIGEgKyAxKSkgKyBhKSwgeS5yZXBlYXQodSk7XG59XG5mdW5jdGlvbiBiKHIpIHtcbiAgcmV0dXJuIHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgXCJcIik7XG59XG5mdW5jdGlvbiBQKHIsIGEgPSB7fSwgbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKSB7XG4gIGNvbnN0IHtcbiAgICBwcm9wZXJ0aWVzOiB5ID0gW1xuICAgICAgXCJwYXNzd29yZFwiLFxuICAgICAgXCJrZXlcIixcbiAgICAgIFwic2VjcmV0XCIsXG4gICAgICBcInRva2VuXCIsXG4gICAgICBcInByaXZhdGVrZXlcIixcbiAgICAgIFwicGFzc3BocmFzZVwiXG4gICAgXSxcbiAgICBwcm9wZXJ0eU1hdGNoZXI6IHUgPSBudWxsLFxuICAgIG1hc2tMZW5ndGg6IGogPSA4LFxuICAgIG1pbkxlbmd0aDogdyA9IDUsXG4gICAgbWF4TGVuZ3RoOiB6ID0gMTUsXG4gICAgbWFza0NoYXI6IGkgPSBcIipcIixcbiAgICBmdWxsTWFzazogayA9ICExXG4gIH0gPSBhO1xuICBpZiAoby5oYXMocikpXG4gICAgcmV0dXJuIG8uZ2V0KHIpO1xuICBjb25zdCBBID0geS5tYXAoKGUpID0+IGIoZSkpO1xuICBmdW5jdGlvbiBPKGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIGsgPT0gXCJzdHJpbmdcIiA/IGsgOiBrID09PSAhMCA/IGkucmVwZWF0KGUubGVuZ3RoKSA6IEwoaiwgdywgeiwgaSk7XG4gIH1cbiAgZnVuY3Rpb24gZyhlLCBzLCBuID0gW10pIHtcbiAgICBjb25zdCB0ID0gYihlKTtcbiAgICByZXR1cm4gdSAmJiB0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIgPyB1KGUsIHQsIHMsIG4pIDogQS5pbmRleE9mKHQpICE9PSAtMTtcbiAgfVxuICBmdW5jdGlvbiBoKGUsIHMsIG4gPSBbXSkge1xuICAgIGlmIChlID09IG51bGwpXG4gICAgICByZXR1cm4gZTtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBvLmhhcyhlKSlcbiAgICAgIHJldHVybiBvLmdldChlKTtcbiAgICBsZXQgdDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgdCA9IFtdLCBvLnNldChlLCB0KTtcbiAgICAgIGZvciAobGV0IGYgPSAwOyBmIDwgZS5sZW5ndGg7IGYgKz0gMSkge1xuICAgICAgICBjb25zdCBjID0gWy4uLm4sIGZdO1xuICAgICAgICB0W2ZdID0gaChlW2ZdLCBzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpIHtcbiAgICAgIHQgPSB7fSwgby5zZXQoZSwgdCk7XG4gICAgICBjb25zdCBmID0gT2JqZWN0LmtleXMoZSk7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGYubGVuZ3RoOyBjICs9IDEpIHtcbiAgICAgICAgY29uc3QgcCA9IGZbY10sIE0gPSBbLi4ubiwgcF0sIHggPSBzIHx8IGcocCwgZVtwXSwgTSk7XG4gICAgICAgIHRbcF0gPSBoKFxuICAgICAgICAgIGVbcF0sXG4gICAgICAgICAgeCxcbiAgICAgICAgICBNXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHMgJiYgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHQgPSBPKGUpIDogdCA9IGU7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgbGV0IGw7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSB7XG4gICAgbCA9IFtdLCBvLnNldChyLCBsKTtcbiAgICBmb3IgKGxldCBlID0gMDsgZSA8IHIubGVuZ3RoOyBlICs9IDEpXG4gICAgICBsW2VdID0gaChyW2VdLCAhMSwgW2VdKTtcbiAgfSBlbHNlIGlmIChyICYmIHR5cGVvZiByID09IFwib2JqZWN0XCIpIHtcbiAgICBsID0ge30sIG8uc2V0KHIsIGwpO1xuICAgIGNvbnN0IGUgPSBPYmplY3Qua2V5cyhyKTtcbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IGUubGVuZ3RoOyBzICs9IDEpIHtcbiAgICAgIGNvbnN0IG4gPSBlW3NdLCB0ID0gZyhuLCByW25dLCBbbl0pO1xuICAgICAgbFtuXSA9IGgocltuXSwgdCwgW25dKTtcbiAgICB9XG4gIH0gZWxzZVxuICAgIGwgPSByO1xuICByZXR1cm4gbDtcbn1cbmV4cG9ydCB7XG4gIFAgYXMgZGVmYXVsdFxufTtcbiIsIi8qKlxuICogSW5wdXQgdmFsaWRhdGlvbiBhbmQgc2FuaXRpemF0aW9uIGZ1bmN0aW9uc1xuICogUHJldmVudHMgWFNTIGFuZCBvdGhlciBpbmplY3Rpb24gYXR0YWNrcyBmcm9tIHVzZXIgaW5wdXRcbiAqL1xuXG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSAnZGVidWcnXG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ3dlYnNzaDItY2xpZW50OnZhbGlkYXRvcicpXG5cbi8qKlxuICogTWF4aW11bSBhbGxvd2VkIGxlbmd0aHMgZm9yIHZhcmlvdXMgaW5wdXQgZmllbGRzXG4gKi9cbmV4cG9ydCBjb25zdCBNQVhfTEVOR1RIUyA9IHtcbiAgaG9zdDogMjUzLCAvLyBNYXggRE5TIGhvc3RuYW1lIGxlbmd0aFxuICBwb3J0OiA1LCAvLyBNYXggcG9ydCBudW1iZXIgaXMgNjU1MzVcbiAgdXNlcm5hbWU6IDMyLCAvLyBUeXBpY2FsIFVuaXggdXNlcm5hbWUgbGltaXRcbiAgcGFzc3dvcmQ6IDI1NiwgLy8gUmVhc29uYWJsZSBwYXNzd29yZCBsZW5ndGhcbiAgaGVhZGVyOiAyMDAsIC8vIEhlYWRlciB0ZXh0IGxlbmd0aFxuICBoZWFkZXJiYWNrZ3JvdW5kOiA1MCwgLy8gQ29sb3IgdmFsdWUgbGVuZ3RoXG4gIHNzaHRlcm06IDUwLCAvLyBUZXJtaW5hbCB0eXBlIGxlbmd0aFxuICBsb2dMZXZlbDogMjAsIC8vIExvZyBsZXZlbCBzdHJpbmcgbGVuZ3RoXG4gIHByaXZhdGVLZXk6IDE2Mzg0LCAvLyBNYXggU1NIIGtleSBzaXplICgxNktCKVxuICBwYXNzcGhyYXNlOiAyNTYgLy8gS2V5IHBhc3NwaHJhc2UgbGVuZ3RoXG59IGFzIGNvbnN0XG5cbi8qKlxuICogVmFsaWRhdGVzIGFuZCBzYW5pdGl6ZXMgYSBob3N0bmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVIb3N0KGhvc3Q6IHVua25vd24pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFob3N0IHx8IHR5cGVvZiBob3N0ICE9PSAnc3RyaW5nJykgcmV0dXJuIG51bGxcblxuICBsZXQgdmFsdWUgPSBob3N0XG4gIC8vIFJlbW92ZSBhbnkgcHJvdG9jb2wgcHJlZml4ZXNcbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcLy8sICcnKVxuICAvLyBSZW1vdmUgYW55IHBhdGggY29tcG9uZW50c1xuICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcvJylbMF0gPz8gdmFsdWVcbiAgLy8gUmVtb3ZlIHBvcnQgaWYgcHJlc2VudFxuICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6JylbMF0gPz8gdmFsdWVcblxuICBpZiAodmFsdWUubGVuZ3RoID4gTUFYX0xFTkdUSFMuaG9zdCkgcmV0dXJuIG51bGxcblxuICBjb25zdCBob3N0bmFtZVJlZ2V4ID1cbiAgICAvXlthLXpBLVowLTldKFthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oXFwuW2EtekEtWjAtOV0oW2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC9cbiAgY29uc3QgaXB2NFJlZ2V4ID0gL14oXFxkezEsM31cXC4pezN9XFxkezEsM30kL1xuICBjb25zdCBpcHY2UmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezd9WzAtOWEtZkEtRl17MSw0fXw6OjF8OjopJC9cblxuICBpZiAoXG4gICAgaG9zdG5hbWVSZWdleC50ZXN0KHZhbHVlKSB8fFxuICAgIGlwdjRSZWdleC50ZXN0KHZhbHVlKSB8fFxuICAgIGlwdjZSZWdleC50ZXN0KHZhbHVlKVxuICApIHtcbiAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZGVidWcoJ0ludmFsaWQgaG9zdG5hbWU6JywgdmFsdWUpXG4gIHJldHVybiBudWxsXG59XG5cbi8qKiBWYWxpZGF0ZXMgYSBwb3J0IG51bWJlciAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUG9ydChwb3J0OiB1bmtub3duKTogbnVtYmVyIHwgbnVsbCB7XG4gIGNvbnN0IHBvcnROdW0gPSB0eXBlb2YgcG9ydCA9PT0gJ251bWJlcicgPyBwb3J0IDogcGFyc2VJbnQoU3RyaW5nKHBvcnQpLCAxMClcbiAgaWYgKE51bWJlci5pc05hTihwb3J0TnVtKSB8fCBwb3J0TnVtIDwgMSB8fCBwb3J0TnVtID4gNjU1MzUpIHtcbiAgICBkZWJ1ZygnSW52YWxpZCBwb3J0OicsIHBvcnQpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gcG9ydE51bVxufVxuXG4vKiogVmFsaWRhdGVzIGFuZCBzYW5pdGl6ZXMgYSB1c2VybmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVXNlcm5hbWUodXNlcm5hbWU6IHVua25vd24pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCF1c2VybmFtZSB8fCB0eXBlb2YgdXNlcm5hbWUgIT09ICdzdHJpbmcnKSByZXR1cm4gbnVsbFxuICBjb25zdCB2YWx1ZSA9IHVzZXJuYW1lLnRyaW0oKVxuICBpZiAodmFsdWUubGVuZ3RoID09PSAwIHx8IHZhbHVlLmxlbmd0aCA+IE1BWF9MRU5HVEhTLnVzZXJuYW1lKSB7XG4gICAgZGVidWcoJ0ludmFsaWQgdXNlcm5hbWUgbGVuZ3RoOicsIHZhbHVlLmxlbmd0aClcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGNvbnN0IHVzZXJuYW1lUmVnZXggPSAvXlthLXpBLVowLTkuXy1dKyQvXG4gIGlmICghdXNlcm5hbWVSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgIGRlYnVnKCdJbnZhbGlkIHVzZXJuYW1lIGNoYXJhY3RlcnM6JywgdmFsdWUpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqIFZhbGlkYXRlcyBhIHBhc3N3b3JkIChiYXNpYyBsZW5ndGggY2hlY2sgb25seSkgKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkOiB1bmtub3duKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICdzdHJpbmcnKSByZXR1cm4gbnVsbFxuICBpZiAocGFzc3dvcmQubGVuZ3RoID4gTUFYX0xFTkdUSFMucGFzc3dvcmQpIHtcbiAgICBkZWJ1ZygnUGFzc3dvcmQgdG9vIGxvbmc6JywgcGFzc3dvcmQubGVuZ3RoKVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgcmV0dXJuIHBhc3N3b3JkXG59XG5cbi8qKiBWYWxpZGF0ZXMgYW5kIHNhbml0aXplcyB0ZXh0IGNvbnRlbnQgKGZvciBoZWFkZXJzLCBmb290ZXJzLCBldGMuKSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVGV4dChcbiAgdGV4dDogdW5rbm93bixcbiAgbWF4TGVuZ3RoOiBudW1iZXIgPSBNQVhfTEVOR1RIUy5oZWFkZXJcbik6IHN0cmluZyB7XG4gIGlmICghdGV4dCB8fCB0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHJldHVybiAnJ1xuICBsZXQgdmFsdWUgPSB0ZXh0XG4gIGlmICh2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICBkZWJ1ZygnVGV4dCB0cnVuY2F0ZWQgZnJvbScsIHZhbHVlLmxlbmd0aCwgJ3RvJywgbWF4TGVuZ3RoKVxuICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIG1heExlbmd0aClcbiAgfVxuICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXFwwL2csICcnKVxufVxuXG4vKiogVmFsaWRhdGVzIGEgY29sb3IgdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUNvbG9yKGNvbG9yOiB1bmtub3duKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICghY29sb3IgfHwgdHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykgcmV0dXJuIG51bGxcbiAgY29uc3QgdmFsdWUgPSBjb2xvci50cmltKClcbiAgaWYgKHZhbHVlLmxlbmd0aCA+IE1BWF9MRU5HVEhTLmhlYWRlcmJhY2tncm91bmQpIHJldHVybiBudWxsXG4gIGNvbnN0IGhleFJlZ2V4ID0gL14jKFswLTlhLWZBLUZdezN9KXsxLDJ9JC9cbiAgY29uc3QgcmdiUmVnZXggPSAvXnJnYmE/XFwoXFxzKihcXGR7MSwzfVxccyosXFxzKil7MiwzfVxccypcXGR7MSwzfVxccypcXCkkL1xuICBjb25zdCBuYW1lZENvbG9yUmVnZXggPSAvXlthLXpBLVpdKyQvXG4gIGlmIChcbiAgICBoZXhSZWdleC50ZXN0KHZhbHVlKSB8fFxuICAgIHJnYlJlZ2V4LnRlc3QodmFsdWUpIHx8XG4gICAgbmFtZWRDb2xvclJlZ2V4LnRlc3QodmFsdWUpXG4gICkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIGRlYnVnKCdJbnZhbGlkIGNvbG9yOicsIHZhbHVlKVxuICByZXR1cm4gbnVsbFxufVxuXG4vKiogVmFsaWRhdGVzIHRlcm1pbmFsIHR5cGUgKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRlcm1pbmFsVHlwZSh0ZXJtOiB1bmtub3duKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICghdGVybSB8fCB0eXBlb2YgdGVybSAhPT0gJ3N0cmluZycpIHJldHVybiBudWxsXG4gIGNvbnN0IHZhbHVlID0gdGVybS50cmltKClcbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCB8fCB2YWx1ZS5sZW5ndGggPiBNQVhfTEVOR1RIUy5zc2h0ZXJtKSByZXR1cm4gbnVsbFxuICBjb25zdCB2YWxpZFRlcm1UeXBlcyA9IFtcbiAgICAneHRlcm0nLFxuICAgICd4dGVybS0yNTZjb2xvcicsXG4gICAgJ3h0ZXJtLWNvbG9yJyxcbiAgICAneHRlcm0tMTZjb2xvcicsXG4gICAgJ3Z0MTAwJyxcbiAgICAndnQxMDInLFxuICAgICd2dDIyMCcsXG4gICAgJ2Fuc2knLFxuICAgICdsaW51eCcsXG4gICAgJ3NjcmVlbicsXG4gICAgJ3NjcmVlbi0yNTZjb2xvcicsXG4gICAgJ3J4dnQnLFxuICAgICdyeHZ0LXVuaWNvZGUnLFxuICAgICd0bXV4JyxcbiAgICAndG11eC0yNTZjb2xvcidcbiAgXVxuICBpZiAodmFsaWRUZXJtVHlwZXMuaW5jbHVkZXModmFsdWUudG9Mb3dlckNhc2UoKSkpIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHRlcm1SZWdleCA9IC9eW2EtekEtWjAtOS1dKyQvXG4gIGlmICh0ZXJtUmVnZXgudGVzdCh2YWx1ZSkpIHJldHVybiB2YWx1ZVxuICBkZWJ1ZygnSW52YWxpZCB0ZXJtaW5hbCB0eXBlOicsIHZhbHVlKVxuICByZXR1cm4gbnVsbFxufVxuXG4vKiogVmFsaWRhdGVzIGxvZyBsZXZlbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTG9nTGV2ZWwobGV2ZWw6IHVua25vd24pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFsZXZlbCB8fCB0eXBlb2YgbGV2ZWwgIT09ICdzdHJpbmcnKSByZXR1cm4gbnVsbFxuICBjb25zdCB2YWx1ZSA9IGxldmVsLnRyaW0oKS50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHZhbGlkTGV2ZWxzID0gWydlcnJvcicsICd3YXJuJywgJ2luZm8nLCAnZGVidWcnLCAndHJhY2UnLCAnc2lsZW50J11cbiAgaWYgKHZhbGlkTGV2ZWxzLmluY2x1ZGVzKHZhbHVlKSkgcmV0dXJuIHZhbHVlXG4gIGRlYnVnKCdJbnZhbGlkIGxvZyBsZXZlbDonLCB2YWx1ZSlcbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqIFZhbGlkYXRlcyBhbGwgVVJMIHBhcmFtZXRlcnMgYW5kIHJldHVybnMgc2FuaXRpemVkIHZhbHVlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVXJsUGFyYW1ldGVycyhwYXJhbXM6IFVSTFNlYXJjaFBhcmFtcykge1xuICBjb25zdCB2YWxpZGF0ZWQgPSB7XG4gICAgaG9zdDogbnVsbCBhcyBzdHJpbmcgfCBudWxsLFxuICAgIHBvcnQ6IDIyLFxuICAgIHVzZXJuYW1lOiBudWxsIGFzIHN0cmluZyB8IG51bGwsXG4gICAgcGFzc3dvcmQ6IG51bGwgYXMgc3RyaW5nIHwgbnVsbCxcbiAgICBoZWFkZXI6IHsgdGV4dDogJycsIGJhY2tncm91bmQ6IG51bGwgYXMgc3RyaW5nIHwgbnVsbCB9LFxuICAgIHNzaHRlcm06IG51bGwgYXMgc3RyaW5nIHwgbnVsbCxcbiAgICBsb2dMZXZlbDogbnVsbCBhcyBzdHJpbmcgfCBudWxsXG4gIH1cbiAgY29uc3QgaG9zdCA9IHBhcmFtcy5nZXQoJ2hvc3QnKVxuICBpZiAoaG9zdCkgdmFsaWRhdGVkLmhvc3QgPSB2YWxpZGF0ZUhvc3QoaG9zdClcbiAgY29uc3QgcG9ydCA9IHBhcmFtcy5nZXQoJ3BvcnQnKVxuICBpZiAocG9ydCkge1xuICAgIGNvbnN0IHZhbGlkUG9ydCA9IHZhbGlkYXRlUG9ydChwb3J0KVxuICAgIGlmICh2YWxpZFBvcnQpIHZhbGlkYXRlZC5wb3J0ID0gdmFsaWRQb3J0XG4gIH1cbiAgY29uc3QgdXNlcm5hbWUgPSBwYXJhbXMuZ2V0KCd1c2VybmFtZScpXG4gIGlmICh1c2VybmFtZSkgdmFsaWRhdGVkLnVzZXJuYW1lID0gdmFsaWRhdGVVc2VybmFtZSh1c2VybmFtZSlcbiAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMuZ2V0KCdwYXNzd29yZCcpXG4gIGlmIChwYXNzd29yZCkgdmFsaWRhdGVkLnBhc3N3b3JkID0gdmFsaWRhdGVQYXNzd29yZChwYXNzd29yZClcbiAgY29uc3QgaGVhZGVyID0gcGFyYW1zLmdldCgnaGVhZGVyJylcbiAgaWYgKGhlYWRlcikgdmFsaWRhdGVkLmhlYWRlci50ZXh0ID0gdmFsaWRhdGVUZXh0KGhlYWRlcilcbiAgY29uc3QgaGVhZGVyQmcgPSBwYXJhbXMuZ2V0KCdoZWFkZXJiYWNrZ3JvdW5kJylcbiAgaWYgKGhlYWRlckJnKSB2YWxpZGF0ZWQuaGVhZGVyLmJhY2tncm91bmQgPSB2YWxpZGF0ZUNvbG9yKGhlYWRlckJnKVxuICBjb25zdCB0ZXJtID0gcGFyYW1zLmdldCgnc3NodGVybScpXG4gIGlmICh0ZXJtKSB2YWxpZGF0ZWQuc3NodGVybSA9IHZhbGlkYXRlVGVybWluYWxUeXBlKHRlcm0pXG4gIGNvbnN0IGxvZ0xldmVsID0gcGFyYW1zLmdldCgnbG9nTGV2ZWwnKVxuICBpZiAobG9nTGV2ZWwpIHZhbGlkYXRlZC5sb2dMZXZlbCA9IHZhbGlkYXRlTG9nTGV2ZWwobG9nTGV2ZWwpXG4gIGRlYnVnKCdWYWxpZGF0ZWQgVVJMIHBhcmFtZXRlcnM6JywgdmFsaWRhdGVkKVxuICByZXR1cm4gdmFsaWRhdGVkXG59XG5cbi8qKiBWYWxpZGF0ZXMgZm9ybSBkYXRhIGJlZm9yZSBzdWJtaXNzaW9uICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGb3JtRGF0YShmb3JtRGF0YTogdW5rbm93bikge1xuICBpZiAoIWZvcm1EYXRhIHx8IHR5cGVvZiBmb3JtRGF0YSAhPT0gJ29iamVjdCcpIHJldHVybiBudWxsXG4gIGNvbnN0IGZkID0gZm9ybURhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgY29uc3QgdmFsaWRhdGVkOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9XG5cbiAgaWYgKCFmZFsnaG9zdCddIHx8ICF2YWxpZGF0ZUhvc3QoZmRbJ2hvc3QnXSkpIHtcbiAgICBkZWJ1ZygnSW52YWxpZCBvciBtaXNzaW5nIGhvc3QnKVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFsaWRhdGVkWydob3N0J10gPSB2YWxpZGF0ZUhvc3QoZmRbJ2hvc3QnXSlcblxuICBpZiAoIWZkWyd1c2VybmFtZSddIHx8ICF2YWxpZGF0ZVVzZXJuYW1lKGZkWyd1c2VybmFtZSddKSkge1xuICAgIGRlYnVnKCdJbnZhbGlkIG9yIG1pc3NpbmcgdXNlcm5hbWUnKVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFsaWRhdGVkWyd1c2VybmFtZSddID0gdmFsaWRhdGVVc2VybmFtZShmZFsndXNlcm5hbWUnXSlcblxuICBpZiAoZmRbJ3BvcnQnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcG9ydCA9IHZhbGlkYXRlUG9ydChmZFsncG9ydCddKVxuICAgIGlmICghcG9ydCkge1xuICAgICAgZGVidWcoJ0ludmFsaWQgcG9ydCcpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YWxpZGF0ZWRbJ3BvcnQnXSA9IHBvcnRcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZWRbJ3BvcnQnXSA9IDIyXG4gIH1cblxuICBpZiAoZmRbJ3Bhc3N3b3JkJ10pIHZhbGlkYXRlZFsncGFzc3dvcmQnXSA9IHZhbGlkYXRlUGFzc3dvcmQoZmRbJ3Bhc3N3b3JkJ10pXG4gIGlmIChmZFsncHJpdmF0ZUtleSddKSB7XG4gICAgY29uc3QgcGsgPSBTdHJpbmcoZmRbJ3ByaXZhdGVLZXknXSlcbiAgICBpZiAocGsubGVuZ3RoID4gTUFYX0xFTkdUSFMucHJpdmF0ZUtleSkge1xuICAgICAgZGVidWcoJ1ByaXZhdGUga2V5IHRvbyBsYXJnZScpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YWxpZGF0ZWRbJ3ByaXZhdGVLZXknXSA9IHBrXG4gIH1cbiAgaWYgKGZkWydwYXNzcGhyYXNlJ10pIHtcbiAgICBjb25zdCBwcCA9IFN0cmluZyhmZFsncGFzc3BocmFzZSddKVxuICAgIGlmIChwcC5sZW5ndGggPiBNQVhfTEVOR1RIUy5wYXNzcGhyYXNlKSB7XG4gICAgICBkZWJ1ZygnUGFzc3BocmFzZSB0b28gbG9uZycpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YWxpZGF0ZWRbJ3Bhc3NwaHJhc2UnXSA9IHBwXG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRlZFxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZhbGlkYXRlSG9zdCxcbiAgdmFsaWRhdGVQb3J0LFxuICB2YWxpZGF0ZVVzZXJuYW1lLFxuICB2YWxpZGF0ZVBhc3N3b3JkLFxuICB2YWxpZGF0ZVRleHQsXG4gIHZhbGlkYXRlQ29sb3IsXG4gIHZhbGlkYXRlVGVybWluYWxUeXBlLFxuICB2YWxpZGF0ZUxvZ0xldmVsLFxuICB2YWxpZGF0ZVVybFBhcmFtZXRlcnMsXG4gIHZhbGlkYXRlRm9ybURhdGEsXG4gIE1BWF9MRU5HVEhTXG59XG4iLCIvLyBjbGllbnRcbi8vIGNsaWVudC9zcmMvanMvdXRpbHMudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCBtYXNrT2JqZWN0IGZyb20gJ2pzbWFza2VyJ1xuaW1wb3J0IHtcbiAgdmFsaWRhdGVIb3N0LFxuICB2YWxpZGF0ZVBvcnQsXG4gIHZhbGlkYXRlVXNlcm5hbWUsXG4gIHZhbGlkYXRlUGFzc3dvcmQsXG4gIHZhbGlkYXRlVGV4dCxcbiAgdmFsaWRhdGVDb2xvcixcbiAgdmFsaWRhdGVUZXJtaW5hbFR5cGUsXG4gIHZhbGlkYXRlTG9nTGV2ZWxcbn0gZnJvbSAnLi9pbnB1dC12YWxpZGF0b3IuanMnXG5cbmltcG9ydCB0eXBlIHsgVGVybWluYWxTZXR0aW5ncywgV2ViU1NIMkNvbmZpZyB9IGZyb20gJy4uL3R5cGVzL2NvbmZpZy5kJ1xuaW1wb3J0IHR5cGUgeyBDbGllbnRBdXRoZW50aWNhdGVQYXlsb2FkIH0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzLmQnXG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ3dlYnNzaDItY2xpZW50OnV0aWxzJylcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRTZXR0aW5nczogVGVybWluYWxTZXR0aW5ncyA9IHtcbiAgY3Vyc29yQmxpbms6IHRydWUsXG4gIHNjcm9sbGJhY2s6IDEwMDAwLFxuICB0YWJTdG9wV2lkdGg6IDgsXG4gIGJlbGxTdHlsZTogJ3NvdW5kJyxcbiAgZm9udFNpemU6IDE0LFxuICBmb250RmFtaWx5OiAnY291cmllci1uZXcsIGNvdXJpZXIsIG1vbm9zcGFjZScsXG4gIGxldHRlclNwYWNpbmc6IDAsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIGxvZ0xldmVsOiAnaW5mbydcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKFxuICB2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLFxuICBtaW46IG51bWJlcixcbiAgbWF4OiBudW1iZXIsXG4gIGRlZmF1bHRWYWx1ZTogbnVtYmVyXG4pOiBudW1iZXIge1xuICBjb25zdCBudW0gPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBOdW1iZXIodmFsdWUpXG4gIGlmIChOdW1iZXIuaXNOYU4obnVtKSB8fCBudW0gPCBtaW4gfHwgbnVtID4gbWF4KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICB9XG4gIHJldHVybiBudW1cbn1cblxudHlwZSBPYmogPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoaXRlbTogdW5rbm93bik6IGl0ZW0gaXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICByZXR1cm4gISFpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEZWVwPFQsIFUgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIHRhcmdldDogVCxcbiAgc291cmNlOiBVXG4pOiBUICYgVSB7XG4gIGNvbnN0IG91dHB1dDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7XG4gICAgLi4uKHRhcmdldCBhcyB1bmtub3duIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVxuICB9XG4gIGlmIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3Qgc1ZhbCA9IChzb3VyY2UgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW2tleV1cbiAgICAgIGNvbnN0IHRWYWwgPSAodGFyZ2V0IGFzIHVua25vd24gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW2tleV1cbiAgICAgIGlmIChpc09iamVjdChzVmFsKSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gKHRhcmdldCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikpKSB7XG4gICAgICAgICAgb3V0cHV0W2tleV0gPSBzVmFsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0W2tleV0gPSBtZXJnZURlZXAoXG4gICAgICAgICAgICBpc09iamVjdCh0VmFsKSA/ICh0VmFsIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KSA6IHt9LFxuICAgICAgICAgICAgc1ZhbCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0W2tleV0gPSBzVmFsXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICByZXR1cm4gb3V0cHV0IGFzIFQgJiBVXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlKGRhdGU6IERhdGUpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7ZGF0ZS5nZXRGdWxsWWVhcigpfS8ke1N0cmluZyhkYXRlLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpfS8ke1N0cmluZyhkYXRlLmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKX0gQCAke1N0cmluZyhkYXRlLmdldEhvdXJzKCkpLnBhZFN0YXJ0KDIsICcwJyl9OiR7U3RyaW5nKGRhdGUuZ2V0TWludXRlcygpKS5wYWRTdGFydCgyLCAnMCcpfToke1N0cmluZyhkYXRlLmdldFNlY29uZHMoKSkucGFkU3RhcnQoMiwgJzAnKX1gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJlbGxTdHlsZShcbiAgdmFsdWU6IHN0cmluZyxcbiAgZGVmYXVsdFZhbHVlOiAnc291bmQnIHwgJ25vbmUnID0gJ3NvdW5kJ1xuKTogJ3NvdW5kJyB8ICdub25lJyB7XG4gIHJldHVybiBbJ3NvdW5kJywgJ25vbmUnXS5pbmNsdWRlcyh2YWx1ZSlcbiAgICA/ICh2YWx1ZSBhcyAnc291bmQnIHwgJ25vbmUnKVxuICAgIDogZGVmYXVsdFZhbHVlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQ29uZmlnKCk6IFdlYlNTSDJDb25maWcge1xuICBjb25zdCBkZWZhdWx0Q29uZmlnOiBXZWJTU0gyQ29uZmlnID0ge1xuICAgIHNvY2tldDoge1xuICAgICAgdXJsOiBudWxsLFxuICAgICAgcGF0aDogJy9zc2gvc29ja2V0LmlvJ1xuICAgIH0sXG4gICAgc3NoOiB7XG4gICAgICBob3N0OiBudWxsLFxuICAgICAgcG9ydDogMjIsXG4gICAgICB1c2VybmFtZTogbnVsbCxcbiAgICAgIHBhc3N3b3JkOiBudWxsLFxuICAgICAgc3NodGVybTogJ3h0ZXJtLWNvbG9yJ1xuICAgIH0sXG4gICAgdGVybWluYWw6IHsgLi4uZGVmYXVsdFNldHRpbmdzIH0sXG4gICAgaGVhZGVyOiB7XG4gICAgICB0ZXh0OiBudWxsLFxuICAgICAgYmFja2dyb3VuZDogJ2dyZWVuJ1xuICAgIH0sXG4gICAgYXV0b0Nvbm5lY3Q6IGZhbHNlLFxuICAgIGxvZ0xldmVsOiAnaW5mbydcbiAgfVxuICBjb25zdCB1c2VyQ29uZmlnID0gKHdpbmRvdyBhcyBXaW5kb3cpLndlYnNzaDJDb25maWcgfHwge31cbiAgY29uc3QgY29uZmlnID0gbWVyZ2VEZWVwKFxuICAgIGRlZmF1bHRDb25maWcsXG4gICAgdXNlckNvbmZpZyBhcyBQYXJ0aWFsPFdlYlNTSDJDb25maWc+XG4gICkgYXMgV2ViU1NIMkNvbmZpZ1xuICBkZWJ1ZygnaW5pdGlhbGl6ZUNvbmZpZycsIGNvbmZpZylcbiAgcmV0dXJuIGNvbmZpZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wdWxhdGVGb3JtRnJvbVVybChjb25maWc6IFdlYlNTSDJDb25maWcpOiBXZWJTU0gyQ29uZmlnIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gZ2V0VXJsUGFyYW1zKClcbiAgY29uc3QgcGFyYW1zOiBPYmogPSB7XG4gICAgc3NoOiB7fSxcbiAgICBoZWFkZXI6IHt9LFxuICAgIHRlcm1pbmFsOiB7fVxuICB9XG5cbiAgY29uc3QgcGFyYW1ldGVyTGlzdCA9IFtcbiAgICAnaG9zdCcsXG4gICAgJ3BvcnQnLFxuICAgICdoZWFkZXInLFxuICAgICdoZWFkZXJiYWNrZ3JvdW5kJyxcbiAgICAnc3NodGVybScsXG4gICAgJ3VzZXJuYW1lJyxcbiAgICAncGFzc3dvcmQnLFxuICAgICdsb2dMZXZlbCdcbiAgXSBhcyBjb25zdFxuXG4gIHBhcmFtZXRlckxpc3QuZm9yRWFjaCgocGFyYW0pID0+IHtcbiAgICBsZXQgdmFsdWUgPSBzZWFyY2hQYXJhbXMuZ2V0KHBhcmFtKVxuXG4gICAgaWYgKHBhcmFtID09PSAncG9ydCcgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJykpIHtcbiAgICAgIHZhbHVlID0gJzIyJ1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgbGV0IF9fdmFsaWRhdGVkVmFsdWU6IHVua25vd24gPSBudWxsXG5cbiAgICAgIHN3aXRjaCAocGFyYW0pIHtcbiAgICAgICAgY2FzZSAnaG9zdCc6XG4gICAgICAgICAgX192YWxpZGF0ZWRWYWx1ZSA9IHZhbGlkYXRlSG9zdCh2YWx1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwb3J0JzpcbiAgICAgICAgICBfX3ZhbGlkYXRlZFZhbHVlID0gdmFsaWRhdGVQb3J0KHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3VzZXJuYW1lJzpcbiAgICAgICAgICBfX3ZhbGlkYXRlZFZhbHVlID0gdmFsaWRhdGVVc2VybmFtZSh2YWx1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICAgICAgX192YWxpZGF0ZWRWYWx1ZSA9IHZhbGlkYXRlUGFzc3dvcmQodmFsdWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnaGVhZGVyJzoge1xuICAgICAgICAgIGNvbnN0IHRleHQgPSB2YWxpZGF0ZVRleHQodmFsdWUpXG4gICAgICAgICAgaWYgKHRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IChwYXJhbXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pWydoZWFkZXInXSBhc1xuICAgICAgICAgICAgICB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgICAgICAgICAgIHwgdW5kZWZpbmVkXG4gICAgICAgICAgICA7KHBhcmFtcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbJ2hlYWRlciddID0ge1xuICAgICAgICAgICAgICAuLi4oaGVhZGVyID8/IHt9KSxcbiAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2hlYWRlcmJhY2tncm91bmQnOiB7XG4gICAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IHZhbGlkYXRlQ29sb3IodmFsdWUpXG4gICAgICAgICAgaWYgKGJhY2tncm91bmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IChwYXJhbXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pWydoZWFkZXInXSBhc1xuICAgICAgICAgICAgICB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgICAgICAgICAgIHwgdW5kZWZpbmVkXG4gICAgICAgICAgICA7KHBhcmFtcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbJ2hlYWRlciddID0ge1xuICAgICAgICAgICAgICAuLi4oaGVhZGVyID8/IHt9KSxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NzaHRlcm0nOlxuICAgICAgICAgIF9fdmFsaWRhdGVkVmFsdWUgPSB2YWxpZGF0ZVRlcm1pbmFsVHlwZSh2YWx1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdsb2dMZXZlbCc6XG4gICAgICAgICAgX192YWxpZGF0ZWRWYWx1ZSA9IHZhbGlkYXRlTG9nTGV2ZWwodmFsdWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBfX3ZhbGlkYXRlZFZhbHVlID0gdmFsdWVcbiAgICAgIH1cblxuICAgICAgLy8gRm9ybSB2YWx1ZXMgYXJlIG5vdyBoYW5kbGVkIGJ5IFNvbGlkSlMgY29udHJvbGxlZCBjb21wb25lbnRzXG4gICAgICAvLyBObyBuZWVkIHRvIHNldCBET00gaW5wdXQgdmFsdWVzIGRpcmVjdGx5XG4gICAgfVxuICB9KVxuICBjb25zdCByZXN1bHQgPSBtZXJnZURlZXAoY29uZmlnLCBwYXJhbXMgYXMgT2JqKSBhcyBXZWJTU0gyQ29uZmlnXG5cbiAgLy8gRW5hYmxlIGF1dG9Db25uZWN0IGlmIGhvc3QgaXMgcHJvdmlkZWQgaW4gVVJMXG4gIGNvbnN0IHVybEhvc3QgPSBzZWFyY2hQYXJhbXMuZ2V0KCdob3N0JylcbiAgaWYgKHVybEhvc3QgJiYgcmVzdWx0LnNzaCkge1xuICAgIHJlc3VsdC5hdXRvQ29ubmVjdCA9IHRydWVcbiAgICBkZWJ1ZygncG9wdWxhdGVGb3JtRnJvbVVybDogYXV0b0Nvbm5lY3QgZW5hYmxlZCBkdWUgdG8gVVJMIGhvc3QgcGFyYW1ldGVyJylcbiAgfVxuXG4gIGRlYnVnKCdwb3B1bGF0ZUZvcm1Gcm9tVXJsJywgcmVzdWx0KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGdldFVybFBhcmFtcygpOiBVUkxTZWFyY2hQYXJhbXMge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHMoXG4gIGZvcm1EYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IG51bGwgPSBudWxsLFxuICB0ZXJtaW5hbERpbWVuc2lvbnM6IHsgY29scz86IG51bWJlcjsgcm93cz86IG51bWJlciB9ID0ge31cbik6IENsaWVudEF1dGhlbnRpY2F0ZVBheWxvYWQge1xuICBjb25zdCBjZmcgPSAod2luZG93IGFzIFdpbmRvdykud2Vic3NoMkNvbmZpZyB8fCB7fVxuICBjb25zdCB1cmxQYXJhbXMgPSBnZXRVcmxQYXJhbXMoKVxuXG4gIGNvbnN0IGZkID0gZm9ybURhdGEgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsXG5cbiAgY29uc3QgcG9ydFZhbHVlID1cbiAgICAoZmQ/LlsncG9ydCddIGFzIG51bWJlciB8IHN0cmluZyB8IHVuZGVmaW5lZCkgfHxcbiAgICB1cmxQYXJhbXMuZ2V0KCdwb3J0JykgfHxcbiAgICAoY2ZnLnNzaD8ucG9ydCBhcyBudW1iZXIgfCB1bmRlZmluZWQpIHx8XG4gICAgJzIyJ1xuXG4gIGxldCBwb3J0ID0gcGFyc2VJbnQoU3RyaW5nKHBvcnRWYWx1ZSksIDEwKVxuICBpZiAoTnVtYmVyLmlzTmFOKHBvcnQpIHx8IHBvcnQgPCAxIHx8IHBvcnQgPiA2NTUzNSkge1xuICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBwb3J0IHZhbHVlOiAke1N0cmluZyhwb3J0VmFsdWUpfSwgZGVmYXVsdGluZyB0byAyMmApXG4gICAgcG9ydCA9IDIyXG4gIH1cblxuICBjb25zdCBtZXJnZWRDb25maWc6IENsaWVudEF1dGhlbnRpY2F0ZVBheWxvYWQgPSB7XG4gICAgaG9zdDpcbiAgICAgIChmZD8uWydob3N0J10gYXMgc3RyaW5nIHwgdW5kZWZpbmVkKSB8fFxuICAgICAgdXJsUGFyYW1zLmdldCgnaG9zdCcpIHx8XG4gICAgICAoY2ZnLnNzaD8uaG9zdCBhcyBzdHJpbmcgfCB1bmRlZmluZWQpIHx8XG4gICAgICAnJyxcbiAgICBwb3J0LFxuICAgIHVzZXJuYW1lOlxuICAgICAgKGZkPy5bJ3VzZXJuYW1lJ10gYXMgc3RyaW5nIHwgdW5kZWZpbmVkKSB8fFxuICAgICAgdXJsUGFyYW1zLmdldCgndXNlcm5hbWUnKSB8fFxuICAgICAgKGNmZy5zc2g/LnVzZXJuYW1lIGFzIHN0cmluZyB8IHVuZGVmaW5lZCkgfHxcbiAgICAgICcnLFxuICAgIHBhc3N3b3JkOlxuICAgICAgKGZkPy5bJ3Bhc3N3b3JkJ10gYXMgc3RyaW5nIHwgdW5kZWZpbmVkKSB8fFxuICAgICAgdXJsUGFyYW1zLmdldCgncGFzc3dvcmQnKSB8fFxuICAgICAgKGNmZy5zc2g/LnBhc3N3b3JkIGFzIHN0cmluZyB8IHVuZGVmaW5lZCkgfHxcbiAgICAgICcnLFxuICAgIHRlcm06XG4gICAgICAoZmQ/LlsndGVybSddIGFzIHN0cmluZyB8IHVuZGVmaW5lZCkgfHxcbiAgICAgIHVybFBhcmFtcy5nZXQoJ3NzaHRlcm0nKSB8fFxuICAgICAgKGNmZy5zc2g/LnNzaHRlcm0gYXMgc3RyaW5nIHwgdW5kZWZpbmVkKSB8fFxuICAgICAgJ3h0ZXJtLWNvbG9yJ1xuICB9XG5cbiAgY29uc3QgcHJpdmF0ZUtleSA9XG4gICAgKGZkPy5bJ3ByaXZhdGVLZXknXSBhcyBzdHJpbmcgfCB1bmRlZmluZWQpIHx8XG4gICAgdXJsUGFyYW1zLmdldCgncHJpdmF0ZUtleScpIHx8XG4gICAgKGNmZy5zc2g/LnByaXZhdGVLZXkgYXMgc3RyaW5nIHwgdW5kZWZpbmVkKSB8fFxuICAgICcnXG4gIGlmIChwcml2YXRlS2V5KSB7XG4gICAgbWVyZ2VkQ29uZmlnLnByaXZhdGVLZXkgPSBwcml2YXRlS2V5XG4gICAgY29uc3QgcGFzc3BocmFzZSA9XG4gICAgICAoZmQ/LlsncGFzc3BocmFzZSddIGFzIHN0cmluZyB8IHVuZGVmaW5lZCkgfHxcbiAgICAgIHVybFBhcmFtcy5nZXQoJ3Bhc3NwaHJhc2UnKSB8fFxuICAgICAgKGNmZy5zc2g/LnBhc3NwaHJhc2UgYXMgc3RyaW5nIHwgdW5kZWZpbmVkKSB8fFxuICAgICAgJydcbiAgICBpZiAocGFzc3BocmFzZSkgbWVyZ2VkQ29uZmlnLnBhc3NwaHJhc2UgPSBwYXNzcGhyYXNlXG4gIH1cblxuICBpZiAodGVybWluYWxEaW1lbnNpb25zLmNvbHMpIG1lcmdlZENvbmZpZy5jb2xzID0gdGVybWluYWxEaW1lbnNpb25zLmNvbHNcbiAgaWYgKHRlcm1pbmFsRGltZW5zaW9ucy5yb3dzKSBtZXJnZWRDb25maWcucm93cyA9IHRlcm1pbmFsRGltZW5zaW9ucy5yb3dzXG5cbiAgY29uc3QgbWFza2VkQ29udGVudCA9IG1hc2tPYmplY3QobWVyZ2VkQ29uZmlnKVxuICBkZWJ1ZygnZ2V0Q3JlZGVudGlhbHM6IG1lcmdlZENvbmZpZzonLCBtYXNrZWRDb250ZW50KVxuICByZXR1cm4gbWVyZ2VkQ29uZmlnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUNvbG9yKGNvbG9yOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgY29sb3JSZWdleCA9XG4gICAgL14oIyhbMC05YS1mQS1GXXszfSl7MSwyfXxyZ2JhP1xcKFxccyooXFxkezEsM31cXHMqLFxccyopezIsM31cXHMqXFxkezEsM31cXHMqXFwpfFthLXpBLVpdKykkL1xuICByZXR1cm4gY29sb3JSZWdleC50ZXN0KGNvbG9yKSA/IGNvbG9yIDogbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJCYXNpY0F1dGhDb29raWUoKTogdm9pZCB7XG4gIGRvY3VtZW50LmNvb2tpZSA9ICdiYXNpY2F1dGg9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDOyBwYXRoPS8nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYXNpY0F1dGhDb29raWUoKTogeyBob3N0Pzogc3RyaW5nOyBwb3J0PzogbnVtYmVyIH0gfCBudWxsIHtcbiAgY29uc3QgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29va2llcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvb2tpZSA9IGNvb2tpZXNbaV0hLnRyaW0oKVxuICAgIGlmIChjb29raWUuc3RhcnRzV2l0aCgnYmFzaWNhdXRoPScpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKFxuICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChjb29raWUuc3Vic3RyaW5nKCdiYXNpY2F1dGg9Jy5sZW5ndGgpKVxuICAgICAgICApIGFzIHtcbiAgICAgICAgICBob3N0Pzogc3RyaW5nXG4gICAgICAgICAgcG9ydD86IG51bWJlclxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnZ2V0QmFzaWNBdXRoQ29va2llOiBGYWlsZWQgdG8gcGFyc2UgYmFzaWNhdXRoIGNvb2tpZTonLFxuICAgICAgICAgIGVcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcml2YXRlS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIEJlIGluY2x1c2l2ZSBvZiBjb21tb24ga2V5IGZvcm1hdHMgdXNlZCBieSBPcGVuU1NIIGFuZCBQS0NTIzEvUEtDUyM4XG4gIC8vIEFjY2VwdHM6IE9QRU5TU0ggUFJJVkFURSBLRVksIFJTQS9FQy9EU0EgUFJJVkFURSBLRVksIGFuZCBnZW5lcmljIFBSSVZBVEUgS0VZXG4gIGNvbnN0IHRleHQgPSBTdHJpbmcoa2V5IHx8ICcnKS50cmltKClcbiAgaWYgKCF0ZXh0LnN0YXJ0c1dpdGgoJy0tLS0tQkVHSU4nKSB8fCAhdGV4dC5pbmNsdWRlcygnUFJJVkFURSBLRVktLS0tLScpKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IHBhdHRlcm5zOiBSZWdFeHBbXSA9IFtcbiAgICAvLyBPcGVuU1NIIGZvcm1hdFxuICAgIC9eLS0tLS1CRUdJTiBPUEVOU1NIIFBSSVZBVEUgS0VZLS0tLS1bXFxzXFxTXSstLS0tLUVORCBPUEVOU1NIIFBSSVZBVEUgS0VZLS0tLS1cXHMqJC9tLFxuICAgIC8vIFBLQ1MjOCBnZW5lcmljXG4gICAgL14tLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1bXFxzXFxTXSstLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tXFxzKiQvbSxcbiAgICAvLyBQS0NTIzEgUlNBXG4gICAgL14tLS0tLUJFR0lOIFJTQSBQUklWQVRFIEtFWS0tLS0tW1xcc1xcU10rLS0tLS1FTkQgUlNBIFBSSVZBVEUgS0VZLS0tLS1cXHMqJC9tLFxuICAgIC8vIEVDIGFuZCBEU0FcbiAgICAvXi0tLS0tQkVHSU4gRUMgUFJJVkFURSBLRVktLS0tLVtcXHNcXFNdKy0tLS0tRU5EIEVDIFBSSVZBVEUgS0VZLS0tLS1cXHMqJC9tLFxuICAgIC9eLS0tLS1CRUdJTiBEU0EgUFJJVkFURSBLRVktLS0tLVtcXHNcXFNdKy0tLS0tRU5EIERTQSBQUklWQVRFIEtFWS0tLS0tXFxzKiQvbVxuICBdXG4gIHJldHVybiBwYXR0ZXJucy5zb21lKChyZSkgPT4gcmUudGVzdCh0ZXh0KSlcbn1cblxuLyoqXG4gKiBEZWVwIHZhbGlkYXRpb24gb2YgcHJpdmF0ZSBrZXlzLlxuICogUGhhc2UgMTogaGVhZGVyL2Zvb3RlciByZWdleCAoaGFuZGxlZCBieSB2YWxpZGF0ZVByaXZhdGVLZXkpLlxuICogUGhhc2UgMjogcGFyc2UgdGhlIGJsb2NrIHBheWxvYWQgdG8gZW5zdXJlIGl0IGlzIHN0cnVjdHVyYWxseSB2YWxpZC5cbiAqIC0gT1BFTlNTSDogYmFzZTY0IGRlY29kZXMgdG8gY29udGVudCBzdGFydGluZyB3aXRoIFwib3BlbnNzaC1rZXktdjFcXDBcIlxuICogLSBQS0NTIzEvOC9FQy9EU0E6IGJhc2U2NCBkZWNvZGVzIHRvIERFUiBzdGFydGluZyB3aXRoIDB4MzAgKFNFUVVFTkNFKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcml2YXRlS2V5RGVlcChcbiAga2V5OiBzdHJpbmdcbik6IHsgZm9ybWF0OiAnT1BFTlNTSCcgfCAnUEtDUzgnIHwgJ1BLQ1MxLVJTQScgfCAnRUMnIHwgJ0RTQScgfSB8IG51bGwge1xuICBjb25zdCB0ZXh0ID0gU3RyaW5nKGtleSB8fCAnJykudHJpbSgpXG4gIC8vIElkZW50aWZ5IGJsb2NrIHR5cGUgYW5kIGV4dHJhY3QgYmFzZTY0IGJvZHlcbiAgY29uc3QgYmxvY2tzOiBBcnJheTx7IHR5cGU6IHN0cmluZzsgYm9keTogc3RyaW5nIH0+ID0gW11cbiAgY29uc3QgcGF0dGVybnM6IEFycmF5PHsgdHlwZTogc3RyaW5nOyByZTogUmVnRXhwIH0+ID0gW1xuICAgIHtcbiAgICAgIHR5cGU6ICdPUEVOU1NIJyxcbiAgICAgIHJlOiAvLS0tLS1CRUdJTiBPUEVOU1NIIFBSSVZBVEUgS0VZLS0tLS0oPzxib2R5PltcXHNcXFNdKz8pLS0tLS1FTkQgT1BFTlNTSCBQUklWQVRFIEtFWS0tLS0tL21cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6ICdQS0NTOCcsXG4gICAgICByZTogLy0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLSg/PGJvZHk+W1xcc1xcU10rPyktLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tL21cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6ICdQS0NTMS1SU0EnLFxuICAgICAgcmU6IC8tLS0tLUJFR0lOIFJTQSBQUklWQVRFIEtFWS0tLS0tKD88Ym9keT5bXFxzXFxTXSs/KS0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tL21cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6ICdFQycsXG4gICAgICByZTogLy0tLS0tQkVHSU4gRUMgUFJJVkFURSBLRVktLS0tLSg/PGJvZHk+W1xcc1xcU10rPyktLS0tLUVORCBFQyBQUklWQVRFIEtFWS0tLS0tL21cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6ICdEU0EnLFxuICAgICAgcmU6IC8tLS0tLUJFR0lOIERTQSBQUklWQVRFIEtFWS0tLS0tKD88Ym9keT5bXFxzXFxTXSs/KS0tLS0tRU5EIERTQSBQUklWQVRFIEtFWS0tLS0tL21cbiAgICB9XG4gIF1cbiAgZm9yIChjb25zdCB7IHR5cGUsIHJlIH0gb2YgcGF0dGVybnMpIHtcbiAgICBjb25zdCBtID0gdGV4dC5tYXRjaChyZSlcbiAgICBpZiAobSAmJiBtLmdyb3VwcyAmJiBtLmdyb3Vwc1snYm9keSddKSB7XG4gICAgICBibG9ja3MucHVzaCh7IHR5cGUsIGJvZHk6IG0uZ3JvdXBzWydib2R5J10gfSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGlmIChibG9ja3MubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IHsgdHlwZSwgYm9keSB9ID0gYmxvY2tzWzBdIVxuICBjb25zdCBiNjQgPSBib2R5LnJlcGxhY2UoL1xccysvZywgJycpXG4gIGxldCBieXRlczogVWludDhBcnJheVxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgYmluID0gYXRvYihiNjQpXG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7IGkrKykgYnl0ZXNbaV0gPSBiaW4uY2hhckNvZGVBdChpKVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChnbG9iYWxUaGlzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVsnQnVmZmVyJ11cbiAgICApIHtcbiAgICAgIGNvbnN0IEIgPSAoXG4gICAgICAgIGdsb2JhbFRoaXMgYXMgdW5rbm93biBhcyB7XG4gICAgICAgICAgQnVmZmVyOiB7IGZyb206IChzOiBzdHJpbmcsIGVuYzogc3RyaW5nKSA9PiBVaW50OEFycmF5IH1cbiAgICAgICAgfVxuICAgICAgKVsnQnVmZmVyJ11cbiAgICAgIGNvbnN0IGJ1ZiA9IEIuZnJvbShiNjQsICdiYXNlNjQnKVxuICAgICAgYnl0ZXMgPSBidWYgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnVmIDogbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnT1BFTlNTSCcpIHtcbiAgICAvLyBPcGVuU1NIIGtleXMgc3RhcnQgd2l0aCBtYWdpYzogXCJvcGVuc3NoLWtleS12MVxcMFwiXG4gICAgY29uc3QgbWFnaWMgPSAnb3BlbnNzaC1rZXktdjFcXDAnXG4gICAgY29uc3QgcHJlZml4ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzLnNsaWNlKDAsIG1hZ2ljLmxlbmd0aCkpXG4gICAgaWYgKHByZWZpeCA9PT0gbWFnaWMpIHJldHVybiB7IGZvcm1hdDogJ09QRU5TU0gnIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gREVSIHNob3VsZCBzdGFydCB3aXRoIFNFUVVFTkNFICgweDMwKVxuICBpZiAoYnl0ZXMubGVuZ3RoID49IDIgJiYgYnl0ZXNbMF0gPT09IDB4MzApIHtcbiAgICAvLyBPcHRpb25hbDogY2hlY2sgdGhlIGxlbmd0aCBmaWVsZCBpcyBwbGF1c2libGVcbiAgICAvLyBUaGlzIGlzIGEgbGlnaHQgY2hlY2sgdG8gYXZvaWQgZnVsbCBBU04uMSBwYXJzaW5nXG4gICAgcmV0dXJuIHsgZm9ybWF0OiB0eXBlIGFzICdQS0NTOCcgfCAnUEtDUzEtUlNBJyB8ICdFQycgfCAnRFNBJyB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cbiIsImltcG9ydCB7ICRQUk9YWSwgJFRSQUNLLCBnZXRMaXN0ZW5lciwgYmF0Y2gsIGNyZWF0ZVNpZ25hbCB9IGZyb20gJ3NvbGlkLWpzJztcblxuY29uc3QgJFJBVyA9IFN5bWJvbChcInN0b3JlLXJhd1wiKSxcbiAgJE5PREUgPSBTeW1ib2woXCJzdG9yZS1ub2RlXCIpLFxuICAkSEFTID0gU3ltYm9sKFwic3RvcmUtaGFzXCIpLFxuICAkU0VMRiA9IFN5bWJvbChcInN0b3JlLXNlbGZcIik7XG5mdW5jdGlvbiB3cmFwJDEodmFsdWUpIHtcbiAgbGV0IHAgPSB2YWx1ZVskUFJPWFldO1xuICBpZiAoIXApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsICRQUk9YWSwge1xuICAgICAgdmFsdWU6IHAgPSBuZXcgUHJveHkodmFsdWUsIHByb3h5VHJhcHMkMSlcbiAgICB9KTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpLFxuICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModmFsdWUpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBwcm9wID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGRlc2NbcHJvcF0uZ2V0KSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCBwcm9wLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjW3Byb3BdLmVudW1lcmFibGUsXG4gICAgICAgICAgICBnZXQ6IGRlc2NbcHJvcF0uZ2V0LmJpbmQocClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGlzV3JhcHBhYmxlKG9iaikge1xuICBsZXQgcHJvdG87XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIChvYmpbJFBST1hZXSB8fCAhKHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8IEFycmF5LmlzQXJyYXkob2JqKSk7XG59XG5mdW5jdGlvbiB1bndyYXAoaXRlbSwgc2V0ID0gbmV3IFNldCgpKSB7XG4gIGxldCByZXN1bHQsIHVud3JhcHBlZCwgdiwgcHJvcDtcbiAgaWYgKHJlc3VsdCA9IGl0ZW0gIT0gbnVsbCAmJiBpdGVtWyRSQVddKSByZXR1cm4gcmVzdWx0O1xuICBpZiAoIWlzV3JhcHBhYmxlKGl0ZW0pIHx8IHNldC5oYXMoaXRlbSkpIHJldHVybiBpdGVtO1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgIGlmIChPYmplY3QuaXNGcm96ZW4oaXRlbSkpIGl0ZW0gPSBpdGVtLnNsaWNlKDApO2Vsc2Ugc2V0LmFkZChpdGVtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGl0ZW0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2ID0gaXRlbVtpXTtcbiAgICAgIGlmICgodW53cmFwcGVkID0gdW53cmFwKHYsIHNldCkpICE9PSB2KSBpdGVtW2ldID0gdW53cmFwcGVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoT2JqZWN0LmlzRnJvemVuKGl0ZW0pKSBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgaXRlbSk7ZWxzZSBzZXQuYWRkKGl0ZW0pO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpdGVtKSxcbiAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhpdGVtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwcm9wID0ga2V5c1tpXTtcbiAgICAgIGlmIChkZXNjW3Byb3BdLmdldCkgY29udGludWU7XG4gICAgICB2ID0gaXRlbVtwcm9wXTtcbiAgICAgIGlmICgodW53cmFwcGVkID0gdW53cmFwKHYsIHNldCkpICE9PSB2KSBpdGVtW3Byb3BdID0gdW53cmFwcGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVzKHRhcmdldCwgc3ltYm9sKSB7XG4gIGxldCBub2RlcyA9IHRhcmdldFtzeW1ib2xdO1xuICBpZiAoIW5vZGVzKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBzeW1ib2wsIHtcbiAgICB2YWx1ZTogbm9kZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIH0pO1xuICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBnZXROb2RlKG5vZGVzLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgaWYgKG5vZGVzW3Byb3BlcnR5XSkgcmV0dXJuIG5vZGVzW3Byb3BlcnR5XTtcbiAgY29uc3QgW3MsIHNldF0gPSBjcmVhdGVTaWduYWwodmFsdWUsIHtcbiAgICBlcXVhbHM6IGZhbHNlLFxuICAgIGludGVybmFsOiB0cnVlXG4gIH0pO1xuICBzLiQgPSBzZXQ7XG4gIHJldHVybiBub2Rlc1twcm9wZXJ0eV0gPSBzO1xufVxuZnVuY3Rpb24gcHJveHlEZXNjcmlwdG9yJDEodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIGlmICghZGVzYyB8fCBkZXNjLmdldCB8fCAhZGVzYy5jb25maWd1cmFibGUgfHwgcHJvcGVydHkgPT09ICRQUk9YWSB8fCBwcm9wZXJ0eSA9PT0gJE5PREUpIHJldHVybiBkZXNjO1xuICBkZWxldGUgZGVzYy52YWx1ZTtcbiAgZGVsZXRlIGRlc2Mud3JpdGFibGU7XG4gIGRlc2MuZ2V0ID0gKCkgPT4gdGFyZ2V0WyRQUk9YWV1bcHJvcGVydHldO1xuICByZXR1cm4gZGVzYztcbn1cbmZ1bmN0aW9uIHRyYWNrU2VsZih0YXJnZXQpIHtcbiAgZ2V0TGlzdGVuZXIoKSAmJiBnZXROb2RlKGdldE5vZGVzKHRhcmdldCwgJE5PREUpLCAkU0VMRikoKTtcbn1cbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gIHRyYWNrU2VsZih0YXJnZXQpO1xuICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG59XG5jb25zdCBwcm94eVRyYXBzJDEgPSB7XG4gIGdldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJFJBVykgcmV0dXJuIHRhcmdldDtcbiAgICBpZiAocHJvcGVydHkgPT09ICRQUk9YWSkgcmV0dXJuIHJlY2VpdmVyO1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJFRSQUNLKSB7XG4gICAgICB0cmFja1NlbGYodGFyZ2V0KTtcbiAgICAgIHJldHVybiByZWNlaXZlcjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBnZXROb2Rlcyh0YXJnZXQsICROT0RFKTtcbiAgICBjb25zdCB0cmFja2VkID0gbm9kZXNbcHJvcGVydHldO1xuICAgIGxldCB2YWx1ZSA9IHRyYWNrZWQgPyB0cmFja2VkKCkgOiB0YXJnZXRbcHJvcGVydHldO1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJE5PREUgfHwgcHJvcGVydHkgPT09ICRIQVMgfHwgcHJvcGVydHkgPT09IFwiX19wcm90b19fXCIpIHJldHVybiB2YWx1ZTtcbiAgICBpZiAoIXRyYWNrZWQpIHtcbiAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKGdldExpc3RlbmVyKCkgJiYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiIHx8IHRhcmdldC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpICYmICEoZGVzYyAmJiBkZXNjLmdldCkpIHZhbHVlID0gZ2V0Tm9kZShub2RlcywgcHJvcGVydHksIHZhbHVlKSgpO1xuICAgIH1cbiAgICByZXR1cm4gaXNXcmFwcGFibGUodmFsdWUpID8gd3JhcCQxKHZhbHVlKSA6IHZhbHVlO1xuICB9LFxuICBoYXModGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJFJBVyB8fCBwcm9wZXJ0eSA9PT0gJFBST1hZIHx8IHByb3BlcnR5ID09PSAkVFJBQ0sgfHwgcHJvcGVydHkgPT09ICROT0RFIHx8IHByb3BlcnR5ID09PSAkSEFTIHx8IHByb3BlcnR5ID09PSBcIl9fcHJvdG9fX1wiKSByZXR1cm4gdHJ1ZTtcbiAgICBnZXRMaXN0ZW5lcigpICYmIGdldE5vZGUoZ2V0Tm9kZXModGFyZ2V0LCAkSEFTKSwgcHJvcGVydHkpKCk7XG4gICAgcmV0dXJuIHByb3BlcnR5IGluIHRhcmdldDtcbiAgfSxcbiAgc2V0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgb3duS2V5czogb3duS2V5cyxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBwcm94eURlc2NyaXB0b3IkMVxufTtcbmZ1bmN0aW9uIHNldFByb3BlcnR5KHN0YXRlLCBwcm9wZXJ0eSwgdmFsdWUsIGRlbGV0aW5nID0gZmFsc2UpIHtcbiAgaWYgKCFkZWxldGluZyAmJiBzdGF0ZVtwcm9wZXJ0eV0gPT09IHZhbHVlKSByZXR1cm47XG4gIGNvbnN0IHByZXYgPSBzdGF0ZVtwcm9wZXJ0eV0sXG4gICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBzdGF0ZVtwcm9wZXJ0eV07XG4gICAgaWYgKHN0YXRlWyRIQVNdICYmIHN0YXRlWyRIQVNdW3Byb3BlcnR5XSAmJiBwcmV2ICE9PSB1bmRlZmluZWQpIHN0YXRlWyRIQVNdW3Byb3BlcnR5XS4kKCk7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgaWYgKHN0YXRlWyRIQVNdICYmIHN0YXRlWyRIQVNdW3Byb3BlcnR5XSAmJiBwcmV2ID09PSB1bmRlZmluZWQpIHN0YXRlWyRIQVNdW3Byb3BlcnR5XS4kKCk7XG4gIH1cbiAgbGV0IG5vZGVzID0gZ2V0Tm9kZXMoc3RhdGUsICROT0RFKSxcbiAgICBub2RlO1xuICBpZiAobm9kZSA9IGdldE5vZGUobm9kZXMsIHByb3BlcnR5LCBwcmV2KSkgbm9kZS4kKCgpID0+IHZhbHVlKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGUpICYmIHN0YXRlLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXRlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSAobm9kZSA9IG5vZGVzW2ldKSAmJiBub2RlLiQoKTtcbiAgICAobm9kZSA9IGdldE5vZGUobm9kZXMsIFwibGVuZ3RoXCIsIGxlbikpICYmIG5vZGUuJChzdGF0ZS5sZW5ndGgpO1xuICB9XG4gIChub2RlID0gbm9kZXNbJFNFTEZdKSAmJiBub2RlLiQoKTtcbn1cbmZ1bmN0aW9uIG1lcmdlU3RvcmVOb2RlKHN0YXRlLCB2YWx1ZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIHNldFByb3BlcnR5KHN0YXRlLCBrZXksIHZhbHVlW2tleV0pO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVBcnJheShjdXJyZW50LCBuZXh0KSB7XG4gIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJmdW5jdGlvblwiKSBuZXh0ID0gbmV4dChjdXJyZW50KTtcbiAgbmV4dCA9IHVud3JhcChuZXh0KTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbmV4dCkgcmV0dXJuO1xuICAgIGxldCBpID0gMCxcbiAgICAgIGxlbiA9IG5leHQubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbmV4dFtpXTtcbiAgICAgIGlmIChjdXJyZW50W2ldICE9PSB2YWx1ZSkgc2V0UHJvcGVydHkoY3VycmVudCwgaSwgdmFsdWUpO1xuICAgIH1cbiAgICBzZXRQcm9wZXJ0eShjdXJyZW50LCBcImxlbmd0aFwiLCBsZW4pO1xuICB9IGVsc2UgbWVyZ2VTdG9yZU5vZGUoY3VycmVudCwgbmV4dCk7XG59XG5mdW5jdGlvbiB1cGRhdGVQYXRoKGN1cnJlbnQsIHBhdGgsIHRyYXZlcnNlZCA9IFtdKSB7XG4gIGxldCBwYXJ0LFxuICAgIHByZXYgPSBjdXJyZW50O1xuICBpZiAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgcGFydCA9IHBhdGguc2hpZnQoKTtcbiAgICBjb25zdCBwYXJ0VHlwZSA9IHR5cGVvZiBwYXJ0LFxuICAgICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY3VycmVudCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFydCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVQYXRoKGN1cnJlbnQsIFtwYXJ0W2ldXS5jb25jYXQocGF0aCksIHRyYXZlcnNlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpc0FycmF5ICYmIHBhcnRUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGFydChjdXJyZW50W2ldLCBpKSkgdXBkYXRlUGF0aChjdXJyZW50LCBbaV0uY29uY2F0KHBhdGgpLCB0cmF2ZXJzZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSAmJiBwYXJ0VHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcm9tID0gMCxcbiAgICAgICAgdG8gPSBjdXJyZW50Lmxlbmd0aCAtIDEsXG4gICAgICAgIGJ5ID0gMVxuICAgICAgfSA9IHBhcnQ7XG4gICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8PSB0bzsgaSArPSBieSkge1xuICAgICAgICB1cGRhdGVQYXRoKGN1cnJlbnQsIFtpXS5jb25jYXQocGF0aCksIHRyYXZlcnNlZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgIHVwZGF0ZVBhdGgoY3VycmVudFtwYXJ0XSwgcGF0aCwgW3BhcnRdLmNvbmNhdCh0cmF2ZXJzZWQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJldiA9IGN1cnJlbnRbcGFydF07XG4gICAgdHJhdmVyc2VkID0gW3BhcnRdLmNvbmNhdCh0cmF2ZXJzZWQpO1xuICB9XG4gIGxldCB2YWx1ZSA9IHBhdGhbMF07XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhbHVlID0gdmFsdWUocHJldiwgdHJhdmVyc2VkKTtcbiAgICBpZiAodmFsdWUgPT09IHByZXYpIHJldHVybjtcbiAgfVxuICBpZiAocGFydCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICB2YWx1ZSA9IHVud3JhcCh2YWx1ZSk7XG4gIGlmIChwYXJ0ID09PSB1bmRlZmluZWQgfHwgaXNXcmFwcGFibGUocHJldikgJiYgaXNXcmFwcGFibGUodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIG1lcmdlU3RvcmVOb2RlKHByZXYsIHZhbHVlKTtcbiAgfSBlbHNlIHNldFByb3BlcnR5KGN1cnJlbnQsIHBhcnQsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKC4uLltzdG9yZSwgb3B0aW9uc10pIHtcbiAgY29uc3QgdW53cmFwcGVkU3RvcmUgPSB1bndyYXAoc3RvcmUgfHwge30pO1xuICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh1bndyYXBwZWRTdG9yZSk7XG4gIGNvbnN0IHdyYXBwZWRTdG9yZSA9IHdyYXAkMSh1bndyYXBwZWRTdG9yZSk7XG4gIGZ1bmN0aW9uIHNldFN0b3JlKC4uLmFyZ3MpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICBpc0FycmF5ICYmIGFyZ3MubGVuZ3RoID09PSAxID8gdXBkYXRlQXJyYXkodW53cmFwcGVkU3RvcmUsIGFyZ3NbMF0pIDogdXBkYXRlUGF0aCh1bndyYXBwZWRTdG9yZSwgYXJncyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFt3cmFwcGVkU3RvcmUsIHNldFN0b3JlXTtcbn1cblxuZnVuY3Rpb24gcHJveHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHkpO1xuICBpZiAoIWRlc2MgfHwgZGVzYy5nZXQgfHwgZGVzYy5zZXQgfHwgIWRlc2MuY29uZmlndXJhYmxlIHx8IHByb3BlcnR5ID09PSAkUFJPWFkgfHwgcHJvcGVydHkgPT09ICROT0RFKSByZXR1cm4gZGVzYztcbiAgZGVsZXRlIGRlc2MudmFsdWU7XG4gIGRlbGV0ZSBkZXNjLndyaXRhYmxlO1xuICBkZXNjLmdldCA9ICgpID0+IHRhcmdldFskUFJPWFldW3Byb3BlcnR5XTtcbiAgZGVzYy5zZXQgPSB2ID0+IHRhcmdldFskUFJPWFldW3Byb3BlcnR5XSA9IHY7XG4gIHJldHVybiBkZXNjO1xufVxuY29uc3QgcHJveHlUcmFwcyA9IHtcbiAgZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkUkFXKSByZXR1cm4gdGFyZ2V0O1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJFBST1hZKSByZXR1cm4gcmVjZWl2ZXI7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkVFJBQ0spIHtcbiAgICAgIHRyYWNrU2VsZih0YXJnZXQpO1xuICAgICAgcmV0dXJuIHJlY2VpdmVyO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IGdldE5vZGVzKHRhcmdldCwgJE5PREUpO1xuICAgIGNvbnN0IHRyYWNrZWQgPSBub2Rlc1twcm9wZXJ0eV07XG4gICAgbGV0IHZhbHVlID0gdHJhY2tlZCA/IHRyYWNrZWQoKSA6IHRhcmdldFtwcm9wZXJ0eV07XG4gICAgaWYgKHByb3BlcnR5ID09PSAkTk9ERSB8fCBwcm9wZXJ0eSA9PT0gJEhBUyB8fCBwcm9wZXJ0eSA9PT0gXCJfX3Byb3RvX19cIikgcmV0dXJuIHZhbHVlO1xuICAgIGlmICghdHJhY2tlZCkge1xuICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBjb25zdCBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICBpZiAoZ2V0TGlzdGVuZXIoKSAmJiAoIWlzRnVuY3Rpb24gfHwgdGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkgJiYgIShkZXNjICYmIGRlc2MuZ2V0KSkgdmFsdWUgPSBnZXROb2RlKG5vZGVzLCBwcm9wZXJ0eSwgdmFsdWUpKCk7ZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiBpc0Z1bmN0aW9uICYmIHZhbHVlID09PSBBcnJheS5wcm90b3R5cGVbcHJvcGVydHldKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gYmF0Y2goKCkgPT4gQXJyYXkucHJvdG90eXBlW3Byb3BlcnR5XS5hcHBseShyZWNlaXZlciwgYXJncykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNXcmFwcGFibGUodmFsdWUpID8gd3JhcCh2YWx1ZSkgOiB2YWx1ZTtcbiAgfSxcbiAgaGFzKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICRSQVcgfHwgcHJvcGVydHkgPT09ICRQUk9YWSB8fCBwcm9wZXJ0eSA9PT0gJFRSQUNLIHx8IHByb3BlcnR5ID09PSAkTk9ERSB8fCBwcm9wZXJ0eSA9PT0gJEhBUyB8fCBwcm9wZXJ0eSA9PT0gXCJfX3Byb3RvX19cIikgcmV0dXJuIHRydWU7XG4gICAgZ2V0TGlzdGVuZXIoKSAmJiBnZXROb2RlKGdldE5vZGVzKHRhcmdldCwgJEhBUyksIHByb3BlcnR5KSgpO1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0YXJnZXQ7XG4gIH0sXG4gIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGJhdGNoKCgpID0+IHNldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHVud3JhcCh2YWx1ZSkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgIGJhdGNoKCgpID0+IHNldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBvd25LZXlzOiBvd25LZXlzLFxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IHByb3h5RGVzY3JpcHRvclxufTtcbmZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgbGV0IHAgPSB2YWx1ZVskUFJPWFldO1xuICBpZiAoIXApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsICRQUk9YWSwge1xuICAgICAgdmFsdWU6IHAgPSBuZXcgUHJveHkodmFsdWUsIHByb3h5VHJhcHMpXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKSxcbiAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh2YWx1ZSk7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgIGNvbnN0IGlzQ2xhc3MgPSBwcm90byAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHByb3RvICE9PSBPYmplY3QucHJvdG90eXBlO1xuICAgIGlmIChpc0NsYXNzKSB7XG4gICAgICBsZXQgY3VyUHJvdG8gPSBwcm90bztcbiAgICAgIHdoaWxlIChjdXJQcm90byAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoY3VyUHJvdG8pO1xuICAgICAgICBrZXlzLnB1c2goLi4uT2JqZWN0LmtleXMoZGVzY3JpcHRvcnMpKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihkZXNjLCBkZXNjcmlwdG9ycyk7XG4gICAgICAgIGN1clByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1clByb3RvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgcHJvcCA9IGtleXNbaV07XG4gICAgICBpZiAoaXNDbGFzcyAmJiBwcm9wID09PSBcImNvbnN0cnVjdG9yXCIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGRlc2NbcHJvcF0uZ2V0KSB7XG4gICAgICAgIGNvbnN0IGdldCA9IGRlc2NbcHJvcF0uZ2V0LmJpbmQocCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgcHJvcCwge1xuICAgICAgICAgIGdldCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZGVzY1twcm9wXS5zZXQpIHtcbiAgICAgICAgY29uc3Qgb2cgPSBkZXNjW3Byb3BdLnNldCxcbiAgICAgICAgICBzZXQgPSB2ID0+IGJhdGNoKCgpID0+IG9nLmNhbGwocCwgdikpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsIHByb3AsIHtcbiAgICAgICAgICBzZXQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU11dGFibGUoc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgdW53cmFwcGVkU3RvcmUgPSB1bndyYXAoc3RhdGUgfHwge30pO1xuICBjb25zdCB3cmFwcGVkU3RvcmUgPSB3cmFwKHVud3JhcHBlZFN0b3JlKTtcbiAgcmV0dXJuIHdyYXBwZWRTdG9yZTtcbn1cbmZ1bmN0aW9uIG1vZGlmeU11dGFibGUoc3RhdGUsIG1vZGlmaWVyKSB7XG4gIGJhdGNoKCgpID0+IG1vZGlmaWVyKHVud3JhcChzdGF0ZSkpKTtcbn1cblxuY29uc3QgJFJPT1QgPSBTeW1ib2woXCJzdG9yZS1yb290XCIpO1xuZnVuY3Rpb24gYXBwbHlTdGF0ZSh0YXJnZXQsIHBhcmVudCwgcHJvcGVydHksIG1lcmdlLCBrZXkpIHtcbiAgY29uc3QgcHJldmlvdXMgPSBwYXJlbnRbcHJvcGVydHldO1xuICBpZiAodGFyZ2V0ID09PSBwcmV2aW91cykgcmV0dXJuO1xuICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuICBpZiAocHJvcGVydHkgIT09ICRST09UICYmICghaXNXcmFwcGFibGUodGFyZ2V0KSB8fCAhaXNXcmFwcGFibGUocHJldmlvdXMpIHx8IGlzQXJyYXkgIT09IEFycmF5LmlzQXJyYXkocHJldmlvdXMpIHx8IGtleSAmJiB0YXJnZXRba2V5XSAhPT0gcHJldmlvdXNba2V5XSkpIHtcbiAgICBzZXRQcm9wZXJ0eShwYXJlbnQsIHByb3BlcnR5LCB0YXJnZXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNBcnJheSkge1xuICAgIGlmICh0YXJnZXQubGVuZ3RoICYmIHByZXZpb3VzLmxlbmd0aCAmJiAoIW1lcmdlIHx8IGtleSAmJiB0YXJnZXRbMF0gJiYgdGFyZ2V0WzBdW2tleV0gIT0gbnVsbCkpIHtcbiAgICAgIGxldCBpLCBqLCBzdGFydCwgZW5kLCBuZXdFbmQsIGl0ZW0sIG5ld0luZGljZXNOZXh0LCBrZXlWYWw7XG4gICAgICBmb3IgKHN0YXJ0ID0gMCwgZW5kID0gTWF0aC5taW4ocHJldmlvdXMubGVuZ3RoLCB0YXJnZXQubGVuZ3RoKTsgc3RhcnQgPCBlbmQgJiYgKHByZXZpb3VzW3N0YXJ0XSA9PT0gdGFyZ2V0W3N0YXJ0XSB8fCBrZXkgJiYgcHJldmlvdXNbc3RhcnRdICYmIHRhcmdldFtzdGFydF0gJiYgcHJldmlvdXNbc3RhcnRdW2tleV0gJiYgcHJldmlvdXNbc3RhcnRdW2tleV0gPT09IHRhcmdldFtzdGFydF1ba2V5XSk7IHN0YXJ0KyspIHtcbiAgICAgICAgYXBwbHlTdGF0ZSh0YXJnZXRbc3RhcnRdLCBwcmV2aW91cywgc3RhcnQsIG1lcmdlLCBrZXkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVtcCA9IG5ldyBBcnJheSh0YXJnZXQubGVuZ3RoKSxcbiAgICAgICAgbmV3SW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAoZW5kID0gcHJldmlvdXMubGVuZ3RoIC0gMSwgbmV3RW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDE7IGVuZCA+PSBzdGFydCAmJiBuZXdFbmQgPj0gc3RhcnQgJiYgKHByZXZpb3VzW2VuZF0gPT09IHRhcmdldFtuZXdFbmRdIHx8IGtleSAmJiBwcmV2aW91c1tlbmRdICYmIHRhcmdldFtuZXdFbmRdICYmIHByZXZpb3VzW2VuZF1ba2V5XSAmJiBwcmV2aW91c1tlbmRdW2tleV0gPT09IHRhcmdldFtuZXdFbmRdW2tleV0pOyBlbmQtLSwgbmV3RW5kLS0pIHtcbiAgICAgICAgdGVtcFtuZXdFbmRdID0gcHJldmlvdXNbZW5kXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA+IG5ld0VuZCB8fCBzdGFydCA+IGVuZCkge1xuICAgICAgICBmb3IgKGogPSBzdGFydDsgaiA8PSBuZXdFbmQ7IGorKykgc2V0UHJvcGVydHkocHJldmlvdXMsIGosIHRhcmdldFtqXSk7XG4gICAgICAgIGZvciAoOyBqIDwgdGFyZ2V0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2V0UHJvcGVydHkocHJldmlvdXMsIGosIHRlbXBbal0pO1xuICAgICAgICAgIGFwcGx5U3RhdGUodGFyZ2V0W2pdLCBwcmV2aW91cywgaiwgbWVyZ2UsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzLmxlbmd0aCA+IHRhcmdldC5sZW5ndGgpIHNldFByb3BlcnR5KHByZXZpb3VzLCBcImxlbmd0aFwiLCB0YXJnZXQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmV3SW5kaWNlc05leHQgPSBuZXcgQXJyYXkobmV3RW5kICsgMSk7XG4gICAgICBmb3IgKGogPSBuZXdFbmQ7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgICBpdGVtID0gdGFyZ2V0W2pdO1xuICAgICAgICBrZXlWYWwgPSBrZXkgJiYgaXRlbSA/IGl0ZW1ba2V5XSA6IGl0ZW07XG4gICAgICAgIGkgPSBuZXdJbmRpY2VzLmdldChrZXlWYWwpO1xuICAgICAgICBuZXdJbmRpY2VzTmV4dFtqXSA9IGkgPT09IHVuZGVmaW5lZCA/IC0xIDogaTtcbiAgICAgICAgbmV3SW5kaWNlcy5zZXQoa2V5VmFsLCBqKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBwcmV2aW91c1tpXTtcbiAgICAgICAga2V5VmFsID0ga2V5ICYmIGl0ZW0gPyBpdGVtW2tleV0gOiBpdGVtO1xuICAgICAgICBqID0gbmV3SW5kaWNlcy5nZXQoa2V5VmFsKTtcbiAgICAgICAgaWYgKGogIT09IHVuZGVmaW5lZCAmJiBqICE9PSAtMSkge1xuICAgICAgICAgIHRlbXBbal0gPSBwcmV2aW91c1tpXTtcbiAgICAgICAgICBqID0gbmV3SW5kaWNlc05leHRbal07XG4gICAgICAgICAgbmV3SW5kaWNlcy5zZXQoa2V5VmFsLCBqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChqID0gc3RhcnQ7IGogPCB0YXJnZXQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGogaW4gdGVtcCkge1xuICAgICAgICAgIHNldFByb3BlcnR5KHByZXZpb3VzLCBqLCB0ZW1wW2pdKTtcbiAgICAgICAgICBhcHBseVN0YXRlKHRhcmdldFtqXSwgcHJldmlvdXMsIGosIG1lcmdlLCBrZXkpO1xuICAgICAgICB9IGVsc2Ugc2V0UHJvcGVydHkocHJldmlvdXMsIGosIHRhcmdldFtqXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0YXJnZXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXBwbHlTdGF0ZSh0YXJnZXRbaV0sIHByZXZpb3VzLCBpLCBtZXJnZSwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXZpb3VzLmxlbmd0aCA+IHRhcmdldC5sZW5ndGgpIHNldFByb3BlcnR5KHByZXZpb3VzLCBcImxlbmd0aFwiLCB0YXJnZXQubGVuZ3RoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0S2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0YXJnZXRLZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXBwbHlTdGF0ZSh0YXJnZXRbdGFyZ2V0S2V5c1tpXV0sIHByZXZpb3VzLCB0YXJnZXRLZXlzW2ldLCBtZXJnZSwga2V5KTtcbiAgfVxuICBjb25zdCBwcmV2aW91c0tleXMgPSBPYmplY3Qua2V5cyhwcmV2aW91cyk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwcmV2aW91c0tleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAodGFyZ2V0W3ByZXZpb3VzS2V5c1tpXV0gPT09IHVuZGVmaW5lZCkgc2V0UHJvcGVydHkocHJldmlvdXMsIHByZXZpb3VzS2V5c1tpXSwgdW5kZWZpbmVkKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjb25jaWxlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgICAgbWVyZ2UsXG4gICAgICBrZXkgPSBcImlkXCJcbiAgICB9ID0gb3B0aW9ucyxcbiAgICB2ID0gdW53cmFwKHZhbHVlKTtcbiAgcmV0dXJuIHN0YXRlID0+IHtcbiAgICBpZiAoIWlzV3JhcHBhYmxlKHN0YXRlKSB8fCAhaXNXcmFwcGFibGUodikpIHJldHVybiB2O1xuICAgIGNvbnN0IHJlcyA9IGFwcGx5U3RhdGUodiwge1xuICAgICAgWyRST09UXTogc3RhdGVcbiAgICB9LCAkUk9PVCwgbWVyZ2UsIGtleSk7XG4gICAgcmV0dXJuIHJlcyA9PT0gdW5kZWZpbmVkID8gc3RhdGUgOiByZXM7XG4gIH07XG59XG5jb25zdCBwcm9kdWNlcnMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2V0dGVyVHJhcHMgPSB7XG4gIGdldCh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkUkFXKSByZXR1cm4gdGFyZ2V0O1xuICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BlcnR5XTtcbiAgICBsZXQgcHJveHk7XG4gICAgcmV0dXJuIGlzV3JhcHBhYmxlKHZhbHVlKSA/IHByb2R1Y2Vycy5nZXQodmFsdWUpIHx8IChwcm9kdWNlcnMuc2V0KHZhbHVlLCBwcm94eSA9IG5ldyBQcm94eSh2YWx1ZSwgc2V0dGVyVHJhcHMpKSwgcHJveHkpIDogdmFsdWU7XG4gIH0sXG4gIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHNldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHVud3JhcCh2YWx1ZSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgc2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb2R1Y2UoZm4pIHtcbiAgcmV0dXJuIHN0YXRlID0+IHtcbiAgICBpZiAoaXNXcmFwcGFibGUoc3RhdGUpKSB7XG4gICAgICBsZXQgcHJveHk7XG4gICAgICBpZiAoIShwcm94eSA9IHByb2R1Y2Vycy5nZXQoc3RhdGUpKSkge1xuICAgICAgICBwcm9kdWNlcnMuc2V0KHN0YXRlLCBwcm94eSA9IG5ldyBQcm94eShzdGF0ZSwgc2V0dGVyVHJhcHMpKTtcbiAgICAgIH1cbiAgICAgIGZuKHByb3h5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xufVxuXG5jb25zdCBERVYgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCB7ICRSQVcsIERFViwgY3JlYXRlTXV0YWJsZSwgY3JlYXRlU3RvcmUsIG1vZGlmeU11dGFibGUsIHByb2R1Y2UsIHJlY29uY2lsZSwgdW53cmFwIH07XG4iLCIvLyBTb2xpZEpTIFN0YXRlIE1hbmFnZW1lbnQgZm9yIFdlYlNTSDIgQ2xpZW50XG5pbXBvcnQgeyBjcmVhdGVTdG9yZSB9IGZyb20gJ3NvbGlkLWpzL3N0b3JlJ1xuaW1wb3J0IHsgY3JlYXRlU2lnbmFsIH0gZnJvbSAnc29saWQtanMnXG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSAnZGVidWcnXG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ3dlYnNzaDItY2xpZW50OnN0YXRlLXNvbGlkJylcblxuZXhwb3J0IGludGVyZmFjZSBBcHBTdGF0ZSB7XG4gIGFsbG93UmVhdXRoOiBib29sZWFuXG4gIGFsbG93UmVjb25uZWN0OiBib29sZWFuXG4gIGFsbG93UmVwbGF5OiBib29sZWFuXG4gIGlzQmFzaWNBdXRoQ29va2llUHJlc2VudDogYm9vbGVhblxuICBpc0Nvbm5lY3Rpbmc6IGJvb2xlYW5cbiAgbG9nZ2VkRGF0YTogYm9vbGVhblxuICByZWF1dGhSZXF1aXJlZDogYm9vbGVhblxuICBzZXNzaW9uTG9nRW5hYmxlOiBib29sZWFuXG4gIHRlcm06IHN0cmluZyB8IG51bGxcbn1cblxuY29uc3QgaW5pdGlhbFN0YXRlOiBBcHBTdGF0ZSA9IHtcbiAgYWxsb3dSZWF1dGg6IGZhbHNlLFxuICBhbGxvd1JlY29ubmVjdDogZmFsc2UsXG4gIGFsbG93UmVwbGF5OiBmYWxzZSxcbiAgaXNCYXNpY0F1dGhDb29raWVQcmVzZW50OiBmYWxzZSxcbiAgaXNDb25uZWN0aW5nOiBmYWxzZSxcbiAgbG9nZ2VkRGF0YTogZmFsc2UsXG4gIHJlYXV0aFJlcXVpcmVkOiBmYWxzZSxcbiAgc2Vzc2lvbkxvZ0VuYWJsZTogZmFsc2UsXG4gIHRlcm06IG51bGxcbn1cblxuLy8gQ3JlYXRlIHJlYWN0aXZlIHN0b3JlXG5leHBvcnQgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBjcmVhdGVTdG9yZTxBcHBTdGF0ZT4oaW5pdGlhbFN0YXRlKVxuXG4vLyBBZGRpdGlvbmFsIHN0YXRlIHNpZ25hbHMgZm9yIFVJXG5leHBvcnQgY29uc3QgW3Nlc3Npb25Gb290ZXIsIHNldFNlc3Npb25Gb290ZXJdID0gY3JlYXRlU2lnbmFsPHN0cmluZyB8IG51bGw+KFxuICBudWxsXG4pXG5leHBvcnQgY29uc3QgW2Vycm9yTWVzc2FnZSwgc2V0RXJyb3JNZXNzYWdlXSA9IGNyZWF0ZVNpZ25hbDxzdHJpbmcgfCBudWxsPihudWxsKVxuZXhwb3J0IGNvbnN0IFtpc0xvZ2luRGlhbG9nT3Blbiwgc2V0SXNMb2dpbkRpYWxvZ09wZW5dID0gY3JlYXRlU2lnbmFsKGZhbHNlKVxuZXhwb3J0IGNvbnN0IFtpc0Vycm9yRGlhbG9nT3Blbiwgc2V0SXNFcnJvckRpYWxvZ09wZW5dID0gY3JlYXRlU2lnbmFsKGZhbHNlKVxuZXhwb3J0IGNvbnN0IFtpc1Rlcm1pbmFsU2V0dGluZ3NPcGVuLCBzZXRJc1Rlcm1pbmFsU2V0dGluZ3NPcGVuXSA9XG4gIGNyZWF0ZVNpZ25hbChmYWxzZSlcbmV4cG9ydCBjb25zdCBbc2hvd1JlY29ubmVjdEJ1dHRvbiwgc2V0U2hvd1JlY29ubmVjdEJ1dHRvbl0gPSBjcmVhdGVTaWduYWwoZmFsc2UpXG5cbi8vIEhlYWRlciBjb250ZW50IHN0YXRlXG5leHBvcnQgY29uc3QgW2hlYWRlckNvbnRlbnQsIHNldEhlYWRlckNvbnRlbnRdID0gY3JlYXRlU2lnbmFsPHtcbiAgdGV4dDogc3RyaW5nXG4gIGJhY2tncm91bmQ/OiBzdHJpbmdcbn0gfCBudWxsPihudWxsKVxuXG4vLyBQcm9tcHQgZGlhbG9nIHN0YXRlXG5leHBvcnQgY29uc3QgW3Byb21wdERhdGEsIHNldFByb21wdERhdGFdID0gY3JlYXRlU2lnbmFsPHtcbiAgdGl0bGU6IHN0cmluZ1xuICBwcm9tcHRzOiBBcnJheTx7IHByb21wdDogc3RyaW5nOyBlY2hvOiBib29sZWFuIH0+XG59IHwgbnVsbD4obnVsbClcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHN0YXRlIG1hbmFnZW1lbnRcbmV4cG9ydCBjb25zdCB0b2dnbGVCb29sZWFuU3RhdGUgPSA8SyBleHRlbmRzIGtleW9mIEFwcFN0YXRlPihcbiAga2V5OiBLIGV4dGVuZHMga2V5b2YgQXBwU3RhdGVcbiAgICA/IEFwcFN0YXRlW0tdIGV4dGVuZHMgYm9vbGVhblxuICAgICAgPyBLXG4gICAgICA6IG5ldmVyXG4gICAgOiBuZXZlclxuKTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHN0YXRlW2tleV0gYXMgYm9vbGVhblxuICBjb25zdCBuZXdWYWx1ZSA9ICFjdXJyZW50VmFsdWVcbiAgc2V0U3RhdGUoa2V5LCBuZXdWYWx1ZSBhcyBBcHBTdGF0ZVtLXSlcbiAgZGVidWcoJ3RvZ2dsZUJvb2xlYW5TdGF0ZScsIHsgW2tleV06IG5ld1ZhbHVlIH0pXG4gIHJldHVybiBuZXdWYWx1ZVxufVxuXG4vLyBTdGF0ZSB1cGRhdGUgaGVscGVyc1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVN0YXRlID0gKHVwZGF0ZXM6IFBhcnRpYWw8QXBwU3RhdGU+KSA9PiB7XG4gIHNldFN0YXRlKHVwZGF0ZXMpXG4gIGRlYnVnKCd1cGRhdGVTdGF0ZScsIHVwZGF0ZXMpXG59XG5cbi8vIFJlc2V0IHN0YXRlIHRvIGluaXRpYWwgdmFsdWVzXG5leHBvcnQgY29uc3QgcmVzZXRTdGF0ZSA9ICgpID0+IHtcbiAgc2V0U3RhdGUoaW5pdGlhbFN0YXRlKVxuICBkZWJ1ZygncmVzZXRTdGF0ZScpXG59XG5cbiIsIi8vIEJyb3dzZXIgdXRpbGl0eSBmdW5jdGlvbnNcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tICdkZWJ1ZydcblxuY29uc3QgZGVidWcgPSBjcmVhdGVEZWJ1Zygnd2Vic3NoMi1jbGllbnQ6YnJvd3Nlci11dGlscycpXG5cbi8qKlxuICogVHJpZ2dlcnMgYSBkb3dubG9hZCBvZiBhIGJsb2Igd2l0aCB0aGUgZ2l2ZW4gZmlsZW5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaWdnZXJEb3dubG9hZChibG9iOiBCbG9iLCBmaWxlbmFtZTogc3RyaW5nKTogdm9pZCB7XG4gIGRlYnVnKGB0cmlnZ2VyRG93bmxvYWQ6ICR7ZmlsZW5hbWV9YClcbiAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICBsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gIGxpbmsuZG93bmxvYWQgPSBmaWxlbmFtZVxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspXG4gIGxpbmsuY2xpY2soKVxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspXG4gIFVSTC5yZXZva2VPYmplY3RVUkwobGluay5ocmVmKVxufVxuXG4vKipcbiAqIEdldCB0ZXJtaW5hbCBkaW1lbnNpb25zIHRoYXQgZml0IHRoZSBjdXJyZW50IHZpZXdwb3J0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3cG9ydFRlcm1pbmFsRGltZW5zaW9ucygpOiB7XG4gIGNvbHM6IG51bWJlclxuICByb3dzOiBudW1iZXJcbn0gfCBudWxsIHtcbiAgLy8gVGhpcyB3b3VsZCBjYWxjdWxhdGUgb3B0aW1hbCB0ZXJtaW5hbCBkaW1lbnNpb25zIGJhc2VkIG9uIHZpZXdwb3J0XG4gIC8vIEZvciBub3csIHJldHVybiBudWxsIHRvIGluZGljYXRlIGNhbGN1bGF0aW9uIGlzIG5lZWRlZCBlbHNld2hlcmVcbiAgZGVidWcoJ2dldFZpZXdwb3J0VGVybWluYWxEaW1lbnNpb25zOiBjYWxjdWxhdGlvbiBuZWVkZWQnKVxuICByZXR1cm4gbnVsbFxufVxuIiwiLy8gU29saWRKUyBUeXBlU2NyaXB0IExvZ2dpbmcgU2VydmljZVxuaW1wb3J0IHsgY3JlYXRlTWVtbyB9IGZyb20gJ3NvbGlkLWpzJ1xuaW1wb3J0IGNyZWF0ZURlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IHsgc3RhdGUsIHNldFN0YXRlIH0gZnJvbSAnLi4vc3RhdGUtc29saWQuanMnXG5pbXBvcnQgeyB0cmlnZ2VyRG93bmxvYWQgfSBmcm9tICcuLi91dGlscy9icm93c2VyLmpzJ1xuaW1wb3J0IHsgZm9ybWF0RGF0ZSB9IGZyb20gJy4uL3V0aWxzLmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGNyZWF0ZURlYnVnKCd3ZWJzc2gyLWNsaWVudDpsb2dnaW5nLXNlcnZpY2UnKVxuXG5jb25zdCBMT0dfS0VZID0gJ3dlYnNzaDJfc2Vzc2lvbl9sb2cnXG5jb25zdCBMT0dfREFURV9LRVkgPSAnd2Vic3NoMl9zZXNzaW9uX2xvZ19kYXRlJ1xuXG4vLyBTZXNzaW9uIGZvb3RlciBmb3IgbG9nIGhlYWRlcnNcbmxldCBzZXNzaW9uRm9vdGVyOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuXG5pbnRlcmZhY2UgTG9nZ2luZ1NlcnZpY2Uge1xuICAvLyBSZWFjdGl2ZSBzdGF0ZVxuICBoYXNMb2dEYXRhOiAoKSA9PiBib29sZWFuXG4gIGlzTG9nZ2luZzogKCkgPT4gYm9vbGVhblxuXG4gIC8vIEFjdGlvbnNcbiAgc3RhcnRMb2dnaW5nKCk6IHZvaWRcbiAgc3RvcExvZ2dpbmcoKTogdm9pZFxuICBjbGVhckxvZygpOiB2b2lkXG4gIGRvd25sb2FkTG9nKCk6IHZvaWRcbiAgYWRkVG9Mb2coZGF0YTogc3RyaW5nKTogdm9pZFxuICBjaGVja1NhdmVkTG9nKCk6IHZvaWRcbiAgc2V0U2Vzc2lvbkZvb3Rlcihmb290ZXI6IHN0cmluZyB8IG51bGwpOiB2b2lkXG59XG5cbmNsYXNzIExvZ2dpbmdTZXJ2aWNlSW1wbCBpbXBsZW1lbnRzIExvZ2dpbmdTZXJ2aWNlIHtcbiAgLy8gUmVhY3RpdmUgY29tcHV0YXRpb25zXG4gIGhhc0xvZ0RhdGEgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICAvLyBSZXR1cm4gc3RhdGUubG9nZ2VkRGF0YSB3aGljaCB0cmFja3Mgd2hldGhlciB3ZSBoYXZlIGxvZyBkYXRhXG4gICAgLy8gVGhpcyB3aWxsIGJlIHJlYWN0aXZlIHRvIHN0YXRlIGNoYW5nZXNcbiAgICByZXR1cm4gc3RhdGUubG9nZ2VkRGF0YVxuICB9KVxuXG4gIGlzTG9nZ2luZyA9ICgpID0+IHN0YXRlLnNlc3Npb25Mb2dFbmFibGVcblxuICBzZXRTZXNzaW9uRm9vdGVyKGZvb3Rlcjogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xuICAgIHNlc3Npb25Gb290ZXIgPSBmb290ZXJcbiAgICBkZWJ1ZygnU2Vzc2lvbiBmb290ZXIgc2V0OicsIGZvb3RlcilcbiAgfVxuXG4gIGFkZFRvTG9nKGRhdGE6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghc3RhdGUuc2Vzc2lvbkxvZ0VuYWJsZSkgcmV0dXJuXG5cbiAgICBsZXQgc2Vzc2lvbkxvZyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0dfS0VZKSB8fCAnJ1xuICAgIGNvbnN0IGlzTmV3TG9nID0gc2Vzc2lvbkxvZyA9PT0gJydcblxuICAgIHNlc3Npb25Mb2cgKz0gZGF0YVxuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0dfS0VZLCBzZXNzaW9uTG9nKVxuXG4gICAgLy8gVXBkYXRlIHN0YXRlIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGxvZyBlbnRyeVxuICAgIGlmIChpc05ld0xvZykge1xuICAgICAgc2V0U3RhdGUoJ2xvZ2dlZERhdGEnLCB0cnVlKVxuICAgICAgZGVidWcoJ1N0YXJ0ZWQgbG9nZ2luZyBzZXNzaW9uJylcbiAgICB9XG4gIH1cblxuICBzdGFydExvZ2dpbmcoKTogdm9pZCB7XG4gICAgZGVidWcoJ1N0YXJ0aW5nIGxvZyBzZXNzaW9uJylcbiAgICBzZXRTdGF0ZSgnc2Vzc2lvbkxvZ0VuYWJsZScsIHRydWUpXG4gICAgc2V0U3RhdGUoJ2xvZ2dlZERhdGEnLCB0cnVlKVxuXG4gICAgY29uc3QgZm9vdGVyID0gc2Vzc2lvbkZvb3RlciA/PyAnJ1xuICAgIGNvbnN0IGxvZ1N0YXJ0TWVzc2FnZSA9IGBMb2cgU3RhcnQgZm9yICR7Zm9vdGVyfSAtICR7Zm9ybWF0RGF0ZShuZXcgRGF0ZSgpKX1cXHJcXG5cXHJcXG5gXG5cbiAgICAvLyBBZGQgc3RhcnQgbWVzc2FnZSB0byBsb2dcbiAgICBsZXQgc2Vzc2lvbkxvZyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0dfS0VZKSB8fCAnJ1xuICAgIHNlc3Npb25Mb2cgKz0gbG9nU3RhcnRNZXNzYWdlXG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKExPR19LRVksIHNlc3Npb25Mb2cpXG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKExPR19EQVRFX0tFWSwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpKVxuXG4gICAgZGVidWcoJ0xvZyBzZXNzaW9uIHN0YXJ0ZWQnKVxuICB9XG5cbiAgc3RvcExvZ2dpbmcoKTogdm9pZCB7XG4gICAgZGVidWcoJ1N0b3BwaW5nIGxvZyBzZXNzaW9uJylcbiAgICBzZXRTdGF0ZSgnc2Vzc2lvbkxvZ0VuYWJsZScsIGZhbHNlKVxuXG4gICAgLy8gQWRkIGVuZCBtZXNzYWdlIGlmIHdlIGhhdmUgbG9nIGRhdGFcbiAgICBjb25zdCBoYXNMb2dEYXRhID0gISF3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9HX0tFWSlcbiAgICBpZiAoaGFzTG9nRGF0YSkge1xuICAgICAgY29uc3QgZm9vdGVyID0gc2Vzc2lvbkZvb3RlciA/PyAnJ1xuICAgICAgY29uc3QgbG9nRW5kTWVzc2FnZSA9IGBcXHJcXG5cXHJcXG5Mb2cgRW5kIGZvciAke2Zvb3Rlcn0gLSAke2Zvcm1hdERhdGUobmV3IERhdGUoKSl9XFxyXFxuYFxuXG4gICAgICBsZXQgc2Vzc2lvbkxvZyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0dfS0VZKSB8fCAnJ1xuICAgICAgc2Vzc2lvbkxvZyArPSBsb2dFbmRNZXNzYWdlXG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oTE9HX0tFWSwgc2Vzc2lvbkxvZylcblxuICAgICAgZGVidWcoJ0xvZyBzZXNzaW9uIHN0b3BwZWQgd2l0aCBlbmQgbWVzc2FnZScpXG4gICAgfVxuICB9XG5cbiAgY2xlYXJMb2coKTogdm9pZCB7XG4gICAgY29uc3Qgc2Vzc2lvbkxvZyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0dfS0VZKVxuICAgIGlmICghc2Vzc2lvbkxvZykge1xuICAgICAgZGVidWcoJ05vIHNlc3Npb24gbG9nIGZvdW5kIHRvIGNsZWFyJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRlbGV0ZUxvZyA9IHdpbmRvdy5jb25maXJtKCdDbGVhciB0aGUgc2Vzc2lvbiBsb2c/JylcbiAgICBpZiAoZGVsZXRlTG9nKSB7XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9HX0tFWSlcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShMT0dfREFURV9LRVkpXG4gICAgICBzZXRTdGF0ZSgnbG9nZ2VkRGF0YScsIGZhbHNlKVxuICAgICAgZGVidWcoJ1Nlc3Npb24gbG9nIGNsZWFyZWQgZnJvbSBsb2NhbFN0b3JhZ2UnKVxuICAgIH1cbiAgfVxuXG4gIGRvd25sb2FkTG9nKCk6IHZvaWQge1xuICAgIGNvbnN0IHNlc3Npb25Mb2cgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9HX0tFWSlcbiAgICBjb25zdCBoYXNMb2dEYXRhID0gISFzZXNzaW9uTG9nXG4gICAgaWYgKCFzZXNzaW9uTG9nIHx8ICFoYXNMb2dEYXRhKSB7XG4gICAgICBkZWJ1ZygnTm8gbG9nIGRhdGEgYXZhaWxhYmxlIGZvciBkb3dubG9hZCcpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBhdXRvRG93bmxvYWQgPSB3aW5kb3cuY29uZmlybShcbiAgICAgICdXb3VsZCB5b3UgbGlrZSB0byBkb3dubG9hZCB0aGUgc2Vzc2lvbiBsb2c/J1xuICAgIClcbiAgICBpZiAoIWF1dG9Eb3dubG9hZCkgcmV0dXJuXG5cbiAgICBjb25zdCBmaWxlbmFtZSA9IGBXZWJTU0gyLSR7Zm9ybWF0RGF0ZShuZXcgRGF0ZSgpKS5yZXBsYWNlKC9bLzpcXHNAXS9nLCAnJyl9LmxvZ2BcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3Nlc3Npb25Mb2ddLCB7IHR5cGU6ICd0ZXh0L3BsYWluJyB9KVxuXG4gICAgdHJ5IHtcbiAgICAgIHRyaWdnZXJEb3dubG9hZChibG9iLCBmaWxlbmFtZSlcbiAgICAgIGRlYnVnKCdMb2cgZG93bmxvYWRlZCBzdWNjZXNzZnVsbHknKVxuXG4gICAgICAvLyBPbmx5IGNsZWFyIGxvY2FsU3RvcmFnZSBpZiBsb2dnaW5nIGlzIHN0b3BwZWRcbiAgICAgIGNvbnN0IGlzTG9nZ2luZyA9IHN0YXRlLnNlc3Npb25Mb2dFbmFibGVcbiAgICAgIGlmICghaXNMb2dnaW5nKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShMT0dfS0VZKVxuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9HX0RBVEVfS0VZKVxuICAgICAgICBzZXRTdGF0ZSgnbG9nZ2VkRGF0YScsIGZhbHNlKVxuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAnTG9nIGNsZWFyZWQgZnJvbSBsb2NhbFN0b3JhZ2UgYWZ0ZXIgZG93bmxvYWQgKGxvZ2dpbmcgd2FzIHN0b3BwZWQpJ1xuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBLZWVwIHRoZSBsb2cgaW4gbG9jYWxTdG9yYWdlIGJ1dCB1cGRhdGUgdGhlIGRhdGVcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKExPR19EQVRFX0tFWSwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpKVxuICAgICAgICBkZWJ1ZygnTG9nIGtlcHQgaW4gbG9jYWxTdG9yYWdlIChsb2dnaW5nIGlzIHN0aWxsIGFjdGl2ZSknKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZG93bmxvYWQgc2Vzc2lvbiBsb2c6JywgZXJyb3IpXG4gICAgICAvLyBPbiBmYWlsdXJlLCB0cmlnZ2VyIGRvd25sb2FkIGFuZCBjbGVhciB0byBwcmV2ZW50IGRhdGEgbG9zc1xuICAgICAgdHJpZ2dlckRvd25sb2FkKGJsb2IsIGZpbGVuYW1lKVxuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKExPR19LRVkpXG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9HX0RBVEVfS0VZKVxuICAgICAgc2V0U3RhdGUoJ2xvZ2dlZERhdGEnLCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICBjaGVja1NhdmVkTG9nKCk6IHZvaWQge1xuICAgIGNvbnN0IHNhdmVkTG9nID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKExPR19LRVkpXG4gICAgY29uc3Qgc2F2ZWREYXRlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKExPR19EQVRFX0tFWSlcblxuICAgIGlmIChzYXZlZExvZyAmJiBzYXZlZERhdGUpIHtcbiAgICAgIGNvbnN0IHJlc3RvcmVMb2cgPSB3aW5kb3cuY29uZmlybShcbiAgICAgICAgYEEgc2F2ZWQgc2Vzc2lvbiBsb2cgZnJvbSAke25ldyBEYXRlKHNhdmVkRGF0ZSkudG9Mb2NhbGVTdHJpbmcoKX0gd2FzIGZvdW5kLiBXb3VsZCB5b3UgbGlrZSB0byBkb3dubG9hZCBpdD9gXG4gICAgICApXG5cbiAgICAgIGlmIChyZXN0b3JlTG9nKSB7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gYFdlYlNTSDItUmVjb3ZlcmVkLSR7Zm9ybWF0RGF0ZShuZXcgRGF0ZShzYXZlZERhdGUpKS5yZXBsYWNlKC9bLzpcXHNAXS9nLCAnJyl9LmxvZ2BcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtzYXZlZExvZ10sIHsgdHlwZTogJ3RleHQvcGxhaW4nIH0pXG4gICAgICAgIHRyaWdnZXJEb3dubG9hZChibG9iLCBmaWxlbmFtZSlcblxuICAgICAgICAvLyBDbGVhciBzdG9yZWQgbG9nIGFmdGVyIHN1Y2Nlc3NmdWwgcmVjb3ZlcnkgZG93bmxvYWRcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKExPR19LRVkpXG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShMT0dfREFURV9LRVkpXG4gICAgICAgIHNldFN0YXRlKCdsb2dnZWREYXRhJywgZmFsc2UpXG4gICAgICAgIGRlYnVnKCdSZWNvdmVyZWQgbG9nIGRvd25sb2FkZWQgYW5kIGNsZWFyZWQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlciBkZWNsaW5lZCByZWNvdmVyeSwgYnV0IGxvZyBleGlzdHMgc28gdXBkYXRlIHN0YXRlXG4gICAgICAgIHNldFN0YXRlKCdsb2dnZWREYXRhJywgdHJ1ZSlcbiAgICAgICAgZGVidWcoJ1JlY292ZXJlZCBsb2cga2VwdCwgc3RhdGUgdXBkYXRlZCcpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIENyZWF0ZSBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBsb2dnaW5nU2VydmljZTogTG9nZ2luZ1NlcnZpY2UgPSBuZXcgTG9nZ2luZ1NlcnZpY2VJbXBsKClcblxuLy8gRXhwb3J0IGluZGl2aWR1YWwgZnVuY3Rpb25zIGZvciBjb21wYXRpYmlsaXR5XG5leHBvcnQgY29uc3Qge1xuICBoYXNMb2dEYXRhLFxuICBpc0xvZ2dpbmcsXG4gIHN0YXJ0TG9nZ2luZyxcbiAgc3RvcExvZ2dpbmcsXG4gIGNsZWFyTG9nLFxuICBkb3dubG9hZExvZyxcbiAgYWRkVG9Mb2csXG4gIGNoZWNrU2F2ZWRMb2csXG4gIHNldFNlc3Npb25Gb290ZXJcbn0gPSBsb2dnaW5nU2VydmljZVxuIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5GaXRBZGRvbj10KCk6ZS5GaXRBZGRvbj10KCl9KHNlbGYsKCgpPT4oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17fTtyZXR1cm4oKCk9Pnt2YXIgdD1lO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRml0QWRkb249dm9pZCAwLHQuRml0QWRkb249Y2xhc3N7YWN0aXZhdGUoZSl7dGhpcy5fdGVybWluYWw9ZX1kaXNwb3NlKCl7fWZpdCgpe2NvbnN0IGU9dGhpcy5wcm9wb3NlRGltZW5zaW9ucygpO2lmKCFlfHwhdGhpcy5fdGVybWluYWx8fGlzTmFOKGUuY29scyl8fGlzTmFOKGUucm93cykpcmV0dXJuO2NvbnN0IHQ9dGhpcy5fdGVybWluYWwuX2NvcmU7dGhpcy5fdGVybWluYWwucm93cz09PWUucm93cyYmdGhpcy5fdGVybWluYWwuY29scz09PWUuY29sc3x8KHQuX3JlbmRlclNlcnZpY2UuY2xlYXIoKSx0aGlzLl90ZXJtaW5hbC5yZXNpemUoZS5jb2xzLGUucm93cykpfXByb3Bvc2VEaW1lbnNpb25zKCl7aWYoIXRoaXMuX3Rlcm1pbmFsKXJldHVybjtpZighdGhpcy5fdGVybWluYWwuZWxlbWVudHx8IXRoaXMuX3Rlcm1pbmFsLmVsZW1lbnQucGFyZW50RWxlbWVudClyZXR1cm47Y29uc3QgZT10aGlzLl90ZXJtaW5hbC5fY29yZSx0PWUuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucztpZigwPT09dC5jc3MuY2VsbC53aWR0aHx8MD09PXQuY3NzLmNlbGwuaGVpZ2h0KXJldHVybjtjb25zdCByPTA9PT10aGlzLl90ZXJtaW5hbC5vcHRpb25zLnNjcm9sbGJhY2s/MDplLnZpZXdwb3J0LnNjcm9sbEJhcldpZHRoLGk9d2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fdGVybWluYWwuZWxlbWVudC5wYXJlbnRFbGVtZW50KSxvPXBhcnNlSW50KGkuZ2V0UHJvcGVydHlWYWx1ZShcImhlaWdodFwiKSkscz1NYXRoLm1heCgwLHBhcnNlSW50KGkuZ2V0UHJvcGVydHlWYWx1ZShcIndpZHRoXCIpKSksbj13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl90ZXJtaW5hbC5lbGVtZW50KSxsPW8tKHBhcnNlSW50KG4uZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctdG9wXCIpKStwYXJzZUludChuLmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLWJvdHRvbVwiKSkpLGE9cy0ocGFyc2VJbnQobi5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1yaWdodFwiKSkrcGFyc2VJbnQobi5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1sZWZ0XCIpKSktcjtyZXR1cm57Y29sczpNYXRoLm1heCgyLE1hdGguZmxvb3IoYS90LmNzcy5jZWxsLndpZHRoKSkscm93czpNYXRoLm1heCgxLE1hdGguZmxvb3IobC90LmNzcy5jZWxsLmhlaWdodCkpfX19fSkoKSxlfSkoKSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkb24tZml0LmpzLm1hcCIsIiFmdW5jdGlvbihlLHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPXQoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sdCk7ZWxzZXt2YXIgaT10KCk7Zm9yKHZhciBzIGluIGkpKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHM6ZSlbc109aVtzXX19KGdsb2JhbFRoaXMsKCgpPT4oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17NDU2NzpmdW5jdGlvbihlLHQsaSl7dmFyIHM9dGhpcyYmdGhpcy5fX2RlY29yYXRlfHxmdW5jdGlvbihlLHQsaSxzKXt2YXIgcixuPWFyZ3VtZW50cy5sZW5ndGgsbz1uPDM/dDpudWxsPT09cz9zPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxpKTpzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZWZsZWN0LmRlY29yYXRlKW89UmVmbGVjdC5kZWNvcmF0ZShlLHQsaSxzKTtlbHNlIGZvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTA7YS0tKShyPWVbYV0pJiYobz0objwzP3Iobyk6bj4zP3IodCxpLG8pOnIodCxpKSl8fG8pO3JldHVybiBuPjMmJm8mJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGksbyksb30scj10aGlzJiZ0aGlzLl9fcGFyYW18fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkscyl7dChpLHMsZSl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkFjY2Vzc2liaWxpdHlNYW5hZ2VyPXZvaWQgMDtjb25zdCBuPWkoOTA0Miksbz1pKDk5MjQpLGE9aSg4NDQpLGg9aSg0NzI1KSxjPWkoMjU4NSksbD1pKDM2NTYpO2xldCBkPXQuQWNjZXNzaWJpbGl0eU1hbmFnZXI9Y2xhc3MgZXh0ZW5kcyBhLkRpc3Bvc2FibGV7Y29uc3RydWN0b3IoZSx0LGkscyl7c3VwZXIoKSx0aGlzLl90ZXJtaW5hbD1lLHRoaXMuX2NvcmVCcm93c2VyU2VydmljZT1pLHRoaXMuX3JlbmRlclNlcnZpY2U9cyx0aGlzLl9yb3dDb2x1bW5zPW5ldyBXZWFrTWFwLHRoaXMuX2xpdmVSZWdpb25MaW5lQ291bnQ9MCx0aGlzLl9jaGFyc1RvQ29uc3VtZT1bXSx0aGlzLl9jaGFyc1RvQW5ub3VuY2U9XCJcIix0aGlzLl9hY2Nlc3NpYmlsaXR5Q29udGFpbmVyPXRoaXMuX2NvcmVCcm93c2VyU2VydmljZS5tYWluRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl9hY2Nlc3NpYmlsaXR5Q29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ4dGVybS1hY2Nlc3NpYmlsaXR5XCIpLHRoaXMuX3Jvd0NvbnRhaW5lcj10aGlzLl9jb3JlQnJvd3NlclNlcnZpY2UubWFpbkRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5fcm93Q29udGFpbmVyLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImxpc3RcIiksdGhpcy5fcm93Q29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ4dGVybS1hY2Nlc3NpYmlsaXR5LXRyZWVcIiksdGhpcy5fcm93RWxlbWVudHM9W107Zm9yKGxldCBlPTA7ZTx0aGlzLl90ZXJtaW5hbC5yb3dzO2UrKyl0aGlzLl9yb3dFbGVtZW50c1tlXT10aGlzLl9jcmVhdGVBY2Nlc3NpYmlsaXR5VHJlZU5vZGUoKSx0aGlzLl9yb3dDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm93RWxlbWVudHNbZV0pO2lmKHRoaXMuX3RvcEJvdW5kYXJ5Rm9jdXNMaXN0ZW5lcj1lPT50aGlzLl9oYW5kbGVCb3VuZGFyeUZvY3VzKGUsMCksdGhpcy5fYm90dG9tQm91bmRhcnlGb2N1c0xpc3RlbmVyPWU9PnRoaXMuX2hhbmRsZUJvdW5kYXJ5Rm9jdXMoZSwxKSx0aGlzLl9yb3dFbGVtZW50c1swXS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLl90b3BCb3VuZGFyeUZvY3VzTGlzdGVuZXIpLHRoaXMuX3Jvd0VsZW1lbnRzW3RoaXMuX3Jvd0VsZW1lbnRzLmxlbmd0aC0xXS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLl9ib3R0b21Cb3VuZGFyeUZvY3VzTGlzdGVuZXIpLHRoaXMuX3JlZnJlc2hSb3dzRGltZW5zaW9ucygpLHRoaXMuX2FjY2Vzc2liaWxpdHlDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm93Q29udGFpbmVyKSx0aGlzLl9saXZlUmVnaW9uPXRoaXMuX2NvcmVCcm93c2VyU2VydmljZS5tYWluRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl9saXZlUmVnaW9uLmNsYXNzTGlzdC5hZGQoXCJsaXZlLXJlZ2lvblwiKSx0aGlzLl9saXZlUmVnaW9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLFwiYXNzZXJ0aXZlXCIpLHRoaXMuX2FjY2Vzc2liaWxpdHlDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fbGl2ZVJlZ2lvbiksdGhpcy5fbGl2ZVJlZ2lvbkRlYm91bmNlcj10aGlzLnJlZ2lzdGVyKG5ldyBvLlRpbWVCYXNlZERlYm91bmNlcih0aGlzLl9yZW5kZXJSb3dzLmJpbmQodGhpcykpKSwhdGhpcy5fdGVybWluYWwuZWxlbWVudCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZW5hYmxlIGFjY2Vzc2liaWxpdHkgYmVmb3JlIFRlcm1pbmFsLm9wZW5cIik7dGhpcy5fdGVybWluYWwuZWxlbWVudC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsdGhpcy5fYWNjZXNzaWJpbGl0eUNvbnRhaW5lciksdGhpcy5yZWdpc3Rlcih0aGlzLl90ZXJtaW5hbC5vblJlc2l6ZSgoZT0+dGhpcy5faGFuZGxlUmVzaXplKGUucm93cykpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl90ZXJtaW5hbC5vblJlbmRlcigoZT0+dGhpcy5fcmVmcmVzaFJvd3MoZS5zdGFydCxlLmVuZCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl90ZXJtaW5hbC5vblNjcm9sbCgoKCk9PnRoaXMuX3JlZnJlc2hSb3dzKCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl90ZXJtaW5hbC5vbkExMXlDaGFyKChlPT50aGlzLl9oYW5kbGVDaGFyKGUpKSkpLHRoaXMucmVnaXN0ZXIodGhpcy5fdGVybWluYWwub25MaW5lRmVlZCgoKCk9PnRoaXMuX2hhbmRsZUNoYXIoXCJcXG5cIikpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl90ZXJtaW5hbC5vbkExMXlUYWIoKGU9PnRoaXMuX2hhbmRsZVRhYihlKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX3Rlcm1pbmFsLm9uS2V5KChlPT50aGlzLl9oYW5kbGVLZXkoZS5rZXkpKSkpLHRoaXMucmVnaXN0ZXIodGhpcy5fdGVybWluYWwub25CbHVyKCgoKT0+dGhpcy5fY2xlYXJMaXZlUmVnaW9uKCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9yZW5kZXJTZXJ2aWNlLm9uRGltZW5zaW9uc0NoYW5nZSgoKCk9PnRoaXMuX3JlZnJlc2hSb3dzRGltZW5zaW9ucygpKSkpLHRoaXMucmVnaXN0ZXIoKDAsbC5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKGRvY3VtZW50LFwic2VsZWN0aW9uY2hhbmdlXCIsKCgpPT50aGlzLl9oYW5kbGVTZWxlY3Rpb25DaGFuZ2UoKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX2NvcmVCcm93c2VyU2VydmljZS5vbkRwckNoYW5nZSgoKCk9PnRoaXMuX3JlZnJlc2hSb3dzRGltZW5zaW9ucygpKSkpLHRoaXMuX3JlZnJlc2hSb3dzKCksdGhpcy5yZWdpc3RlcigoMCxhLnRvRGlzcG9zYWJsZSkoKCgpPT57dGhpcy5fYWNjZXNzaWJpbGl0eUNvbnRhaW5lci5yZW1vdmUoKSx0aGlzLl9yb3dFbGVtZW50cy5sZW5ndGg9MH0pKSl9X2hhbmRsZVRhYihlKXtmb3IobGV0IHQ9MDt0PGU7dCsrKXRoaXMuX2hhbmRsZUNoYXIoXCIgXCIpfV9oYW5kbGVDaGFyKGUpe3RoaXMuX2xpdmVSZWdpb25MaW5lQ291bnQ8MjEmJih0aGlzLl9jaGFyc1RvQ29uc3VtZS5sZW5ndGg+MD90aGlzLl9jaGFyc1RvQ29uc3VtZS5zaGlmdCgpIT09ZSYmKHRoaXMuX2NoYXJzVG9Bbm5vdW5jZSs9ZSk6dGhpcy5fY2hhcnNUb0Fubm91bmNlKz1lLFwiXFxuXCI9PT1lJiYodGhpcy5fbGl2ZVJlZ2lvbkxpbmVDb3VudCsrLDIxPT09dGhpcy5fbGl2ZVJlZ2lvbkxpbmVDb3VudCYmKHRoaXMuX2xpdmVSZWdpb24udGV4dENvbnRlbnQrPW4udG9vTXVjaE91dHB1dCkpKX1fY2xlYXJMaXZlUmVnaW9uKCl7dGhpcy5fbGl2ZVJlZ2lvbi50ZXh0Q29udGVudD1cIlwiLHRoaXMuX2xpdmVSZWdpb25MaW5lQ291bnQ9MH1faGFuZGxlS2V5KGUpe3RoaXMuX2NsZWFyTGl2ZVJlZ2lvbigpLC9cXHB7Q29udHJvbH0vdS50ZXN0KGUpfHx0aGlzLl9jaGFyc1RvQ29uc3VtZS5wdXNoKGUpfV9yZWZyZXNoUm93cyhlLHQpe3RoaXMuX2xpdmVSZWdpb25EZWJvdW5jZXIucmVmcmVzaChlLHQsdGhpcy5fdGVybWluYWwucm93cyl9X3JlbmRlclJvd3MoZSx0KXtjb25zdCBpPXRoaXMuX3Rlcm1pbmFsLmJ1ZmZlcixzPWkubGluZXMubGVuZ3RoLnRvU3RyaW5nKCk7Zm9yKGxldCByPWU7cjw9dDtyKyspe2NvbnN0IGU9aS5saW5lcy5nZXQoaS55ZGlzcCtyKSx0PVtdLG49ZT8udHJhbnNsYXRlVG9TdHJpbmcoITAsdm9pZCAwLHZvaWQgMCx0KXx8XCJcIixvPShpLnlkaXNwK3IrMSkudG9TdHJpbmcoKSxhPXRoaXMuX3Jvd0VsZW1lbnRzW3JdO2EmJigwPT09bi5sZW5ndGg/KGEuaW5uZXJUZXh0PVwiwqBcIix0aGlzLl9yb3dDb2x1bW5zLnNldChhLFswLDFdKSk6KGEudGV4dENvbnRlbnQ9bix0aGlzLl9yb3dDb2x1bW5zLnNldChhLHQpKSxhLnNldEF0dHJpYnV0ZShcImFyaWEtcG9zaW5zZXRcIixvKSxhLnNldEF0dHJpYnV0ZShcImFyaWEtc2V0c2l6ZVwiLHMpKX10aGlzLl9hbm5vdW5jZUNoYXJhY3RlcnMoKX1fYW5ub3VuY2VDaGFyYWN0ZXJzKCl7MCE9PXRoaXMuX2NoYXJzVG9Bbm5vdW5jZS5sZW5ndGgmJih0aGlzLl9saXZlUmVnaW9uLnRleHRDb250ZW50Kz10aGlzLl9jaGFyc1RvQW5ub3VuY2UsdGhpcy5fY2hhcnNUb0Fubm91bmNlPVwiXCIpfV9oYW5kbGVCb3VuZGFyeUZvY3VzKGUsdCl7Y29uc3QgaT1lLnRhcmdldCxzPXRoaXMuX3Jvd0VsZW1lbnRzWzA9PT10PzE6dGhpcy5fcm93RWxlbWVudHMubGVuZ3RoLTJdO2lmKGkuZ2V0QXR0cmlidXRlKFwiYXJpYS1wb3NpbnNldFwiKT09PSgwPT09dD9cIjFcIjpgJHt0aGlzLl90ZXJtaW5hbC5idWZmZXIubGluZXMubGVuZ3RofWApKXJldHVybjtpZihlLnJlbGF0ZWRUYXJnZXQhPT1zKXJldHVybjtsZXQgcixuO2lmKDA9PT10PyhyPWksbj10aGlzLl9yb3dFbGVtZW50cy5wb3AoKSx0aGlzLl9yb3dDb250YWluZXIucmVtb3ZlQ2hpbGQobikpOihyPXRoaXMuX3Jvd0VsZW1lbnRzLnNoaWZ0KCksbj1pLHRoaXMuX3Jvd0NvbnRhaW5lci5yZW1vdmVDaGlsZChyKSksci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLl90b3BCb3VuZGFyeUZvY3VzTGlzdGVuZXIpLG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5fYm90dG9tQm91bmRhcnlGb2N1c0xpc3RlbmVyKSwwPT09dCl7Y29uc3QgZT10aGlzLl9jcmVhdGVBY2Nlc3NpYmlsaXR5VHJlZU5vZGUoKTt0aGlzLl9yb3dFbGVtZW50cy51bnNoaWZ0KGUpLHRoaXMuX3Jvd0NvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsZSl9ZWxzZXtjb25zdCBlPXRoaXMuX2NyZWF0ZUFjY2Vzc2liaWxpdHlUcmVlTm9kZSgpO3RoaXMuX3Jvd0VsZW1lbnRzLnB1c2goZSksdGhpcy5fcm93Q29udGFpbmVyLmFwcGVuZENoaWxkKGUpfXRoaXMuX3Jvd0VsZW1lbnRzWzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXMuX3RvcEJvdW5kYXJ5Rm9jdXNMaXN0ZW5lciksdGhpcy5fcm93RWxlbWVudHNbdGhpcy5fcm93RWxlbWVudHMubGVuZ3RoLTFdLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXMuX2JvdHRvbUJvdW5kYXJ5Rm9jdXNMaXN0ZW5lciksdGhpcy5fdGVybWluYWwuc2Nyb2xsTGluZXMoMD09PXQ/LTE6MSksdGhpcy5fcm93RWxlbWVudHNbMD09PXQ/MTp0aGlzLl9yb3dFbGVtZW50cy5sZW5ndGgtMl0uZm9jdXMoKSxlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKX1faGFuZGxlU2VsZWN0aW9uQ2hhbmdlKCl7aWYoMD09PXRoaXMuX3Jvd0VsZW1lbnRzLmxlbmd0aClyZXR1cm47Y29uc3QgZT1kb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtpZighZSlyZXR1cm47aWYoZS5pc0NvbGxhcHNlZClyZXR1cm4gdm9pZCh0aGlzLl9yb3dDb250YWluZXIuY29udGFpbnMoZS5hbmNob3JOb2RlKSYmdGhpcy5fdGVybWluYWwuY2xlYXJTZWxlY3Rpb24oKSk7aWYoIWUuYW5jaG9yTm9kZXx8IWUuZm9jdXNOb2RlKXJldHVybiB2b2lkIGNvbnNvbGUuZXJyb3IoXCJhbmNob3JOb2RlIGFuZC9vciBmb2N1c05vZGUgYXJlIG51bGxcIik7bGV0IHQ9e25vZGU6ZS5hbmNob3JOb2RlLG9mZnNldDplLmFuY2hvck9mZnNldH0saT17bm9kZTplLmZvY3VzTm9kZSxvZmZzZXQ6ZS5mb2N1c09mZnNldH07aWYoKHQubm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpLm5vZGUpJk5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HfHx0Lm5vZGU9PT1pLm5vZGUmJnQub2Zmc2V0Pmkub2Zmc2V0KSYmKFt0LGldPVtpLHRdKSx0Lm5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcy5fcm93RWxlbWVudHNbMF0pJihOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWXxOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORykmJih0PXtub2RlOnRoaXMuX3Jvd0VsZW1lbnRzWzBdLmNoaWxkTm9kZXNbMF0sb2Zmc2V0OjB9KSwhdGhpcy5fcm93Q29udGFpbmVyLmNvbnRhaW5zKHQubm9kZSkpcmV0dXJuO2NvbnN0IHM9dGhpcy5fcm93RWxlbWVudHMuc2xpY2UoLTEpWzBdO2lmKGkubm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihzKSYoTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQll8Tm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpJiYoaT17bm9kZTpzLG9mZnNldDpzLnRleHRDb250ZW50Py5sZW5ndGg/PzB9KSwhdGhpcy5fcm93Q29udGFpbmVyLmNvbnRhaW5zKGkubm9kZSkpcmV0dXJuO2NvbnN0IHI9KHtub2RlOmUsb2Zmc2V0OnR9KT0+e2NvbnN0IGk9ZSBpbnN0YW5jZW9mIFRleHQ/ZS5wYXJlbnROb2RlOmU7bGV0IHM9cGFyc2VJbnQoaT8uZ2V0QXR0cmlidXRlKFwiYXJpYS1wb3NpbnNldFwiKSwxMCktMTtpZihpc05hTihzKSlyZXR1cm4gY29uc29sZS53YXJuKFwicm93IGlzIGludmFsaWQuIFJhY2UgY29uZGl0aW9uP1wiKSxudWxsO2NvbnN0IHI9dGhpcy5fcm93Q29sdW1ucy5nZXQoaSk7aWYoIXIpcmV0dXJuIGNvbnNvbGUud2FybihcImNvbHVtbnMgaXMgbnVsbC4gUmFjZSBjb25kaXRpb24/XCIpLG51bGw7bGV0IG49dDxyLmxlbmd0aD9yW3RdOnIuc2xpY2UoLTEpWzBdKzE7cmV0dXJuIG4+PXRoaXMuX3Rlcm1pbmFsLmNvbHMmJigrK3Msbj0wKSx7cm93OnMsY29sdW1uOm59fSxuPXIodCksbz1yKGkpO2lmKG4mJm8pe2lmKG4ucm93Pm8ucm93fHxuLnJvdz09PW8ucm93JiZuLmNvbHVtbj49by5jb2x1bW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByYW5nZVwiKTt0aGlzLl90ZXJtaW5hbC5zZWxlY3Qobi5jb2x1bW4sbi5yb3csKG8ucm93LW4ucm93KSp0aGlzLl90ZXJtaW5hbC5jb2xzLW4uY29sdW1uK28uY29sdW1uKX19X2hhbmRsZVJlc2l6ZShlKXt0aGlzLl9yb3dFbGVtZW50c1t0aGlzLl9yb3dFbGVtZW50cy5sZW5ndGgtMV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5fYm90dG9tQm91bmRhcnlGb2N1c0xpc3RlbmVyKTtmb3IobGV0IGU9dGhpcy5fcm93Q29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aDtlPHRoaXMuX3Rlcm1pbmFsLnJvd3M7ZSsrKXRoaXMuX3Jvd0VsZW1lbnRzW2VdPXRoaXMuX2NyZWF0ZUFjY2Vzc2liaWxpdHlUcmVlTm9kZSgpLHRoaXMuX3Jvd0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb3dFbGVtZW50c1tlXSk7Zm9yKDt0aGlzLl9yb3dFbGVtZW50cy5sZW5ndGg+ZTspdGhpcy5fcm93Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX3Jvd0VsZW1lbnRzLnBvcCgpKTt0aGlzLl9yb3dFbGVtZW50c1t0aGlzLl9yb3dFbGVtZW50cy5sZW5ndGgtMV0uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5fYm90dG9tQm91bmRhcnlGb2N1c0xpc3RlbmVyKSx0aGlzLl9yZWZyZXNoUm93c0RpbWVuc2lvbnMoKX1fY3JlYXRlQWNjZXNzaWJpbGl0eVRyZWVOb2RlKCl7Y29uc3QgZT10aGlzLl9jb3JlQnJvd3NlclNlcnZpY2UubWFpbkRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLFwibGlzdGl0ZW1cIiksZS50YWJJbmRleD0tMSx0aGlzLl9yZWZyZXNoUm93RGltZW5zaW9ucyhlKSxlfV9yZWZyZXNoUm93c0RpbWVuc2lvbnMoKXtpZih0aGlzLl9yZW5kZXJTZXJ2aWNlLmRpbWVuc2lvbnMuY3NzLmNlbGwuaGVpZ2h0KXt0aGlzLl9hY2Nlc3NpYmlsaXR5Q29udGFpbmVyLnN0eWxlLndpZHRoPWAke3RoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2FudmFzLndpZHRofXB4YCx0aGlzLl9yb3dFbGVtZW50cy5sZW5ndGghPT10aGlzLl90ZXJtaW5hbC5yb3dzJiZ0aGlzLl9oYW5kbGVSZXNpemUodGhpcy5fdGVybWluYWwucm93cyk7Zm9yKGxldCBlPTA7ZTx0aGlzLl90ZXJtaW5hbC5yb3dzO2UrKyl0aGlzLl9yZWZyZXNoUm93RGltZW5zaW9ucyh0aGlzLl9yb3dFbGVtZW50c1tlXSl9fV9yZWZyZXNoUm93RGltZW5zaW9ucyhlKXtlLnN0eWxlLmhlaWdodD1gJHt0aGlzLl9yZW5kZXJTZXJ2aWNlLmRpbWVuc2lvbnMuY3NzLmNlbGwuaGVpZ2h0fXB4YH19O3QuQWNjZXNzaWJpbGl0eU1hbmFnZXI9ZD1zKFtyKDEsYy5JSW5zdGFudGlhdGlvblNlcnZpY2UpLHIoMixoLklDb3JlQnJvd3NlclNlcnZpY2UpLHIoMyxoLklSZW5kZXJTZXJ2aWNlKV0sZCl9LDM2MTQ6KGUsdCk9PntmdW5jdGlvbiBpKGUpe3JldHVybiBlLnJlcGxhY2UoL1xccj9cXG4vZyxcIlxcclwiKX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIHQ/XCJcdTAwMWJbMjAwflwiK2UrXCJcdTAwMWJbMjAxflwiOmV9ZnVuY3Rpb24gcihlLHQscixuKXtlPXMoZT1pKGUpLHIuZGVjUHJpdmF0ZU1vZGVzLmJyYWNrZXRlZFBhc3RlTW9kZSYmITAhPT1uLnJhd09wdGlvbnMuaWdub3JlQnJhY2tldGVkUGFzdGVNb2RlKSxyLnRyaWdnZXJEYXRhRXZlbnQoZSwhMCksdC52YWx1ZT1cIlwifWZ1bmN0aW9uIG4oZSx0LGkpe2NvbnN0IHM9aS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxyPWUuY2xpZW50WC1zLmxlZnQtMTAsbj1lLmNsaWVudFktcy50b3AtMTA7dC5zdHlsZS53aWR0aD1cIjIwcHhcIix0LnN0eWxlLmhlaWdodD1cIjIwcHhcIix0LnN0eWxlLmxlZnQ9YCR7cn1weGAsdC5zdHlsZS50b3A9YCR7bn1weGAsdC5zdHlsZS56SW5kZXg9XCIxMDAwXCIsdC5mb2N1cygpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucmlnaHRDbGlja0hhbmRsZXI9dC5tb3ZlVGV4dEFyZWFVbmRlck1vdXNlQ3Vyc29yPXQucGFzdGU9dC5oYW5kbGVQYXN0ZUV2ZW50PXQuY29weUhhbmRsZXI9dC5icmFja2V0VGV4dEZvclBhc3RlPXQucHJlcGFyZVRleHRGb3JUZXJtaW5hbD12b2lkIDAsdC5wcmVwYXJlVGV4dEZvclRlcm1pbmFsPWksdC5icmFja2V0VGV4dEZvclBhc3RlPXMsdC5jb3B5SGFuZGxlcj1mdW5jdGlvbihlLHQpe2UuY2xpcGJvYXJkRGF0YSYmZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsdC5zZWxlY3Rpb25UZXh0KSxlLnByZXZlbnREZWZhdWx0KCl9LHQuaGFuZGxlUGFzdGVFdmVudD1mdW5jdGlvbihlLHQsaSxzKXtlLnN0b3BQcm9wYWdhdGlvbigpLGUuY2xpcGJvYXJkRGF0YSYmcihlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIiksdCxpLHMpfSx0LnBhc3RlPXIsdC5tb3ZlVGV4dEFyZWFVbmRlck1vdXNlQ3Vyc29yPW4sdC5yaWdodENsaWNrSGFuZGxlcj1mdW5jdGlvbihlLHQsaSxzLHIpe24oZSx0LGkpLHImJnMucmlnaHRDbGlja1NlbGVjdChlKSx0LnZhbHVlPXMuc2VsZWN0aW9uVGV4dCx0LnNlbGVjdCgpfX0sNzIzOTooZSx0LGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Db2xvckNvbnRyYXN0Q2FjaGU9dm9pZCAwO2NvbnN0IHM9aSgxNTA1KTt0LkNvbG9yQ29udHJhc3RDYWNoZT1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuX2NvbG9yPW5ldyBzLlR3b0tleU1hcCx0aGlzLl9jc3M9bmV3IHMuVHdvS2V5TWFwfXNldENzcyhlLHQsaSl7dGhpcy5fY3NzLnNldChlLHQsaSl9Z2V0Q3NzKGUsdCl7cmV0dXJuIHRoaXMuX2Nzcy5nZXQoZSx0KX1zZXRDb2xvcihlLHQsaSl7dGhpcy5fY29sb3Iuc2V0KGUsdCxpKX1nZXRDb2xvcihlLHQpe3JldHVybiB0aGlzLl9jb2xvci5nZXQoZSx0KX1jbGVhcigpe3RoaXMuX2NvbG9yLmNsZWFyKCksdGhpcy5fY3NzLmNsZWFyKCl9fX0sMzY1NjooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyPXZvaWQgMCx0LmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcj1mdW5jdGlvbihlLHQsaSxzKXtlLmFkZEV2ZW50TGlzdGVuZXIodCxpLHMpO2xldCByPSExO3JldHVybntkaXNwb3NlOigpPT57cnx8KHI9ITAsZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsaSxzKSl9fX19LDM1NTE6ZnVuY3Rpb24oZSx0LGkpe3ZhciBzPXRoaXMmJnRoaXMuX19kZWNvcmF0ZXx8ZnVuY3Rpb24oZSx0LGkscyl7dmFyIHIsbj1hcmd1bWVudHMubGVuZ3RoLG89bjwzP3Q6bnVsbD09PXM/cz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsaSk6cztpZihcIm9iamVjdFwiPT10eXBlb2YgUmVmbGVjdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSlvPVJlZmxlY3QuZGVjb3JhdGUoZSx0LGkscyk7ZWxzZSBmb3IodmFyIGE9ZS5sZW5ndGgtMTthPj0wO2EtLSkocj1lW2FdKSYmKG89KG48Mz9yKG8pOm4+Mz9yKHQsaSxvKTpyKHQsaSkpfHxvKTtyZXR1cm4gbj4zJiZvJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLG8pLG99LHI9dGhpcyYmdGhpcy5fX3BhcmFtfHxmdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihpLHMpe3QoaSxzLGUpfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5MaW5raWZpZXI9dm9pZCAwO2NvbnN0IG49aSgzNjU2KSxvPWkoODQ2MCksYT1pKDg0NCksaD1pKDI1ODUpLGM9aSg0NzI1KTtsZXQgbD10LkxpbmtpZmllcj1jbGFzcyBleHRlbmRzIGEuRGlzcG9zYWJsZXtnZXQgY3VycmVudExpbmsoKXtyZXR1cm4gdGhpcy5fY3VycmVudExpbmt9Y29uc3RydWN0b3IoZSx0LGkscyxyKXtzdXBlcigpLHRoaXMuX2VsZW1lbnQ9ZSx0aGlzLl9tb3VzZVNlcnZpY2U9dCx0aGlzLl9yZW5kZXJTZXJ2aWNlPWksdGhpcy5fYnVmZmVyU2VydmljZT1zLHRoaXMuX2xpbmtQcm92aWRlclNlcnZpY2U9cix0aGlzLl9saW5rQ2FjaGVEaXNwb3NhYmxlcz1bXSx0aGlzLl9pc01vdXNlT3V0PSEwLHRoaXMuX3dhc1Jlc2l6ZWQ9ITEsdGhpcy5fYWN0aXZlTGluZT0tMSx0aGlzLl9vblNob3dMaW5rVW5kZXJsaW5lPXRoaXMucmVnaXN0ZXIobmV3IG8uRXZlbnRFbWl0dGVyKSx0aGlzLm9uU2hvd0xpbmtVbmRlcmxpbmU9dGhpcy5fb25TaG93TGlua1VuZGVybGluZS5ldmVudCx0aGlzLl9vbkhpZGVMaW5rVW5kZXJsaW5lPXRoaXMucmVnaXN0ZXIobmV3IG8uRXZlbnRFbWl0dGVyKSx0aGlzLm9uSGlkZUxpbmtVbmRlcmxpbmU9dGhpcy5fb25IaWRlTGlua1VuZGVybGluZS5ldmVudCx0aGlzLnJlZ2lzdGVyKCgwLGEuZ2V0RGlzcG9zZUFycmF5RGlzcG9zYWJsZSkodGhpcy5fbGlua0NhY2hlRGlzcG9zYWJsZXMpKSx0aGlzLnJlZ2lzdGVyKCgwLGEudG9EaXNwb3NhYmxlKSgoKCk9Pnt0aGlzLl9sYXN0TW91c2VFdmVudD12b2lkIDAsdGhpcy5fYWN0aXZlUHJvdmlkZXJSZXBsaWVzPy5jbGVhcigpfSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX2J1ZmZlclNlcnZpY2Uub25SZXNpemUoKCgpPT57dGhpcy5fY2xlYXJDdXJyZW50TGluaygpLHRoaXMuX3dhc1Jlc2l6ZWQ9ITB9KSkpLHRoaXMucmVnaXN0ZXIoKDAsbi5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMuX2VsZW1lbnQsXCJtb3VzZWxlYXZlXCIsKCgpPT57dGhpcy5faXNNb3VzZU91dD0hMCx0aGlzLl9jbGVhckN1cnJlbnRMaW5rKCl9KSkpLHRoaXMucmVnaXN0ZXIoKDAsbi5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMuX2VsZW1lbnQsXCJtb3VzZW1vdmVcIix0aGlzLl9oYW5kbGVNb3VzZU1vdmUuYmluZCh0aGlzKSkpLHRoaXMucmVnaXN0ZXIoKDAsbi5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMuX2VsZW1lbnQsXCJtb3VzZWRvd25cIix0aGlzLl9oYW5kbGVNb3VzZURvd24uYmluZCh0aGlzKSkpLHRoaXMucmVnaXN0ZXIoKDAsbi5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMuX2VsZW1lbnQsXCJtb3VzZXVwXCIsdGhpcy5faGFuZGxlTW91c2VVcC5iaW5kKHRoaXMpKSl9X2hhbmRsZU1vdXNlTW92ZShlKXt0aGlzLl9sYXN0TW91c2VFdmVudD1lO2NvbnN0IHQ9dGhpcy5fcG9zaXRpb25Gcm9tTW91c2VFdmVudChlLHRoaXMuX2VsZW1lbnQsdGhpcy5fbW91c2VTZXJ2aWNlKTtpZighdClyZXR1cm47dGhpcy5faXNNb3VzZU91dD0hMTtjb25zdCBpPWUuY29tcG9zZWRQYXRoKCk7Zm9yKGxldCBlPTA7ZTxpLmxlbmd0aDtlKyspe2NvbnN0IHQ9aVtlXTtpZih0LmNsYXNzTGlzdC5jb250YWlucyhcInh0ZXJtXCIpKWJyZWFrO2lmKHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwieHRlcm0taG92ZXJcIikpcmV0dXJufXRoaXMuX2xhc3RCdWZmZXJDZWxsJiZ0Lng9PT10aGlzLl9sYXN0QnVmZmVyQ2VsbC54JiZ0Lnk9PT10aGlzLl9sYXN0QnVmZmVyQ2VsbC55fHwodGhpcy5faGFuZGxlSG92ZXIodCksdGhpcy5fbGFzdEJ1ZmZlckNlbGw9dCl9X2hhbmRsZUhvdmVyKGUpe2lmKHRoaXMuX2FjdGl2ZUxpbmUhPT1lLnl8fHRoaXMuX3dhc1Jlc2l6ZWQpcmV0dXJuIHRoaXMuX2NsZWFyQ3VycmVudExpbmsoKSx0aGlzLl9hc2tGb3JMaW5rKGUsITEpLHZvaWQodGhpcy5fd2FzUmVzaXplZD0hMSk7dGhpcy5fY3VycmVudExpbmsmJnRoaXMuX2xpbmtBdFBvc2l0aW9uKHRoaXMuX2N1cnJlbnRMaW5rLmxpbmssZSl8fCh0aGlzLl9jbGVhckN1cnJlbnRMaW5rKCksdGhpcy5fYXNrRm9yTGluayhlLCEwKSl9X2Fza0ZvckxpbmsoZSx0KXt0aGlzLl9hY3RpdmVQcm92aWRlclJlcGxpZXMmJnR8fCh0aGlzLl9hY3RpdmVQcm92aWRlclJlcGxpZXM/LmZvckVhY2goKGU9PntlPy5mb3JFYWNoKChlPT57ZS5saW5rLmRpc3Bvc2UmJmUubGluay5kaXNwb3NlKCl9KSl9KSksdGhpcy5fYWN0aXZlUHJvdmlkZXJSZXBsaWVzPW5ldyBNYXAsdGhpcy5fYWN0aXZlTGluZT1lLnkpO2xldCBpPSExO2Zvcihjb25zdFtzLHJdb2YgdGhpcy5fbGlua1Byb3ZpZGVyU2VydmljZS5saW5rUHJvdmlkZXJzLmVudHJpZXMoKSlpZih0KXtjb25zdCB0PXRoaXMuX2FjdGl2ZVByb3ZpZGVyUmVwbGllcz8uZ2V0KHMpO3QmJihpPXRoaXMuX2NoZWNrTGlua1Byb3ZpZGVyUmVzdWx0KHMsZSxpKSl9ZWxzZSByLnByb3ZpZGVMaW5rcyhlLnksKHQ9PntpZih0aGlzLl9pc01vdXNlT3V0KXJldHVybjtjb25zdCByPXQ/Lm1hcCgoZT0+KHtsaW5rOmV9KSkpO3RoaXMuX2FjdGl2ZVByb3ZpZGVyUmVwbGllcz8uc2V0KHMsciksaT10aGlzLl9jaGVja0xpbmtQcm92aWRlclJlc3VsdChzLGUsaSksdGhpcy5fYWN0aXZlUHJvdmlkZXJSZXBsaWVzPy5zaXplPT09dGhpcy5fbGlua1Byb3ZpZGVyU2VydmljZS5saW5rUHJvdmlkZXJzLmxlbmd0aCYmdGhpcy5fcmVtb3ZlSW50ZXJzZWN0aW5nTGlua3MoZS55LHRoaXMuX2FjdGl2ZVByb3ZpZGVyUmVwbGllcyl9KSl9X3JlbW92ZUludGVyc2VjdGluZ0xpbmtzKGUsdCl7Y29uc3QgaT1uZXcgU2V0O2ZvcihsZXQgcz0wO3M8dC5zaXplO3MrKyl7Y29uc3Qgcj10LmdldChzKTtpZihyKWZvcihsZXQgdD0wO3Q8ci5sZW5ndGg7dCsrKXtjb25zdCBzPXJbdF0sbj1zLmxpbmsucmFuZ2Uuc3RhcnQueTxlPzA6cy5saW5rLnJhbmdlLnN0YXJ0Lngsbz1zLmxpbmsucmFuZ2UuZW5kLnk+ZT90aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHM6cy5saW5rLnJhbmdlLmVuZC54O2ZvcihsZXQgZT1uO2U8PW87ZSsrKXtpZihpLmhhcyhlKSl7ci5zcGxpY2UodC0tLDEpO2JyZWFrfWkuYWRkKGUpfX19fV9jaGVja0xpbmtQcm92aWRlclJlc3VsdChlLHQsaSl7aWYoIXRoaXMuX2FjdGl2ZVByb3ZpZGVyUmVwbGllcylyZXR1cm4gaTtjb25zdCBzPXRoaXMuX2FjdGl2ZVByb3ZpZGVyUmVwbGllcy5nZXQoZSk7bGV0IHI9ITE7Zm9yKGxldCB0PTA7dDxlO3QrKyl0aGlzLl9hY3RpdmVQcm92aWRlclJlcGxpZXMuaGFzKHQpJiYhdGhpcy5fYWN0aXZlUHJvdmlkZXJSZXBsaWVzLmdldCh0KXx8KHI9ITApO2lmKCFyJiZzKXtjb25zdCBlPXMuZmluZCgoZT0+dGhpcy5fbGlua0F0UG9zaXRpb24oZS5saW5rLHQpKSk7ZSYmKGk9ITAsdGhpcy5faGFuZGxlTmV3TGluayhlKSl9aWYodGhpcy5fYWN0aXZlUHJvdmlkZXJSZXBsaWVzLnNpemU9PT10aGlzLl9saW5rUHJvdmlkZXJTZXJ2aWNlLmxpbmtQcm92aWRlcnMubGVuZ3RoJiYhaSlmb3IobGV0IGU9MDtlPHRoaXMuX2FjdGl2ZVByb3ZpZGVyUmVwbGllcy5zaXplO2UrKyl7Y29uc3Qgcz10aGlzLl9hY3RpdmVQcm92aWRlclJlcGxpZXMuZ2V0KGUpPy5maW5kKChlPT50aGlzLl9saW5rQXRQb3NpdGlvbihlLmxpbmssdCkpKTtpZihzKXtpPSEwLHRoaXMuX2hhbmRsZU5ld0xpbmsocyk7YnJlYWt9fXJldHVybiBpfV9oYW5kbGVNb3VzZURvd24oKXt0aGlzLl9tb3VzZURvd25MaW5rPXRoaXMuX2N1cnJlbnRMaW5rfV9oYW5kbGVNb3VzZVVwKGUpe2lmKCF0aGlzLl9jdXJyZW50TGluaylyZXR1cm47Y29uc3QgdD10aGlzLl9wb3NpdGlvbkZyb21Nb3VzZUV2ZW50KGUsdGhpcy5fZWxlbWVudCx0aGlzLl9tb3VzZVNlcnZpY2UpO3QmJnRoaXMuX21vdXNlRG93bkxpbms9PT10aGlzLl9jdXJyZW50TGluayYmdGhpcy5fbGlua0F0UG9zaXRpb24odGhpcy5fY3VycmVudExpbmsubGluayx0KSYmdGhpcy5fY3VycmVudExpbmsubGluay5hY3RpdmF0ZShlLHRoaXMuX2N1cnJlbnRMaW5rLmxpbmsudGV4dCl9X2NsZWFyQ3VycmVudExpbmsoZSx0KXt0aGlzLl9jdXJyZW50TGluayYmdGhpcy5fbGFzdE1vdXNlRXZlbnQmJighZXx8IXR8fHRoaXMuX2N1cnJlbnRMaW5rLmxpbmsucmFuZ2Uuc3RhcnQueT49ZSYmdGhpcy5fY3VycmVudExpbmsubGluay5yYW5nZS5lbmQueTw9dCkmJih0aGlzLl9saW5rTGVhdmUodGhpcy5fZWxlbWVudCx0aGlzLl9jdXJyZW50TGluay5saW5rLHRoaXMuX2xhc3RNb3VzZUV2ZW50KSx0aGlzLl9jdXJyZW50TGluaz12b2lkIDAsKDAsYS5kaXNwb3NlQXJyYXkpKHRoaXMuX2xpbmtDYWNoZURpc3Bvc2FibGVzKSl9X2hhbmRsZU5ld0xpbmsoZSl7aWYoIXRoaXMuX2xhc3RNb3VzZUV2ZW50KXJldHVybjtjb25zdCB0PXRoaXMuX3Bvc2l0aW9uRnJvbU1vdXNlRXZlbnQodGhpcy5fbGFzdE1vdXNlRXZlbnQsdGhpcy5fZWxlbWVudCx0aGlzLl9tb3VzZVNlcnZpY2UpO3QmJnRoaXMuX2xpbmtBdFBvc2l0aW9uKGUubGluayx0KSYmKHRoaXMuX2N1cnJlbnRMaW5rPWUsdGhpcy5fY3VycmVudExpbmsuc3RhdGU9e2RlY29yYXRpb25zOnt1bmRlcmxpbmU6dm9pZCAwPT09ZS5saW5rLmRlY29yYXRpb25zfHxlLmxpbmsuZGVjb3JhdGlvbnMudW5kZXJsaW5lLHBvaW50ZXJDdXJzb3I6dm9pZCAwPT09ZS5saW5rLmRlY29yYXRpb25zfHxlLmxpbmsuZGVjb3JhdGlvbnMucG9pbnRlckN1cnNvcn0saXNIb3ZlcmVkOiEwfSx0aGlzLl9saW5rSG92ZXIodGhpcy5fZWxlbWVudCxlLmxpbmssdGhpcy5fbGFzdE1vdXNlRXZlbnQpLGUubGluay5kZWNvcmF0aW9ucz17fSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLmxpbmsuZGVjb3JhdGlvbnMse3BvaW50ZXJDdXJzb3I6e2dldDooKT0+dGhpcy5fY3VycmVudExpbms/LnN0YXRlPy5kZWNvcmF0aW9ucy5wb2ludGVyQ3Vyc29yLHNldDplPT57dGhpcy5fY3VycmVudExpbms/LnN0YXRlJiZ0aGlzLl9jdXJyZW50TGluay5zdGF0ZS5kZWNvcmF0aW9ucy5wb2ludGVyQ3Vyc29yIT09ZSYmKHRoaXMuX2N1cnJlbnRMaW5rLnN0YXRlLmRlY29yYXRpb25zLnBvaW50ZXJDdXJzb3I9ZSx0aGlzLl9jdXJyZW50TGluay5zdGF0ZS5pc0hvdmVyZWQmJnRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcInh0ZXJtLWN1cnNvci1wb2ludGVyXCIsZSkpfX0sdW5kZXJsaW5lOntnZXQ6KCk9PnRoaXMuX2N1cnJlbnRMaW5rPy5zdGF0ZT8uZGVjb3JhdGlvbnMudW5kZXJsaW5lLHNldDp0PT57dGhpcy5fY3VycmVudExpbms/LnN0YXRlJiZ0aGlzLl9jdXJyZW50TGluaz8uc3RhdGU/LmRlY29yYXRpb25zLnVuZGVybGluZSE9PXQmJih0aGlzLl9jdXJyZW50TGluay5zdGF0ZS5kZWNvcmF0aW9ucy51bmRlcmxpbmU9dCx0aGlzLl9jdXJyZW50TGluay5zdGF0ZS5pc0hvdmVyZWQmJnRoaXMuX2ZpcmVVbmRlcmxpbmVFdmVudChlLmxpbmssdCkpfX19KSx0aGlzLl9saW5rQ2FjaGVEaXNwb3NhYmxlcy5wdXNoKHRoaXMuX3JlbmRlclNlcnZpY2Uub25SZW5kZXJlZFZpZXdwb3J0Q2hhbmdlKChlPT57aWYoIXRoaXMuX2N1cnJlbnRMaW5rKXJldHVybjtjb25zdCB0PTA9PT1lLnN0YXJ0PzA6ZS5zdGFydCsxK3RoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLnlkaXNwLGk9dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIueWRpc3ArMStlLmVuZDtpZih0aGlzLl9jdXJyZW50TGluay5saW5rLnJhbmdlLnN0YXJ0Lnk+PXQmJnRoaXMuX2N1cnJlbnRMaW5rLmxpbmsucmFuZ2UuZW5kLnk8PWkmJih0aGlzLl9jbGVhckN1cnJlbnRMaW5rKHQsaSksdGhpcy5fbGFzdE1vdXNlRXZlbnQpKXtjb25zdCBlPXRoaXMuX3Bvc2l0aW9uRnJvbU1vdXNlRXZlbnQodGhpcy5fbGFzdE1vdXNlRXZlbnQsdGhpcy5fZWxlbWVudCx0aGlzLl9tb3VzZVNlcnZpY2UpO2UmJnRoaXMuX2Fza0ZvckxpbmsoZSwhMSl9fSkpKSl9X2xpbmtIb3ZlcihlLHQsaSl7dGhpcy5fY3VycmVudExpbms/LnN0YXRlJiYodGhpcy5fY3VycmVudExpbmsuc3RhdGUuaXNIb3ZlcmVkPSEwLHRoaXMuX2N1cnJlbnRMaW5rLnN0YXRlLmRlY29yYXRpb25zLnVuZGVybGluZSYmdGhpcy5fZmlyZVVuZGVybGluZUV2ZW50KHQsITApLHRoaXMuX2N1cnJlbnRMaW5rLnN0YXRlLmRlY29yYXRpb25zLnBvaW50ZXJDdXJzb3ImJmUuY2xhc3NMaXN0LmFkZChcInh0ZXJtLWN1cnNvci1wb2ludGVyXCIpKSx0LmhvdmVyJiZ0LmhvdmVyKGksdC50ZXh0KX1fZmlyZVVuZGVybGluZUV2ZW50KGUsdCl7Y29uc3QgaT1lLnJhbmdlLHM9dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIueWRpc3Ascj10aGlzLl9jcmVhdGVMaW5rVW5kZXJsaW5lRXZlbnQoaS5zdGFydC54LTEsaS5zdGFydC55LXMtMSxpLmVuZC54LGkuZW5kLnktcy0xLHZvaWQgMCk7KHQ/dGhpcy5fb25TaG93TGlua1VuZGVybGluZTp0aGlzLl9vbkhpZGVMaW5rVW5kZXJsaW5lKS5maXJlKHIpfV9saW5rTGVhdmUoZSx0LGkpe3RoaXMuX2N1cnJlbnRMaW5rPy5zdGF0ZSYmKHRoaXMuX2N1cnJlbnRMaW5rLnN0YXRlLmlzSG92ZXJlZD0hMSx0aGlzLl9jdXJyZW50TGluay5zdGF0ZS5kZWNvcmF0aW9ucy51bmRlcmxpbmUmJnRoaXMuX2ZpcmVVbmRlcmxpbmVFdmVudCh0LCExKSx0aGlzLl9jdXJyZW50TGluay5zdGF0ZS5kZWNvcmF0aW9ucy5wb2ludGVyQ3Vyc29yJiZlLmNsYXNzTGlzdC5yZW1vdmUoXCJ4dGVybS1jdXJzb3ItcG9pbnRlclwiKSksdC5sZWF2ZSYmdC5sZWF2ZShpLHQudGV4dCl9X2xpbmtBdFBvc2l0aW9uKGUsdCl7Y29uc3QgaT1lLnJhbmdlLnN0YXJ0LnkqdGhpcy5fYnVmZmVyU2VydmljZS5jb2xzK2UucmFuZ2Uuc3RhcnQueCxzPWUucmFuZ2UuZW5kLnkqdGhpcy5fYnVmZmVyU2VydmljZS5jb2xzK2UucmFuZ2UuZW5kLngscj10LnkqdGhpcy5fYnVmZmVyU2VydmljZS5jb2xzK3QueDtyZXR1cm4gaTw9ciYmcjw9c31fcG9zaXRpb25Gcm9tTW91c2VFdmVudChlLHQsaSl7Y29uc3Qgcz1pLmdldENvb3JkcyhlLHQsdGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLHRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cyk7aWYocylyZXR1cm57eDpzWzBdLHk6c1sxXSt0aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci55ZGlzcH19X2NyZWF0ZUxpbmtVbmRlcmxpbmVFdmVudChlLHQsaSxzLHIpe3JldHVybnt4MTplLHkxOnQseDI6aSx5MjpzLGNvbHM6dGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLGZnOnJ9fX07dC5MaW5raWZpZXI9bD1zKFtyKDEsYy5JTW91c2VTZXJ2aWNlKSxyKDIsYy5JUmVuZGVyU2VydmljZSkscigzLGguSUJ1ZmZlclNlcnZpY2UpLHIoNCxjLklMaW5rUHJvdmlkZXJTZXJ2aWNlKV0sbCl9LDkwNDI6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnRvb011Y2hPdXRwdXQ9dC5wcm9tcHRMYWJlbD12b2lkIDAsdC5wcm9tcHRMYWJlbD1cIlRlcm1pbmFsIGlucHV0XCIsdC50b29NdWNoT3V0cHV0PVwiVG9vIG11Y2ggb3V0cHV0IHRvIGFubm91bmNlLCBuYXZpZ2F0ZSB0byByb3dzIG1hbnVhbGx5IHRvIHJlYWRcIn0sMzczMDpmdW5jdGlvbihlLHQsaSl7dmFyIHM9dGhpcyYmdGhpcy5fX2RlY29yYXRlfHxmdW5jdGlvbihlLHQsaSxzKXt2YXIgcixuPWFyZ3VtZW50cy5sZW5ndGgsbz1uPDM/dDpudWxsPT09cz9zPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxpKTpzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZWZsZWN0LmRlY29yYXRlKW89UmVmbGVjdC5kZWNvcmF0ZShlLHQsaSxzKTtlbHNlIGZvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTA7YS0tKShyPWVbYV0pJiYobz0objwzP3Iobyk6bj4zP3IodCxpLG8pOnIodCxpKSl8fG8pO3JldHVybiBuPjMmJm8mJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGksbyksb30scj10aGlzJiZ0aGlzLl9fcGFyYW18fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkscyl7dChpLHMsZSl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk9zY0xpbmtQcm92aWRlcj12b2lkIDA7Y29uc3Qgbj1pKDUxMSksbz1pKDI1ODUpO2xldCBhPXQuT3NjTGlua1Byb3ZpZGVyPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxpKXt0aGlzLl9idWZmZXJTZXJ2aWNlPWUsdGhpcy5fb3B0aW9uc1NlcnZpY2U9dCx0aGlzLl9vc2NMaW5rU2VydmljZT1pfXByb3ZpZGVMaW5rcyhlLHQpe2NvbnN0IGk9dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIubGluZXMuZ2V0KGUtMSk7aWYoIWkpcmV0dXJuIHZvaWQgdCh2b2lkIDApO2NvbnN0IHM9W10scj10aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmxpbmtIYW5kbGVyLG89bmV3IG4uQ2VsbERhdGEsYT1pLmdldFRyaW1tZWRMZW5ndGgoKTtsZXQgYz0tMSxsPS0xLGQ9ITE7Zm9yKGxldCB0PTA7dDxhO3QrKylpZigtMSE9PWx8fGkuaGFzQ29udGVudCh0KSl7aWYoaS5sb2FkQ2VsbCh0LG8pLG8uaGFzRXh0ZW5kZWRBdHRycygpJiZvLmV4dGVuZGVkLnVybElkKXtpZigtMT09PWwpe2w9dCxjPW8uZXh0ZW5kZWQudXJsSWQ7Y29udGludWV9ZD1vLmV4dGVuZGVkLnVybElkIT09Y31lbHNlLTEhPT1sJiYoZD0hMCk7aWYoZHx8LTEhPT1sJiZ0PT09YS0xKXtjb25zdCBpPXRoaXMuX29zY0xpbmtTZXJ2aWNlLmdldExpbmtEYXRhKGMpPy51cmk7aWYoaSl7Y29uc3Qgbj17c3RhcnQ6e3g6bCsxLHk6ZX0sZW5kOnt4OnQrKGR8fHQhPT1hLTE/MDoxKSx5OmV9fTtsZXQgbz0hMTtpZighcj8uYWxsb3dOb25IdHRwUHJvdG9jb2xzKXRyeXtjb25zdCBlPW5ldyBVUkwoaSk7W1wiaHR0cDpcIixcImh0dHBzOlwiXS5pbmNsdWRlcyhlLnByb3RvY29sKXx8KG89ITApfWNhdGNoKGUpe289ITB9b3x8cy5wdXNoKHt0ZXh0OmkscmFuZ2U6bixhY3RpdmF0ZTooZSx0KT0+cj9yLmFjdGl2YXRlKGUsdCxuKTpoKDAsdCksaG92ZXI6KGUsdCk9PnI/LmhvdmVyPy4oZSx0LG4pLGxlYXZlOihlLHQpPT5yPy5sZWF2ZT8uKGUsdCxuKX0pfWQ9ITEsby5oYXNFeHRlbmRlZEF0dHJzKCkmJm8uZXh0ZW5kZWQudXJsSWQ/KGw9dCxjPW8uZXh0ZW5kZWQudXJsSWQpOihsPS0xLGM9LTEpfX10KHMpfX07ZnVuY3Rpb24gaChlLHQpe2lmKGNvbmZpcm0oYERvIHlvdSB3YW50IHRvIG5hdmlnYXRlIHRvICR7dH0/XFxuXFxuV0FSTklORzogVGhpcyBsaW5rIGNvdWxkIHBvdGVudGlhbGx5IGJlIGRhbmdlcm91c2ApKXtjb25zdCBlPXdpbmRvdy5vcGVuKCk7aWYoZSl7dHJ5e2Uub3BlbmVyPW51bGx9Y2F0Y2h7fWUubG9jYXRpb24uaHJlZj10fWVsc2UgY29uc29sZS53YXJuKFwiT3BlbmluZyBsaW5rIGJsb2NrZWQgYXMgb3BlbmVyIGNvdWxkIG5vdCBiZSBjbGVhcmVkXCIpfX10Lk9zY0xpbmtQcm92aWRlcj1hPXMoW3IoMCxvLklCdWZmZXJTZXJ2aWNlKSxyKDEsby5JT3B0aW9uc1NlcnZpY2UpLHIoMixvLklPc2NMaW5rU2VydmljZSldLGEpfSw2MTkzOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5SZW5kZXJEZWJvdW5jZXI9dm9pZCAwLHQuUmVuZGVyRGVib3VuY2VyPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5fcmVuZGVyQ2FsbGJhY2s9ZSx0aGlzLl9jb3JlQnJvd3NlclNlcnZpY2U9dCx0aGlzLl9yZWZyZXNoQ2FsbGJhY2tzPVtdfWRpc3Bvc2UoKXt0aGlzLl9hbmltYXRpb25GcmFtZSYmKHRoaXMuX2NvcmVCcm93c2VyU2VydmljZS53aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0aW9uRnJhbWUpLHRoaXMuX2FuaW1hdGlvbkZyYW1lPXZvaWQgMCl9YWRkUmVmcmVzaENhbGxiYWNrKGUpe3JldHVybiB0aGlzLl9yZWZyZXNoQ2FsbGJhY2tzLnB1c2goZSksdGhpcy5fYW5pbWF0aW9uRnJhbWV8fCh0aGlzLl9hbmltYXRpb25GcmFtZT10aGlzLl9jb3JlQnJvd3NlclNlcnZpY2Uud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCk9PnRoaXMuX2lubmVyUmVmcmVzaCgpKSkpLHRoaXMuX2FuaW1hdGlvbkZyYW1lfXJlZnJlc2goZSx0LGkpe3RoaXMuX3Jvd0NvdW50PWksZT12b2lkIDAhPT1lP2U6MCx0PXZvaWQgMCE9PXQ/dDp0aGlzLl9yb3dDb3VudC0xLHRoaXMuX3Jvd1N0YXJ0PXZvaWQgMCE9PXRoaXMuX3Jvd1N0YXJ0P01hdGgubWluKHRoaXMuX3Jvd1N0YXJ0LGUpOmUsdGhpcy5fcm93RW5kPXZvaWQgMCE9PXRoaXMuX3Jvd0VuZD9NYXRoLm1heCh0aGlzLl9yb3dFbmQsdCk6dCx0aGlzLl9hbmltYXRpb25GcmFtZXx8KHRoaXMuX2FuaW1hdGlvbkZyYW1lPXRoaXMuX2NvcmVCcm93c2VyU2VydmljZS53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgoKT0+dGhpcy5faW5uZXJSZWZyZXNoKCkpKSl9X2lubmVyUmVmcmVzaCgpe2lmKHRoaXMuX2FuaW1hdGlvbkZyYW1lPXZvaWQgMCx2b2lkIDA9PT10aGlzLl9yb3dTdGFydHx8dm9pZCAwPT09dGhpcy5fcm93RW5kfHx2b2lkIDA9PT10aGlzLl9yb3dDb3VudClyZXR1cm4gdm9pZCB0aGlzLl9ydW5SZWZyZXNoQ2FsbGJhY2tzKCk7Y29uc3QgZT1NYXRoLm1heCh0aGlzLl9yb3dTdGFydCwwKSx0PU1hdGgubWluKHRoaXMuX3Jvd0VuZCx0aGlzLl9yb3dDb3VudC0xKTt0aGlzLl9yb3dTdGFydD12b2lkIDAsdGhpcy5fcm93RW5kPXZvaWQgMCx0aGlzLl9yZW5kZXJDYWxsYmFjayhlLHQpLHRoaXMuX3J1blJlZnJlc2hDYWxsYmFja3MoKX1fcnVuUmVmcmVzaENhbGxiYWNrcygpe2Zvcihjb25zdCBlIG9mIHRoaXMuX3JlZnJlc2hDYWxsYmFja3MpZSgwKTt0aGlzLl9yZWZyZXNoQ2FsbGJhY2tzPVtdfX19LDMyMzY6KGUsdCxpKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVGVybWluYWw9dm9pZCAwO2NvbnN0IHM9aSgzNjE0KSxyPWkoMzY1Niksbj1pKDM1NTEpLG89aSg5MDQyKSxhPWkoMzczMCksaD1pKDE2ODApLGM9aSgzMTA3KSxsPWkoNTc0NCksZD1pKDI5NTApLF89aSgxMjk2KSx1PWkoNDI4KSxmPWkoNDI2OSksdj1pKDUxMTQpLHA9aSg4OTM0KSxnPWkoMzIzMCksbT1pKDkzMTIpLFM9aSg0NzI1KSxDPWkoNjczMSksYj1pKDgwNTUpLHc9aSg4OTY5KSx5PWkoODQ2MCksRT1pKDg0NCksaz1pKDYxMTQpLEw9aSg4NDM3KSxEPWkoMjU4NCksUj1pKDczOTkpLHg9aSg1OTQxKSxBPWkoOTA3NCksQj1pKDI1ODUpLFQ9aSg1NDM1KSxNPWkoNDU2NyksTz1pKDc3OSk7Y2xhc3MgUCBleHRlbmRzIHcuQ29yZVRlcm1pbmFse2dldCBvbkZvY3VzKCl7cmV0dXJuIHRoaXMuX29uRm9jdXMuZXZlbnR9Z2V0IG9uQmx1cigpe3JldHVybiB0aGlzLl9vbkJsdXIuZXZlbnR9Z2V0IG9uQTExeUNoYXIoKXtyZXR1cm4gdGhpcy5fb25BMTF5Q2hhckVtaXR0ZXIuZXZlbnR9Z2V0IG9uQTExeVRhYigpe3JldHVybiB0aGlzLl9vbkExMXlUYWJFbWl0dGVyLmV2ZW50fWdldCBvbldpbGxPcGVuKCl7cmV0dXJuIHRoaXMuX29uV2lsbE9wZW4uZXZlbnR9Y29uc3RydWN0b3IoZT17fSl7c3VwZXIoZSksdGhpcy5icm93c2VyPWssdGhpcy5fa2V5RG93bkhhbmRsZWQ9ITEsdGhpcy5fa2V5RG93blNlZW49ITEsdGhpcy5fa2V5UHJlc3NIYW5kbGVkPSExLHRoaXMuX3VucHJvY2Vzc2VkRGVhZEtleT0hMSx0aGlzLl9hY2Nlc3NpYmlsaXR5TWFuYWdlcj10aGlzLnJlZ2lzdGVyKG5ldyBFLk11dGFibGVEaXNwb3NhYmxlKSx0aGlzLl9vbkN1cnNvck1vdmU9dGhpcy5yZWdpc3RlcihuZXcgeS5FdmVudEVtaXR0ZXIpLHRoaXMub25DdXJzb3JNb3ZlPXRoaXMuX29uQ3Vyc29yTW92ZS5ldmVudCx0aGlzLl9vbktleT10aGlzLnJlZ2lzdGVyKG5ldyB5LkV2ZW50RW1pdHRlciksdGhpcy5vbktleT10aGlzLl9vbktleS5ldmVudCx0aGlzLl9vblJlbmRlcj10aGlzLnJlZ2lzdGVyKG5ldyB5LkV2ZW50RW1pdHRlciksdGhpcy5vblJlbmRlcj10aGlzLl9vblJlbmRlci5ldmVudCx0aGlzLl9vblNlbGVjdGlvbkNoYW5nZT10aGlzLnJlZ2lzdGVyKG5ldyB5LkV2ZW50RW1pdHRlciksdGhpcy5vblNlbGVjdGlvbkNoYW5nZT10aGlzLl9vblNlbGVjdGlvbkNoYW5nZS5ldmVudCx0aGlzLl9vblRpdGxlQ2hhbmdlPXRoaXMucmVnaXN0ZXIobmV3IHkuRXZlbnRFbWl0dGVyKSx0aGlzLm9uVGl0bGVDaGFuZ2U9dGhpcy5fb25UaXRsZUNoYW5nZS5ldmVudCx0aGlzLl9vbkJlbGw9dGhpcy5yZWdpc3RlcihuZXcgeS5FdmVudEVtaXR0ZXIpLHRoaXMub25CZWxsPXRoaXMuX29uQmVsbC5ldmVudCx0aGlzLl9vbkZvY3VzPXRoaXMucmVnaXN0ZXIobmV3IHkuRXZlbnRFbWl0dGVyKSx0aGlzLl9vbkJsdXI9dGhpcy5yZWdpc3RlcihuZXcgeS5FdmVudEVtaXR0ZXIpLHRoaXMuX29uQTExeUNoYXJFbWl0dGVyPXRoaXMucmVnaXN0ZXIobmV3IHkuRXZlbnRFbWl0dGVyKSx0aGlzLl9vbkExMXlUYWJFbWl0dGVyPXRoaXMucmVnaXN0ZXIobmV3IHkuRXZlbnRFbWl0dGVyKSx0aGlzLl9vbldpbGxPcGVuPXRoaXMucmVnaXN0ZXIobmV3IHkuRXZlbnRFbWl0dGVyKSx0aGlzLl9zZXR1cCgpLHRoaXMuX2RlY29yYXRpb25TZXJ2aWNlPXRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKEEuRGVjb3JhdGlvblNlcnZpY2UpLHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLnNldFNlcnZpY2UoQi5JRGVjb3JhdGlvblNlcnZpY2UsdGhpcy5fZGVjb3JhdGlvblNlcnZpY2UpLHRoaXMuX2xpbmtQcm92aWRlclNlcnZpY2U9dGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2UuY3JlYXRlSW5zdGFuY2UoTy5MaW5rUHJvdmlkZXJTZXJ2aWNlKSx0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5zZXRTZXJ2aWNlKFMuSUxpbmtQcm92aWRlclNlcnZpY2UsdGhpcy5fbGlua1Byb3ZpZGVyU2VydmljZSksdGhpcy5fbGlua1Byb3ZpZGVyU2VydmljZS5yZWdpc3RlckxpbmtQcm92aWRlcih0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5jcmVhdGVJbnN0YW5jZShhLk9zY0xpbmtQcm92aWRlcikpLHRoaXMucmVnaXN0ZXIodGhpcy5faW5wdXRIYW5kbGVyLm9uUmVxdWVzdEJlbGwoKCgpPT50aGlzLl9vbkJlbGwuZmlyZSgpKSkpLHRoaXMucmVnaXN0ZXIodGhpcy5faW5wdXRIYW5kbGVyLm9uUmVxdWVzdFJlZnJlc2hSb3dzKCgoZSx0KT0+dGhpcy5yZWZyZXNoKGUsdCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9pbnB1dEhhbmRsZXIub25SZXF1ZXN0U2VuZEZvY3VzKCgoKT0+dGhpcy5fcmVwb3J0Rm9jdXMoKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX2lucHV0SGFuZGxlci5vblJlcXVlc3RSZXNldCgoKCk9PnRoaXMucmVzZXQoKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX2lucHV0SGFuZGxlci5vblJlcXVlc3RXaW5kb3dzT3B0aW9uc1JlcG9ydCgoZT0+dGhpcy5fcmVwb3J0V2luZG93c09wdGlvbnMoZSkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9pbnB1dEhhbmRsZXIub25Db2xvcigoZT0+dGhpcy5faGFuZGxlQ29sb3JFdmVudChlKSkpKSx0aGlzLnJlZ2lzdGVyKCgwLHkuZm9yd2FyZEV2ZW50KSh0aGlzLl9pbnB1dEhhbmRsZXIub25DdXJzb3JNb3ZlLHRoaXMuX29uQ3Vyc29yTW92ZSkpLHRoaXMucmVnaXN0ZXIoKDAseS5mb3J3YXJkRXZlbnQpKHRoaXMuX2lucHV0SGFuZGxlci5vblRpdGxlQ2hhbmdlLHRoaXMuX29uVGl0bGVDaGFuZ2UpKSx0aGlzLnJlZ2lzdGVyKCgwLHkuZm9yd2FyZEV2ZW50KSh0aGlzLl9pbnB1dEhhbmRsZXIub25BMTF5Q2hhcix0aGlzLl9vbkExMXlDaGFyRW1pdHRlcikpLHRoaXMucmVnaXN0ZXIoKDAseS5mb3J3YXJkRXZlbnQpKHRoaXMuX2lucHV0SGFuZGxlci5vbkExMXlUYWIsdGhpcy5fb25BMTF5VGFiRW1pdHRlcikpLHRoaXMucmVnaXN0ZXIodGhpcy5fYnVmZmVyU2VydmljZS5vblJlc2l6ZSgoZT0+dGhpcy5fYWZ0ZXJSZXNpemUoZS5jb2xzLGUucm93cykpKSksdGhpcy5yZWdpc3RlcigoMCxFLnRvRGlzcG9zYWJsZSkoKCgpPT57dGhpcy5fY3VzdG9tS2V5RXZlbnRIYW5kbGVyPXZvaWQgMCx0aGlzLmVsZW1lbnQ/LnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCl9KSkpfV9oYW5kbGVDb2xvckV2ZW50KGUpe2lmKHRoaXMuX3RoZW1lU2VydmljZSlmb3IoY29uc3QgdCBvZiBlKXtsZXQgZSxpPVwiXCI7c3dpdGNoKHQuaW5kZXgpe2Nhc2UgMjU2OmU9XCJmb3JlZ3JvdW5kXCIsaT1cIjEwXCI7YnJlYWs7Y2FzZSAyNTc6ZT1cImJhY2tncm91bmRcIixpPVwiMTFcIjticmVhaztjYXNlIDI1ODplPVwiY3Vyc29yXCIsaT1cIjEyXCI7YnJlYWs7ZGVmYXVsdDplPVwiYW5zaVwiLGk9XCI0O1wiK3QuaW5kZXh9c3dpdGNoKHQudHlwZSl7Y2FzZSAwOmNvbnN0IHM9Yi5jb2xvci50b0NvbG9yUkdCKFwiYW5zaVwiPT09ZT90aGlzLl90aGVtZVNlcnZpY2UuY29sb3JzLmFuc2lbdC5pbmRleF06dGhpcy5fdGhlbWVTZXJ2aWNlLmNvbG9yc1tlXSk7dGhpcy5jb3JlU2VydmljZS50cmlnZ2VyRGF0YUV2ZW50KGAke0QuQzAuRVNDfV0ke2l9OyR7KDAseC50b1JnYlN0cmluZykocyl9JHtELkMxX0VTQ0FQRUQuU1R9YCk7YnJlYWs7Y2FzZSAxOmlmKFwiYW5zaVwiPT09ZSl0aGlzLl90aGVtZVNlcnZpY2UubW9kaWZ5Q29sb3JzKChlPT5lLmFuc2lbdC5pbmRleF09Yi5jaGFubmVscy50b0NvbG9yKC4uLnQuY29sb3IpKSk7ZWxzZXtjb25zdCBpPWU7dGhpcy5fdGhlbWVTZXJ2aWNlLm1vZGlmeUNvbG9ycygoZT0+ZVtpXT1iLmNoYW5uZWxzLnRvQ29sb3IoLi4udC5jb2xvcikpKX1icmVhaztjYXNlIDI6dGhpcy5fdGhlbWVTZXJ2aWNlLnJlc3RvcmVDb2xvcih0LmluZGV4KX19fV9zZXR1cCgpe3N1cGVyLl9zZXR1cCgpLHRoaXMuX2N1c3RvbUtleUV2ZW50SGFuZGxlcj12b2lkIDB9Z2V0IGJ1ZmZlcigpe3JldHVybiB0aGlzLmJ1ZmZlcnMuYWN0aXZlfWZvY3VzKCl7dGhpcy50ZXh0YXJlYSYmdGhpcy50ZXh0YXJlYS5mb2N1cyh7cHJldmVudFNjcm9sbDohMH0pfV9oYW5kbGVTY3JlZW5SZWFkZXJNb2RlT3B0aW9uQ2hhbmdlKGUpe2U/IXRoaXMuX2FjY2Vzc2liaWxpdHlNYW5hZ2VyLnZhbHVlJiZ0aGlzLl9yZW5kZXJTZXJ2aWNlJiYodGhpcy5fYWNjZXNzaWJpbGl0eU1hbmFnZXIudmFsdWU9dGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2UuY3JlYXRlSW5zdGFuY2UoTS5BY2Nlc3NpYmlsaXR5TWFuYWdlcix0aGlzKSk6dGhpcy5fYWNjZXNzaWJpbGl0eU1hbmFnZXIuY2xlYXIoKX1faGFuZGxlVGV4dEFyZWFGb2N1cyhlKXt0aGlzLmNvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5zZW5kRm9jdXMmJnRoaXMuY29yZVNlcnZpY2UudHJpZ2dlckRhdGFFdmVudChELkMwLkVTQytcIltJXCIpLHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZm9jdXNcIiksdGhpcy5fc2hvd0N1cnNvcigpLHRoaXMuX29uRm9jdXMuZmlyZSgpfWJsdXIoKXtyZXR1cm4gdGhpcy50ZXh0YXJlYT8uYmx1cigpfV9oYW5kbGVUZXh0QXJlYUJsdXIoKXt0aGlzLnRleHRhcmVhLnZhbHVlPVwiXCIsdGhpcy5yZWZyZXNoKHRoaXMuYnVmZmVyLnksdGhpcy5idWZmZXIueSksdGhpcy5jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXMuc2VuZEZvY3VzJiZ0aGlzLmNvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQoRC5DMC5FU0MrXCJbT1wiKSx0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImZvY3VzXCIpLHRoaXMuX29uQmx1ci5maXJlKCl9X3N5bmNUZXh0QXJlYSgpe2lmKCF0aGlzLnRleHRhcmVhfHwhdGhpcy5idWZmZXIuaXNDdXJzb3JJblZpZXdwb3J0fHx0aGlzLl9jb21wb3NpdGlvbkhlbHBlci5pc0NvbXBvc2luZ3x8IXRoaXMuX3JlbmRlclNlcnZpY2UpcmV0dXJuO2NvbnN0IGU9dGhpcy5idWZmZXIueWJhc2UrdGhpcy5idWZmZXIueSx0PXRoaXMuYnVmZmVyLmxpbmVzLmdldChlKTtpZighdClyZXR1cm47Y29uc3QgaT1NYXRoLm1pbih0aGlzLmJ1ZmZlci54LHRoaXMuY29scy0xKSxzPXRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC5oZWlnaHQscj10LmdldFdpZHRoKGkpLG49dGhpcy5fcmVuZGVyU2VydmljZS5kaW1lbnNpb25zLmNzcy5jZWxsLndpZHRoKnIsbz10aGlzLmJ1ZmZlci55KnRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC5oZWlnaHQsYT1pKnRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC53aWR0aDt0aGlzLnRleHRhcmVhLnN0eWxlLmxlZnQ9YStcInB4XCIsdGhpcy50ZXh0YXJlYS5zdHlsZS50b3A9bytcInB4XCIsdGhpcy50ZXh0YXJlYS5zdHlsZS53aWR0aD1uK1wicHhcIix0aGlzLnRleHRhcmVhLnN0eWxlLmhlaWdodD1zK1wicHhcIix0aGlzLnRleHRhcmVhLnN0eWxlLmxpbmVIZWlnaHQ9cytcInB4XCIsdGhpcy50ZXh0YXJlYS5zdHlsZS56SW5kZXg9XCItNVwifV9pbml0R2xvYmFsKCl7dGhpcy5fYmluZEtleXMoKSx0aGlzLnJlZ2lzdGVyKCgwLHIuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKSh0aGlzLmVsZW1lbnQsXCJjb3B5XCIsKGU9Pnt0aGlzLmhhc1NlbGVjdGlvbigpJiYoMCxzLmNvcHlIYW5kbGVyKShlLHRoaXMuX3NlbGVjdGlvblNlcnZpY2UpfSkpKTtjb25zdCBlPWU9PigwLHMuaGFuZGxlUGFzdGVFdmVudCkoZSx0aGlzLnRleHRhcmVhLHRoaXMuY29yZVNlcnZpY2UsdGhpcy5vcHRpb25zU2VydmljZSk7dGhpcy5yZWdpc3RlcigoMCxyLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcikodGhpcy50ZXh0YXJlYSxcInBhc3RlXCIsZSkpLHRoaXMucmVnaXN0ZXIoKDAsci5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMuZWxlbWVudCxcInBhc3RlXCIsZSkpLGsuaXNGaXJlZm94P3RoaXMucmVnaXN0ZXIoKDAsci5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMuZWxlbWVudCxcIm1vdXNlZG93blwiLChlPT57Mj09PWUuYnV0dG9uJiYoMCxzLnJpZ2h0Q2xpY2tIYW5kbGVyKShlLHRoaXMudGV4dGFyZWEsdGhpcy5zY3JlZW5FbGVtZW50LHRoaXMuX3NlbGVjdGlvblNlcnZpY2UsdGhpcy5vcHRpb25zLnJpZ2h0Q2xpY2tTZWxlY3RzV29yZCl9KSkpOnRoaXMucmVnaXN0ZXIoKDAsci5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMuZWxlbWVudCxcImNvbnRleHRtZW51XCIsKGU9PnsoMCxzLnJpZ2h0Q2xpY2tIYW5kbGVyKShlLHRoaXMudGV4dGFyZWEsdGhpcy5zY3JlZW5FbGVtZW50LHRoaXMuX3NlbGVjdGlvblNlcnZpY2UsdGhpcy5vcHRpb25zLnJpZ2h0Q2xpY2tTZWxlY3RzV29yZCl9KSkpLGsuaXNMaW51eCYmdGhpcy5yZWdpc3RlcigoMCxyLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcikodGhpcy5lbGVtZW50LFwiYXV4Y2xpY2tcIiwoZT0+ezE9PT1lLmJ1dHRvbiYmKDAscy5tb3ZlVGV4dEFyZWFVbmRlck1vdXNlQ3Vyc29yKShlLHRoaXMudGV4dGFyZWEsdGhpcy5zY3JlZW5FbGVtZW50KX0pKSl9X2JpbmRLZXlzKCl7dGhpcy5yZWdpc3RlcigoMCxyLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcikodGhpcy50ZXh0YXJlYSxcImtleXVwXCIsKGU9PnRoaXMuX2tleVVwKGUpKSwhMCkpLHRoaXMucmVnaXN0ZXIoKDAsci5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMudGV4dGFyZWEsXCJrZXlkb3duXCIsKGU9PnRoaXMuX2tleURvd24oZSkpLCEwKSksdGhpcy5yZWdpc3RlcigoMCxyLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcikodGhpcy50ZXh0YXJlYSxcImtleXByZXNzXCIsKGU9PnRoaXMuX2tleVByZXNzKGUpKSwhMCkpLHRoaXMucmVnaXN0ZXIoKDAsci5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMudGV4dGFyZWEsXCJjb21wb3NpdGlvbnN0YXJ0XCIsKCgpPT50aGlzLl9jb21wb3NpdGlvbkhlbHBlci5jb21wb3NpdGlvbnN0YXJ0KCkpKSksdGhpcy5yZWdpc3RlcigoMCxyLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcikodGhpcy50ZXh0YXJlYSxcImNvbXBvc2l0aW9udXBkYXRlXCIsKGU9PnRoaXMuX2NvbXBvc2l0aW9uSGVscGVyLmNvbXBvc2l0aW9udXBkYXRlKGUpKSkpLHRoaXMucmVnaXN0ZXIoKDAsci5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMudGV4dGFyZWEsXCJjb21wb3NpdGlvbmVuZFwiLCgoKT0+dGhpcy5fY29tcG9zaXRpb25IZWxwZXIuY29tcG9zaXRpb25lbmQoKSkpKSx0aGlzLnJlZ2lzdGVyKCgwLHIuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKSh0aGlzLnRleHRhcmVhLFwiaW5wdXRcIiwoZT0+dGhpcy5faW5wdXRFdmVudChlKSksITApKSx0aGlzLnJlZ2lzdGVyKHRoaXMub25SZW5kZXIoKCgpPT50aGlzLl9jb21wb3NpdGlvbkhlbHBlci51cGRhdGVDb21wb3NpdGlvbkVsZW1lbnRzKCkpKSl9b3BlbihlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJUZXJtaW5hbCByZXF1aXJlcyBhIHBhcmVudCBlbGVtZW50LlwiKTtpZihlLmlzQ29ubmVjdGVkfHx0aGlzLl9sb2dTZXJ2aWNlLmRlYnVnKFwiVGVybWluYWwub3BlbiB3YXMgY2FsbGVkIG9uIGFuIGVsZW1lbnQgdGhhdCB3YXMgbm90IGF0dGFjaGVkIHRvIHRoZSBET01cIiksdGhpcy5lbGVtZW50Py5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3JiZ0aGlzLl9jb3JlQnJvd3NlclNlcnZpY2UpcmV0dXJuIHZvaWQodGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXchPT10aGlzLl9jb3JlQnJvd3NlclNlcnZpY2Uud2luZG93JiYodGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlLndpbmRvdz10aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykpO3RoaXMuX2RvY3VtZW50PWUub3duZXJEb2N1bWVudCx0aGlzLm9wdGlvbnMuZG9jdW1lbnRPdmVycmlkZSYmdGhpcy5vcHRpb25zLmRvY3VtZW50T3ZlcnJpZGUgaW5zdGFuY2VvZiBEb2N1bWVudCYmKHRoaXMuX2RvY3VtZW50PXRoaXMub3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5kb2N1bWVudE92ZXJyaWRlKSx0aGlzLmVsZW1lbnQ9dGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmVsZW1lbnQuZGlyPVwibHRyXCIsdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJ0ZXJtaW5hbFwiKSx0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInh0ZXJtXCIpLGUuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtjb25zdCB0PXRoaXMuX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTt0aGlzLl92aWV3cG9ydEVsZW1lbnQ9dGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl92aWV3cG9ydEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInh0ZXJtLXZpZXdwb3J0XCIpLHQuYXBwZW5kQ2hpbGQodGhpcy5fdmlld3BvcnRFbGVtZW50KSx0aGlzLl92aWV3cG9ydFNjcm9sbEFyZWE9dGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl92aWV3cG9ydFNjcm9sbEFyZWEuY2xhc3NMaXN0LmFkZChcInh0ZXJtLXNjcm9sbC1hcmVhXCIpLHRoaXMuX3ZpZXdwb3J0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl92aWV3cG9ydFNjcm9sbEFyZWEpLHRoaXMuc2NyZWVuRWxlbWVudD10aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuc2NyZWVuRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwieHRlcm0tc2NyZWVuXCIpLHRoaXMucmVnaXN0ZXIoKDAsci5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMuc2NyZWVuRWxlbWVudCxcIm1vdXNlbW92ZVwiLChlPT50aGlzLnVwZGF0ZUN1cnNvclN0eWxlKGUpKSkpLHRoaXMuX2hlbHBlckNvbnRhaW5lcj10aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuX2hlbHBlckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwieHRlcm0taGVscGVyc1wiKSx0aGlzLnNjcmVlbkVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5faGVscGVyQ29udGFpbmVyKSx0LmFwcGVuZENoaWxkKHRoaXMuc2NyZWVuRWxlbWVudCksdGhpcy50ZXh0YXJlYT10aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIiksdGhpcy50ZXh0YXJlYS5jbGFzc0xpc3QuYWRkKFwieHRlcm0taGVscGVyLXRleHRhcmVhXCIpLHRoaXMudGV4dGFyZWEuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLG8ucHJvbXB0TGFiZWwpLGsuaXNDaHJvbWVPU3x8dGhpcy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiLFwiZmFsc2VcIiksdGhpcy50ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLFwib2ZmXCIpLHRoaXMudGV4dGFyZWEuc2V0QXR0cmlidXRlKFwiYXV0b2NhcGl0YWxpemVcIixcIm9mZlwiKSx0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZShcInNwZWxsY2hlY2tcIixcImZhbHNlXCIpLHRoaXMudGV4dGFyZWEudGFiSW5kZXg9MCx0aGlzLl9jb3JlQnJvd3NlclNlcnZpY2U9dGhpcy5yZWdpc3Rlcih0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5jcmVhdGVJbnN0YW5jZSh2LkNvcmVCcm93c2VyU2VydmljZSx0aGlzLnRleHRhcmVhLGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldz8/d2luZG93LHRoaXMuX2RvY3VtZW50Pz9cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdy5kb2N1bWVudDpudWxsKSksdGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2Uuc2V0U2VydmljZShTLklDb3JlQnJvd3NlclNlcnZpY2UsdGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlKSx0aGlzLnJlZ2lzdGVyKCgwLHIuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKSh0aGlzLnRleHRhcmVhLFwiZm9jdXNcIiwoZT0+dGhpcy5faGFuZGxlVGV4dEFyZWFGb2N1cyhlKSkpKSx0aGlzLnJlZ2lzdGVyKCgwLHIuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKSh0aGlzLnRleHRhcmVhLFwiYmx1clwiLCgoKT0+dGhpcy5faGFuZGxlVGV4dEFyZWFCbHVyKCkpKSksdGhpcy5faGVscGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGV4dGFyZWEpLHRoaXMuX2NoYXJTaXplU2VydmljZT10aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5jcmVhdGVJbnN0YW5jZSh1LkNoYXJTaXplU2VydmljZSx0aGlzLl9kb2N1bWVudCx0aGlzLl9oZWxwZXJDb250YWluZXIpLHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLnNldFNlcnZpY2UoUy5JQ2hhclNpemVTZXJ2aWNlLHRoaXMuX2NoYXJTaXplU2VydmljZSksdGhpcy5fdGhlbWVTZXJ2aWNlPXRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKEMuVGhlbWVTZXJ2aWNlKSx0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5zZXRTZXJ2aWNlKFMuSVRoZW1lU2VydmljZSx0aGlzLl90aGVtZVNlcnZpY2UpLHRoaXMuX2NoYXJhY3RlckpvaW5lclNlcnZpY2U9dGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2UuY3JlYXRlSW5zdGFuY2UoZi5DaGFyYWN0ZXJKb2luZXJTZXJ2aWNlKSx0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5zZXRTZXJ2aWNlKFMuSUNoYXJhY3RlckpvaW5lclNlcnZpY2UsdGhpcy5fY2hhcmFjdGVySm9pbmVyU2VydmljZSksdGhpcy5fcmVuZGVyU2VydmljZT10aGlzLnJlZ2lzdGVyKHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKGcuUmVuZGVyU2VydmljZSx0aGlzLnJvd3MsdGhpcy5zY3JlZW5FbGVtZW50KSksdGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2Uuc2V0U2VydmljZShTLklSZW5kZXJTZXJ2aWNlLHRoaXMuX3JlbmRlclNlcnZpY2UpLHRoaXMucmVnaXN0ZXIodGhpcy5fcmVuZGVyU2VydmljZS5vblJlbmRlcmVkVmlld3BvcnRDaGFuZ2UoKGU9PnRoaXMuX29uUmVuZGVyLmZpcmUoZSkpKSksdGhpcy5vblJlc2l6ZSgoZT0+dGhpcy5fcmVuZGVyU2VydmljZS5yZXNpemUoZS5jb2xzLGUucm93cykpKSx0aGlzLl9jb21wb3NpdGlvblZpZXc9dGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl9jb21wb3NpdGlvblZpZXcuY2xhc3NMaXN0LmFkZChcImNvbXBvc2l0aW9uLXZpZXdcIiksdGhpcy5fY29tcG9zaXRpb25IZWxwZXI9dGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2UuY3JlYXRlSW5zdGFuY2UoZC5Db21wb3NpdGlvbkhlbHBlcix0aGlzLnRleHRhcmVhLHRoaXMuX2NvbXBvc2l0aW9uVmlldyksdGhpcy5faGVscGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NvbXBvc2l0aW9uVmlldyksdGhpcy5fbW91c2VTZXJ2aWNlPXRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKHAuTW91c2VTZXJ2aWNlKSx0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5zZXRTZXJ2aWNlKFMuSU1vdXNlU2VydmljZSx0aGlzLl9tb3VzZVNlcnZpY2UpLHRoaXMubGlua2lmaWVyPXRoaXMucmVnaXN0ZXIodGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2UuY3JlYXRlSW5zdGFuY2Uobi5MaW5raWZpZXIsdGhpcy5zY3JlZW5FbGVtZW50KSksdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHQpO3RyeXt0aGlzLl9vbldpbGxPcGVuLmZpcmUodGhpcy5lbGVtZW50KX1jYXRjaHt9dGhpcy5fcmVuZGVyU2VydmljZS5oYXNSZW5kZXJlcigpfHx0aGlzLl9yZW5kZXJTZXJ2aWNlLnNldFJlbmRlcmVyKHRoaXMuX2NyZWF0ZVJlbmRlcmVyKCkpLHRoaXMudmlld3BvcnQ9dGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2UuY3JlYXRlSW5zdGFuY2UoaC5WaWV3cG9ydCx0aGlzLl92aWV3cG9ydEVsZW1lbnQsdGhpcy5fdmlld3BvcnRTY3JvbGxBcmVhKSx0aGlzLnZpZXdwb3J0Lm9uUmVxdWVzdFNjcm9sbExpbmVzKChlPT50aGlzLnNjcm9sbExpbmVzKGUuYW1vdW50LGUuc3VwcHJlc3NTY3JvbGxFdmVudCwxKSkpLHRoaXMucmVnaXN0ZXIodGhpcy5faW5wdXRIYW5kbGVyLm9uUmVxdWVzdFN5bmNTY3JvbGxCYXIoKCgpPT50aGlzLnZpZXdwb3J0LnN5bmNTY3JvbGxBcmVhKCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLnZpZXdwb3J0KSx0aGlzLnJlZ2lzdGVyKHRoaXMub25DdXJzb3JNb3ZlKCgoKT0+e3RoaXMuX3JlbmRlclNlcnZpY2UuaGFuZGxlQ3Vyc29yTW92ZSgpLHRoaXMuX3N5bmNUZXh0QXJlYSgpfSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMub25SZXNpemUoKCgpPT50aGlzLl9yZW5kZXJTZXJ2aWNlLmhhbmRsZVJlc2l6ZSh0aGlzLmNvbHMsdGhpcy5yb3dzKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMub25CbHVyKCgoKT0+dGhpcy5fcmVuZGVyU2VydmljZS5oYW5kbGVCbHVyKCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLm9uRm9jdXMoKCgpPT50aGlzLl9yZW5kZXJTZXJ2aWNlLmhhbmRsZUZvY3VzKCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9yZW5kZXJTZXJ2aWNlLm9uRGltZW5zaW9uc0NoYW5nZSgoKCk9PnRoaXMudmlld3BvcnQuc3luY1Njcm9sbEFyZWEoKSkpKSx0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlPXRoaXMucmVnaXN0ZXIodGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2UuY3JlYXRlSW5zdGFuY2UobS5TZWxlY3Rpb25TZXJ2aWNlLHRoaXMuZWxlbWVudCx0aGlzLnNjcmVlbkVsZW1lbnQsdGhpcy5saW5raWZpZXIpKSx0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5zZXRTZXJ2aWNlKFMuSVNlbGVjdGlvblNlcnZpY2UsdGhpcy5fc2VsZWN0aW9uU2VydmljZSksdGhpcy5yZWdpc3Rlcih0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLm9uUmVxdWVzdFNjcm9sbExpbmVzKChlPT50aGlzLnNjcm9sbExpbmVzKGUuYW1vdW50LGUuc3VwcHJlc3NTY3JvbGxFdmVudCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLm9uU2VsZWN0aW9uQ2hhbmdlKCgoKT0+dGhpcy5fb25TZWxlY3Rpb25DaGFuZ2UuZmlyZSgpKSkpLHRoaXMucmVnaXN0ZXIodGhpcy5fc2VsZWN0aW9uU2VydmljZS5vblJlcXVlc3RSZWRyYXcoKGU9PnRoaXMuX3JlbmRlclNlcnZpY2UuaGFuZGxlU2VsZWN0aW9uQ2hhbmdlZChlLnN0YXJ0LGUuZW5kLGUuY29sdW1uU2VsZWN0TW9kZSkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLm9uTGludXhNb3VzZVNlbGVjdGlvbigoZT0+e3RoaXMudGV4dGFyZWEudmFsdWU9ZSx0aGlzLnRleHRhcmVhLmZvY3VzKCksdGhpcy50ZXh0YXJlYS5zZWxlY3QoKX0pKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9vblNjcm9sbC5ldmVudCgoZT0+e3RoaXMudmlld3BvcnQuc3luY1Njcm9sbEFyZWEoKSx0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnJlZnJlc2goKX0pKSksdGhpcy5yZWdpc3RlcigoMCxyLmFkZERpc3Bvc2FibGVEb21MaXN0ZW5lcikodGhpcy5fdmlld3BvcnRFbGVtZW50LFwic2Nyb2xsXCIsKCgpPT50aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnJlZnJlc2goKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKGMuQnVmZmVyRGVjb3JhdGlvblJlbmRlcmVyLHRoaXMuc2NyZWVuRWxlbWVudCkpLHRoaXMucmVnaXN0ZXIoKDAsci5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHRoaXMuZWxlbWVudCxcIm1vdXNlZG93blwiLChlPT50aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmhhbmRsZU1vdXNlRG93bihlKSkpKSx0aGlzLmNvcmVNb3VzZVNlcnZpY2UuYXJlTW91c2VFdmVudHNBY3RpdmU/KHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZGlzYWJsZSgpLHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZW5hYmxlLW1vdXNlLWV2ZW50c1wiKSk6dGhpcy5fc2VsZWN0aW9uU2VydmljZS5lbmFibGUoKSx0aGlzLm9wdGlvbnMuc2NyZWVuUmVhZGVyTW9kZSYmKHRoaXMuX2FjY2Vzc2liaWxpdHlNYW5hZ2VyLnZhbHVlPXRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKE0uQWNjZXNzaWJpbGl0eU1hbmFnZXIsdGhpcykpLHRoaXMucmVnaXN0ZXIodGhpcy5vcHRpb25zU2VydmljZS5vblNwZWNpZmljT3B0aW9uQ2hhbmdlKFwic2NyZWVuUmVhZGVyTW9kZVwiLChlPT50aGlzLl9oYW5kbGVTY3JlZW5SZWFkZXJNb2RlT3B0aW9uQ2hhbmdlKGUpKSkpLHRoaXMub3B0aW9ucy5vdmVydmlld1J1bGVyV2lkdGgmJih0aGlzLl9vdmVydmlld1J1bGVyUmVuZGVyZXI9dGhpcy5yZWdpc3Rlcih0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5jcmVhdGVJbnN0YW5jZShsLk92ZXJ2aWV3UnVsZXJSZW5kZXJlcix0aGlzLl92aWV3cG9ydEVsZW1lbnQsdGhpcy5zY3JlZW5FbGVtZW50KSkpLHRoaXMub3B0aW9uc1NlcnZpY2Uub25TcGVjaWZpY09wdGlvbkNoYW5nZShcIm92ZXJ2aWV3UnVsZXJXaWR0aFwiLChlPT57IXRoaXMuX292ZXJ2aWV3UnVsZXJSZW5kZXJlciYmZSYmdGhpcy5fdmlld3BvcnRFbGVtZW50JiZ0aGlzLnNjcmVlbkVsZW1lbnQmJih0aGlzLl9vdmVydmlld1J1bGVyUmVuZGVyZXI9dGhpcy5yZWdpc3Rlcih0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5jcmVhdGVJbnN0YW5jZShsLk92ZXJ2aWV3UnVsZXJSZW5kZXJlcix0aGlzLl92aWV3cG9ydEVsZW1lbnQsdGhpcy5zY3JlZW5FbGVtZW50KSkpfSkpLHRoaXMuX2NoYXJTaXplU2VydmljZS5tZWFzdXJlKCksdGhpcy5yZWZyZXNoKDAsdGhpcy5yb3dzLTEpLHRoaXMuX2luaXRHbG9iYWwoKSx0aGlzLmJpbmRNb3VzZSgpfV9jcmVhdGVSZW5kZXJlcigpe3JldHVybiB0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5jcmVhdGVJbnN0YW5jZShfLkRvbVJlbmRlcmVyLHRoaXMsdGhpcy5fZG9jdW1lbnQsdGhpcy5lbGVtZW50LHRoaXMuc2NyZWVuRWxlbWVudCx0aGlzLl92aWV3cG9ydEVsZW1lbnQsdGhpcy5faGVscGVyQ29udGFpbmVyLHRoaXMubGlua2lmaWVyKX1iaW5kTW91c2UoKXtjb25zdCBlPXRoaXMsdD10aGlzLmVsZW1lbnQ7ZnVuY3Rpb24gaSh0KXtjb25zdCBpPWUuX21vdXNlU2VydmljZS5nZXRNb3VzZVJlcG9ydENvb3Jkcyh0LGUuc2NyZWVuRWxlbWVudCk7aWYoIWkpcmV0dXJuITE7bGV0IHMscjtzd2l0Y2godC5vdmVycmlkZVR5cGV8fHQudHlwZSl7Y2FzZVwibW91c2Vtb3ZlXCI6cj0zMix2b2lkIDA9PT10LmJ1dHRvbnM/KHM9Myx2b2lkIDAhPT10LmJ1dHRvbiYmKHM9dC5idXR0b248Mz90LmJ1dHRvbjozKSk6cz0xJnQuYnV0dG9ucz8wOjQmdC5idXR0b25zPzE6MiZ0LmJ1dHRvbnM/MjozO2JyZWFrO2Nhc2VcIm1vdXNldXBcIjpyPTAscz10LmJ1dHRvbjwzP3QuYnV0dG9uOjM7YnJlYWs7Y2FzZVwibW91c2Vkb3duXCI6cj0xLHM9dC5idXR0b248Mz90LmJ1dHRvbjozO2JyZWFrO2Nhc2VcIndoZWVsXCI6aWYoZS5fY3VzdG9tV2hlZWxFdmVudEhhbmRsZXImJiExPT09ZS5fY3VzdG9tV2hlZWxFdmVudEhhbmRsZXIodCkpcmV0dXJuITE7aWYoMD09PWUudmlld3BvcnQuZ2V0TGluZXNTY3JvbGxlZCh0KSlyZXR1cm4hMTtyPXQuZGVsdGFZPDA/MDoxLHM9NDticmVhaztkZWZhdWx0OnJldHVybiExfXJldHVybiEodm9pZCAwPT09cnx8dm9pZCAwPT09c3x8cz40KSYmZS5jb3JlTW91c2VTZXJ2aWNlLnRyaWdnZXJNb3VzZUV2ZW50KHtjb2w6aS5jb2wscm93Omkucm93LHg6aS54LHk6aS55LGJ1dHRvbjpzLGFjdGlvbjpyLGN0cmw6dC5jdHJsS2V5LGFsdDp0LmFsdEtleSxzaGlmdDp0LnNoaWZ0S2V5fSl9Y29uc3Qgcz17bW91c2V1cDpudWxsLHdoZWVsOm51bGwsbW91c2VkcmFnOm51bGwsbW91c2Vtb3ZlOm51bGx9LG49e21vdXNldXA6ZT0+KGkoZSksZS5idXR0b25zfHwodGhpcy5fZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIixzLm1vdXNldXApLHMubW91c2VkcmFnJiZ0aGlzLl9kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIscy5tb3VzZWRyYWcpKSx0aGlzLmNhbmNlbChlKSksd2hlZWw6ZT0+KGkoZSksdGhpcy5jYW5jZWwoZSwhMCkpLG1vdXNlZHJhZzplPT57ZS5idXR0b25zJiZpKGUpfSxtb3VzZW1vdmU6ZT0+e2UuYnV0dG9uc3x8aShlKX19O3RoaXMucmVnaXN0ZXIodGhpcy5jb3JlTW91c2VTZXJ2aWNlLm9uUHJvdG9jb2xDaGFuZ2UoKGU9PntlPyhcImRlYnVnXCI9PT10aGlzLm9wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMubG9nTGV2ZWwmJnRoaXMuX2xvZ1NlcnZpY2UuZGVidWcoXCJCaW5kaW5nIHRvIG1vdXNlIGV2ZW50czpcIix0aGlzLmNvcmVNb3VzZVNlcnZpY2UuZXhwbGFpbkV2ZW50cyhlKSksdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJlbmFibGUtbW91c2UtZXZlbnRzXCIpLHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZGlzYWJsZSgpKToodGhpcy5fbG9nU2VydmljZS5kZWJ1ZyhcIlVuYmluZGluZyBmcm9tIG1vdXNlIGV2ZW50cy5cIiksdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJlbmFibGUtbW91c2UtZXZlbnRzXCIpLHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZW5hYmxlKCkpLDgmZT9zLm1vdXNlbW92ZXx8KHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLG4ubW91c2Vtb3ZlKSxzLm1vdXNlbW92ZT1uLm1vdXNlbW92ZSk6KHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHMubW91c2Vtb3ZlKSxzLm1vdXNlbW92ZT1udWxsKSwxNiZlP3Mud2hlZWx8fCh0LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLG4ud2hlZWwse3Bhc3NpdmU6ITF9KSxzLndoZWVsPW4ud2hlZWwpOih0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLHMud2hlZWwpLHMud2hlZWw9bnVsbCksMiZlP3MubW91c2V1cHx8KHMubW91c2V1cD1uLm1vdXNldXApOih0aGlzLl9kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHMubW91c2V1cCkscy5tb3VzZXVwPW51bGwpLDQmZT9zLm1vdXNlZHJhZ3x8KHMubW91c2VkcmFnPW4ubW91c2VkcmFnKToodGhpcy5fZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLHMubW91c2VkcmFnKSxzLm1vdXNlZHJhZz1udWxsKX0pKSksdGhpcy5jb3JlTW91c2VTZXJ2aWNlLmFjdGl2ZVByb3RvY29sPXRoaXMuY29yZU1vdXNlU2VydmljZS5hY3RpdmVQcm90b2NvbCx0aGlzLnJlZ2lzdGVyKCgwLHIuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKSh0LFwibW91c2Vkb3duXCIsKGU9PntpZihlLnByZXZlbnREZWZhdWx0KCksdGhpcy5mb2N1cygpLHRoaXMuY29yZU1vdXNlU2VydmljZS5hcmVNb3VzZUV2ZW50c0FjdGl2ZSYmIXRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc2hvdWxkRm9yY2VTZWxlY3Rpb24oZSkpcmV0dXJuIGkoZSkscy5tb3VzZXVwJiZ0aGlzLl9kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHMubW91c2V1cCkscy5tb3VzZWRyYWcmJnRoaXMuX2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixzLm1vdXNlZHJhZyksdGhpcy5jYW5jZWwoZSl9KSkpLHRoaXMucmVnaXN0ZXIoKDAsci5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHQsXCJ3aGVlbFwiLChlPT57aWYoIXMud2hlZWwpe2lmKHRoaXMuX2N1c3RvbVdoZWVsRXZlbnRIYW5kbGVyJiYhMT09PXRoaXMuX2N1c3RvbVdoZWVsRXZlbnRIYW5kbGVyKGUpKXJldHVybiExO2lmKCF0aGlzLmJ1ZmZlci5oYXNTY3JvbGxiYWNrKXtjb25zdCB0PXRoaXMudmlld3BvcnQuZ2V0TGluZXNTY3JvbGxlZChlKTtpZigwPT09dClyZXR1cm47Y29uc3QgaT1ELkMwLkVTQysodGhpcy5jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXMuYXBwbGljYXRpb25DdXJzb3JLZXlzP1wiT1wiOlwiW1wiKSsoZS5kZWx0YVk8MD9cIkFcIjpcIkJcIik7bGV0IHM9XCJcIjtmb3IobGV0IGU9MDtlPE1hdGguYWJzKHQpO2UrKylzKz1pO3JldHVybiB0aGlzLmNvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQocywhMCksdGhpcy5jYW5jZWwoZSwhMCl9cmV0dXJuIHRoaXMudmlld3BvcnQuaGFuZGxlV2hlZWwoZSk/dGhpcy5jYW5jZWwoZSk6dm9pZCAwfX0pLHtwYXNzaXZlOiExfSkpLHRoaXMucmVnaXN0ZXIoKDAsci5hZGREaXNwb3NhYmxlRG9tTGlzdGVuZXIpKHQsXCJ0b3VjaHN0YXJ0XCIsKGU9PntpZighdGhpcy5jb3JlTW91c2VTZXJ2aWNlLmFyZU1vdXNlRXZlbnRzQWN0aXZlKXJldHVybiB0aGlzLnZpZXdwb3J0LmhhbmRsZVRvdWNoU3RhcnQoZSksdGhpcy5jYW5jZWwoZSl9KSx7cGFzc2l2ZTohMH0pKSx0aGlzLnJlZ2lzdGVyKCgwLHIuYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKSh0LFwidG91Y2htb3ZlXCIsKGU9PntpZighdGhpcy5jb3JlTW91c2VTZXJ2aWNlLmFyZU1vdXNlRXZlbnRzQWN0aXZlKXJldHVybiB0aGlzLnZpZXdwb3J0LmhhbmRsZVRvdWNoTW92ZShlKT92b2lkIDA6dGhpcy5jYW5jZWwoZSl9KSx7cGFzc2l2ZTohMX0pKX1yZWZyZXNoKGUsdCl7dGhpcy5fcmVuZGVyU2VydmljZT8ucmVmcmVzaFJvd3MoZSx0KX11cGRhdGVDdXJzb3JTdHlsZShlKXt0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlPy5zaG91bGRDb2x1bW5TZWxlY3QoZSk/dGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb2x1bW4tc2VsZWN0XCIpOnRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiY29sdW1uLXNlbGVjdFwiKX1fc2hvd0N1cnNvcigpe3RoaXMuY29yZVNlcnZpY2UuaXNDdXJzb3JJbml0aWFsaXplZHx8KHRoaXMuY29yZVNlcnZpY2UuaXNDdXJzb3JJbml0aWFsaXplZD0hMCx0aGlzLnJlZnJlc2godGhpcy5idWZmZXIueSx0aGlzLmJ1ZmZlci55KSl9c2Nyb2xsTGluZXMoZSx0LGk9MCl7MT09PWk/KHN1cGVyLnNjcm9sbExpbmVzKGUsdCxpKSx0aGlzLnJlZnJlc2goMCx0aGlzLnJvd3MtMSkpOnRoaXMudmlld3BvcnQ/LnNjcm9sbExpbmVzKGUpfXBhc3RlKGUpeygwLHMucGFzdGUpKGUsdGhpcy50ZXh0YXJlYSx0aGlzLmNvcmVTZXJ2aWNlLHRoaXMub3B0aW9uc1NlcnZpY2UpfWF0dGFjaEN1c3RvbUtleUV2ZW50SGFuZGxlcihlKXt0aGlzLl9jdXN0b21LZXlFdmVudEhhbmRsZXI9ZX1hdHRhY2hDdXN0b21XaGVlbEV2ZW50SGFuZGxlcihlKXt0aGlzLl9jdXN0b21XaGVlbEV2ZW50SGFuZGxlcj1lfXJlZ2lzdGVyTGlua1Byb3ZpZGVyKGUpe3JldHVybiB0aGlzLl9saW5rUHJvdmlkZXJTZXJ2aWNlLnJlZ2lzdGVyTGlua1Byb3ZpZGVyKGUpfXJlZ2lzdGVyQ2hhcmFjdGVySm9pbmVyKGUpe2lmKCF0aGlzLl9jaGFyYWN0ZXJKb2luZXJTZXJ2aWNlKXRocm93IG5ldyBFcnJvcihcIlRlcm1pbmFsIG11c3QgYmUgb3BlbmVkIGZpcnN0XCIpO2NvbnN0IHQ9dGhpcy5fY2hhcmFjdGVySm9pbmVyU2VydmljZS5yZWdpc3RlcihlKTtyZXR1cm4gdGhpcy5yZWZyZXNoKDAsdGhpcy5yb3dzLTEpLHR9ZGVyZWdpc3RlckNoYXJhY3RlckpvaW5lcihlKXtpZighdGhpcy5fY2hhcmFjdGVySm9pbmVyU2VydmljZSl0aHJvdyBuZXcgRXJyb3IoXCJUZXJtaW5hbCBtdXN0IGJlIG9wZW5lZCBmaXJzdFwiKTt0aGlzLl9jaGFyYWN0ZXJKb2luZXJTZXJ2aWNlLmRlcmVnaXN0ZXIoZSkmJnRoaXMucmVmcmVzaCgwLHRoaXMucm93cy0xKX1nZXQgbWFya2Vycygpe3JldHVybiB0aGlzLmJ1ZmZlci5tYXJrZXJzfXJlZ2lzdGVyTWFya2VyKGUpe3JldHVybiB0aGlzLmJ1ZmZlci5hZGRNYXJrZXIodGhpcy5idWZmZXIueWJhc2UrdGhpcy5idWZmZXIueStlKX1yZWdpc3RlckRlY29yYXRpb24oZSl7cmV0dXJuIHRoaXMuX2RlY29yYXRpb25TZXJ2aWNlLnJlZ2lzdGVyRGVjb3JhdGlvbihlKX1oYXNTZWxlY3Rpb24oKXtyZXR1cm4hIXRoaXMuX3NlbGVjdGlvblNlcnZpY2UmJnRoaXMuX3NlbGVjdGlvblNlcnZpY2UuaGFzU2VsZWN0aW9ufXNlbGVjdChlLHQsaSl7dGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZXRTZWxlY3Rpb24oZSx0LGkpfWdldFNlbGVjdGlvbigpe3JldHVybiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlP3RoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uVGV4dDpcIlwifWdldFNlbGVjdGlvblBvc2l0aW9uKCl7aWYodGhpcy5fc2VsZWN0aW9uU2VydmljZSYmdGhpcy5fc2VsZWN0aW9uU2VydmljZS5oYXNTZWxlY3Rpb24pcmV0dXJue3N0YXJ0Ont4OnRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uU3RhcnRbMF0seTp0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvblN0YXJ0WzFdfSxlbmQ6e3g6dGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb25FbmRbMF0seTp0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbkVuZFsxXX19fWNsZWFyU2VsZWN0aW9uKCl7dGhpcy5fc2VsZWN0aW9uU2VydmljZT8uY2xlYXJTZWxlY3Rpb24oKX1zZWxlY3RBbGwoKXt0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlPy5zZWxlY3RBbGwoKX1zZWxlY3RMaW5lcyhlLHQpe3RoaXMuX3NlbGVjdGlvblNlcnZpY2U/LnNlbGVjdExpbmVzKGUsdCl9X2tleURvd24oZSl7aWYodGhpcy5fa2V5RG93bkhhbmRsZWQ9ITEsdGhpcy5fa2V5RG93blNlZW49ITAsdGhpcy5fY3VzdG9tS2V5RXZlbnRIYW5kbGVyJiYhMT09PXRoaXMuX2N1c3RvbUtleUV2ZW50SGFuZGxlcihlKSlyZXR1cm4hMTtjb25zdCB0PXRoaXMuYnJvd3Nlci5pc01hYyYmdGhpcy5vcHRpb25zLm1hY09wdGlvbklzTWV0YSYmZS5hbHRLZXk7aWYoIXQmJiF0aGlzLl9jb21wb3NpdGlvbkhlbHBlci5rZXlkb3duKGUpKXJldHVybiB0aGlzLm9wdGlvbnMuc2Nyb2xsT25Vc2VySW5wdXQmJnRoaXMuYnVmZmVyLnliYXNlIT09dGhpcy5idWZmZXIueWRpc3AmJnRoaXMuc2Nyb2xsVG9Cb3R0b20oKSwhMTt0fHxcIkRlYWRcIiE9PWUua2V5JiZcIkFsdEdyYXBoXCIhPT1lLmtleXx8KHRoaXMuX3VucHJvY2Vzc2VkRGVhZEtleT0hMCk7Y29uc3QgaT0oMCxSLmV2YWx1YXRlS2V5Ym9hcmRFdmVudCkoZSx0aGlzLmNvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5hcHBsaWNhdGlvbkN1cnNvcktleXMsdGhpcy5icm93c2VyLmlzTWFjLHRoaXMub3B0aW9ucy5tYWNPcHRpb25Jc01ldGEpO2lmKHRoaXMudXBkYXRlQ3Vyc29yU3R5bGUoZSksMz09PWkudHlwZXx8Mj09PWkudHlwZSl7Y29uc3QgdD10aGlzLnJvd3MtMTtyZXR1cm4gdGhpcy5zY3JvbGxMaW5lcygyPT09aS50eXBlPy10OnQpLHRoaXMuY2FuY2VsKGUsITApfXJldHVybiAxPT09aS50eXBlJiZ0aGlzLnNlbGVjdEFsbCgpLCEhdGhpcy5faXNUaGlyZExldmVsU2hpZnQodGhpcy5icm93c2VyLGUpfHwoaS5jYW5jZWwmJnRoaXMuY2FuY2VsKGUsITApLCFpLmtleXx8ISEoZS5rZXkmJiFlLmN0cmxLZXkmJiFlLmFsdEtleSYmIWUubWV0YUtleSYmMT09PWUua2V5Lmxlbmd0aCYmZS5rZXkuY2hhckNvZGVBdCgwKT49NjUmJmUua2V5LmNoYXJDb2RlQXQoMCk8PTkwKXx8KHRoaXMuX3VucHJvY2Vzc2VkRGVhZEtleT8odGhpcy5fdW5wcm9jZXNzZWREZWFkS2V5PSExLCEwKTooaS5rZXkhPT1ELkMwLkVUWCYmaS5rZXkhPT1ELkMwLkNSfHwodGhpcy50ZXh0YXJlYS52YWx1ZT1cIlwiKSx0aGlzLl9vbktleS5maXJlKHtrZXk6aS5rZXksZG9tRXZlbnQ6ZX0pLHRoaXMuX3Nob3dDdXJzb3IoKSx0aGlzLmNvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQoaS5rZXksITApLCF0aGlzLm9wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuc2NyZWVuUmVhZGVyTW9kZXx8ZS5hbHRLZXl8fGUuY3RybEtleT90aGlzLmNhbmNlbChlLCEwKTp2b2lkKHRoaXMuX2tleURvd25IYW5kbGVkPSEwKSkpKX1faXNUaGlyZExldmVsU2hpZnQoZSx0KXtjb25zdCBpPWUuaXNNYWMmJiF0aGlzLm9wdGlvbnMubWFjT3B0aW9uSXNNZXRhJiZ0LmFsdEtleSYmIXQuY3RybEtleSYmIXQubWV0YUtleXx8ZS5pc1dpbmRvd3MmJnQuYWx0S2V5JiZ0LmN0cmxLZXkmJiF0Lm1ldGFLZXl8fGUuaXNXaW5kb3dzJiZ0LmdldE1vZGlmaWVyU3RhdGUoXCJBbHRHcmFwaFwiKTtyZXR1cm5cImtleXByZXNzXCI9PT10LnR5cGU/aTppJiYoIXQua2V5Q29kZXx8dC5rZXlDb2RlPjQ3KX1fa2V5VXAoZSl7dGhpcy5fa2V5RG93blNlZW49ITEsdGhpcy5fY3VzdG9tS2V5RXZlbnRIYW5kbGVyJiYhMT09PXRoaXMuX2N1c3RvbUtleUV2ZW50SGFuZGxlcihlKXx8KGZ1bmN0aW9uKGUpe3JldHVybiAxNj09PWUua2V5Q29kZXx8MTc9PT1lLmtleUNvZGV8fDE4PT09ZS5rZXlDb2RlfShlKXx8dGhpcy5mb2N1cygpLHRoaXMudXBkYXRlQ3Vyc29yU3R5bGUoZSksdGhpcy5fa2V5UHJlc3NIYW5kbGVkPSExKX1fa2V5UHJlc3MoZSl7bGV0IHQ7aWYodGhpcy5fa2V5UHJlc3NIYW5kbGVkPSExLHRoaXMuX2tleURvd25IYW5kbGVkKXJldHVybiExO2lmKHRoaXMuX2N1c3RvbUtleUV2ZW50SGFuZGxlciYmITE9PT10aGlzLl9jdXN0b21LZXlFdmVudEhhbmRsZXIoZSkpcmV0dXJuITE7aWYodGhpcy5jYW5jZWwoZSksZS5jaGFyQ29kZSl0PWUuY2hhckNvZGU7ZWxzZSBpZihudWxsPT09ZS53aGljaHx8dm9pZCAwPT09ZS53aGljaCl0PWUua2V5Q29kZTtlbHNle2lmKDA9PT1lLndoaWNofHwwPT09ZS5jaGFyQ29kZSlyZXR1cm4hMTt0PWUud2hpY2h9cmV0dXJuISghdHx8KGUuYWx0S2V5fHxlLmN0cmxLZXl8fGUubWV0YUtleSkmJiF0aGlzLl9pc1RoaXJkTGV2ZWxTaGlmdCh0aGlzLmJyb3dzZXIsZSl8fCh0PVN0cmluZy5mcm9tQ2hhckNvZGUodCksdGhpcy5fb25LZXkuZmlyZSh7a2V5OnQsZG9tRXZlbnQ6ZX0pLHRoaXMuX3Nob3dDdXJzb3IoKSx0aGlzLmNvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQodCwhMCksdGhpcy5fa2V5UHJlc3NIYW5kbGVkPSEwLHRoaXMuX3VucHJvY2Vzc2VkRGVhZEtleT0hMSwwKSl9X2lucHV0RXZlbnQoZSl7aWYoZS5kYXRhJiZcImluc2VydFRleHRcIj09PWUuaW5wdXRUeXBlJiYoIWUuY29tcG9zZWR8fCF0aGlzLl9rZXlEb3duU2VlbikmJiF0aGlzLm9wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuc2NyZWVuUmVhZGVyTW9kZSl7aWYodGhpcy5fa2V5UHJlc3NIYW5kbGVkKXJldHVybiExO3RoaXMuX3VucHJvY2Vzc2VkRGVhZEtleT0hMTtjb25zdCB0PWUuZGF0YTtyZXR1cm4gdGhpcy5jb3JlU2VydmljZS50cmlnZ2VyRGF0YUV2ZW50KHQsITApLHRoaXMuY2FuY2VsKGUpLCEwfXJldHVybiExfXJlc2l6ZShlLHQpe2UhPT10aGlzLmNvbHN8fHQhPT10aGlzLnJvd3M/c3VwZXIucmVzaXplKGUsdCk6dGhpcy5fY2hhclNpemVTZXJ2aWNlJiYhdGhpcy5fY2hhclNpemVTZXJ2aWNlLmhhc1ZhbGlkU2l6ZSYmdGhpcy5fY2hhclNpemVTZXJ2aWNlLm1lYXN1cmUoKX1fYWZ0ZXJSZXNpemUoZSx0KXt0aGlzLl9jaGFyU2l6ZVNlcnZpY2U/Lm1lYXN1cmUoKSx0aGlzLnZpZXdwb3J0Py5zeW5jU2Nyb2xsQXJlYSghMCl9Y2xlYXIoKXtpZigwIT09dGhpcy5idWZmZXIueWJhc2V8fDAhPT10aGlzLmJ1ZmZlci55KXt0aGlzLmJ1ZmZlci5jbGVhckFsbE1hcmtlcnMoKSx0aGlzLmJ1ZmZlci5saW5lcy5zZXQoMCx0aGlzLmJ1ZmZlci5saW5lcy5nZXQodGhpcy5idWZmZXIueWJhc2UrdGhpcy5idWZmZXIueSkpLHRoaXMuYnVmZmVyLmxpbmVzLmxlbmd0aD0xLHRoaXMuYnVmZmVyLnlkaXNwPTAsdGhpcy5idWZmZXIueWJhc2U9MCx0aGlzLmJ1ZmZlci55PTA7Zm9yKGxldCBlPTE7ZTx0aGlzLnJvd3M7ZSsrKXRoaXMuYnVmZmVyLmxpbmVzLnB1c2godGhpcy5idWZmZXIuZ2V0QmxhbmtMaW5lKEwuREVGQVVMVF9BVFRSX0RBVEEpKTt0aGlzLl9vblNjcm9sbC5maXJlKHtwb3NpdGlvbjp0aGlzLmJ1ZmZlci55ZGlzcCxzb3VyY2U6MH0pLHRoaXMudmlld3BvcnQ/LnJlc2V0KCksdGhpcy5yZWZyZXNoKDAsdGhpcy5yb3dzLTEpfX1yZXNldCgpe3RoaXMub3B0aW9ucy5yb3dzPXRoaXMucm93cyx0aGlzLm9wdGlvbnMuY29scz10aGlzLmNvbHM7Y29uc3QgZT10aGlzLl9jdXN0b21LZXlFdmVudEhhbmRsZXI7dGhpcy5fc2V0dXAoKSxzdXBlci5yZXNldCgpLHRoaXMuX3NlbGVjdGlvblNlcnZpY2U/LnJlc2V0KCksdGhpcy5fZGVjb3JhdGlvblNlcnZpY2UucmVzZXQoKSx0aGlzLnZpZXdwb3J0Py5yZXNldCgpLHRoaXMuX2N1c3RvbUtleUV2ZW50SGFuZGxlcj1lLHRoaXMucmVmcmVzaCgwLHRoaXMucm93cy0xKX1jbGVhclRleHR1cmVBdGxhcygpe3RoaXMuX3JlbmRlclNlcnZpY2U/LmNsZWFyVGV4dHVyZUF0bGFzKCl9X3JlcG9ydEZvY3VzKCl7dGhpcy5lbGVtZW50Py5jbGFzc0xpc3QuY29udGFpbnMoXCJmb2N1c1wiKT90aGlzLmNvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQoRC5DMC5FU0MrXCJbSVwiKTp0aGlzLmNvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQoRC5DMC5FU0MrXCJbT1wiKX1fcmVwb3J0V2luZG93c09wdGlvbnMoZSl7aWYodGhpcy5fcmVuZGVyU2VydmljZSlzd2l0Y2goZSl7Y2FzZSBULldpbmRvd3NPcHRpb25zUmVwb3J0VHlwZS5HRVRfV0lOX1NJWkVfUElYRUxTOmNvbnN0IGU9dGhpcy5fcmVuZGVyU2VydmljZS5kaW1lbnNpb25zLmNzcy5jYW52YXMud2lkdGgudG9GaXhlZCgwKSx0PXRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2FudmFzLmhlaWdodC50b0ZpeGVkKDApO3RoaXMuY29yZVNlcnZpY2UudHJpZ2dlckRhdGFFdmVudChgJHtELkMwLkVTQ31bNDske3R9OyR7ZX10YCk7YnJlYWs7Y2FzZSBULldpbmRvd3NPcHRpb25zUmVwb3J0VHlwZS5HRVRfQ0VMTF9TSVpFX1BJWEVMUzpjb25zdCBpPXRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC53aWR0aC50b0ZpeGVkKDApLHM9dGhpcy5fcmVuZGVyU2VydmljZS5kaW1lbnNpb25zLmNzcy5jZWxsLmhlaWdodC50b0ZpeGVkKDApO3RoaXMuY29yZVNlcnZpY2UudHJpZ2dlckRhdGFFdmVudChgJHtELkMwLkVTQ31bNjske3N9OyR7aX10YCl9fWNhbmNlbChlLHQpe2lmKHRoaXMub3B0aW9ucy5jYW5jZWxFdmVudHN8fHQpcmV0dXJuIGUucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLCExfX10LlRlcm1pbmFsPVB9LDk5MjQ6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlRpbWVCYXNlZERlYm91bmNlcj12b2lkIDAsdC5UaW1lQmFzZWREZWJvdW5jZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0PTFlMyl7dGhpcy5fcmVuZGVyQ2FsbGJhY2s9ZSx0aGlzLl9kZWJvdW5jZVRocmVzaG9sZE1TPXQsdGhpcy5fbGFzdFJlZnJlc2hNcz0wLHRoaXMuX2FkZGl0aW9uYWxSZWZyZXNoUmVxdWVzdGVkPSExfWRpc3Bvc2UoKXt0aGlzLl9yZWZyZXNoVGltZW91dElEJiZjbGVhclRpbWVvdXQodGhpcy5fcmVmcmVzaFRpbWVvdXRJRCl9cmVmcmVzaChlLHQsaSl7dGhpcy5fcm93Q291bnQ9aSxlPXZvaWQgMCE9PWU/ZTowLHQ9dm9pZCAwIT09dD90OnRoaXMuX3Jvd0NvdW50LTEsdGhpcy5fcm93U3RhcnQ9dm9pZCAwIT09dGhpcy5fcm93U3RhcnQ/TWF0aC5taW4odGhpcy5fcm93U3RhcnQsZSk6ZSx0aGlzLl9yb3dFbmQ9dm9pZCAwIT09dGhpcy5fcm93RW5kP01hdGgubWF4KHRoaXMuX3Jvd0VuZCx0KTp0O2NvbnN0IHM9RGF0ZS5ub3coKTtpZihzLXRoaXMuX2xhc3RSZWZyZXNoTXM+PXRoaXMuX2RlYm91bmNlVGhyZXNob2xkTVMpdGhpcy5fbGFzdFJlZnJlc2hNcz1zLHRoaXMuX2lubmVyUmVmcmVzaCgpO2Vsc2UgaWYoIXRoaXMuX2FkZGl0aW9uYWxSZWZyZXNoUmVxdWVzdGVkKXtjb25zdCBlPXMtdGhpcy5fbGFzdFJlZnJlc2hNcyx0PXRoaXMuX2RlYm91bmNlVGhyZXNob2xkTVMtZTt0aGlzLl9hZGRpdGlvbmFsUmVmcmVzaFJlcXVlc3RlZD0hMCx0aGlzLl9yZWZyZXNoVGltZW91dElEPXdpbmRvdy5zZXRUaW1lb3V0KCgoKT0+e3RoaXMuX2xhc3RSZWZyZXNoTXM9RGF0ZS5ub3coKSx0aGlzLl9pbm5lclJlZnJlc2goKSx0aGlzLl9hZGRpdGlvbmFsUmVmcmVzaFJlcXVlc3RlZD0hMSx0aGlzLl9yZWZyZXNoVGltZW91dElEPXZvaWQgMH0pLHQpfX1faW5uZXJSZWZyZXNoKCl7aWYodm9pZCAwPT09dGhpcy5fcm93U3RhcnR8fHZvaWQgMD09PXRoaXMuX3Jvd0VuZHx8dm9pZCAwPT09dGhpcy5fcm93Q291bnQpcmV0dXJuO2NvbnN0IGU9TWF0aC5tYXgodGhpcy5fcm93U3RhcnQsMCksdD1NYXRoLm1pbih0aGlzLl9yb3dFbmQsdGhpcy5fcm93Q291bnQtMSk7dGhpcy5fcm93U3RhcnQ9dm9pZCAwLHRoaXMuX3Jvd0VuZD12b2lkIDAsdGhpcy5fcmVuZGVyQ2FsbGJhY2soZSx0KX19fSwxNjgwOmZ1bmN0aW9uKGUsdCxpKXt2YXIgcz10aGlzJiZ0aGlzLl9fZGVjb3JhdGV8fGZ1bmN0aW9uKGUsdCxpLHMpe3ZhciByLG49YXJndW1lbnRzLmxlbmd0aCxvPW48Mz90Om51bGw9PT1zP3M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGkpOnM7aWYoXCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3QmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUpbz1SZWZsZWN0LmRlY29yYXRlKGUsdCxpLHMpO2Vsc2UgZm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MDthLS0pKHI9ZVthXSkmJihvPShuPDM/cihvKTpuPjM/cih0LGksbyk6cih0LGkpKXx8byk7cmV0dXJuIG4+MyYmbyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSxvKSxvfSxyPXRoaXMmJnRoaXMuX19wYXJhbXx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oaSxzKXt0KGkscyxlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVmlld3BvcnQ9dm9pZCAwO2NvbnN0IG49aSgzNjU2KSxvPWkoNDcyNSksYT1pKDg0NjApLGg9aSg4NDQpLGM9aSgyNTg1KTtsZXQgbD10LlZpZXdwb3J0PWNsYXNzIGV4dGVuZHMgaC5EaXNwb3NhYmxle2NvbnN0cnVjdG9yKGUsdCxpLHMscixvLGgsYyl7c3VwZXIoKSx0aGlzLl92aWV3cG9ydEVsZW1lbnQ9ZSx0aGlzLl9zY3JvbGxBcmVhPXQsdGhpcy5fYnVmZmVyU2VydmljZT1pLHRoaXMuX29wdGlvbnNTZXJ2aWNlPXMsdGhpcy5fY2hhclNpemVTZXJ2aWNlPXIsdGhpcy5fcmVuZGVyU2VydmljZT1vLHRoaXMuX2NvcmVCcm93c2VyU2VydmljZT1oLHRoaXMuc2Nyb2xsQmFyV2lkdGg9MCx0aGlzLl9jdXJyZW50Um93SGVpZ2h0PTAsdGhpcy5fY3VycmVudERldmljZUNlbGxIZWlnaHQ9MCx0aGlzLl9sYXN0UmVjb3JkZWRCdWZmZXJMZW5ndGg9MCx0aGlzLl9sYXN0UmVjb3JkZWRWaWV3cG9ydEhlaWdodD0wLHRoaXMuX2xhc3RSZWNvcmRlZEJ1ZmZlckhlaWdodD0wLHRoaXMuX2xhc3RUb3VjaFk9MCx0aGlzLl9sYXN0U2Nyb2xsVG9wPTAsdGhpcy5fd2hlZWxQYXJ0aWFsU2Nyb2xsPTAsdGhpcy5fcmVmcmVzaEFuaW1hdGlvbkZyYW1lPW51bGwsdGhpcy5faWdub3JlTmV4dFNjcm9sbEV2ZW50PSExLHRoaXMuX3Ntb290aFNjcm9sbFN0YXRlPXtzdGFydFRpbWU6MCxvcmlnaW46LTEsdGFyZ2V0Oi0xfSx0aGlzLl9vblJlcXVlc3RTY3JvbGxMaW5lcz10aGlzLnJlZ2lzdGVyKG5ldyBhLkV2ZW50RW1pdHRlciksdGhpcy5vblJlcXVlc3RTY3JvbGxMaW5lcz10aGlzLl9vblJlcXVlc3RTY3JvbGxMaW5lcy5ldmVudCx0aGlzLnNjcm9sbEJhcldpZHRoPXRoaXMuX3ZpZXdwb3J0RWxlbWVudC5vZmZzZXRXaWR0aC10aGlzLl9zY3JvbGxBcmVhLm9mZnNldFdpZHRofHwxNSx0aGlzLnJlZ2lzdGVyKCgwLG4uYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKSh0aGlzLl92aWV3cG9ydEVsZW1lbnQsXCJzY3JvbGxcIix0aGlzLl9oYW5kbGVTY3JvbGwuYmluZCh0aGlzKSkpLHRoaXMuX2FjdGl2ZUJ1ZmZlcj10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlcix0aGlzLnJlZ2lzdGVyKHRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVycy5vbkJ1ZmZlckFjdGl2YXRlKChlPT50aGlzLl9hY3RpdmVCdWZmZXI9ZS5hY3RpdmVCdWZmZXIpKSksdGhpcy5fcmVuZGVyRGltZW5zaW9ucz10aGlzLl9yZW5kZXJTZXJ2aWNlLmRpbWVuc2lvbnMsdGhpcy5yZWdpc3Rlcih0aGlzLl9yZW5kZXJTZXJ2aWNlLm9uRGltZW5zaW9uc0NoYW5nZSgoZT0+dGhpcy5fcmVuZGVyRGltZW5zaW9ucz1lKSkpLHRoaXMuX2hhbmRsZVRoZW1lQ2hhbmdlKGMuY29sb3JzKSx0aGlzLnJlZ2lzdGVyKGMub25DaGFuZ2VDb2xvcnMoKGU9PnRoaXMuX2hhbmRsZVRoZW1lQ2hhbmdlKGUpKSkpLHRoaXMucmVnaXN0ZXIodGhpcy5fb3B0aW9uc1NlcnZpY2Uub25TcGVjaWZpY09wdGlvbkNoYW5nZShcInNjcm9sbGJhY2tcIiwoKCk9PnRoaXMuc3luY1Njcm9sbEFyZWEoKSkpKSxzZXRUaW1lb3V0KCgoKT0+dGhpcy5zeW5jU2Nyb2xsQXJlYSgpKSl9X2hhbmRsZVRoZW1lQ2hhbmdlKGUpe3RoaXMuX3ZpZXdwb3J0RWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9ZS5iYWNrZ3JvdW5kLmNzc31yZXNldCgpe3RoaXMuX2N1cnJlbnRSb3dIZWlnaHQ9MCx0aGlzLl9jdXJyZW50RGV2aWNlQ2VsbEhlaWdodD0wLHRoaXMuX2xhc3RSZWNvcmRlZEJ1ZmZlckxlbmd0aD0wLHRoaXMuX2xhc3RSZWNvcmRlZFZpZXdwb3J0SGVpZ2h0PTAsdGhpcy5fbGFzdFJlY29yZGVkQnVmZmVySGVpZ2h0PTAsdGhpcy5fbGFzdFRvdWNoWT0wLHRoaXMuX2xhc3RTY3JvbGxUb3A9MCx0aGlzLl9jb3JlQnJvd3NlclNlcnZpY2Uud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCk9PnRoaXMuc3luY1Njcm9sbEFyZWEoKSkpfV9yZWZyZXNoKGUpe2lmKGUpcmV0dXJuIHRoaXMuX2lubmVyUmVmcmVzaCgpLHZvaWQobnVsbCE9PXRoaXMuX3JlZnJlc2hBbmltYXRpb25GcmFtZSYmdGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlLndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZWZyZXNoQW5pbWF0aW9uRnJhbWUpKTtudWxsPT09dGhpcy5fcmVmcmVzaEFuaW1hdGlvbkZyYW1lJiYodGhpcy5fcmVmcmVzaEFuaW1hdGlvbkZyYW1lPXRoaXMuX2NvcmVCcm93c2VyU2VydmljZS53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgoKT0+dGhpcy5faW5uZXJSZWZyZXNoKCkpKSl9X2lubmVyUmVmcmVzaCgpe2lmKHRoaXMuX2NoYXJTaXplU2VydmljZS5oZWlnaHQ+MCl7dGhpcy5fY3VycmVudFJvd0hlaWdodD10aGlzLl9yZW5kZXJEaW1lbnNpb25zLmRldmljZS5jZWxsLmhlaWdodC90aGlzLl9jb3JlQnJvd3NlclNlcnZpY2UuZHByLHRoaXMuX2N1cnJlbnREZXZpY2VDZWxsSGVpZ2h0PXRoaXMuX3JlbmRlckRpbWVuc2lvbnMuZGV2aWNlLmNlbGwuaGVpZ2h0LHRoaXMuX2xhc3RSZWNvcmRlZFZpZXdwb3J0SGVpZ2h0PXRoaXMuX3ZpZXdwb3J0RWxlbWVudC5vZmZzZXRIZWlnaHQ7Y29uc3QgZT1NYXRoLnJvdW5kKHRoaXMuX2N1cnJlbnRSb3dIZWlnaHQqdGhpcy5fbGFzdFJlY29yZGVkQnVmZmVyTGVuZ3RoKSsodGhpcy5fbGFzdFJlY29yZGVkVmlld3BvcnRIZWlnaHQtdGhpcy5fcmVuZGVyRGltZW5zaW9ucy5jc3MuY2FudmFzLmhlaWdodCk7dGhpcy5fbGFzdFJlY29yZGVkQnVmZmVySGVpZ2h0IT09ZSYmKHRoaXMuX2xhc3RSZWNvcmRlZEJ1ZmZlckhlaWdodD1lLHRoaXMuX3Njcm9sbEFyZWEuc3R5bGUuaGVpZ2h0PXRoaXMuX2xhc3RSZWNvcmRlZEJ1ZmZlckhlaWdodCtcInB4XCIpfWNvbnN0IGU9dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIueWRpc3AqdGhpcy5fY3VycmVudFJvd0hlaWdodDt0aGlzLl92aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wIT09ZSYmKHRoaXMuX2lnbm9yZU5leHRTY3JvbGxFdmVudD0hMCx0aGlzLl92aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wPWUpLHRoaXMuX3JlZnJlc2hBbmltYXRpb25GcmFtZT1udWxsfXN5bmNTY3JvbGxBcmVhKGU9ITEpe2lmKHRoaXMuX2xhc3RSZWNvcmRlZEJ1ZmZlckxlbmd0aCE9PXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLmxpbmVzLmxlbmd0aClyZXR1cm4gdGhpcy5fbGFzdFJlY29yZGVkQnVmZmVyTGVuZ3RoPXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLmxpbmVzLmxlbmd0aCx2b2lkIHRoaXMuX3JlZnJlc2goZSk7dGhpcy5fbGFzdFJlY29yZGVkVmlld3BvcnRIZWlnaHQ9PT10aGlzLl9yZW5kZXJTZXJ2aWNlLmRpbWVuc2lvbnMuY3NzLmNhbnZhcy5oZWlnaHQmJnRoaXMuX2xhc3RTY3JvbGxUb3A9PT10aGlzLl9hY3RpdmVCdWZmZXIueWRpc3AqdGhpcy5fY3VycmVudFJvd0hlaWdodCYmdGhpcy5fcmVuZGVyRGltZW5zaW9ucy5kZXZpY2UuY2VsbC5oZWlnaHQ9PT10aGlzLl9jdXJyZW50RGV2aWNlQ2VsbEhlaWdodHx8dGhpcy5fcmVmcmVzaChlKX1faGFuZGxlU2Nyb2xsKGUpe2lmKHRoaXMuX2xhc3RTY3JvbGxUb3A9dGhpcy5fdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcCwhdGhpcy5fdmlld3BvcnRFbGVtZW50Lm9mZnNldFBhcmVudClyZXR1cm47aWYodGhpcy5faWdub3JlTmV4dFNjcm9sbEV2ZW50KXJldHVybiB0aGlzLl9pZ25vcmVOZXh0U2Nyb2xsRXZlbnQ9ITEsdm9pZCB0aGlzLl9vblJlcXVlc3RTY3JvbGxMaW5lcy5maXJlKHthbW91bnQ6MCxzdXBwcmVzc1Njcm9sbEV2ZW50OiEwfSk7Y29uc3QgdD1NYXRoLnJvdW5kKHRoaXMuX2xhc3RTY3JvbGxUb3AvdGhpcy5fY3VycmVudFJvd0hlaWdodCktdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIueWRpc3A7dGhpcy5fb25SZXF1ZXN0U2Nyb2xsTGluZXMuZmlyZSh7YW1vdW50OnQsc3VwcHJlc3NTY3JvbGxFdmVudDohMH0pfV9zbW9vdGhTY3JvbGwoKXtpZih0aGlzLl9pc0Rpc3Bvc2VkfHwtMT09PXRoaXMuX3Ntb290aFNjcm9sbFN0YXRlLm9yaWdpbnx8LTE9PT10aGlzLl9zbW9vdGhTY3JvbGxTdGF0ZS50YXJnZXQpcmV0dXJuO2NvbnN0IGU9dGhpcy5fc21vb3RoU2Nyb2xsUGVyY2VudCgpO3RoaXMuX3ZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3A9dGhpcy5fc21vb3RoU2Nyb2xsU3RhdGUub3JpZ2luK01hdGgucm91bmQoZSoodGhpcy5fc21vb3RoU2Nyb2xsU3RhdGUudGFyZ2V0LXRoaXMuX3Ntb290aFNjcm9sbFN0YXRlLm9yaWdpbikpLGU8MT90aGlzLl9jb3JlQnJvd3NlclNlcnZpY2Uud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCk9PnRoaXMuX3Ntb290aFNjcm9sbCgpKSk6dGhpcy5fY2xlYXJTbW9vdGhTY3JvbGxTdGF0ZSgpfV9zbW9vdGhTY3JvbGxQZXJjZW50KCl7cmV0dXJuIHRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuc21vb3RoU2Nyb2xsRHVyYXRpb24mJnRoaXMuX3Ntb290aFNjcm9sbFN0YXRlLnN0YXJ0VGltZT9NYXRoLm1heChNYXRoLm1pbigoRGF0ZS5ub3coKS10aGlzLl9zbW9vdGhTY3JvbGxTdGF0ZS5zdGFydFRpbWUpL3RoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuc21vb3RoU2Nyb2xsRHVyYXRpb24sMSksMCk6MX1fY2xlYXJTbW9vdGhTY3JvbGxTdGF0ZSgpe3RoaXMuX3Ntb290aFNjcm9sbFN0YXRlLnN0YXJ0VGltZT0wLHRoaXMuX3Ntb290aFNjcm9sbFN0YXRlLm9yaWdpbj0tMSx0aGlzLl9zbW9vdGhTY3JvbGxTdGF0ZS50YXJnZXQ9LTF9X2J1YmJsZVNjcm9sbChlLHQpe2NvbnN0IGk9dGhpcy5fdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcCt0aGlzLl9sYXN0UmVjb3JkZWRWaWV3cG9ydEhlaWdodDtyZXR1cm4hKHQ8MCYmMCE9PXRoaXMuX3ZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3B8fHQ+MCYmaTx0aGlzLl9sYXN0UmVjb3JkZWRCdWZmZXJIZWlnaHQpfHwoZS5jYW5jZWxhYmxlJiZlLnByZXZlbnREZWZhdWx0KCksITEpfWhhbmRsZVdoZWVsKGUpe2NvbnN0IHQ9dGhpcy5fZ2V0UGl4ZWxzU2Nyb2xsZWQoZSk7cmV0dXJuIDAhPT10JiYodGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5zbW9vdGhTY3JvbGxEdXJhdGlvbj8odGhpcy5fc21vb3RoU2Nyb2xsU3RhdGUuc3RhcnRUaW1lPURhdGUubm93KCksdGhpcy5fc21vb3RoU2Nyb2xsUGVyY2VudCgpPDE/KHRoaXMuX3Ntb290aFNjcm9sbFN0YXRlLm9yaWdpbj10aGlzLl92aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wLC0xPT09dGhpcy5fc21vb3RoU2Nyb2xsU3RhdGUudGFyZ2V0P3RoaXMuX3Ntb290aFNjcm9sbFN0YXRlLnRhcmdldD10aGlzLl92aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wK3Q6dGhpcy5fc21vb3RoU2Nyb2xsU3RhdGUudGFyZ2V0Kz10LHRoaXMuX3Ntb290aFNjcm9sbFN0YXRlLnRhcmdldD1NYXRoLm1heChNYXRoLm1pbih0aGlzLl9zbW9vdGhTY3JvbGxTdGF0ZS50YXJnZXQsdGhpcy5fdmlld3BvcnRFbGVtZW50LnNjcm9sbEhlaWdodCksMCksdGhpcy5fc21vb3RoU2Nyb2xsKCkpOnRoaXMuX2NsZWFyU21vb3RoU2Nyb2xsU3RhdGUoKSk6dGhpcy5fdmlld3BvcnRFbGVtZW50LnNjcm9sbFRvcCs9dCx0aGlzLl9idWJibGVTY3JvbGwoZSx0KSl9c2Nyb2xsTGluZXMoZSl7aWYoMCE9PWUpaWYodGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5zbW9vdGhTY3JvbGxEdXJhdGlvbil7Y29uc3QgdD1lKnRoaXMuX2N1cnJlbnRSb3dIZWlnaHQ7dGhpcy5fc21vb3RoU2Nyb2xsU3RhdGUuc3RhcnRUaW1lPURhdGUubm93KCksdGhpcy5fc21vb3RoU2Nyb2xsUGVyY2VudCgpPDE/KHRoaXMuX3Ntb290aFNjcm9sbFN0YXRlLm9yaWdpbj10aGlzLl92aWV3cG9ydEVsZW1lbnQuc2Nyb2xsVG9wLHRoaXMuX3Ntb290aFNjcm9sbFN0YXRlLnRhcmdldD10aGlzLl9zbW9vdGhTY3JvbGxTdGF0ZS5vcmlnaW4rdCx0aGlzLl9zbW9vdGhTY3JvbGxTdGF0ZS50YXJnZXQ9TWF0aC5tYXgoTWF0aC5taW4odGhpcy5fc21vb3RoU2Nyb2xsU3RhdGUudGFyZ2V0LHRoaXMuX3ZpZXdwb3J0RWxlbWVudC5zY3JvbGxIZWlnaHQpLDApLHRoaXMuX3Ntb290aFNjcm9sbCgpKTp0aGlzLl9jbGVhclNtb290aFNjcm9sbFN0YXRlKCl9ZWxzZSB0aGlzLl9vblJlcXVlc3RTY3JvbGxMaW5lcy5maXJlKHthbW91bnQ6ZSxzdXBwcmVzc1Njcm9sbEV2ZW50OiExfSl9X2dldFBpeGVsc1Njcm9sbGVkKGUpe2lmKDA9PT1lLmRlbHRhWXx8ZS5zaGlmdEtleSlyZXR1cm4gMDtsZXQgdD10aGlzLl9hcHBseVNjcm9sbE1vZGlmaWVyKGUuZGVsdGFZLGUpO3JldHVybiBlLmRlbHRhTW9kZT09PVdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkU/dCo9dGhpcy5fY3VycmVudFJvd0hlaWdodDplLmRlbHRhTW9kZT09PVdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0UmJih0Kj10aGlzLl9jdXJyZW50Um93SGVpZ2h0KnRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cyksdH1nZXRCdWZmZXJFbGVtZW50cyhlLHQpe2xldCBpLHM9XCJcIjtjb25zdCByPVtdLG49dD8/dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIubGluZXMubGVuZ3RoLG89dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIubGluZXM7Zm9yKGxldCB0PWU7dDxuO3QrKyl7Y29uc3QgZT1vLmdldCh0KTtpZighZSljb250aW51ZTtjb25zdCBuPW8uZ2V0KHQrMSk/LmlzV3JhcHBlZDtpZihzKz1lLnRyYW5zbGF0ZVRvU3RyaW5nKCFuKSwhbnx8dD09PW8ubGVuZ3RoLTEpe2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtlLnRleHRDb250ZW50PXMsci5wdXNoKGUpLHMubGVuZ3RoPjAmJihpPWUpLHM9XCJcIn19cmV0dXJue2J1ZmZlckVsZW1lbnRzOnIsY3Vyc29yRWxlbWVudDppfX1nZXRMaW5lc1Njcm9sbGVkKGUpe2lmKDA9PT1lLmRlbHRhWXx8ZS5zaGlmdEtleSlyZXR1cm4gMDtsZXQgdD10aGlzLl9hcHBseVNjcm9sbE1vZGlmaWVyKGUuZGVsdGFZLGUpO3JldHVybiBlLmRlbHRhTW9kZT09PVdoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMPyh0Lz10aGlzLl9jdXJyZW50Um93SGVpZ2h0KzAsdGhpcy5fd2hlZWxQYXJ0aWFsU2Nyb2xsKz10LHQ9TWF0aC5mbG9vcihNYXRoLmFicyh0aGlzLl93aGVlbFBhcnRpYWxTY3JvbGwpKSoodGhpcy5fd2hlZWxQYXJ0aWFsU2Nyb2xsPjA/MTotMSksdGhpcy5fd2hlZWxQYXJ0aWFsU2Nyb2xsJT0xKTplLmRlbHRhTW9kZT09PVdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0UmJih0Kj10aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3MpLHR9X2FwcGx5U2Nyb2xsTW9kaWZpZXIoZSx0KXtjb25zdCBpPXRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuZmFzdFNjcm9sbE1vZGlmaWVyO3JldHVyblwiYWx0XCI9PT1pJiZ0LmFsdEtleXx8XCJjdHJsXCI9PT1pJiZ0LmN0cmxLZXl8fFwic2hpZnRcIj09PWkmJnQuc2hpZnRLZXk/ZSp0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmZhc3RTY3JvbGxTZW5zaXRpdml0eSp0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLnNjcm9sbFNlbnNpdGl2aXR5OmUqdGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5zY3JvbGxTZW5zaXRpdml0eX1oYW5kbGVUb3VjaFN0YXJ0KGUpe3RoaXMuX2xhc3RUb3VjaFk9ZS50b3VjaGVzWzBdLnBhZ2VZfWhhbmRsZVRvdWNoTW92ZShlKXtjb25zdCB0PXRoaXMuX2xhc3RUb3VjaFktZS50b3VjaGVzWzBdLnBhZ2VZO3JldHVybiB0aGlzLl9sYXN0VG91Y2hZPWUudG91Y2hlc1swXS5wYWdlWSwwIT09dCYmKHRoaXMuX3ZpZXdwb3J0RWxlbWVudC5zY3JvbGxUb3ArPXQsdGhpcy5fYnViYmxlU2Nyb2xsKGUsdCkpfX07dC5WaWV3cG9ydD1sPXMoW3IoMixjLklCdWZmZXJTZXJ2aWNlKSxyKDMsYy5JT3B0aW9uc1NlcnZpY2UpLHIoNCxvLklDaGFyU2l6ZVNlcnZpY2UpLHIoNSxvLklSZW5kZXJTZXJ2aWNlKSxyKDYsby5JQ29yZUJyb3dzZXJTZXJ2aWNlKSxyKDcsby5JVGhlbWVTZXJ2aWNlKV0sbCl9LDMxMDc6ZnVuY3Rpb24oZSx0LGkpe3ZhciBzPXRoaXMmJnRoaXMuX19kZWNvcmF0ZXx8ZnVuY3Rpb24oZSx0LGkscyl7dmFyIHIsbj1hcmd1bWVudHMubGVuZ3RoLG89bjwzP3Q6bnVsbD09PXM/cz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsaSk6cztpZihcIm9iamVjdFwiPT10eXBlb2YgUmVmbGVjdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSlvPVJlZmxlY3QuZGVjb3JhdGUoZSx0LGkscyk7ZWxzZSBmb3IodmFyIGE9ZS5sZW5ndGgtMTthPj0wO2EtLSkocj1lW2FdKSYmKG89KG48Mz9yKG8pOm4+Mz9yKHQsaSxvKTpyKHQsaSkpfHxvKTtyZXR1cm4gbj4zJiZvJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLG8pLG99LHI9dGhpcyYmdGhpcy5fX3BhcmFtfHxmdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihpLHMpe3QoaSxzLGUpfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5CdWZmZXJEZWNvcmF0aW9uUmVuZGVyZXI9dm9pZCAwO2NvbnN0IG49aSg0NzI1KSxvPWkoODQ0KSxhPWkoMjU4NSk7bGV0IGg9dC5CdWZmZXJEZWNvcmF0aW9uUmVuZGVyZXI9Y2xhc3MgZXh0ZW5kcyBvLkRpc3Bvc2FibGV7Y29uc3RydWN0b3IoZSx0LGkscyxyKXtzdXBlcigpLHRoaXMuX3NjcmVlbkVsZW1lbnQ9ZSx0aGlzLl9idWZmZXJTZXJ2aWNlPXQsdGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlPWksdGhpcy5fZGVjb3JhdGlvblNlcnZpY2U9cyx0aGlzLl9yZW5kZXJTZXJ2aWNlPXIsdGhpcy5fZGVjb3JhdGlvbkVsZW1lbnRzPW5ldyBNYXAsdGhpcy5fYWx0QnVmZmVySXNBY3RpdmU9ITEsdGhpcy5fZGltZW5zaW9uc0NoYW5nZWQ9ITEsdGhpcy5fY29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ4dGVybS1kZWNvcmF0aW9uLWNvbnRhaW5lclwiKSx0aGlzLl9zY3JlZW5FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lciksdGhpcy5yZWdpc3Rlcih0aGlzLl9yZW5kZXJTZXJ2aWNlLm9uUmVuZGVyZWRWaWV3cG9ydENoYW5nZSgoKCk9PnRoaXMuX2RvUmVmcmVzaERlY29yYXRpb25zKCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9yZW5kZXJTZXJ2aWNlLm9uRGltZW5zaW9uc0NoYW5nZSgoKCk9Pnt0aGlzLl9kaW1lbnNpb25zQ2hhbmdlZD0hMCx0aGlzLl9xdWV1ZVJlZnJlc2goKX0pKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9jb3JlQnJvd3NlclNlcnZpY2Uub25EcHJDaGFuZ2UoKCgpPT50aGlzLl9xdWV1ZVJlZnJlc2goKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVycy5vbkJ1ZmZlckFjdGl2YXRlKCgoKT0+e3RoaXMuX2FsdEJ1ZmZlcklzQWN0aXZlPXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyPT09dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXJzLmFsdH0pKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9kZWNvcmF0aW9uU2VydmljZS5vbkRlY29yYXRpb25SZWdpc3RlcmVkKCgoKT0+dGhpcy5fcXVldWVSZWZyZXNoKCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9kZWNvcmF0aW9uU2VydmljZS5vbkRlY29yYXRpb25SZW1vdmVkKChlPT50aGlzLl9yZW1vdmVEZWNvcmF0aW9uKGUpKSkpLHRoaXMucmVnaXN0ZXIoKDAsby50b0Rpc3Bvc2FibGUpKCgoKT0+e3RoaXMuX2NvbnRhaW5lci5yZW1vdmUoKSx0aGlzLl9kZWNvcmF0aW9uRWxlbWVudHMuY2xlYXIoKX0pKSl9X3F1ZXVlUmVmcmVzaCgpe3ZvaWQgMD09PXRoaXMuX2FuaW1hdGlvbkZyYW1lJiYodGhpcy5fYW5pbWF0aW9uRnJhbWU9dGhpcy5fcmVuZGVyU2VydmljZS5hZGRSZWZyZXNoQ2FsbGJhY2soKCgpPT57dGhpcy5fZG9SZWZyZXNoRGVjb3JhdGlvbnMoKSx0aGlzLl9hbmltYXRpb25GcmFtZT12b2lkIDB9KSkpfV9kb1JlZnJlc2hEZWNvcmF0aW9ucygpe2Zvcihjb25zdCBlIG9mIHRoaXMuX2RlY29yYXRpb25TZXJ2aWNlLmRlY29yYXRpb25zKXRoaXMuX3JlbmRlckRlY29yYXRpb24oZSk7dGhpcy5fZGltZW5zaW9uc0NoYW5nZWQ9ITF9X3JlbmRlckRlY29yYXRpb24oZSl7dGhpcy5fcmVmcmVzaFN0eWxlKGUpLHRoaXMuX2RpbWVuc2lvbnNDaGFuZ2VkJiZ0aGlzLl9yZWZyZXNoWFBvc2l0aW9uKGUpfV9jcmVhdGVFbGVtZW50KGUpe2NvbnN0IHQ9dGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlLm1haW5Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3QuY2xhc3NMaXN0LmFkZChcInh0ZXJtLWRlY29yYXRpb25cIiksdC5jbGFzc0xpc3QudG9nZ2xlKFwieHRlcm0tZGVjb3JhdGlvbi10b3AtbGF5ZXJcIixcInRvcFwiPT09ZT8ub3B0aW9ucz8ubGF5ZXIpLHQuc3R5bGUud2lkdGg9YCR7TWF0aC5yb3VuZCgoZS5vcHRpb25zLndpZHRofHwxKSp0aGlzLl9yZW5kZXJTZXJ2aWNlLmRpbWVuc2lvbnMuY3NzLmNlbGwud2lkdGgpfXB4YCx0LnN0eWxlLmhlaWdodD0oZS5vcHRpb25zLmhlaWdodHx8MSkqdGhpcy5fcmVuZGVyU2VydmljZS5kaW1lbnNpb25zLmNzcy5jZWxsLmhlaWdodCtcInB4XCIsdC5zdHlsZS50b3A9KGUubWFya2VyLmxpbmUtdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXJzLmFjdGl2ZS55ZGlzcCkqdGhpcy5fcmVuZGVyU2VydmljZS5kaW1lbnNpb25zLmNzcy5jZWxsLmhlaWdodCtcInB4XCIsdC5zdHlsZS5saW5lSGVpZ2h0PWAke3RoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC5oZWlnaHR9cHhgO2NvbnN0IGk9ZS5vcHRpb25zLng/PzA7cmV0dXJuIGkmJmk+dGhpcy5fYnVmZmVyU2VydmljZS5jb2xzJiYodC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKSx0aGlzLl9yZWZyZXNoWFBvc2l0aW9uKGUsdCksdH1fcmVmcmVzaFN0eWxlKGUpe2NvbnN0IHQ9ZS5tYXJrZXIubGluZS10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlcnMuYWN0aXZlLnlkaXNwO2lmKHQ8MHx8dD49dGhpcy5fYnVmZmVyU2VydmljZS5yb3dzKWUuZWxlbWVudCYmKGUuZWxlbWVudC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLGUub25SZW5kZXJFbWl0dGVyLmZpcmUoZS5lbGVtZW50KSk7ZWxzZXtsZXQgaT10aGlzLl9kZWNvcmF0aW9uRWxlbWVudHMuZ2V0KGUpO2l8fChpPXRoaXMuX2NyZWF0ZUVsZW1lbnQoZSksZS5lbGVtZW50PWksdGhpcy5fZGVjb3JhdGlvbkVsZW1lbnRzLnNldChlLGkpLHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChpKSxlLm9uRGlzcG9zZSgoKCk9Pnt0aGlzLl9kZWNvcmF0aW9uRWxlbWVudHMuZGVsZXRlKGUpLGkucmVtb3ZlKCl9KSkpLGkuc3R5bGUudG9wPXQqdGhpcy5fcmVuZGVyU2VydmljZS5kaW1lbnNpb25zLmNzcy5jZWxsLmhlaWdodCtcInB4XCIsaS5zdHlsZS5kaXNwbGF5PXRoaXMuX2FsdEJ1ZmZlcklzQWN0aXZlP1wibm9uZVwiOlwiYmxvY2tcIixlLm9uUmVuZGVyRW1pdHRlci5maXJlKGkpfX1fcmVmcmVzaFhQb3NpdGlvbihlLHQ9ZS5lbGVtZW50KXtpZighdClyZXR1cm47Y29uc3QgaT1lLm9wdGlvbnMueD8/MDtcInJpZ2h0XCI9PT0oZS5vcHRpb25zLmFuY2hvcnx8XCJsZWZ0XCIpP3Quc3R5bGUucmlnaHQ9aT9pKnRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC53aWR0aCtcInB4XCI6XCJcIjp0LnN0eWxlLmxlZnQ9aT9pKnRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC53aWR0aCtcInB4XCI6XCJcIn1fcmVtb3ZlRGVjb3JhdGlvbihlKXt0aGlzLl9kZWNvcmF0aW9uRWxlbWVudHMuZ2V0KGUpPy5yZW1vdmUoKSx0aGlzLl9kZWNvcmF0aW9uRWxlbWVudHMuZGVsZXRlKGUpLGUuZGlzcG9zZSgpfX07dC5CdWZmZXJEZWNvcmF0aW9uUmVuZGVyZXI9aD1zKFtyKDEsYS5JQnVmZmVyU2VydmljZSkscigyLG4uSUNvcmVCcm93c2VyU2VydmljZSkscigzLGEuSURlY29yYXRpb25TZXJ2aWNlKSxyKDQsbi5JUmVuZGVyU2VydmljZSldLGgpfSw1ODcxOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Db2xvclpvbmVTdG9yZT12b2lkIDAsdC5Db2xvclpvbmVTdG9yZT1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuX3pvbmVzPVtdLHRoaXMuX3pvbmVQb29sPVtdLHRoaXMuX3pvbmVQb29sSW5kZXg9MCx0aGlzLl9saW5lUGFkZGluZz17ZnVsbDowLGxlZnQ6MCxjZW50ZXI6MCxyaWdodDowfX1nZXQgem9uZXMoKXtyZXR1cm4gdGhpcy5fem9uZVBvb2wubGVuZ3RoPU1hdGgubWluKHRoaXMuX3pvbmVQb29sLmxlbmd0aCx0aGlzLl96b25lcy5sZW5ndGgpLHRoaXMuX3pvbmVzfWNsZWFyKCl7dGhpcy5fem9uZXMubGVuZ3RoPTAsdGhpcy5fem9uZVBvb2xJbmRleD0wfWFkZERlY29yYXRpb24oZSl7aWYoZS5vcHRpb25zLm92ZXJ2aWV3UnVsZXJPcHRpb25zKXtmb3IoY29uc3QgdCBvZiB0aGlzLl96b25lcylpZih0LmNvbG9yPT09ZS5vcHRpb25zLm92ZXJ2aWV3UnVsZXJPcHRpb25zLmNvbG9yJiZ0LnBvc2l0aW9uPT09ZS5vcHRpb25zLm92ZXJ2aWV3UnVsZXJPcHRpb25zLnBvc2l0aW9uKXtpZih0aGlzLl9saW5lSW50ZXJzZWN0c1pvbmUodCxlLm1hcmtlci5saW5lKSlyZXR1cm47aWYodGhpcy5fbGluZUFkamFjZW50VG9ab25lKHQsZS5tYXJrZXIubGluZSxlLm9wdGlvbnMub3ZlcnZpZXdSdWxlck9wdGlvbnMucG9zaXRpb24pKXJldHVybiB2b2lkIHRoaXMuX2FkZExpbmVUb1pvbmUodCxlLm1hcmtlci5saW5lKX1pZih0aGlzLl96b25lUG9vbEluZGV4PHRoaXMuX3pvbmVQb29sLmxlbmd0aClyZXR1cm4gdGhpcy5fem9uZVBvb2xbdGhpcy5fem9uZVBvb2xJbmRleF0uY29sb3I9ZS5vcHRpb25zLm92ZXJ2aWV3UnVsZXJPcHRpb25zLmNvbG9yLHRoaXMuX3pvbmVQb29sW3RoaXMuX3pvbmVQb29sSW5kZXhdLnBvc2l0aW9uPWUub3B0aW9ucy5vdmVydmlld1J1bGVyT3B0aW9ucy5wb3NpdGlvbix0aGlzLl96b25lUG9vbFt0aGlzLl96b25lUG9vbEluZGV4XS5zdGFydEJ1ZmZlckxpbmU9ZS5tYXJrZXIubGluZSx0aGlzLl96b25lUG9vbFt0aGlzLl96b25lUG9vbEluZGV4XS5lbmRCdWZmZXJMaW5lPWUubWFya2VyLmxpbmUsdm9pZCB0aGlzLl96b25lcy5wdXNoKHRoaXMuX3pvbmVQb29sW3RoaXMuX3pvbmVQb29sSW5kZXgrK10pO3RoaXMuX3pvbmVzLnB1c2goe2NvbG9yOmUub3B0aW9ucy5vdmVydmlld1J1bGVyT3B0aW9ucy5jb2xvcixwb3NpdGlvbjplLm9wdGlvbnMub3ZlcnZpZXdSdWxlck9wdGlvbnMucG9zaXRpb24sc3RhcnRCdWZmZXJMaW5lOmUubWFya2VyLmxpbmUsZW5kQnVmZmVyTGluZTplLm1hcmtlci5saW5lfSksdGhpcy5fem9uZVBvb2wucHVzaCh0aGlzLl96b25lc1t0aGlzLl96b25lcy5sZW5ndGgtMV0pLHRoaXMuX3pvbmVQb29sSW5kZXgrK319c2V0UGFkZGluZyhlKXt0aGlzLl9saW5lUGFkZGluZz1lfV9saW5lSW50ZXJzZWN0c1pvbmUoZSx0KXtyZXR1cm4gdD49ZS5zdGFydEJ1ZmZlckxpbmUmJnQ8PWUuZW5kQnVmZmVyTGluZX1fbGluZUFkamFjZW50VG9ab25lKGUsdCxpKXtyZXR1cm4gdD49ZS5zdGFydEJ1ZmZlckxpbmUtdGhpcy5fbGluZVBhZGRpbmdbaXx8XCJmdWxsXCJdJiZ0PD1lLmVuZEJ1ZmZlckxpbmUrdGhpcy5fbGluZVBhZGRpbmdbaXx8XCJmdWxsXCJdfV9hZGRMaW5lVG9ab25lKGUsdCl7ZS5zdGFydEJ1ZmZlckxpbmU9TWF0aC5taW4oZS5zdGFydEJ1ZmZlckxpbmUsdCksZS5lbmRCdWZmZXJMaW5lPU1hdGgubWF4KGUuZW5kQnVmZmVyTGluZSx0KX19fSw1NzQ0OmZ1bmN0aW9uKGUsdCxpKXt2YXIgcz10aGlzJiZ0aGlzLl9fZGVjb3JhdGV8fGZ1bmN0aW9uKGUsdCxpLHMpe3ZhciByLG49YXJndW1lbnRzLmxlbmd0aCxvPW48Mz90Om51bGw9PT1zP3M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGkpOnM7aWYoXCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3QmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUpbz1SZWZsZWN0LmRlY29yYXRlKGUsdCxpLHMpO2Vsc2UgZm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MDthLS0pKHI9ZVthXSkmJihvPShuPDM/cihvKTpuPjM/cih0LGksbyk6cih0LGkpKXx8byk7cmV0dXJuIG4+MyYmbyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSxvKSxvfSxyPXRoaXMmJnRoaXMuX19wYXJhbXx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oaSxzKXt0KGkscyxlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuT3ZlcnZpZXdSdWxlclJlbmRlcmVyPXZvaWQgMDtjb25zdCBuPWkoNTg3MSksbz1pKDQ3MjUpLGE9aSg4NDQpLGg9aSgyNTg1KSxjPXtmdWxsOjAsbGVmdDowLGNlbnRlcjowLHJpZ2h0OjB9LGw9e2Z1bGw6MCxsZWZ0OjAsY2VudGVyOjAscmlnaHQ6MH0sZD17ZnVsbDowLGxlZnQ6MCxjZW50ZXI6MCxyaWdodDowfTtsZXQgXz10Lk92ZXJ2aWV3UnVsZXJSZW5kZXJlcj1jbGFzcyBleHRlbmRzIGEuRGlzcG9zYWJsZXtnZXQgX3dpZHRoKCl7cmV0dXJuIHRoaXMuX29wdGlvbnNTZXJ2aWNlLm9wdGlvbnMub3ZlcnZpZXdSdWxlcldpZHRofHwwfWNvbnN0cnVjdG9yKGUsdCxpLHMscixvLGgpe3N1cGVyKCksdGhpcy5fdmlld3BvcnRFbGVtZW50PWUsdGhpcy5fc2NyZWVuRWxlbWVudD10LHRoaXMuX2J1ZmZlclNlcnZpY2U9aSx0aGlzLl9kZWNvcmF0aW9uU2VydmljZT1zLHRoaXMuX3JlbmRlclNlcnZpY2U9cix0aGlzLl9vcHRpb25zU2VydmljZT1vLHRoaXMuX2NvcmVCcm93c2VyU2VydmljZT1oLHRoaXMuX2NvbG9yWm9uZVN0b3JlPW5ldyBuLkNvbG9yWm9uZVN0b3JlLHRoaXMuX3Nob3VsZFVwZGF0ZURpbWVuc2lvbnM9ITAsdGhpcy5fc2hvdWxkVXBkYXRlQW5jaG9yPSEwLHRoaXMuX2xhc3RLbm93bkJ1ZmZlckxlbmd0aD0wLHRoaXMuX2NhbnZhcz10aGlzLl9jb3JlQnJvd3NlclNlcnZpY2UubWFpbkRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksdGhpcy5fY2FudmFzLmNsYXNzTGlzdC5hZGQoXCJ4dGVybS1kZWNvcmF0aW9uLW92ZXJ2aWV3LXJ1bGVyXCIpLHRoaXMuX3JlZnJlc2hDYW52YXNEaW1lbnNpb25zKCksdGhpcy5fdmlld3BvcnRFbGVtZW50LnBhcmVudEVsZW1lbnQ/Lmluc2VydEJlZm9yZSh0aGlzLl9jYW52YXMsdGhpcy5fdmlld3BvcnRFbGVtZW50KTtjb25zdCBjPXRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7aWYoIWMpdGhyb3cgbmV3IEVycm9yKFwiQ3R4IGNhbm5vdCBiZSBudWxsXCIpO3RoaXMuX2N0eD1jLHRoaXMuX3JlZ2lzdGVyRGVjb3JhdGlvbkxpc3RlbmVycygpLHRoaXMuX3JlZ2lzdGVyQnVmZmVyQ2hhbmdlTGlzdGVuZXJzKCksdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb25DaGFuZ2VMaXN0ZW5lcnMoKSx0aGlzLnJlZ2lzdGVyKCgwLGEudG9EaXNwb3NhYmxlKSgoKCk9Pnt0aGlzLl9jYW52YXM/LnJlbW92ZSgpfSkpKX1fcmVnaXN0ZXJEZWNvcmF0aW9uTGlzdGVuZXJzKCl7dGhpcy5yZWdpc3Rlcih0aGlzLl9kZWNvcmF0aW9uU2VydmljZS5vbkRlY29yYXRpb25SZWdpc3RlcmVkKCgoKT0+dGhpcy5fcXVldWVSZWZyZXNoKHZvaWQgMCwhMCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9kZWNvcmF0aW9uU2VydmljZS5vbkRlY29yYXRpb25SZW1vdmVkKCgoKT0+dGhpcy5fcXVldWVSZWZyZXNoKHZvaWQgMCwhMCkpKSl9X3JlZ2lzdGVyQnVmZmVyQ2hhbmdlTGlzdGVuZXJzKCl7dGhpcy5yZWdpc3Rlcih0aGlzLl9yZW5kZXJTZXJ2aWNlLm9uUmVuZGVyZWRWaWV3cG9ydENoYW5nZSgoKCk9PnRoaXMuX3F1ZXVlUmVmcmVzaCgpKSkpLHRoaXMucmVnaXN0ZXIodGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXJzLm9uQnVmZmVyQWN0aXZhdGUoKCgpPT57dGhpcy5fY2FudmFzLnN0eWxlLmRpc3BsYXk9dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXI9PT10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlcnMuYWx0P1wibm9uZVwiOlwiYmxvY2tcIn0pKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9idWZmZXJTZXJ2aWNlLm9uU2Nyb2xsKCgoKT0+e3RoaXMuX2xhc3RLbm93bkJ1ZmZlckxlbmd0aCE9PXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVycy5ub3JtYWwubGluZXMubGVuZ3RoJiYodGhpcy5fcmVmcmVzaERyYXdIZWlnaHRDb25zdGFudHMoKSx0aGlzLl9yZWZyZXNoQ29sb3Jab25lUGFkZGluZygpKX0pKSl9X3JlZ2lzdGVyRGltZW5zaW9uQ2hhbmdlTGlzdGVuZXJzKCl7dGhpcy5yZWdpc3Rlcih0aGlzLl9yZW5kZXJTZXJ2aWNlLm9uUmVuZGVyKCgoKT0+e3RoaXMuX2NvbnRhaW5lckhlaWdodCYmdGhpcy5fY29udGFpbmVySGVpZ2h0PT09dGhpcy5fc2NyZWVuRWxlbWVudC5jbGllbnRIZWlnaHR8fCh0aGlzLl9xdWV1ZVJlZnJlc2goITApLHRoaXMuX2NvbnRhaW5lckhlaWdodD10aGlzLl9zY3JlZW5FbGVtZW50LmNsaWVudEhlaWdodCl9KSkpLHRoaXMucmVnaXN0ZXIodGhpcy5fb3B0aW9uc1NlcnZpY2Uub25TcGVjaWZpY09wdGlvbkNoYW5nZShcIm92ZXJ2aWV3UnVsZXJXaWR0aFwiLCgoKT0+dGhpcy5fcXVldWVSZWZyZXNoKCEwKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX2NvcmVCcm93c2VyU2VydmljZS5vbkRwckNoYW5nZSgoKCk9PnRoaXMuX3F1ZXVlUmVmcmVzaCghMCkpKSksdGhpcy5fcXVldWVSZWZyZXNoKCEwKX1fcmVmcmVzaERyYXdDb25zdGFudHMoKXtjb25zdCBlPU1hdGguZmxvb3IodGhpcy5fY2FudmFzLndpZHRoLzMpLHQ9TWF0aC5jZWlsKHRoaXMuX2NhbnZhcy53aWR0aC8zKTtsLmZ1bGw9dGhpcy5fY2FudmFzLndpZHRoLGwubGVmdD1lLGwuY2VudGVyPXQsbC5yaWdodD1lLHRoaXMuX3JlZnJlc2hEcmF3SGVpZ2h0Q29uc3RhbnRzKCksZC5mdWxsPTAsZC5sZWZ0PTAsZC5jZW50ZXI9bC5sZWZ0LGQucmlnaHQ9bC5sZWZ0K2wuY2VudGVyfV9yZWZyZXNoRHJhd0hlaWdodENvbnN0YW50cygpe2MuZnVsbD1NYXRoLnJvdW5kKDIqdGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlLmRwcik7Y29uc3QgZT10aGlzLl9jYW52YXMuaGVpZ2h0L3RoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLmxpbmVzLmxlbmd0aCx0PU1hdGgucm91bmQoTWF0aC5tYXgoTWF0aC5taW4oZSwxMiksNikqdGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlLmRwcik7Yy5sZWZ0PXQsYy5jZW50ZXI9dCxjLnJpZ2h0PXR9X3JlZnJlc2hDb2xvclpvbmVQYWRkaW5nKCl7dGhpcy5fY29sb3Jab25lU3RvcmUuc2V0UGFkZGluZyh7ZnVsbDpNYXRoLmZsb29yKHRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVycy5hY3RpdmUubGluZXMubGVuZ3RoLyh0aGlzLl9jYW52YXMuaGVpZ2h0LTEpKmMuZnVsbCksbGVmdDpNYXRoLmZsb29yKHRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVycy5hY3RpdmUubGluZXMubGVuZ3RoLyh0aGlzLl9jYW52YXMuaGVpZ2h0LTEpKmMubGVmdCksY2VudGVyOk1hdGguZmxvb3IodGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXJzLmFjdGl2ZS5saW5lcy5sZW5ndGgvKHRoaXMuX2NhbnZhcy5oZWlnaHQtMSkqYy5jZW50ZXIpLHJpZ2h0Ok1hdGguZmxvb3IodGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXJzLmFjdGl2ZS5saW5lcy5sZW5ndGgvKHRoaXMuX2NhbnZhcy5oZWlnaHQtMSkqYy5yaWdodCl9KSx0aGlzLl9sYXN0S25vd25CdWZmZXJMZW5ndGg9dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXJzLm5vcm1hbC5saW5lcy5sZW5ndGh9X3JlZnJlc2hDYW52YXNEaW1lbnNpb25zKCl7dGhpcy5fY2FudmFzLnN0eWxlLndpZHRoPWAke3RoaXMuX3dpZHRofXB4YCx0aGlzLl9jYW52YXMud2lkdGg9TWF0aC5yb3VuZCh0aGlzLl93aWR0aCp0aGlzLl9jb3JlQnJvd3NlclNlcnZpY2UuZHByKSx0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0PWAke3RoaXMuX3NjcmVlbkVsZW1lbnQuY2xpZW50SGVpZ2h0fXB4YCx0aGlzLl9jYW52YXMuaGVpZ2h0PU1hdGgucm91bmQodGhpcy5fc2NyZWVuRWxlbWVudC5jbGllbnRIZWlnaHQqdGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlLmRwciksdGhpcy5fcmVmcmVzaERyYXdDb25zdGFudHMoKSx0aGlzLl9yZWZyZXNoQ29sb3Jab25lUGFkZGluZygpfV9yZWZyZXNoRGVjb3JhdGlvbnMoKXt0aGlzLl9zaG91bGRVcGRhdGVEaW1lbnNpb25zJiZ0aGlzLl9yZWZyZXNoQ2FudmFzRGltZW5zaW9ucygpLHRoaXMuX2N0eC5jbGVhclJlY3QoMCwwLHRoaXMuX2NhbnZhcy53aWR0aCx0aGlzLl9jYW52YXMuaGVpZ2h0KSx0aGlzLl9jb2xvclpvbmVTdG9yZS5jbGVhcigpO2Zvcihjb25zdCBlIG9mIHRoaXMuX2RlY29yYXRpb25TZXJ2aWNlLmRlY29yYXRpb25zKXRoaXMuX2NvbG9yWm9uZVN0b3JlLmFkZERlY29yYXRpb24oZSk7dGhpcy5fY3R4LmxpbmVXaWR0aD0xO2NvbnN0IGU9dGhpcy5fY29sb3Jab25lU3RvcmUuem9uZXM7Zm9yKGNvbnN0IHQgb2YgZSlcImZ1bGxcIiE9PXQucG9zaXRpb24mJnRoaXMuX3JlbmRlckNvbG9yWm9uZSh0KTtmb3IoY29uc3QgdCBvZiBlKVwiZnVsbFwiPT09dC5wb3NpdGlvbiYmdGhpcy5fcmVuZGVyQ29sb3Jab25lKHQpO3RoaXMuX3Nob3VsZFVwZGF0ZURpbWVuc2lvbnM9ITEsdGhpcy5fc2hvdWxkVXBkYXRlQW5jaG9yPSExfV9yZW5kZXJDb2xvclpvbmUoZSl7dGhpcy5fY3R4LmZpbGxTdHlsZT1lLmNvbG9yLHRoaXMuX2N0eC5maWxsUmVjdChkW2UucG9zaXRpb258fFwiZnVsbFwiXSxNYXRoLnJvdW5kKCh0aGlzLl9jYW52YXMuaGVpZ2h0LTEpKihlLnN0YXJ0QnVmZmVyTGluZS90aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlcnMuYWN0aXZlLmxpbmVzLmxlbmd0aCktY1tlLnBvc2l0aW9ufHxcImZ1bGxcIl0vMiksbFtlLnBvc2l0aW9ufHxcImZ1bGxcIl0sTWF0aC5yb3VuZCgodGhpcy5fY2FudmFzLmhlaWdodC0xKSooKGUuZW5kQnVmZmVyTGluZS1lLnN0YXJ0QnVmZmVyTGluZSkvdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXJzLmFjdGl2ZS5saW5lcy5sZW5ndGgpK2NbZS5wb3NpdGlvbnx8XCJmdWxsXCJdKSl9X3F1ZXVlUmVmcmVzaChlLHQpe3RoaXMuX3Nob3VsZFVwZGF0ZURpbWVuc2lvbnM9ZXx8dGhpcy5fc2hvdWxkVXBkYXRlRGltZW5zaW9ucyx0aGlzLl9zaG91bGRVcGRhdGVBbmNob3I9dHx8dGhpcy5fc2hvdWxkVXBkYXRlQW5jaG9yLHZvaWQgMD09PXRoaXMuX2FuaW1hdGlvbkZyYW1lJiYodGhpcy5fYW5pbWF0aW9uRnJhbWU9dGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpPT57dGhpcy5fcmVmcmVzaERlY29yYXRpb25zKCksdGhpcy5fYW5pbWF0aW9uRnJhbWU9dm9pZCAwfSkpKX19O3QuT3ZlcnZpZXdSdWxlclJlbmRlcmVyPV89cyhbcigyLGguSUJ1ZmZlclNlcnZpY2UpLHIoMyxoLklEZWNvcmF0aW9uU2VydmljZSkscig0LG8uSVJlbmRlclNlcnZpY2UpLHIoNSxoLklPcHRpb25zU2VydmljZSkscig2LG8uSUNvcmVCcm93c2VyU2VydmljZSldLF8pfSwyOTUwOmZ1bmN0aW9uKGUsdCxpKXt2YXIgcz10aGlzJiZ0aGlzLl9fZGVjb3JhdGV8fGZ1bmN0aW9uKGUsdCxpLHMpe3ZhciByLG49YXJndW1lbnRzLmxlbmd0aCxvPW48Mz90Om51bGw9PT1zP3M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGkpOnM7aWYoXCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3QmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUpbz1SZWZsZWN0LmRlY29yYXRlKGUsdCxpLHMpO2Vsc2UgZm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MDthLS0pKHI9ZVthXSkmJihvPShuPDM/cihvKTpuPjM/cih0LGksbyk6cih0LGkpKXx8byk7cmV0dXJuIG4+MyYmbyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSxvKSxvfSxyPXRoaXMmJnRoaXMuX19wYXJhbXx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oaSxzKXt0KGkscyxlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuQ29tcG9zaXRpb25IZWxwZXI9dm9pZCAwO2NvbnN0IG49aSg0NzI1KSxvPWkoMjU4NSksYT1pKDI1ODQpO2xldCBoPXQuQ29tcG9zaXRpb25IZWxwZXI9Y2xhc3N7Z2V0IGlzQ29tcG9zaW5nKCl7cmV0dXJuIHRoaXMuX2lzQ29tcG9zaW5nfWNvbnN0cnVjdG9yKGUsdCxpLHMscixuKXt0aGlzLl90ZXh0YXJlYT1lLHRoaXMuX2NvbXBvc2l0aW9uVmlldz10LHRoaXMuX2J1ZmZlclNlcnZpY2U9aSx0aGlzLl9vcHRpb25zU2VydmljZT1zLHRoaXMuX2NvcmVTZXJ2aWNlPXIsdGhpcy5fcmVuZGVyU2VydmljZT1uLHRoaXMuX2lzQ29tcG9zaW5nPSExLHRoaXMuX2lzU2VuZGluZ0NvbXBvc2l0aW9uPSExLHRoaXMuX2NvbXBvc2l0aW9uUG9zaXRpb249e3N0YXJ0OjAsZW5kOjB9LHRoaXMuX2RhdGFBbHJlYWR5U2VudD1cIlwifWNvbXBvc2l0aW9uc3RhcnQoKXt0aGlzLl9pc0NvbXBvc2luZz0hMCx0aGlzLl9jb21wb3NpdGlvblBvc2l0aW9uLnN0YXJ0PXRoaXMuX3RleHRhcmVhLnZhbHVlLmxlbmd0aCx0aGlzLl9jb21wb3NpdGlvblZpZXcudGV4dENvbnRlbnQ9XCJcIix0aGlzLl9kYXRhQWxyZWFkeVNlbnQ9XCJcIix0aGlzLl9jb21wb3NpdGlvblZpZXcuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKX1jb21wb3NpdGlvbnVwZGF0ZShlKXt0aGlzLl9jb21wb3NpdGlvblZpZXcudGV4dENvbnRlbnQ9ZS5kYXRhLHRoaXMudXBkYXRlQ29tcG9zaXRpb25FbGVtZW50cygpLHNldFRpbWVvdXQoKCgpPT57dGhpcy5fY29tcG9zaXRpb25Qb3NpdGlvbi5lbmQ9dGhpcy5fdGV4dGFyZWEudmFsdWUubGVuZ3RofSksMCl9Y29tcG9zaXRpb25lbmQoKXt0aGlzLl9maW5hbGl6ZUNvbXBvc2l0aW9uKCEwKX1rZXlkb3duKGUpe2lmKHRoaXMuX2lzQ29tcG9zaW5nfHx0aGlzLl9pc1NlbmRpbmdDb21wb3NpdGlvbil7aWYoMjI5PT09ZS5rZXlDb2RlKXJldHVybiExO2lmKDE2PT09ZS5rZXlDb2RlfHwxNz09PWUua2V5Q29kZXx8MTg9PT1lLmtleUNvZGUpcmV0dXJuITE7dGhpcy5fZmluYWxpemVDb21wb3NpdGlvbighMSl9cmV0dXJuIDIyOSE9PWUua2V5Q29kZXx8KHRoaXMuX2hhbmRsZUFueVRleHRhcmVhQ2hhbmdlcygpLCExKX1fZmluYWxpemVDb21wb3NpdGlvbihlKXtpZih0aGlzLl9jb21wb3NpdGlvblZpZXcuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKSx0aGlzLl9pc0NvbXBvc2luZz0hMSxlKXtjb25zdCBlPXtzdGFydDp0aGlzLl9jb21wb3NpdGlvblBvc2l0aW9uLnN0YXJ0LGVuZDp0aGlzLl9jb21wb3NpdGlvblBvc2l0aW9uLmVuZH07dGhpcy5faXNTZW5kaW5nQ29tcG9zaXRpb249ITAsc2V0VGltZW91dCgoKCk9PntpZih0aGlzLl9pc1NlbmRpbmdDb21wb3NpdGlvbil7bGV0IHQ7dGhpcy5faXNTZW5kaW5nQ29tcG9zaXRpb249ITEsZS5zdGFydCs9dGhpcy5fZGF0YUFscmVhZHlTZW50Lmxlbmd0aCx0PXRoaXMuX2lzQ29tcG9zaW5nP3RoaXMuX3RleHRhcmVhLnZhbHVlLnN1YnN0cmluZyhlLnN0YXJ0LGUuZW5kKTp0aGlzLl90ZXh0YXJlYS52YWx1ZS5zdWJzdHJpbmcoZS5zdGFydCksdC5sZW5ndGg+MCYmdGhpcy5fY29yZVNlcnZpY2UudHJpZ2dlckRhdGFFdmVudCh0LCEwKX19KSwwKX1lbHNle3RoaXMuX2lzU2VuZGluZ0NvbXBvc2l0aW9uPSExO2NvbnN0IGU9dGhpcy5fdGV4dGFyZWEudmFsdWUuc3Vic3RyaW5nKHRoaXMuX2NvbXBvc2l0aW9uUG9zaXRpb24uc3RhcnQsdGhpcy5fY29tcG9zaXRpb25Qb3NpdGlvbi5lbmQpO3RoaXMuX2NvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQoZSwhMCl9fV9oYW5kbGVBbnlUZXh0YXJlYUNoYW5nZXMoKXtjb25zdCBlPXRoaXMuX3RleHRhcmVhLnZhbHVlO3NldFRpbWVvdXQoKCgpPT57aWYoIXRoaXMuX2lzQ29tcG9zaW5nKXtjb25zdCB0PXRoaXMuX3RleHRhcmVhLnZhbHVlLGk9dC5yZXBsYWNlKGUsXCJcIik7dGhpcy5fZGF0YUFscmVhZHlTZW50PWksdC5sZW5ndGg+ZS5sZW5ndGg/dGhpcy5fY29yZVNlcnZpY2UudHJpZ2dlckRhdGFFdmVudChpLCEwKTp0Lmxlbmd0aDxlLmxlbmd0aD90aGlzLl9jb3JlU2VydmljZS50cmlnZ2VyRGF0YUV2ZW50KGAke2EuQzAuREVMfWAsITApOnQubGVuZ3RoPT09ZS5sZW5ndGgmJnQhPT1lJiZ0aGlzLl9jb3JlU2VydmljZS50cmlnZ2VyRGF0YUV2ZW50KHQsITApfX0pLDApfXVwZGF0ZUNvbXBvc2l0aW9uRWxlbWVudHMoZSl7aWYodGhpcy5faXNDb21wb3Npbmcpe2lmKHRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLmlzQ3Vyc29ySW5WaWV3cG9ydCl7Y29uc3QgZT1NYXRoLm1pbih0aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci54LHRoaXMuX2J1ZmZlclNlcnZpY2UuY29scy0xKSx0PXRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC5oZWlnaHQsaT10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci55KnRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC5oZWlnaHQscz1lKnRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC53aWR0aDt0aGlzLl9jb21wb3NpdGlvblZpZXcuc3R5bGUubGVmdD1zK1wicHhcIix0aGlzLl9jb21wb3NpdGlvblZpZXcuc3R5bGUudG9wPWkrXCJweFwiLHRoaXMuX2NvbXBvc2l0aW9uVmlldy5zdHlsZS5oZWlnaHQ9dCtcInB4XCIsdGhpcy5fY29tcG9zaXRpb25WaWV3LnN0eWxlLmxpbmVIZWlnaHQ9dCtcInB4XCIsdGhpcy5fY29tcG9zaXRpb25WaWV3LnN0eWxlLmZvbnRGYW1pbHk9dGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5mb250RmFtaWx5LHRoaXMuX2NvbXBvc2l0aW9uVmlldy5zdHlsZS5mb250U2l6ZT10aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmZvbnRTaXplK1wicHhcIjtjb25zdCByPXRoaXMuX2NvbXBvc2l0aW9uVmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0aGlzLl90ZXh0YXJlYS5zdHlsZS5sZWZ0PXMrXCJweFwiLHRoaXMuX3RleHRhcmVhLnN0eWxlLnRvcD1pK1wicHhcIix0aGlzLl90ZXh0YXJlYS5zdHlsZS53aWR0aD1NYXRoLm1heChyLndpZHRoLDEpK1wicHhcIix0aGlzLl90ZXh0YXJlYS5zdHlsZS5oZWlnaHQ9TWF0aC5tYXgoci5oZWlnaHQsMSkrXCJweFwiLHRoaXMuX3RleHRhcmVhLnN0eWxlLmxpbmVIZWlnaHQ9ci5oZWlnaHQrXCJweFwifWV8fHNldFRpbWVvdXQoKCgpPT50aGlzLnVwZGF0ZUNvbXBvc2l0aW9uRWxlbWVudHMoITApKSwwKX19fTt0LkNvbXBvc2l0aW9uSGVscGVyPWg9cyhbcigyLG8uSUJ1ZmZlclNlcnZpY2UpLHIoMyxvLklPcHRpb25zU2VydmljZSkscig0LG8uSUNvcmVTZXJ2aWNlKSxyKDUsbi5JUmVuZGVyU2VydmljZSldLGgpfSw5ODA2OihlLHQpPT57ZnVuY3Rpb24gaShlLHQsaSl7Y29uc3Qgcz1pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHI9ZS5nZXRDb21wdXRlZFN0eWxlKGkpLG49cGFyc2VJbnQoci5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1sZWZ0XCIpKSxvPXBhcnNlSW50KHIuZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctdG9wXCIpKTtyZXR1cm5bdC5jbGllbnRYLXMubGVmdC1uLHQuY2xpZW50WS1zLnRvcC1vXX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldENvb3Jkcz10LmdldENvb3Jkc1JlbGF0aXZlVG9FbGVtZW50PXZvaWQgMCx0LmdldENvb3Jkc1JlbGF0aXZlVG9FbGVtZW50PWksdC5nZXRDb29yZHM9ZnVuY3Rpb24oZSx0LHMscixuLG8sYSxoLGMpe2lmKCFvKXJldHVybjtjb25zdCBsPWkoZSx0LHMpO3JldHVybiBsPyhsWzBdPU1hdGguY2VpbCgobFswXSsoYz9hLzI6MCkpL2EpLGxbMV09TWF0aC5jZWlsKGxbMV0vaCksbFswXT1NYXRoLm1pbihNYXRoLm1heChsWzBdLDEpLHIrKGM/MTowKSksbFsxXT1NYXRoLm1pbihNYXRoLm1heChsWzFdLDEpLG4pLGwpOnZvaWQgMH19LDk1MDQ6KGUsdCxpKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubW92ZVRvQ2VsbFNlcXVlbmNlPXZvaWQgMDtjb25zdCBzPWkoMjU4NCk7ZnVuY3Rpb24gcihlLHQsaSxzKXtjb25zdCByPWUtbihlLGkpLGE9dC1uKHQsaSksbD1NYXRoLmFicyhyLWEpLWZ1bmN0aW9uKGUsdCxpKXtsZXQgcz0wO2NvbnN0IHI9ZS1uKGUsaSksYT10LW4odCxpKTtmb3IobGV0IG49MDtuPE1hdGguYWJzKHItYSk7bisrKXtjb25zdCBhPVwiQVwiPT09byhlLHQpPy0xOjEsaD1pLmJ1ZmZlci5saW5lcy5nZXQocithKm4pO2g/LmlzV3JhcHBlZCYmcysrfXJldHVybiBzfShlLHQsaSk7cmV0dXJuIGMobCxoKG8oZSx0KSxzKSl9ZnVuY3Rpb24gbihlLHQpe2xldCBpPTAscz10LmJ1ZmZlci5saW5lcy5nZXQoZSkscj1zPy5pc1dyYXBwZWQ7Zm9yKDtyJiZlPj0wJiZlPHQucm93czspaSsrLHM9dC5idWZmZXIubGluZXMuZ2V0KC0tZSkscj1zPy5pc1dyYXBwZWQ7cmV0dXJuIGl9ZnVuY3Rpb24gbyhlLHQpe3JldHVybiBlPnQ/XCJBXCI6XCJCXCJ9ZnVuY3Rpb24gYShlLHQsaSxzLHIsbil7bGV0IG89ZSxhPXQsaD1cIlwiO2Zvcig7byE9PWl8fGEhPT1zOylvKz1yPzE6LTEsciYmbz5uLmNvbHMtMT8oaCs9bi5idWZmZXIudHJhbnNsYXRlQnVmZmVyTGluZVRvU3RyaW5nKGEsITEsZSxvKSxvPTAsZT0wLGErKyk6IXImJm88MCYmKGgrPW4uYnVmZmVyLnRyYW5zbGF0ZUJ1ZmZlckxpbmVUb1N0cmluZyhhLCExLDAsZSsxKSxvPW4uY29scy0xLGU9byxhLS0pO3JldHVybiBoK24uYnVmZmVyLnRyYW5zbGF0ZUJ1ZmZlckxpbmVUb1N0cmluZyhhLCExLGUsbyl9ZnVuY3Rpb24gaChlLHQpe2NvbnN0IGk9dD9cIk9cIjpcIltcIjtyZXR1cm4gcy5DMC5FU0MraStlfWZ1bmN0aW9uIGMoZSx0KXtlPU1hdGguZmxvb3IoZSk7bGV0IGk9XCJcIjtmb3IobGV0IHM9MDtzPGU7cysrKWkrPXQ7cmV0dXJuIGl9dC5tb3ZlVG9DZWxsU2VxdWVuY2U9ZnVuY3Rpb24oZSx0LGkscyl7Y29uc3Qgbz1pLmJ1ZmZlci54LGw9aS5idWZmZXIueTtpZighaS5idWZmZXIuaGFzU2Nyb2xsYmFjaylyZXR1cm4gZnVuY3Rpb24oZSx0LGkscyxvLGwpe3JldHVybiAwPT09cih0LHMsbyxsKS5sZW5ndGg/XCJcIjpjKGEoZSx0LGUsdC1uKHQsbyksITEsbykubGVuZ3RoLGgoXCJEXCIsbCkpfShvLGwsMCx0LGkscykrcihsLHQsaSxzKStmdW5jdGlvbihlLHQsaSxzLG8sbCl7bGV0IGQ7ZD1yKHQscyxvLGwpLmxlbmd0aD4wP3MtbihzLG8pOnQ7Y29uc3QgXz1zLHU9ZnVuY3Rpb24oZSx0LGkscyxvLGEpe2xldCBoO3JldHVybiBoPXIoaSxzLG8sYSkubGVuZ3RoPjA/cy1uKHMsbyk6dCxlPGkmJmg8PXN8fGU+PWkmJmg8cz9cIkNcIjpcIkRcIn0oZSx0LGkscyxvLGwpO3JldHVybiBjKGEoZSxkLGksXyxcIkNcIj09PXUsbykubGVuZ3RoLGgodSxsKSl9KG8sbCxlLHQsaSxzKTtsZXQgZDtpZihsPT09dClyZXR1cm4gZD1vPmU/XCJEXCI6XCJDXCIsYyhNYXRoLmFicyhvLWUpLGgoZCxzKSk7ZD1sPnQ/XCJEXCI6XCJDXCI7Y29uc3QgXz1NYXRoLmFicyhsLXQpO3JldHVybiBjKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQuY29scy1lfShsPnQ/ZTpvLGkpKyhfLTEpKmkuY29scysxKygobD50P286ZSktMSksaChkLHMpKX19LDEyOTY6ZnVuY3Rpb24oZSx0LGkpe3ZhciBzPXRoaXMmJnRoaXMuX19kZWNvcmF0ZXx8ZnVuY3Rpb24oZSx0LGkscyl7dmFyIHIsbj1hcmd1bWVudHMubGVuZ3RoLG89bjwzP3Q6bnVsbD09PXM/cz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsaSk6cztpZihcIm9iamVjdFwiPT10eXBlb2YgUmVmbGVjdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSlvPVJlZmxlY3QuZGVjb3JhdGUoZSx0LGkscyk7ZWxzZSBmb3IodmFyIGE9ZS5sZW5ndGgtMTthPj0wO2EtLSkocj1lW2FdKSYmKG89KG48Mz9yKG8pOm4+Mz9yKHQsaSxvKTpyKHQsaSkpfHxvKTtyZXR1cm4gbj4zJiZvJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLG8pLG99LHI9dGhpcyYmdGhpcy5fX3BhcmFtfHxmdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihpLHMpe3QoaSxzLGUpfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Eb21SZW5kZXJlcj12b2lkIDA7Y29uc3Qgbj1pKDM3ODcpLG89aSgyNTUwKSxhPWkoMjIyMyksaD1pKDYxNzEpLGM9aSg2MDUyKSxsPWkoNDcyNSksZD1pKDgwNTUpLF89aSg4NDYwKSx1PWkoODQ0KSxmPWkoMjU4NSksdj1cInh0ZXJtLWRvbS1yZW5kZXJlci1vd25lci1cIixwPVwieHRlcm0tcm93c1wiLGc9XCJ4dGVybS1mZy1cIixtPVwieHRlcm0tYmctXCIsUz1cInh0ZXJtLWZvY3VzXCIsQz1cInh0ZXJtLXNlbGVjdGlvblwiO2xldCBiPTEsdz10LkRvbVJlbmRlcmVyPWNsYXNzIGV4dGVuZHMgdS5EaXNwb3NhYmxle2NvbnN0cnVjdG9yKGUsdCxpLHMscixhLGwsZCxmLGcsbSxTLHcpe3N1cGVyKCksdGhpcy5fdGVybWluYWw9ZSx0aGlzLl9kb2N1bWVudD10LHRoaXMuX2VsZW1lbnQ9aSx0aGlzLl9zY3JlZW5FbGVtZW50PXMsdGhpcy5fdmlld3BvcnRFbGVtZW50PXIsdGhpcy5faGVscGVyQ29udGFpbmVyPWEsdGhpcy5fbGlua2lmaWVyMj1sLHRoaXMuX2NoYXJTaXplU2VydmljZT1mLHRoaXMuX29wdGlvbnNTZXJ2aWNlPWcsdGhpcy5fYnVmZmVyU2VydmljZT1tLHRoaXMuX2NvcmVCcm93c2VyU2VydmljZT1TLHRoaXMuX3RoZW1lU2VydmljZT13LHRoaXMuX3Rlcm1pbmFsQ2xhc3M9YisrLHRoaXMuX3Jvd0VsZW1lbnRzPVtdLHRoaXMuX3NlbGVjdGlvblJlbmRlck1vZGVsPSgwLGMuY3JlYXRlU2VsZWN0aW9uUmVuZGVyTW9kZWwpKCksdGhpcy5vblJlcXVlc3RSZWRyYXc9dGhpcy5yZWdpc3RlcihuZXcgXy5FdmVudEVtaXR0ZXIpLmV2ZW50LHRoaXMuX3Jvd0NvbnRhaW5lcj10aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuX3Jvd0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHApLHRoaXMuX3Jvd0NvbnRhaW5lci5zdHlsZS5saW5lSGVpZ2h0PVwibm9ybWFsXCIsdGhpcy5fcm93Q29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsXCJ0cnVlXCIpLHRoaXMuX3JlZnJlc2hSb3dFbGVtZW50cyh0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMsdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzKSx0aGlzLl9zZWxlY3Rpb25Db250YWluZXI9dGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl9zZWxlY3Rpb25Db250YWluZXIuY2xhc3NMaXN0LmFkZChDKSx0aGlzLl9zZWxlY3Rpb25Db250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIiksdGhpcy5kaW1lbnNpb25zPSgwLGguY3JlYXRlUmVuZGVyRGltZW5zaW9ucykoKSx0aGlzLl91cGRhdGVEaW1lbnNpb25zKCksdGhpcy5yZWdpc3Rlcih0aGlzLl9vcHRpb25zU2VydmljZS5vbk9wdGlvbkNoYW5nZSgoKCk9PnRoaXMuX2hhbmRsZU9wdGlvbnNDaGFuZ2VkKCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl90aGVtZVNlcnZpY2Uub25DaGFuZ2VDb2xvcnMoKGU9PnRoaXMuX2luamVjdENzcyhlKSkpKSx0aGlzLl9pbmplY3RDc3ModGhpcy5fdGhlbWVTZXJ2aWNlLmNvbG9ycyksdGhpcy5fcm93RmFjdG9yeT1kLmNyZWF0ZUluc3RhbmNlKG4uRG9tUmVuZGVyZXJSb3dGYWN0b3J5LGRvY3VtZW50KSx0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQodit0aGlzLl90ZXJtaW5hbENsYXNzKSx0aGlzLl9zY3JlZW5FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3Jvd0NvbnRhaW5lciksdGhpcy5fc2NyZWVuRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9zZWxlY3Rpb25Db250YWluZXIpLHRoaXMucmVnaXN0ZXIodGhpcy5fbGlua2lmaWVyMi5vblNob3dMaW5rVW5kZXJsaW5lKChlPT50aGlzLl9oYW5kbGVMaW5rSG92ZXIoZSkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9saW5raWZpZXIyLm9uSGlkZUxpbmtVbmRlcmxpbmUoKGU9PnRoaXMuX2hhbmRsZUxpbmtMZWF2ZShlKSkpKSx0aGlzLnJlZ2lzdGVyKCgwLHUudG9EaXNwb3NhYmxlKSgoKCk9Pnt0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodit0aGlzLl90ZXJtaW5hbENsYXNzKSx0aGlzLl9yb3dDb250YWluZXIucmVtb3ZlKCksdGhpcy5fc2VsZWN0aW9uQ29udGFpbmVyLnJlbW92ZSgpLHRoaXMuX3dpZHRoQ2FjaGUuZGlzcG9zZSgpLHRoaXMuX3RoZW1lU3R5bGVFbGVtZW50LnJlbW92ZSgpLHRoaXMuX2RpbWVuc2lvbnNTdHlsZUVsZW1lbnQucmVtb3ZlKCl9KSkpLHRoaXMuX3dpZHRoQ2FjaGU9bmV3IG8uV2lkdGhDYWNoZSh0aGlzLl9kb2N1bWVudCx0aGlzLl9oZWxwZXJDb250YWluZXIpLHRoaXMuX3dpZHRoQ2FjaGUuc2V0Rm9udCh0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmZvbnRGYW1pbHksdGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5mb250U2l6ZSx0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmZvbnRXZWlnaHQsdGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5mb250V2VpZ2h0Qm9sZCksdGhpcy5fc2V0RGVmYXVsdFNwYWNpbmcoKX1fdXBkYXRlRGltZW5zaW9ucygpe2NvbnN0IGU9dGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlLmRwcjt0aGlzLmRpbWVuc2lvbnMuZGV2aWNlLmNoYXIud2lkdGg9dGhpcy5fY2hhclNpemVTZXJ2aWNlLndpZHRoKmUsdGhpcy5kaW1lbnNpb25zLmRldmljZS5jaGFyLmhlaWdodD1NYXRoLmNlaWwodGhpcy5fY2hhclNpemVTZXJ2aWNlLmhlaWdodCplKSx0aGlzLmRpbWVuc2lvbnMuZGV2aWNlLmNlbGwud2lkdGg9dGhpcy5kaW1lbnNpb25zLmRldmljZS5jaGFyLndpZHRoK01hdGgucm91bmQodGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5sZXR0ZXJTcGFjaW5nKSx0aGlzLmRpbWVuc2lvbnMuZGV2aWNlLmNlbGwuaGVpZ2h0PU1hdGguZmxvb3IodGhpcy5kaW1lbnNpb25zLmRldmljZS5jaGFyLmhlaWdodCp0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmxpbmVIZWlnaHQpLHRoaXMuZGltZW5zaW9ucy5kZXZpY2UuY2hhci5sZWZ0PTAsdGhpcy5kaW1lbnNpb25zLmRldmljZS5jaGFyLnRvcD0wLHRoaXMuZGltZW5zaW9ucy5kZXZpY2UuY2FudmFzLndpZHRoPXRoaXMuZGltZW5zaW9ucy5kZXZpY2UuY2VsbC53aWR0aCp0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMsdGhpcy5kaW1lbnNpb25zLmRldmljZS5jYW52YXMuaGVpZ2h0PXRoaXMuZGltZW5zaW9ucy5kZXZpY2UuY2VsbC5oZWlnaHQqdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLHRoaXMuZGltZW5zaW9ucy5jc3MuY2FudmFzLndpZHRoPU1hdGgucm91bmQodGhpcy5kaW1lbnNpb25zLmRldmljZS5jYW52YXMud2lkdGgvZSksdGhpcy5kaW1lbnNpb25zLmNzcy5jYW52YXMuaGVpZ2h0PU1hdGgucm91bmQodGhpcy5kaW1lbnNpb25zLmRldmljZS5jYW52YXMuaGVpZ2h0L2UpLHRoaXMuZGltZW5zaW9ucy5jc3MuY2VsbC53aWR0aD10aGlzLmRpbWVuc2lvbnMuY3NzLmNhbnZhcy53aWR0aC90aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMsdGhpcy5kaW1lbnNpb25zLmNzcy5jZWxsLmhlaWdodD10aGlzLmRpbWVuc2lvbnMuY3NzLmNhbnZhcy5oZWlnaHQvdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzO2Zvcihjb25zdCBlIG9mIHRoaXMuX3Jvd0VsZW1lbnRzKWUuc3R5bGUud2lkdGg9YCR7dGhpcy5kaW1lbnNpb25zLmNzcy5jYW52YXMud2lkdGh9cHhgLGUuc3R5bGUuaGVpZ2h0PWAke3RoaXMuZGltZW5zaW9ucy5jc3MuY2VsbC5oZWlnaHR9cHhgLGUuc3R5bGUubGluZUhlaWdodD1gJHt0aGlzLmRpbWVuc2lvbnMuY3NzLmNlbGwuaGVpZ2h0fXB4YCxlLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCI7dGhpcy5fZGltZW5zaW9uc1N0eWxlRWxlbWVudHx8KHRoaXMuX2RpbWVuc2lvbnNTdHlsZUVsZW1lbnQ9dGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLHRoaXMuX3NjcmVlbkVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fZGltZW5zaW9uc1N0eWxlRWxlbWVudCkpO2NvbnN0IHQ9YCR7dGhpcy5fdGVybWluYWxTZWxlY3Rvcn0gLiR7cH0gc3BhbiB7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgaGVpZ2h0OiAxMDAlOyB2ZXJ0aWNhbC1hbGlnbjogdG9wO31gO3RoaXMuX2RpbWVuc2lvbnNTdHlsZUVsZW1lbnQudGV4dENvbnRlbnQ9dCx0aGlzLl9zZWxlY3Rpb25Db250YWluZXIuc3R5bGUuaGVpZ2h0PXRoaXMuX3ZpZXdwb3J0RWxlbWVudC5zdHlsZS5oZWlnaHQsdGhpcy5fc2NyZWVuRWxlbWVudC5zdHlsZS53aWR0aD1gJHt0aGlzLmRpbWVuc2lvbnMuY3NzLmNhbnZhcy53aWR0aH1weGAsdGhpcy5fc2NyZWVuRWxlbWVudC5zdHlsZS5oZWlnaHQ9YCR7dGhpcy5kaW1lbnNpb25zLmNzcy5jYW52YXMuaGVpZ2h0fXB4YH1faW5qZWN0Q3NzKGUpe3RoaXMuX3RoZW1lU3R5bGVFbGVtZW50fHwodGhpcy5fdGhlbWVTdHlsZUVsZW1lbnQ9dGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLHRoaXMuX3NjcmVlbkVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fdGhlbWVTdHlsZUVsZW1lbnQpKTtsZXQgdD1gJHt0aGlzLl90ZXJtaW5hbFNlbGVjdG9yfSAuJHtwfSB7IGNvbG9yOiAke2UuZm9yZWdyb3VuZC5jc3N9OyBmb250LWZhbWlseTogJHt0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmZvbnRGYW1pbHl9OyBmb250LXNpemU6ICR7dGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5mb250U2l6ZX1weDsgZm9udC1rZXJuaW5nOiBub25lOyB3aGl0ZS1zcGFjZTogcHJlfWA7dCs9YCR7dGhpcy5fdGVybWluYWxTZWxlY3Rvcn0gLiR7cH0gLnh0ZXJtLWRpbSB7IGNvbG9yOiAke2QuY29sb3IubXVsdGlwbHlPcGFjaXR5KGUuZm9yZWdyb3VuZCwuNSkuY3NzfTt9YCx0Kz1gJHt0aGlzLl90ZXJtaW5hbFNlbGVjdG9yfSBzcGFuOm5vdCgueHRlcm0tYm9sZCkgeyBmb250LXdlaWdodDogJHt0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmZvbnRXZWlnaHR9O30ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IHNwYW4ueHRlcm0tYm9sZCB7IGZvbnQtd2VpZ2h0OiAke3RoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuZm9udFdlaWdodEJvbGR9O30ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IHNwYW4ueHRlcm0taXRhbGljIHsgZm9udC1zdHlsZTogaXRhbGljO31gO2NvbnN0IGk9YGJsaW5rX3VuZGVybGluZV8ke3RoaXMuX3Rlcm1pbmFsQ2xhc3N9YCxzPWBibGlua19iYXJfJHt0aGlzLl90ZXJtaW5hbENsYXNzfWAscj1gYmxpbmtfYmxvY2tfJHt0aGlzLl90ZXJtaW5hbENsYXNzfWA7dCs9YEBrZXlmcmFtZXMgJHtpfSB7IDUwJSB7ICBib3JkZXItYm90dG9tLXN0eWxlOiBoaWRkZW47IH19YCx0Kz1gQGtleWZyYW1lcyAke3N9IHsgNTAlIHsgIGJveC1zaGFkb3c6IG5vbmU7IH19YCx0Kz1gQGtleWZyYW1lcyAke3J9IHsgMCUgeyAgYmFja2dyb3VuZC1jb2xvcjogJHtlLmN1cnNvci5jc3N9OyAgY29sb3I6ICR7ZS5jdXJzb3JBY2NlbnQuY3NzfTsgfSA1MCUgeyAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDsgIGNvbG9yOiAke2UuY3Vyc29yLmNzc307IH19YCx0Kz1gJHt0aGlzLl90ZXJtaW5hbFNlbGVjdG9yfSAuJHtwfS4ke1N9IC54dGVybS1jdXJzb3IueHRlcm0tY3Vyc29yLWJsaW5rLnh0ZXJtLWN1cnNvci11bmRlcmxpbmUgeyBhbmltYXRpb246ICR7aX0gMXMgc3RlcC1lbmQgaW5maW5pdGU7fSR7dGhpcy5fdGVybWluYWxTZWxlY3Rvcn0gLiR7cH0uJHtTfSAueHRlcm0tY3Vyc29yLnh0ZXJtLWN1cnNvci1ibGluay54dGVybS1jdXJzb3ItYmFyIHsgYW5pbWF0aW9uOiAke3N9IDFzIHN0ZXAtZW5kIGluZmluaXRlO30ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IC4ke3B9LiR7U30gLnh0ZXJtLWN1cnNvci54dGVybS1jdXJzb3ItYmxpbmsueHRlcm0tY3Vyc29yLWJsb2NrIHsgYW5pbWF0aW9uOiAke3J9IDFzIHN0ZXAtZW5kIGluZmluaXRlO30ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IC4ke3B9IC54dGVybS1jdXJzb3IueHRlcm0tY3Vyc29yLWJsb2NrIHsgYmFja2dyb3VuZC1jb2xvcjogJHtlLmN1cnNvci5jc3N9OyBjb2xvcjogJHtlLmN1cnNvckFjY2VudC5jc3N9O30ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IC4ke3B9IC54dGVybS1jdXJzb3IueHRlcm0tY3Vyc29yLWJsb2NrOm5vdCgueHRlcm0tY3Vyc29yLWJsaW5rKSB7IGJhY2tncm91bmQtY29sb3I6ICR7ZS5jdXJzb3IuY3NzfSAhaW1wb3J0YW50OyBjb2xvcjogJHtlLmN1cnNvckFjY2VudC5jc3N9ICFpbXBvcnRhbnQ7fSR7dGhpcy5fdGVybWluYWxTZWxlY3Rvcn0gLiR7cH0gLnh0ZXJtLWN1cnNvci54dGVybS1jdXJzb3Itb3V0bGluZSB7IG91dGxpbmU6IDFweCBzb2xpZCAke2UuY3Vyc29yLmNzc307IG91dGxpbmUtb2Zmc2V0OiAtMXB4O30ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IC4ke3B9IC54dGVybS1jdXJzb3IueHRlcm0tY3Vyc29yLWJhciB7IGJveC1zaGFkb3c6ICR7dGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5jdXJzb3JXaWR0aH1weCAwIDAgJHtlLmN1cnNvci5jc3N9IGluc2V0O30ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IC4ke3B9IC54dGVybS1jdXJzb3IueHRlcm0tY3Vyc29yLXVuZGVybGluZSB7IGJvcmRlci1ib3R0b206IDFweCAke2UuY3Vyc29yLmNzc307IGJvcmRlci1ib3R0b20tc3R5bGU6IHNvbGlkOyBoZWlnaHQ6IGNhbGMoMTAwJSAtIDFweCk7fWAsdCs9YCR7dGhpcy5fdGVybWluYWxTZWxlY3Rvcn0gLiR7Q30geyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgei1pbmRleDogMTsgcG9pbnRlci1ldmVudHM6IG5vbmU7fSR7dGhpcy5fdGVybWluYWxTZWxlY3Rvcn0uZm9jdXMgLiR7Q30gZGl2IHsgcG9zaXRpb246IGFic29sdXRlOyBiYWNrZ3JvdW5kLWNvbG9yOiAke2Uuc2VsZWN0aW9uQmFja2dyb3VuZE9wYXF1ZS5jc3N9O30ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IC4ke0N9IGRpdiB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgYmFja2dyb3VuZC1jb2xvcjogJHtlLnNlbGVjdGlvbkluYWN0aXZlQmFja2dyb3VuZE9wYXF1ZS5jc3N9O31gO2Zvcihjb25zdFtpLHNdb2YgZS5hbnNpLmVudHJpZXMoKSl0Kz1gJHt0aGlzLl90ZXJtaW5hbFNlbGVjdG9yfSAuJHtnfSR7aX0geyBjb2xvcjogJHtzLmNzc307IH0ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IC4ke2d9JHtpfS54dGVybS1kaW0geyBjb2xvcjogJHtkLmNvbG9yLm11bHRpcGx5T3BhY2l0eShzLC41KS5jc3N9OyB9JHt0aGlzLl90ZXJtaW5hbFNlbGVjdG9yfSAuJHttfSR7aX0geyBiYWNrZ3JvdW5kLWNvbG9yOiAke3MuY3NzfTsgfWA7dCs9YCR7dGhpcy5fdGVybWluYWxTZWxlY3Rvcn0gLiR7Z30ke2EuSU5WRVJURURfREVGQVVMVF9DT0xPUn0geyBjb2xvcjogJHtkLmNvbG9yLm9wYXF1ZShlLmJhY2tncm91bmQpLmNzc307IH0ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IC4ke2d9JHthLklOVkVSVEVEX0RFRkFVTFRfQ09MT1J9Lnh0ZXJtLWRpbSB7IGNvbG9yOiAke2QuY29sb3IubXVsdGlwbHlPcGFjaXR5KGQuY29sb3Iub3BhcXVlKGUuYmFja2dyb3VuZCksLjUpLmNzc307IH0ke3RoaXMuX3Rlcm1pbmFsU2VsZWN0b3J9IC4ke219JHthLklOVkVSVEVEX0RFRkFVTFRfQ09MT1J9IHsgYmFja2dyb3VuZC1jb2xvcjogJHtlLmZvcmVncm91bmQuY3NzfTsgfWAsdGhpcy5fdGhlbWVTdHlsZUVsZW1lbnQudGV4dENvbnRlbnQ9dH1fc2V0RGVmYXVsdFNwYWNpbmcoKXtjb25zdCBlPXRoaXMuZGltZW5zaW9ucy5jc3MuY2VsbC53aWR0aC10aGlzLl93aWR0aENhY2hlLmdldChcIldcIiwhMSwhMSk7dGhpcy5fcm93Q29udGFpbmVyLnN0eWxlLmxldHRlclNwYWNpbmc9YCR7ZX1weGAsdGhpcy5fcm93RmFjdG9yeS5kZWZhdWx0U3BhY2luZz1lfWhhbmRsZURldmljZVBpeGVsUmF0aW9DaGFuZ2UoKXt0aGlzLl91cGRhdGVEaW1lbnNpb25zKCksdGhpcy5fd2lkdGhDYWNoZS5jbGVhcigpLHRoaXMuX3NldERlZmF1bHRTcGFjaW5nKCl9X3JlZnJlc2hSb3dFbGVtZW50cyhlLHQpe2ZvcihsZXQgZT10aGlzLl9yb3dFbGVtZW50cy5sZW5ndGg7ZTw9dDtlKyspe2NvbnN0IGU9dGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0aGlzLl9yb3dDb250YWluZXIuYXBwZW5kQ2hpbGQoZSksdGhpcy5fcm93RWxlbWVudHMucHVzaChlKX1mb3IoO3RoaXMuX3Jvd0VsZW1lbnRzLmxlbmd0aD50Oyl0aGlzLl9yb3dDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fcm93RWxlbWVudHMucG9wKCkpfWhhbmRsZVJlc2l6ZShlLHQpe3RoaXMuX3JlZnJlc2hSb3dFbGVtZW50cyhlLHQpLHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKSx0aGlzLmhhbmRsZVNlbGVjdGlvbkNoYW5nZWQodGhpcy5fc2VsZWN0aW9uUmVuZGVyTW9kZWwuc2VsZWN0aW9uU3RhcnQsdGhpcy5fc2VsZWN0aW9uUmVuZGVyTW9kZWwuc2VsZWN0aW9uRW5kLHRoaXMuX3NlbGVjdGlvblJlbmRlck1vZGVsLmNvbHVtblNlbGVjdE1vZGUpfWhhbmRsZUNoYXJTaXplQ2hhbmdlZCgpe3RoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKSx0aGlzLl93aWR0aENhY2hlLmNsZWFyKCksdGhpcy5fc2V0RGVmYXVsdFNwYWNpbmcoKX1oYW5kbGVCbHVyKCl7dGhpcy5fcm93Q29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoUyksdGhpcy5yZW5kZXJSb3dzKDAsdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLTEpfWhhbmRsZUZvY3VzKCl7dGhpcy5fcm93Q29udGFpbmVyLmNsYXNzTGlzdC5hZGQoUyksdGhpcy5yZW5kZXJSb3dzKHRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLnksdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIueSl9aGFuZGxlU2VsZWN0aW9uQ2hhbmdlZChlLHQsaSl7aWYodGhpcy5fc2VsZWN0aW9uQ29udGFpbmVyLnJlcGxhY2VDaGlsZHJlbigpLHRoaXMuX3Jvd0ZhY3RvcnkuaGFuZGxlU2VsZWN0aW9uQ2hhbmdlZChlLHQsaSksdGhpcy5yZW5kZXJSb3dzKDAsdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLTEpLCFlfHwhdClyZXR1cm47dGhpcy5fc2VsZWN0aW9uUmVuZGVyTW9kZWwudXBkYXRlKHRoaXMuX3Rlcm1pbmFsLGUsdCxpKTtjb25zdCBzPXRoaXMuX3NlbGVjdGlvblJlbmRlck1vZGVsLnZpZXdwb3J0U3RhcnRSb3cscj10aGlzLl9zZWxlY3Rpb25SZW5kZXJNb2RlbC52aWV3cG9ydEVuZFJvdyxuPXRoaXMuX3NlbGVjdGlvblJlbmRlck1vZGVsLnZpZXdwb3J0Q2FwcGVkU3RhcnRSb3csbz10aGlzLl9zZWxlY3Rpb25SZW5kZXJNb2RlbC52aWV3cG9ydENhcHBlZEVuZFJvdztpZihuPj10aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3N8fG88MClyZXR1cm47Y29uc3QgYT10aGlzLl9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7aWYoaSl7Y29uc3QgaT1lWzBdPnRbMF07YS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVTZWxlY3Rpb25FbGVtZW50KG4saT90WzBdOmVbMF0saT9lWzBdOnRbMF0sby1uKzEpKX1lbHNle2NvbnN0IGk9cz09PW4/ZVswXTowLGg9bj09PXI/dFswXTp0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHM7YS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVTZWxlY3Rpb25FbGVtZW50KG4saSxoKSk7Y29uc3QgYz1vLW4tMTtpZihhLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZVNlbGVjdGlvbkVsZW1lbnQobisxLDAsdGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLGMpKSxuIT09byl7Y29uc3QgZT1yPT09bz90WzBdOnRoaXMuX2J1ZmZlclNlcnZpY2UuY29sczthLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZVNlbGVjdGlvbkVsZW1lbnQobywwLGUpKX19dGhpcy5fc2VsZWN0aW9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGEpfV9jcmVhdGVTZWxlY3Rpb25FbGVtZW50KGUsdCxpLHM9MSl7Y29uc3Qgcj10aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG49dCp0aGlzLmRpbWVuc2lvbnMuY3NzLmNlbGwud2lkdGg7bGV0IG89dGhpcy5kaW1lbnNpb25zLmNzcy5jZWxsLndpZHRoKihpLXQpO3JldHVybiBuK28+dGhpcy5kaW1lbnNpb25zLmNzcy5jYW52YXMud2lkdGgmJihvPXRoaXMuZGltZW5zaW9ucy5jc3MuY2FudmFzLndpZHRoLW4pLHIuc3R5bGUuaGVpZ2h0PXMqdGhpcy5kaW1lbnNpb25zLmNzcy5jZWxsLmhlaWdodCtcInB4XCIsci5zdHlsZS50b3A9ZSp0aGlzLmRpbWVuc2lvbnMuY3NzLmNlbGwuaGVpZ2h0K1wicHhcIixyLnN0eWxlLmxlZnQ9YCR7bn1weGAsci5zdHlsZS53aWR0aD1gJHtvfXB4YCxyfWhhbmRsZUN1cnNvck1vdmUoKXt9X2hhbmRsZU9wdGlvbnNDaGFuZ2VkKCl7dGhpcy5fdXBkYXRlRGltZW5zaW9ucygpLHRoaXMuX2luamVjdENzcyh0aGlzLl90aGVtZVNlcnZpY2UuY29sb3JzKSx0aGlzLl93aWR0aENhY2hlLnNldEZvbnQodGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5mb250RmFtaWx5LHRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuZm9udFNpemUsdGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5mb250V2VpZ2h0LHRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuZm9udFdlaWdodEJvbGQpLHRoaXMuX3NldERlZmF1bHRTcGFjaW5nKCl9Y2xlYXIoKXtmb3IoY29uc3QgZSBvZiB0aGlzLl9yb3dFbGVtZW50cyllLnJlcGxhY2VDaGlsZHJlbigpfXJlbmRlclJvd3MoZSx0KXtjb25zdCBpPXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLHM9aS55YmFzZStpLnkscj1NYXRoLm1pbihpLngsdGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLTEpLG49dGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5jdXJzb3JCbGluayxvPXRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuY3Vyc29yU3R5bGUsYT10aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmN1cnNvckluYWN0aXZlU3R5bGU7Zm9yKGxldCBoPWU7aDw9dDtoKyspe2NvbnN0IGU9aCtpLnlkaXNwLHQ9dGhpcy5fcm93RWxlbWVudHNbaF0sYz1pLmxpbmVzLmdldChlKTtpZighdHx8IWMpYnJlYWs7dC5yZXBsYWNlQ2hpbGRyZW4oLi4udGhpcy5fcm93RmFjdG9yeS5jcmVhdGVSb3coYyxlLGU9PT1zLG8sYSxyLG4sdGhpcy5kaW1lbnNpb25zLmNzcy5jZWxsLndpZHRoLHRoaXMuX3dpZHRoQ2FjaGUsLTEsLTEpKX19Z2V0IF90ZXJtaW5hbFNlbGVjdG9yKCl7cmV0dXJuYC4ke3Z9JHt0aGlzLl90ZXJtaW5hbENsYXNzfWB9X2hhbmRsZUxpbmtIb3ZlcihlKXt0aGlzLl9zZXRDZWxsVW5kZXJsaW5lKGUueDEsZS54MixlLnkxLGUueTIsZS5jb2xzLCEwKX1faGFuZGxlTGlua0xlYXZlKGUpe3RoaXMuX3NldENlbGxVbmRlcmxpbmUoZS54MSxlLngyLGUueTEsZS55MixlLmNvbHMsITEpfV9zZXRDZWxsVW5kZXJsaW5lKGUsdCxpLHMscixuKXtpPDAmJihlPTApLHM8MCYmKHQ9MCk7Y29uc3Qgbz10aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3MtMTtpPU1hdGgubWF4KE1hdGgubWluKGksbyksMCkscz1NYXRoLm1heChNYXRoLm1pbihzLG8pLDApLHI9TWF0aC5taW4ocix0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpO2NvbnN0IGE9dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIsaD1hLnliYXNlK2EueSxjPU1hdGgubWluKGEueCxyLTEpLGw9dGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5jdXJzb3JCbGluayxkPXRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuY3Vyc29yU3R5bGUsXz10aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmN1cnNvckluYWN0aXZlU3R5bGU7Zm9yKGxldCBvPWk7bzw9czsrK28pe2NvbnN0IHU9bythLnlkaXNwLGY9dGhpcy5fcm93RWxlbWVudHNbb10sdj1hLmxpbmVzLmdldCh1KTtpZighZnx8IXYpYnJlYWs7Zi5yZXBsYWNlQ2hpbGRyZW4oLi4udGhpcy5fcm93RmFjdG9yeS5jcmVhdGVSb3codix1LHU9PT1oLGQsXyxjLGwsdGhpcy5kaW1lbnNpb25zLmNzcy5jZWxsLndpZHRoLHRoaXMuX3dpZHRoQ2FjaGUsbj9vPT09aT9lOjA6LTEsbj8obz09PXM/dDpyKS0xOi0xKSl9fX07dC5Eb21SZW5kZXJlcj13PXMoW3IoNyxmLklJbnN0YW50aWF0aW9uU2VydmljZSkscig4LGwuSUNoYXJTaXplU2VydmljZSkscig5LGYuSU9wdGlvbnNTZXJ2aWNlKSxyKDEwLGYuSUJ1ZmZlclNlcnZpY2UpLHIoMTEsbC5JQ29yZUJyb3dzZXJTZXJ2aWNlKSxyKDEyLGwuSVRoZW1lU2VydmljZSldLHcpfSwzNzg3OmZ1bmN0aW9uKGUsdCxpKXt2YXIgcz10aGlzJiZ0aGlzLl9fZGVjb3JhdGV8fGZ1bmN0aW9uKGUsdCxpLHMpe3ZhciByLG49YXJndW1lbnRzLmxlbmd0aCxvPW48Mz90Om51bGw9PT1zP3M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGkpOnM7aWYoXCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3QmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUpbz1SZWZsZWN0LmRlY29yYXRlKGUsdCxpLHMpO2Vsc2UgZm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MDthLS0pKHI9ZVthXSkmJihvPShuPDM/cihvKTpuPjM/cih0LGksbyk6cih0LGkpKXx8byk7cmV0dXJuIG4+MyYmbyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSxvKSxvfSxyPXRoaXMmJnRoaXMuX19wYXJhbXx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oaSxzKXt0KGkscyxlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRG9tUmVuZGVyZXJSb3dGYWN0b3J5PXZvaWQgMDtjb25zdCBuPWkoMjIyMyksbz1pKDY0MyksYT1pKDUxMSksaD1pKDI1ODUpLGM9aSg4MDU1KSxsPWkoNDcyNSksZD1pKDQyNjkpLF89aSg2MTcxKSx1PWkoMzczNCk7bGV0IGY9dC5Eb21SZW5kZXJlclJvd0ZhY3Rvcnk9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LGkscyxyLG4sbyl7dGhpcy5fZG9jdW1lbnQ9ZSx0aGlzLl9jaGFyYWN0ZXJKb2luZXJTZXJ2aWNlPXQsdGhpcy5fb3B0aW9uc1NlcnZpY2U9aSx0aGlzLl9jb3JlQnJvd3NlclNlcnZpY2U9cyx0aGlzLl9jb3JlU2VydmljZT1yLHRoaXMuX2RlY29yYXRpb25TZXJ2aWNlPW4sdGhpcy5fdGhlbWVTZXJ2aWNlPW8sdGhpcy5fd29ya0NlbGw9bmV3IGEuQ2VsbERhdGEsdGhpcy5fY29sdW1uU2VsZWN0TW9kZT0hMSx0aGlzLmRlZmF1bHRTcGFjaW5nPTB9aGFuZGxlU2VsZWN0aW9uQ2hhbmdlZChlLHQsaSl7dGhpcy5fc2VsZWN0aW9uU3RhcnQ9ZSx0aGlzLl9zZWxlY3Rpb25FbmQ9dCx0aGlzLl9jb2x1bW5TZWxlY3RNb2RlPWl9Y3JlYXRlUm93KGUsdCxpLHMscixhLGgsbCxfLGYscCl7Y29uc3QgZz1bXSxtPXRoaXMuX2NoYXJhY3RlckpvaW5lclNlcnZpY2UuZ2V0Sm9pbmVkQ2hhcmFjdGVycyh0KSxTPXRoaXMuX3RoZW1lU2VydmljZS5jb2xvcnM7bGV0IEMsYj1lLmdldE5vQmdUcmltbWVkTGVuZ3RoKCk7aSYmYjxhKzEmJihiPWErMSk7bGV0IHc9MCx5PVwiXCIsRT0wLGs9MCxMPTAsRD0hMSxSPTAseD0hMSxBPTA7Y29uc3QgQj1bXSxUPS0xIT09ZiYmLTEhPT1wO2ZvcihsZXQgTT0wO008YjtNKyspe2UubG9hZENlbGwoTSx0aGlzLl93b3JrQ2VsbCk7bGV0IGI9dGhpcy5fd29ya0NlbGwuZ2V0V2lkdGgoKTtpZigwPT09Yiljb250aW51ZTtsZXQgTz0hMSxQPU0sST10aGlzLl93b3JrQ2VsbDtpZihtLmxlbmd0aD4wJiZNPT09bVswXVswXSl7Tz0hMDtjb25zdCB0PW0uc2hpZnQoKTtJPW5ldyBkLkpvaW5lZENlbGxEYXRhKHRoaXMuX3dvcmtDZWxsLGUudHJhbnNsYXRlVG9TdHJpbmcoITAsdFswXSx0WzFdKSx0WzFdLXRbMF0pLFA9dFsxXS0xLGI9SS5nZXRXaWR0aCgpfWNvbnN0IEg9dGhpcy5faXNDZWxsSW5TZWxlY3Rpb24oTSx0KSxGPWkmJk09PT1hLFc9VCYmTT49ZiYmTTw9cDtsZXQgVT0hMTt0aGlzLl9kZWNvcmF0aW9uU2VydmljZS5mb3JFYWNoRGVjb3JhdGlvbkF0Q2VsbChNLHQsdm9pZCAwLChlPT57VT0hMH0pKTtsZXQgTj1JLmdldENoYXJzKCl8fG8uV0hJVEVTUEFDRV9DRUxMX0NIQVI7aWYoXCIgXCI9PT1OJiYoSS5pc1VuZGVybGluZSgpfHxJLmlzT3ZlcmxpbmUoKSkmJihOPVwiwqBcIiksQT1iKmwtXy5nZXQoTixJLmlzQm9sZCgpLEkuaXNJdGFsaWMoKSksQyl7aWYodyYmKEgmJnh8fCFIJiYheCYmSS5iZz09PUUpJiYoSCYmeCYmUy5zZWxlY3Rpb25Gb3JlZ3JvdW5kfHxJLmZnPT09aykmJkkuZXh0ZW5kZWQuZXh0PT09TCYmVz09PUQmJkE9PT1SJiYhRiYmIU8mJiFVKXtJLmlzSW52aXNpYmxlKCk/eSs9by5XSElURVNQQUNFX0NFTExfQ0hBUjp5Kz1OLHcrKztjb250aW51ZX13JiYoQy50ZXh0Q29udGVudD15KSxDPXRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLHc9MCx5PVwiXCJ9ZWxzZSBDPXRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO2lmKEU9SS5iZyxrPUkuZmcsTD1JLmV4dGVuZGVkLmV4dCxEPVcsUj1BLHg9SCxPJiZhPj1NJiZhPD1QJiYoYT1NKSwhdGhpcy5fY29yZVNlcnZpY2UuaXNDdXJzb3JIaWRkZW4mJkYmJnRoaXMuX2NvcmVTZXJ2aWNlLmlzQ3Vyc29ySW5pdGlhbGl6ZWQpaWYoQi5wdXNoKFwieHRlcm0tY3Vyc29yXCIpLHRoaXMuX2NvcmVCcm93c2VyU2VydmljZS5pc0ZvY3VzZWQpaCYmQi5wdXNoKFwieHRlcm0tY3Vyc29yLWJsaW5rXCIpLEIucHVzaChcImJhclwiPT09cz9cInh0ZXJtLWN1cnNvci1iYXJcIjpcInVuZGVybGluZVwiPT09cz9cInh0ZXJtLWN1cnNvci11bmRlcmxpbmVcIjpcInh0ZXJtLWN1cnNvci1ibG9ja1wiKTtlbHNlIGlmKHIpc3dpdGNoKHIpe2Nhc2VcIm91dGxpbmVcIjpCLnB1c2goXCJ4dGVybS1jdXJzb3Itb3V0bGluZVwiKTticmVhaztjYXNlXCJibG9ja1wiOkIucHVzaChcInh0ZXJtLWN1cnNvci1ibG9ja1wiKTticmVhaztjYXNlXCJiYXJcIjpCLnB1c2goXCJ4dGVybS1jdXJzb3ItYmFyXCIpO2JyZWFrO2Nhc2VcInVuZGVybGluZVwiOkIucHVzaChcInh0ZXJtLWN1cnNvci11bmRlcmxpbmVcIil9aWYoSS5pc0JvbGQoKSYmQi5wdXNoKFwieHRlcm0tYm9sZFwiKSxJLmlzSXRhbGljKCkmJkIucHVzaChcInh0ZXJtLWl0YWxpY1wiKSxJLmlzRGltKCkmJkIucHVzaChcInh0ZXJtLWRpbVwiKSx5PUkuaXNJbnZpc2libGUoKT9vLldISVRFU1BBQ0VfQ0VMTF9DSEFSOkkuZ2V0Q2hhcnMoKXx8by5XSElURVNQQUNFX0NFTExfQ0hBUixJLmlzVW5kZXJsaW5lKCkmJihCLnB1c2goYHh0ZXJtLXVuZGVybGluZS0ke0kuZXh0ZW5kZWQudW5kZXJsaW5lU3R5bGV9YCksXCIgXCI9PT15JiYoeT1cIsKgXCIpLCFJLmlzVW5kZXJsaW5lQ29sb3JEZWZhdWx0KCkpKWlmKEkuaXNVbmRlcmxpbmVDb2xvclJHQigpKUMuc3R5bGUudGV4dERlY29yYXRpb25Db2xvcj1gcmdiKCR7dS5BdHRyaWJ1dGVEYXRhLnRvQ29sb3JSR0IoSS5nZXRVbmRlcmxpbmVDb2xvcigpKS5qb2luKFwiLFwiKX0pYDtlbHNle2xldCBlPUkuZ2V0VW5kZXJsaW5lQ29sb3IoKTt0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmRyYXdCb2xkVGV4dEluQnJpZ2h0Q29sb3JzJiZJLmlzQm9sZCgpJiZlPDgmJihlKz04KSxDLnN0eWxlLnRleHREZWNvcmF0aW9uQ29sb3I9Uy5hbnNpW2VdLmNzc31JLmlzT3ZlcmxpbmUoKSYmKEIucHVzaChcInh0ZXJtLW92ZXJsaW5lXCIpLFwiIFwiPT09eSYmKHk9XCLCoFwiKSksSS5pc1N0cmlrZXRocm91Z2goKSYmQi5wdXNoKFwieHRlcm0tc3RyaWtldGhyb3VnaFwiKSxXJiYoQy5zdHlsZS50ZXh0RGVjb3JhdGlvbj1cInVuZGVybGluZVwiKTtsZXQgJD1JLmdldEZnQ29sb3IoKSxqPUkuZ2V0RmdDb2xvck1vZGUoKSx6PUkuZ2V0QmdDb2xvcigpLEs9SS5nZXRCZ0NvbG9yTW9kZSgpO2NvbnN0IHE9ISFJLmlzSW52ZXJzZSgpO2lmKHEpe2NvbnN0IGU9JDskPXosej1lO2NvbnN0IHQ9ajtqPUssSz10fWxldCBWLEcsWCxKPSExO3N3aXRjaCh0aGlzLl9kZWNvcmF0aW9uU2VydmljZS5mb3JFYWNoRGVjb3JhdGlvbkF0Q2VsbChNLHQsdm9pZCAwLChlPT57XCJ0b3BcIiE9PWUub3B0aW9ucy5sYXllciYmSnx8KGUuYmFja2dyb3VuZENvbG9yUkdCJiYoSz01MDMzMTY0OCx6PWUuYmFja2dyb3VuZENvbG9yUkdCLnJnYmE+PjgmMTY3NzcyMTUsVj1lLmJhY2tncm91bmRDb2xvclJHQiksZS5mb3JlZ3JvdW5kQ29sb3JSR0ImJihqPTUwMzMxNjQ4LCQ9ZS5mb3JlZ3JvdW5kQ29sb3JSR0IucmdiYT4+OCYxNjc3NzIxNSxHPWUuZm9yZWdyb3VuZENvbG9yUkdCKSxKPVwidG9wXCI9PT1lLm9wdGlvbnMubGF5ZXIpfSkpLCFKJiZIJiYoVj10aGlzLl9jb3JlQnJvd3NlclNlcnZpY2UuaXNGb2N1c2VkP1Muc2VsZWN0aW9uQmFja2dyb3VuZE9wYXF1ZTpTLnNlbGVjdGlvbkluYWN0aXZlQmFja2dyb3VuZE9wYXF1ZSx6PVYucmdiYT4+OCYxNjc3NzIxNSxLPTUwMzMxNjQ4LEo9ITAsUy5zZWxlY3Rpb25Gb3JlZ3JvdW5kJiYoaj01MDMzMTY0OCwkPVMuc2VsZWN0aW9uRm9yZWdyb3VuZC5yZ2JhPj44JjE2Nzc3MjE1LEc9Uy5zZWxlY3Rpb25Gb3JlZ3JvdW5kKSksSiYmQi5wdXNoKFwieHRlcm0tZGVjb3JhdGlvbi10b3BcIiksSyl7Y2FzZSAxNjc3NzIxNjpjYXNlIDMzNTU0NDMyOlg9Uy5hbnNpW3pdLEIucHVzaChgeHRlcm0tYmctJHt6fWApO2JyZWFrO2Nhc2UgNTAzMzE2NDg6WD1jLmNoYW5uZWxzLnRvQ29sb3Ioej4+MTYsej4+OCYyNTUsMjU1JnopLHRoaXMuX2FkZFN0eWxlKEMsYGJhY2tncm91bmQtY29sb3I6IyR7digoej4+PjApLnRvU3RyaW5nKDE2KSxcIjBcIiw2KX1gKTticmVhaztkZWZhdWx0OnE/KFg9Uy5mb3JlZ3JvdW5kLEIucHVzaChgeHRlcm0tYmctJHtuLklOVkVSVEVEX0RFRkFVTFRfQ09MT1J9YCkpOlg9Uy5iYWNrZ3JvdW5kfXN3aXRjaChWfHxJLmlzRGltKCkmJihWPWMuY29sb3IubXVsdGlwbHlPcGFjaXR5KFgsLjUpKSxqKXtjYXNlIDE2Nzc3MjE2OmNhc2UgMzM1NTQ0MzI6SS5pc0JvbGQoKSYmJDw4JiZ0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmRyYXdCb2xkVGV4dEluQnJpZ2h0Q29sb3JzJiYoJCs9OCksdGhpcy5fYXBwbHlNaW5pbXVtQ29udHJhc3QoQyxYLFMuYW5zaVskXSxJLFYsdm9pZCAwKXx8Qi5wdXNoKGB4dGVybS1mZy0keyR9YCk7YnJlYWs7Y2FzZSA1MDMzMTY0ODpjb25zdCBlPWMuY2hhbm5lbHMudG9Db2xvcigkPj4xNiYyNTUsJD4+OCYyNTUsMjU1JiQpO3RoaXMuX2FwcGx5TWluaW11bUNvbnRyYXN0KEMsWCxlLEksVixHKXx8dGhpcy5fYWRkU3R5bGUoQyxgY29sb3I6IyR7digkLnRvU3RyaW5nKDE2KSxcIjBcIiw2KX1gKTticmVhaztkZWZhdWx0OnRoaXMuX2FwcGx5TWluaW11bUNvbnRyYXN0KEMsWCxTLmZvcmVncm91bmQsSSxWLEcpfHxxJiZCLnB1c2goYHh0ZXJtLWZnLSR7bi5JTlZFUlRFRF9ERUZBVUxUX0NPTE9SfWApfUIubGVuZ3RoJiYoQy5jbGFzc05hbWU9Qi5qb2luKFwiIFwiKSxCLmxlbmd0aD0wKSxGfHxPfHxVP0MudGV4dENvbnRlbnQ9eTp3KyssQSE9PXRoaXMuZGVmYXVsdFNwYWNpbmcmJihDLnN0eWxlLmxldHRlclNwYWNpbmc9YCR7QX1weGApLGcucHVzaChDKSxNPVB9cmV0dXJuIEMmJncmJihDLnRleHRDb250ZW50PXkpLGd9X2FwcGx5TWluaW11bUNvbnRyYXN0KGUsdCxpLHMscixuKXtpZigxPT09dGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5taW5pbXVtQ29udHJhc3RSYXRpb3x8KDAsXy50cmVhdEdseXBoQXNCYWNrZ3JvdW5kQ29sb3IpKHMuZ2V0Q29kZSgpKSlyZXR1cm4hMTtjb25zdCBvPXRoaXMuX2dldENvbnRyYXN0Q2FjaGUocyk7bGV0IGE7aWYocnx8bnx8KGE9by5nZXRDb2xvcih0LnJnYmEsaS5yZ2JhKSksdm9pZCAwPT09YSl7Y29uc3QgZT10aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLm1pbmltdW1Db250cmFzdFJhdGlvLyhzLmlzRGltKCk/MjoxKTthPWMuY29sb3IuZW5zdXJlQ29udHJhc3RSYXRpbyhyfHx0LG58fGksZSksby5zZXRDb2xvcigocnx8dCkucmdiYSwobnx8aSkucmdiYSxhPz9udWxsKX1yZXR1cm4hIWEmJih0aGlzLl9hZGRTdHlsZShlLGBjb2xvcjoke2EuY3NzfWApLCEwKX1fZ2V0Q29udHJhc3RDYWNoZShlKXtyZXR1cm4gZS5pc0RpbSgpP3RoaXMuX3RoZW1lU2VydmljZS5jb2xvcnMuaGFsZkNvbnRyYXN0Q2FjaGU6dGhpcy5fdGhlbWVTZXJ2aWNlLmNvbG9ycy5jb250cmFzdENhY2hlfV9hZGRTdHlsZShlLHQpe2Uuc2V0QXR0cmlidXRlKFwic3R5bGVcIixgJHtlLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpfHxcIlwifSR7dH07YCl9X2lzQ2VsbEluU2VsZWN0aW9uKGUsdCl7Y29uc3QgaT10aGlzLl9zZWxlY3Rpb25TdGFydCxzPXRoaXMuX3NlbGVjdGlvbkVuZDtyZXR1cm4hKCFpfHwhcykmJih0aGlzLl9jb2x1bW5TZWxlY3RNb2RlP2lbMF08PXNbMF0/ZT49aVswXSYmdD49aVsxXSYmZTxzWzBdJiZ0PD1zWzFdOmU8aVswXSYmdD49aVsxXSYmZT49c1swXSYmdDw9c1sxXTp0PmlbMV0mJnQ8c1sxXXx8aVsxXT09PXNbMV0mJnQ9PT1pWzFdJiZlPj1pWzBdJiZlPHNbMF18fGlbMV08c1sxXSYmdD09PXNbMV0mJmU8c1swXXx8aVsxXTxzWzFdJiZ0PT09aVsxXSYmZT49aVswXSl9fTtmdW5jdGlvbiB2KGUsdCxpKXtmb3IoO2UubGVuZ3RoPGk7KWU9dCtlO3JldHVybiBlfXQuRG9tUmVuZGVyZXJSb3dGYWN0b3J5PWY9cyhbcigxLGwuSUNoYXJhY3RlckpvaW5lclNlcnZpY2UpLHIoMixoLklPcHRpb25zU2VydmljZSkscigzLGwuSUNvcmVCcm93c2VyU2VydmljZSkscig0LGguSUNvcmVTZXJ2aWNlKSxyKDUsaC5JRGVjb3JhdGlvblNlcnZpY2UpLHIoNixsLklUaGVtZVNlcnZpY2UpXSxmKX0sMjU1MDooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuV2lkdGhDYWNoZT12b2lkIDAsdC5XaWR0aENhY2hlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5fZmxhdD1uZXcgRmxvYXQzMkFycmF5KDI1NiksdGhpcy5fZm9udD1cIlwiLHRoaXMuX2ZvbnRTaXplPTAsdGhpcy5fd2VpZ2h0PVwibm9ybWFsXCIsdGhpcy5fd2VpZ2h0Qm9sZD1cImJvbGRcIix0aGlzLl9tZWFzdXJlRWxlbWVudHM9W10sdGhpcy5fY29udGFpbmVyPWUuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInh0ZXJtLXdpZHRoLWNhY2hlLW1lYXN1cmUtY29udGFpbmVyXCIpLHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKSx0aGlzLl9jb250YWluZXIuc3R5bGUud2hpdGVTcGFjZT1cInByZVwiLHRoaXMuX2NvbnRhaW5lci5zdHlsZS5mb250S2VybmluZz1cIm5vbmVcIjtjb25zdCBpPWUuY3JlYXRlRWxlbWVudChcInNwYW5cIik7aS5jbGFzc0xpc3QuYWRkKFwieHRlcm0tY2hhci1tZWFzdXJlLWVsZW1lbnRcIik7Y29uc3Qgcz1lLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO3MuY2xhc3NMaXN0LmFkZChcInh0ZXJtLWNoYXItbWVhc3VyZS1lbGVtZW50XCIpLHMuc3R5bGUuZm9udFdlaWdodD1cImJvbGRcIjtjb25zdCByPWUuY3JlYXRlRWxlbWVudChcInNwYW5cIik7ci5jbGFzc0xpc3QuYWRkKFwieHRlcm0tY2hhci1tZWFzdXJlLWVsZW1lbnRcIiksci5zdHlsZS5mb250U3R5bGU9XCJpdGFsaWNcIjtjb25zdCBuPWUuY3JlYXRlRWxlbWVudChcInNwYW5cIik7bi5jbGFzc0xpc3QuYWRkKFwieHRlcm0tY2hhci1tZWFzdXJlLWVsZW1lbnRcIiksbi5zdHlsZS5mb250V2VpZ2h0PVwiYm9sZFwiLG4uc3R5bGUuZm9udFN0eWxlPVwiaXRhbGljXCIsdGhpcy5fbWVhc3VyZUVsZW1lbnRzPVtpLHMscixuXSx0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoaSksdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHMpLHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChyKSx0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQobiksdC5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpLHRoaXMuY2xlYXIoKX1kaXNwb3NlKCl7dGhpcy5fY29udGFpbmVyLnJlbW92ZSgpLHRoaXMuX21lYXN1cmVFbGVtZW50cy5sZW5ndGg9MCx0aGlzLl9ob2xleT12b2lkIDB9Y2xlYXIoKXt0aGlzLl9mbGF0LmZpbGwoLTk5OTkpLHRoaXMuX2hvbGV5PW5ldyBNYXB9c2V0Rm9udChlLHQsaSxzKXtlPT09dGhpcy5fZm9udCYmdD09PXRoaXMuX2ZvbnRTaXplJiZpPT09dGhpcy5fd2VpZ2h0JiZzPT09dGhpcy5fd2VpZ2h0Qm9sZHx8KHRoaXMuX2ZvbnQ9ZSx0aGlzLl9mb250U2l6ZT10LHRoaXMuX3dlaWdodD1pLHRoaXMuX3dlaWdodEJvbGQ9cyx0aGlzLl9jb250YWluZXIuc3R5bGUuZm9udEZhbWlseT10aGlzLl9mb250LHRoaXMuX2NvbnRhaW5lci5zdHlsZS5mb250U2l6ZT1gJHt0aGlzLl9mb250U2l6ZX1weGAsdGhpcy5fbWVhc3VyZUVsZW1lbnRzWzBdLnN0eWxlLmZvbnRXZWlnaHQ9YCR7aX1gLHRoaXMuX21lYXN1cmVFbGVtZW50c1sxXS5zdHlsZS5mb250V2VpZ2h0PWAke3N9YCx0aGlzLl9tZWFzdXJlRWxlbWVudHNbMl0uc3R5bGUuZm9udFdlaWdodD1gJHtpfWAsdGhpcy5fbWVhc3VyZUVsZW1lbnRzWzNdLnN0eWxlLmZvbnRXZWlnaHQ9YCR7c31gLHRoaXMuY2xlYXIoKSl9Z2V0KGUsdCxpKXtsZXQgcz0wO2lmKCF0JiYhaSYmMT09PWUubGVuZ3RoJiYocz1lLmNoYXJDb2RlQXQoMCkpPDI1Nil7aWYoLTk5OTkhPT10aGlzLl9mbGF0W3NdKXJldHVybiB0aGlzLl9mbGF0W3NdO2NvbnN0IHQ9dGhpcy5fbWVhc3VyZShlLDApO3JldHVybiB0PjAmJih0aGlzLl9mbGF0W3NdPXQpLHR9bGV0IHI9ZTt0JiYocis9XCJCXCIpLGkmJihyKz1cIklcIik7bGV0IG49dGhpcy5faG9sZXkuZ2V0KHIpO2lmKHZvaWQgMD09PW4pe2xldCBzPTA7dCYmKHN8PTEpLGkmJihzfD0yKSxuPXRoaXMuX21lYXN1cmUoZSxzKSxuPjAmJnRoaXMuX2hvbGV5LnNldChyLG4pfXJldHVybiBufV9tZWFzdXJlKGUsdCl7Y29uc3QgaT10aGlzLl9tZWFzdXJlRWxlbWVudHNbdF07cmV0dXJuIGkudGV4dENvbnRlbnQ9ZS5yZXBlYXQoMzIpLGkub2Zmc2V0V2lkdGgvMzJ9fX0sMjIyMzooZSx0LGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5URVhUX0JBU0VMSU5FPXQuRElNX09QQUNJVFk9dC5JTlZFUlRFRF9ERUZBVUxUX0NPTE9SPXZvaWQgMDtjb25zdCBzPWkoNjExNCk7dC5JTlZFUlRFRF9ERUZBVUxUX0NPTE9SPTI1Nyx0LkRJTV9PUEFDSVRZPS41LHQuVEVYVF9CQVNFTElORT1zLmlzRmlyZWZveHx8cy5pc0xlZ2FjeUVkZ2U/XCJib3R0b21cIjpcImlkZW9ncmFwaGljXCJ9LDYxNzE6KGUsdCk9PntmdW5jdGlvbiBpKGUpe3JldHVybiA1NzUwODw9ZSYmZTw9NTc1NTh9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZT49MTI4NTEyJiZlPD0xMjg1OTF8fGU+PTEyNzc0NCYmZTw9MTI4NTExfHxlPj0xMjg2NDAmJmU8PTEyODc2N3x8ZT49OTcyOCYmZTw9OTk4M3x8ZT49OTk4NCYmZTw9MTAxNzV8fGU+PTY1MDI0JiZlPD02NTAzOXx8ZT49MTI5MjgwJiZlPD0xMjk1MzV8fGU+PTEyNzQ2MiYmZTw9MTI3NDg3fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY29tcHV0ZU5leHRWYXJpYW50T2Zmc2V0PXQuY3JlYXRlUmVuZGVyRGltZW5zaW9ucz10LnRyZWF0R2x5cGhBc0JhY2tncm91bmRDb2xvcj10LmFsbG93UmVzY2FsaW5nPXQuaXNFbW9qaT10LmlzUmVzdHJpY3RlZFBvd2VybGluZUdseXBoPXQuaXNQb3dlcmxpbmVHbHlwaD10LnRocm93SWZGYWxzeT12b2lkIDAsdC50aHJvd0lmRmFsc3k9ZnVuY3Rpb24oZSl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgbXVzdCBub3QgYmUgZmFsc3lcIik7cmV0dXJuIGV9LHQuaXNQb3dlcmxpbmVHbHlwaD1pLHQuaXNSZXN0cmljdGVkUG93ZXJsaW5lR2x5cGg9ZnVuY3Rpb24oZSl7cmV0dXJuIDU3NTIwPD1lJiZlPD01NzUyN30sdC5pc0Vtb2ppPXMsdC5hbGxvd1Jlc2NhbGluZz1mdW5jdGlvbihlLHQscixuKXtyZXR1cm4gMT09PXQmJnI+TWF0aC5jZWlsKDEuNSpuKSYmdm9pZCAwIT09ZSYmZT4yNTUmJiFzKGUpJiYhaShlKSYmIWZ1bmN0aW9uKGUpe3JldHVybiA1NzM0NDw9ZSYmZTw9NjM3NDN9KGUpfSx0LnRyZWF0R2x5cGhBc0JhY2tncm91bmRDb2xvcj1mdW5jdGlvbihlKXtyZXR1cm4gaShlKXx8ZnVuY3Rpb24oZSl7cmV0dXJuIDk0NzI8PWUmJmU8PTk2MzF9KGUpfSx0LmNyZWF0ZVJlbmRlckRpbWVuc2lvbnM9ZnVuY3Rpb24oKXtyZXR1cm57Y3NzOntjYW52YXM6e3dpZHRoOjAsaGVpZ2h0OjB9LGNlbGw6e3dpZHRoOjAsaGVpZ2h0OjB9fSxkZXZpY2U6e2NhbnZhczp7d2lkdGg6MCxoZWlnaHQ6MH0sY2VsbDp7d2lkdGg6MCxoZWlnaHQ6MH0sY2hhcjp7d2lkdGg6MCxoZWlnaHQ6MCxsZWZ0OjAsdG9wOjB9fX19LHQuY29tcHV0ZU5leHRWYXJpYW50T2Zmc2V0PWZ1bmN0aW9uKGUsdCxpPTApe3JldHVybihlLSgyKk1hdGgucm91bmQodCktaSkpJSgyKk1hdGgucm91bmQodCkpfX0sNjA1MjooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlU2VsZWN0aW9uUmVuZGVyTW9kZWw9dm9pZCAwO2NsYXNzIGl7Y29uc3RydWN0b3IoKXt0aGlzLmNsZWFyKCl9Y2xlYXIoKXt0aGlzLmhhc1NlbGVjdGlvbj0hMSx0aGlzLmNvbHVtblNlbGVjdE1vZGU9ITEsdGhpcy52aWV3cG9ydFN0YXJ0Um93PTAsdGhpcy52aWV3cG9ydEVuZFJvdz0wLHRoaXMudmlld3BvcnRDYXBwZWRTdGFydFJvdz0wLHRoaXMudmlld3BvcnRDYXBwZWRFbmRSb3c9MCx0aGlzLnN0YXJ0Q29sPTAsdGhpcy5lbmRDb2w9MCx0aGlzLnNlbGVjdGlvblN0YXJ0PXZvaWQgMCx0aGlzLnNlbGVjdGlvbkVuZD12b2lkIDB9dXBkYXRlKGUsdCxpLHM9ITEpe2lmKHRoaXMuc2VsZWN0aW9uU3RhcnQ9dCx0aGlzLnNlbGVjdGlvbkVuZD1pLCF0fHwhaXx8dFswXT09PWlbMF0mJnRbMV09PT1pWzFdKXJldHVybiB2b2lkIHRoaXMuY2xlYXIoKTtjb25zdCByPWUuYnVmZmVycy5hY3RpdmUueWRpc3Asbj10WzFdLXIsbz1pWzFdLXIsYT1NYXRoLm1heChuLDApLGg9TWF0aC5taW4obyxlLnJvd3MtMSk7YT49ZS5yb3dzfHxoPDA/dGhpcy5jbGVhcigpOih0aGlzLmhhc1NlbGVjdGlvbj0hMCx0aGlzLmNvbHVtblNlbGVjdE1vZGU9cyx0aGlzLnZpZXdwb3J0U3RhcnRSb3c9bix0aGlzLnZpZXdwb3J0RW5kUm93PW8sdGhpcy52aWV3cG9ydENhcHBlZFN0YXJ0Um93PWEsdGhpcy52aWV3cG9ydENhcHBlZEVuZFJvdz1oLHRoaXMuc3RhcnRDb2w9dFswXSx0aGlzLmVuZENvbD1pWzBdKX1pc0NlbGxTZWxlY3RlZChlLHQsaSl7cmV0dXJuISF0aGlzLmhhc1NlbGVjdGlvbiYmKGktPWUuYnVmZmVyLmFjdGl2ZS52aWV3cG9ydFksdGhpcy5jb2x1bW5TZWxlY3RNb2RlP3RoaXMuc3RhcnRDb2w8PXRoaXMuZW5kQ29sP3Q+PXRoaXMuc3RhcnRDb2wmJmk+PXRoaXMudmlld3BvcnRDYXBwZWRTdGFydFJvdyYmdDx0aGlzLmVuZENvbCYmaTw9dGhpcy52aWV3cG9ydENhcHBlZEVuZFJvdzp0PHRoaXMuc3RhcnRDb2wmJmk+PXRoaXMudmlld3BvcnRDYXBwZWRTdGFydFJvdyYmdD49dGhpcy5lbmRDb2wmJmk8PXRoaXMudmlld3BvcnRDYXBwZWRFbmRSb3c6aT50aGlzLnZpZXdwb3J0U3RhcnRSb3cmJmk8dGhpcy52aWV3cG9ydEVuZFJvd3x8dGhpcy52aWV3cG9ydFN0YXJ0Um93PT09dGhpcy52aWV3cG9ydEVuZFJvdyYmaT09PXRoaXMudmlld3BvcnRTdGFydFJvdyYmdD49dGhpcy5zdGFydENvbCYmdDx0aGlzLmVuZENvbHx8dGhpcy52aWV3cG9ydFN0YXJ0Um93PHRoaXMudmlld3BvcnRFbmRSb3cmJmk9PT10aGlzLnZpZXdwb3J0RW5kUm93JiZ0PHRoaXMuZW5kQ29sfHx0aGlzLnZpZXdwb3J0U3RhcnRSb3c8dGhpcy52aWV3cG9ydEVuZFJvdyYmaT09PXRoaXMudmlld3BvcnRTdGFydFJvdyYmdD49dGhpcy5zdGFydENvbCl9fXQuY3JlYXRlU2VsZWN0aW9uUmVuZGVyTW9kZWw9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGl9fSw0NTY6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlNlbGVjdGlvbk1vZGVsPXZvaWQgMCx0LlNlbGVjdGlvbk1vZGVsPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX2J1ZmZlclNlcnZpY2U9ZSx0aGlzLmlzU2VsZWN0QWxsQWN0aXZlPSExLHRoaXMuc2VsZWN0aW9uU3RhcnRMZW5ndGg9MH1jbGVhclNlbGVjdGlvbigpe3RoaXMuc2VsZWN0aW9uU3RhcnQ9dm9pZCAwLHRoaXMuc2VsZWN0aW9uRW5kPXZvaWQgMCx0aGlzLmlzU2VsZWN0QWxsQWN0aXZlPSExLHRoaXMuc2VsZWN0aW9uU3RhcnRMZW5ndGg9MH1nZXQgZmluYWxTZWxlY3Rpb25TdGFydCgpe3JldHVybiB0aGlzLmlzU2VsZWN0QWxsQWN0aXZlP1swLDBdOnRoaXMuc2VsZWN0aW9uRW5kJiZ0aGlzLnNlbGVjdGlvblN0YXJ0JiZ0aGlzLmFyZVNlbGVjdGlvblZhbHVlc1JldmVyc2VkKCk/dGhpcy5zZWxlY3Rpb25FbmQ6dGhpcy5zZWxlY3Rpb25TdGFydH1nZXQgZmluYWxTZWxlY3Rpb25FbmQoKXtpZih0aGlzLmlzU2VsZWN0QWxsQWN0aXZlKXJldHVyblt0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMsdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIueWJhc2UrdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLTFdO2lmKHRoaXMuc2VsZWN0aW9uU3RhcnQpe2lmKCF0aGlzLnNlbGVjdGlvbkVuZHx8dGhpcy5hcmVTZWxlY3Rpb25WYWx1ZXNSZXZlcnNlZCgpKXtjb25zdCBlPXRoaXMuc2VsZWN0aW9uU3RhcnRbMF0rdGhpcy5zZWxlY3Rpb25TdGFydExlbmd0aDtyZXR1cm4gZT50aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHM/ZSV0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHM9PTA/W3RoaXMuX2J1ZmZlclNlcnZpY2UuY29scyx0aGlzLnNlbGVjdGlvblN0YXJ0WzFdK01hdGguZmxvb3IoZS90aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpLTFdOltlJXRoaXMuX2J1ZmZlclNlcnZpY2UuY29scyx0aGlzLnNlbGVjdGlvblN0YXJ0WzFdK01hdGguZmxvb3IoZS90aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpXTpbZSx0aGlzLnNlbGVjdGlvblN0YXJ0WzFdXX1pZih0aGlzLnNlbGVjdGlvblN0YXJ0TGVuZ3RoJiZ0aGlzLnNlbGVjdGlvbkVuZFsxXT09PXRoaXMuc2VsZWN0aW9uU3RhcnRbMV0pe2NvbnN0IGU9dGhpcy5zZWxlY3Rpb25TdGFydFswXSt0aGlzLnNlbGVjdGlvblN0YXJ0TGVuZ3RoO3JldHVybiBlPnRoaXMuX2J1ZmZlclNlcnZpY2UuY29scz9bZSV0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMsdGhpcy5zZWxlY3Rpb25TdGFydFsxXStNYXRoLmZsb29yKGUvdGhpcy5fYnVmZmVyU2VydmljZS5jb2xzKV06W01hdGgubWF4KGUsdGhpcy5zZWxlY3Rpb25FbmRbMF0pLHRoaXMuc2VsZWN0aW9uRW5kWzFdXX1yZXR1cm4gdGhpcy5zZWxlY3Rpb25FbmR9fWFyZVNlbGVjdGlvblZhbHVlc1JldmVyc2VkKCl7Y29uc3QgZT10aGlzLnNlbGVjdGlvblN0YXJ0LHQ9dGhpcy5zZWxlY3Rpb25FbmQ7cmV0dXJuISghZXx8IXQpJiYoZVsxXT50WzFdfHxlWzFdPT09dFsxXSYmZVswXT50WzBdKX1oYW5kbGVUcmltKGUpe3JldHVybiB0aGlzLnNlbGVjdGlvblN0YXJ0JiYodGhpcy5zZWxlY3Rpb25TdGFydFsxXS09ZSksdGhpcy5zZWxlY3Rpb25FbmQmJih0aGlzLnNlbGVjdGlvbkVuZFsxXS09ZSksdGhpcy5zZWxlY3Rpb25FbmQmJnRoaXMuc2VsZWN0aW9uRW5kWzFdPDA/KHRoaXMuY2xlYXJTZWxlY3Rpb24oKSwhMCk6KHRoaXMuc2VsZWN0aW9uU3RhcnQmJnRoaXMuc2VsZWN0aW9uU3RhcnRbMV08MCYmKHRoaXMuc2VsZWN0aW9uU3RhcnRbMV09MCksITEpfX19LDQyODpmdW5jdGlvbihlLHQsaSl7dmFyIHM9dGhpcyYmdGhpcy5fX2RlY29yYXRlfHxmdW5jdGlvbihlLHQsaSxzKXt2YXIgcixuPWFyZ3VtZW50cy5sZW5ndGgsbz1uPDM/dDpudWxsPT09cz9zPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxpKTpzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZWZsZWN0LmRlY29yYXRlKW89UmVmbGVjdC5kZWNvcmF0ZShlLHQsaSxzKTtlbHNlIGZvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTA7YS0tKShyPWVbYV0pJiYobz0objwzP3Iobyk6bj4zP3IodCxpLG8pOnIodCxpKSl8fG8pO3JldHVybiBuPjMmJm8mJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGksbyksb30scj10aGlzJiZ0aGlzLl9fcGFyYW18fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkscyl7dChpLHMsZSl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkNoYXJTaXplU2VydmljZT12b2lkIDA7Y29uc3Qgbj1pKDI1ODUpLG89aSg4NDYwKSxhPWkoODQ0KTtsZXQgaD10LkNoYXJTaXplU2VydmljZT1jbGFzcyBleHRlbmRzIGEuRGlzcG9zYWJsZXtnZXQgaGFzVmFsaWRTaXplKCl7cmV0dXJuIHRoaXMud2lkdGg+MCYmdGhpcy5oZWlnaHQ+MH1jb25zdHJ1Y3RvcihlLHQsaSl7c3VwZXIoKSx0aGlzLl9vcHRpb25zU2VydmljZT1pLHRoaXMud2lkdGg9MCx0aGlzLmhlaWdodD0wLHRoaXMuX29uQ2hhclNpemVDaGFuZ2U9dGhpcy5yZWdpc3RlcihuZXcgby5FdmVudEVtaXR0ZXIpLHRoaXMub25DaGFyU2l6ZUNoYW5nZT10aGlzLl9vbkNoYXJTaXplQ2hhbmdlLmV2ZW50O3RyeXt0aGlzLl9tZWFzdXJlU3RyYXRlZ3k9dGhpcy5yZWdpc3RlcihuZXcgZCh0aGlzLl9vcHRpb25zU2VydmljZSkpfWNhdGNoe3RoaXMuX21lYXN1cmVTdHJhdGVneT10aGlzLnJlZ2lzdGVyKG5ldyBsKGUsdCx0aGlzLl9vcHRpb25zU2VydmljZSkpfXRoaXMucmVnaXN0ZXIodGhpcy5fb3B0aW9uc1NlcnZpY2Uub25NdWx0aXBsZU9wdGlvbkNoYW5nZShbXCJmb250RmFtaWx5XCIsXCJmb250U2l6ZVwiXSwoKCk9PnRoaXMubWVhc3VyZSgpKSkpfW1lYXN1cmUoKXtjb25zdCBlPXRoaXMuX21lYXN1cmVTdHJhdGVneS5tZWFzdXJlKCk7ZS53aWR0aD09PXRoaXMud2lkdGgmJmUuaGVpZ2h0PT09dGhpcy5oZWlnaHR8fCh0aGlzLndpZHRoPWUud2lkdGgsdGhpcy5oZWlnaHQ9ZS5oZWlnaHQsdGhpcy5fb25DaGFyU2l6ZUNoYW5nZS5maXJlKCkpfX07dC5DaGFyU2l6ZVNlcnZpY2U9aD1zKFtyKDIsbi5JT3B0aW9uc1NlcnZpY2UpXSxoKTtjbGFzcyBjIGV4dGVuZHMgYS5EaXNwb3NhYmxle2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLl9yZXN1bHQ9e3dpZHRoOjAsaGVpZ2h0OjB9fV92YWxpZGF0ZUFuZFNldChlLHQpe3ZvaWQgMCE9PWUmJmU+MCYmdm9pZCAwIT09dCYmdD4wJiYodGhpcy5fcmVzdWx0LndpZHRoPWUsdGhpcy5fcmVzdWx0LmhlaWdodD10KX19Y2xhc3MgbCBleHRlbmRzIGN7Y29uc3RydWN0b3IoZSx0LGkpe3N1cGVyKCksdGhpcy5fZG9jdW1lbnQ9ZSx0aGlzLl9wYXJlbnRFbGVtZW50PXQsdGhpcy5fb3B0aW9uc1NlcnZpY2U9aSx0aGlzLl9tZWFzdXJlRWxlbWVudD10aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSx0aGlzLl9tZWFzdXJlRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwieHRlcm0tY2hhci1tZWFzdXJlLWVsZW1lbnRcIiksdGhpcy5fbWVhc3VyZUVsZW1lbnQudGV4dENvbnRlbnQ9XCJXXCIucmVwZWF0KDMyKSx0aGlzLl9tZWFzdXJlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKSx0aGlzLl9tZWFzdXJlRWxlbWVudC5zdHlsZS53aGl0ZVNwYWNlPVwicHJlXCIsdGhpcy5fbWVhc3VyZUVsZW1lbnQuc3R5bGUuZm9udEtlcm5pbmc9XCJub25lXCIsdGhpcy5fcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9tZWFzdXJlRWxlbWVudCl9bWVhc3VyZSgpe3JldHVybiB0aGlzLl9tZWFzdXJlRWxlbWVudC5zdHlsZS5mb250RmFtaWx5PXRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuZm9udEZhbWlseSx0aGlzLl9tZWFzdXJlRWxlbWVudC5zdHlsZS5mb250U2l6ZT1gJHt0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmZvbnRTaXplfXB4YCx0aGlzLl92YWxpZGF0ZUFuZFNldChOdW1iZXIodGhpcy5fbWVhc3VyZUVsZW1lbnQub2Zmc2V0V2lkdGgpLzMyLE51bWJlcih0aGlzLl9tZWFzdXJlRWxlbWVudC5vZmZzZXRIZWlnaHQpKSx0aGlzLl9yZXN1bHR9fWNsYXNzIGQgZXh0ZW5kcyBje2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5fb3B0aW9uc1NlcnZpY2U9ZSx0aGlzLl9jYW52YXM9bmV3IE9mZnNjcmVlbkNhbnZhcygxMDAsMTAwKSx0aGlzLl9jdHg9dGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtjb25zdCB0PXRoaXMuX2N0eC5tZWFzdXJlVGV4dChcIldcIik7aWYoIShcIndpZHRoXCJpbiB0JiZcImZvbnRCb3VuZGluZ0JveEFzY2VudFwiaW4gdCYmXCJmb250Qm91bmRpbmdCb3hEZXNjZW50XCJpbiB0KSl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBmb250IG1ldHJpY3Mgbm90IHN1cHBvcnRlZFwiKX1tZWFzdXJlKCl7dGhpcy5fY3R4LmZvbnQ9YCR7dGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5mb250U2l6ZX1weCAke3RoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuZm9udEZhbWlseX1gO2NvbnN0IGU9dGhpcy5fY3R4Lm1lYXN1cmVUZXh0KFwiV1wiKTtyZXR1cm4gdGhpcy5fdmFsaWRhdGVBbmRTZXQoZS53aWR0aCxlLmZvbnRCb3VuZGluZ0JveEFzY2VudCtlLmZvbnRCb3VuZGluZ0JveERlc2NlbnQpLHRoaXMuX3Jlc3VsdH19fSw0MjY5OmZ1bmN0aW9uKGUsdCxpKXt2YXIgcz10aGlzJiZ0aGlzLl9fZGVjb3JhdGV8fGZ1bmN0aW9uKGUsdCxpLHMpe3ZhciByLG49YXJndW1lbnRzLmxlbmd0aCxvPW48Mz90Om51bGw9PT1zP3M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGkpOnM7aWYoXCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3QmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUpbz1SZWZsZWN0LmRlY29yYXRlKGUsdCxpLHMpO2Vsc2UgZm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MDthLS0pKHI9ZVthXSkmJihvPShuPDM/cihvKTpuPjM/cih0LGksbyk6cih0LGkpKXx8byk7cmV0dXJuIG4+MyYmbyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSxvKSxvfSxyPXRoaXMmJnRoaXMuX19wYXJhbXx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oaSxzKXt0KGkscyxlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuQ2hhcmFjdGVySm9pbmVyU2VydmljZT10LkpvaW5lZENlbGxEYXRhPXZvaWQgMDtjb25zdCBuPWkoMzczNCksbz1pKDY0MyksYT1pKDUxMSksaD1pKDI1ODUpO2NsYXNzIGMgZXh0ZW5kcyBuLkF0dHJpYnV0ZURhdGF7Y29uc3RydWN0b3IoZSx0LGkpe3N1cGVyKCksdGhpcy5jb250ZW50PTAsdGhpcy5jb21iaW5lZERhdGE9XCJcIix0aGlzLmZnPWUuZmcsdGhpcy5iZz1lLmJnLHRoaXMuY29tYmluZWREYXRhPXQsdGhpcy5fd2lkdGg9aX1pc0NvbWJpbmVkKCl7cmV0dXJuIDIwOTcxNTJ9Z2V0V2lkdGgoKXtyZXR1cm4gdGhpcy5fd2lkdGh9Z2V0Q2hhcnMoKXtyZXR1cm4gdGhpcy5jb21iaW5lZERhdGF9Z2V0Q29kZSgpe3JldHVybiAyMDk3MTUxfXNldEZyb21DaGFyRGF0YShlKXt0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIil9Z2V0QXNDaGFyRGF0YSgpe3JldHVyblt0aGlzLmZnLHRoaXMuZ2V0Q2hhcnMoKSx0aGlzLmdldFdpZHRoKCksdGhpcy5nZXRDb2RlKCldfX10LkpvaW5lZENlbGxEYXRhPWM7bGV0IGw9dC5DaGFyYWN0ZXJKb2luZXJTZXJ2aWNlPWNsYXNzIGV7Y29uc3RydWN0b3IoZSl7dGhpcy5fYnVmZmVyU2VydmljZT1lLHRoaXMuX2NoYXJhY3RlckpvaW5lcnM9W10sdGhpcy5fbmV4dENoYXJhY3RlckpvaW5lcklkPTAsdGhpcy5fd29ya0NlbGw9bmV3IGEuQ2VsbERhdGF9cmVnaXN0ZXIoZSl7Y29uc3QgdD17aWQ6dGhpcy5fbmV4dENoYXJhY3RlckpvaW5lcklkKyssaGFuZGxlcjplfTtyZXR1cm4gdGhpcy5fY2hhcmFjdGVySm9pbmVycy5wdXNoKHQpLHQuaWR9ZGVyZWdpc3RlcihlKXtmb3IobGV0IHQ9MDt0PHRoaXMuX2NoYXJhY3RlckpvaW5lcnMubGVuZ3RoO3QrKylpZih0aGlzLl9jaGFyYWN0ZXJKb2luZXJzW3RdLmlkPT09ZSlyZXR1cm4gdGhpcy5fY2hhcmFjdGVySm9pbmVycy5zcGxpY2UodCwxKSwhMDtyZXR1cm4hMX1nZXRKb2luZWRDaGFyYWN0ZXJzKGUpe2lmKDA9PT10aGlzLl9jaGFyYWN0ZXJKb2luZXJzLmxlbmd0aClyZXR1cm5bXTtjb25zdCB0PXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLmxpbmVzLmdldChlKTtpZighdHx8MD09PXQubGVuZ3RoKXJldHVybltdO2NvbnN0IGk9W10scz10LnRyYW5zbGF0ZVRvU3RyaW5nKCEwKTtsZXQgcj0wLG49MCxhPTAsaD10LmdldEZnKDApLGM9dC5nZXRCZygwKTtmb3IobGV0IGU9MDtlPHQuZ2V0VHJpbW1lZExlbmd0aCgpO2UrKylpZih0LmxvYWRDZWxsKGUsdGhpcy5fd29ya0NlbGwpLDAhPT10aGlzLl93b3JrQ2VsbC5nZXRXaWR0aCgpKXtpZih0aGlzLl93b3JrQ2VsbC5mZyE9PWh8fHRoaXMuX3dvcmtDZWxsLmJnIT09Yyl7aWYoZS1yPjEpe2NvbnN0IGU9dGhpcy5fZ2V0Sm9pbmVkUmFuZ2VzKHMsYSxuLHQscik7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspaS5wdXNoKGVbdF0pfXI9ZSxhPW4saD10aGlzLl93b3JrQ2VsbC5mZyxjPXRoaXMuX3dvcmtDZWxsLmJnfW4rPXRoaXMuX3dvcmtDZWxsLmdldENoYXJzKCkubGVuZ3RofHxvLldISVRFU1BBQ0VfQ0VMTF9DSEFSLmxlbmd0aH1pZih0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMtcj4xKXtjb25zdCBlPXRoaXMuX2dldEpvaW5lZFJhbmdlcyhzLGEsbix0LHIpO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKWkucHVzaChlW3RdKX1yZXR1cm4gaX1fZ2V0Sm9pbmVkUmFuZ2VzKHQsaSxzLHIsbil7Y29uc3Qgbz10LnN1YnN0cmluZyhpLHMpO2xldCBhPVtdO3RyeXthPXRoaXMuX2NoYXJhY3RlckpvaW5lcnNbMF0uaGFuZGxlcihvKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKGUpfWZvcihsZXQgdD0xO3Q8dGhpcy5fY2hhcmFjdGVySm9pbmVycy5sZW5ndGg7dCsrKXRyeXtjb25zdCBpPXRoaXMuX2NoYXJhY3RlckpvaW5lcnNbdF0uaGFuZGxlcihvKTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoO3QrKyllLl9tZXJnZVJhbmdlcyhhLGlbdF0pfWNhdGNoKGUpe2NvbnNvbGUuZXJyb3IoZSl9cmV0dXJuIHRoaXMuX3N0cmluZ1Jhbmdlc1RvQ2VsbFJhbmdlcyhhLHIsbiksYX1fc3RyaW5nUmFuZ2VzVG9DZWxsUmFuZ2VzKGUsdCxpKXtsZXQgcz0wLHI9ITEsbj0wLGE9ZVtzXTtpZihhKXtmb3IobGV0IGg9aTtoPHRoaXMuX2J1ZmZlclNlcnZpY2UuY29scztoKyspe2NvbnN0IGk9dC5nZXRXaWR0aChoKSxjPXQuZ2V0U3RyaW5nKGgpLmxlbmd0aHx8by5XSElURVNQQUNFX0NFTExfQ0hBUi5sZW5ndGg7aWYoMCE9PWkpe2lmKCFyJiZhWzBdPD1uJiYoYVswXT1oLHI9ITApLGFbMV08PW4pe2lmKGFbMV09aCxhPWVbKytzXSwhYSlicmVhazthWzBdPD1uPyhhWzBdPWgscj0hMCk6cj0hMX1uKz1jfX1hJiYoYVsxXT10aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpfX1zdGF0aWMgX21lcmdlUmFuZ2VzKGUsdCl7bGV0IGk9ITE7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDtzKyspe2NvbnN0IHI9ZVtzXTtpZihpKXtpZih0WzFdPD1yWzBdKXJldHVybiBlW3MtMV1bMV09dFsxXSxlO2lmKHRbMV08PXJbMV0pcmV0dXJuIGVbcy0xXVsxXT1NYXRoLm1heCh0WzFdLHJbMV0pLGUuc3BsaWNlKHMsMSksZTtlLnNwbGljZShzLDEpLHMtLX1lbHNle2lmKHRbMV08PXJbMF0pcmV0dXJuIGUuc3BsaWNlKHMsMCx0KSxlO2lmKHRbMV08PXJbMV0pcmV0dXJuIHJbMF09TWF0aC5taW4odFswXSxyWzBdKSxlO3RbMF08clsxXSYmKHJbMF09TWF0aC5taW4odFswXSxyWzBdKSxpPSEwKX19cmV0dXJuIGk/ZVtlLmxlbmd0aC0xXVsxXT10WzFdOmUucHVzaCh0KSxlfX07dC5DaGFyYWN0ZXJKb2luZXJTZXJ2aWNlPWw9cyhbcigwLGguSUJ1ZmZlclNlcnZpY2UpXSxsKX0sNTExNDooZSx0LGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Db3JlQnJvd3NlclNlcnZpY2U9dm9pZCAwO2NvbnN0IHM9aSg4NDQpLHI9aSg4NDYwKSxuPWkoMzY1Nik7Y2xhc3MgbyBleHRlbmRzIHMuRGlzcG9zYWJsZXtjb25zdHJ1Y3RvcihlLHQsaSl7c3VwZXIoKSx0aGlzLl90ZXh0YXJlYT1lLHRoaXMuX3dpbmRvdz10LHRoaXMubWFpbkRvY3VtZW50PWksdGhpcy5faXNGb2N1c2VkPSExLHRoaXMuX2NhY2hlZElzRm9jdXNlZD12b2lkIDAsdGhpcy5fc2NyZWVuRHByTW9uaXRvcj1uZXcgYSh0aGlzLl93aW5kb3cpLHRoaXMuX29uRHByQ2hhbmdlPXRoaXMucmVnaXN0ZXIobmV3IHIuRXZlbnRFbWl0dGVyKSx0aGlzLm9uRHByQ2hhbmdlPXRoaXMuX29uRHByQ2hhbmdlLmV2ZW50LHRoaXMuX29uV2luZG93Q2hhbmdlPXRoaXMucmVnaXN0ZXIobmV3IHIuRXZlbnRFbWl0dGVyKSx0aGlzLm9uV2luZG93Q2hhbmdlPXRoaXMuX29uV2luZG93Q2hhbmdlLmV2ZW50LHRoaXMucmVnaXN0ZXIodGhpcy5vbldpbmRvd0NoYW5nZSgoZT0+dGhpcy5fc2NyZWVuRHByTW9uaXRvci5zZXRXaW5kb3coZSkpKSksdGhpcy5yZWdpc3RlcigoMCxyLmZvcndhcmRFdmVudCkodGhpcy5fc2NyZWVuRHByTW9uaXRvci5vbkRwckNoYW5nZSx0aGlzLl9vbkRwckNoYW5nZSkpLHRoaXMuX3RleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCgoKT0+dGhpcy5faXNGb2N1c2VkPSEwKSksdGhpcy5fdGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwoKCk9PnRoaXMuX2lzRm9jdXNlZD0hMSkpfWdldCB3aW5kb3coKXtyZXR1cm4gdGhpcy5fd2luZG93fXNldCB3aW5kb3coZSl7dGhpcy5fd2luZG93IT09ZSYmKHRoaXMuX3dpbmRvdz1lLHRoaXMuX29uV2luZG93Q2hhbmdlLmZpcmUodGhpcy5fd2luZG93KSl9Z2V0IGRwcigpe3JldHVybiB0aGlzLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfWdldCBpc0ZvY3VzZWQoKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5fY2FjaGVkSXNGb2N1c2VkJiYodGhpcy5fY2FjaGVkSXNGb2N1c2VkPXRoaXMuX2lzRm9jdXNlZCYmdGhpcy5fdGV4dGFyZWEub3duZXJEb2N1bWVudC5oYXNGb2N1cygpLHF1ZXVlTWljcm90YXNrKCgoKT0+dGhpcy5fY2FjaGVkSXNGb2N1c2VkPXZvaWQgMCkpKSx0aGlzLl9jYWNoZWRJc0ZvY3VzZWR9fXQuQ29yZUJyb3dzZXJTZXJ2aWNlPW87Y2xhc3MgYSBleHRlbmRzIHMuRGlzcG9zYWJsZXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuX3BhcmVudFdpbmRvdz1lLHRoaXMuX3dpbmRvd1Jlc2l6ZUxpc3RlbmVyPXRoaXMucmVnaXN0ZXIobmV3IHMuTXV0YWJsZURpc3Bvc2FibGUpLHRoaXMuX29uRHByQ2hhbmdlPXRoaXMucmVnaXN0ZXIobmV3IHIuRXZlbnRFbWl0dGVyKSx0aGlzLm9uRHByQ2hhbmdlPXRoaXMuX29uRHByQ2hhbmdlLmV2ZW50LHRoaXMuX291dGVyTGlzdGVuZXI9KCk9PnRoaXMuX3NldERwckFuZEZpcmVJZkRpZmZlcnMoKSx0aGlzLl9jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbz10aGlzLl9wYXJlbnRXaW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyx0aGlzLl91cGRhdGVEcHIoKSx0aGlzLl9zZXRXaW5kb3dSZXNpemVMaXN0ZW5lcigpLHRoaXMucmVnaXN0ZXIoKDAscy50b0Rpc3Bvc2FibGUpKCgoKT0+dGhpcy5jbGVhckxpc3RlbmVyKCkpKSl9c2V0V2luZG93KGUpe3RoaXMuX3BhcmVudFdpbmRvdz1lLHRoaXMuX3NldFdpbmRvd1Jlc2l6ZUxpc3RlbmVyKCksdGhpcy5fc2V0RHByQW5kRmlyZUlmRGlmZmVycygpfV9zZXRXaW5kb3dSZXNpemVMaXN0ZW5lcigpe3RoaXMuX3dpbmRvd1Jlc2l6ZUxpc3RlbmVyLnZhbHVlPSgwLG4uYWRkRGlzcG9zYWJsZURvbUxpc3RlbmVyKSh0aGlzLl9wYXJlbnRXaW5kb3csXCJyZXNpemVcIiwoKCk9PnRoaXMuX3NldERwckFuZEZpcmVJZkRpZmZlcnMoKSkpfV9zZXREcHJBbmRGaXJlSWZEaWZmZXJzKCl7dGhpcy5fcGFyZW50V2luZG93LmRldmljZVBpeGVsUmF0aW8hPT10aGlzLl9jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyYmdGhpcy5fb25EcHJDaGFuZ2UuZmlyZSh0aGlzLl9wYXJlbnRXaW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyksdGhpcy5fdXBkYXRlRHByKCl9X3VwZGF0ZURwcigpe3RoaXMuX291dGVyTGlzdGVuZXImJih0aGlzLl9yZXNvbHV0aW9uTWVkaWFNYXRjaExpc3Q/LnJlbW92ZUxpc3RlbmVyKHRoaXMuX291dGVyTGlzdGVuZXIpLHRoaXMuX2N1cnJlbnREZXZpY2VQaXhlbFJhdGlvPXRoaXMuX3BhcmVudFdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLHRoaXMuX3Jlc29sdXRpb25NZWRpYU1hdGNoTGlzdD10aGlzLl9wYXJlbnRXaW5kb3cubWF0Y2hNZWRpYShgc2NyZWVuIGFuZCAocmVzb2x1dGlvbjogJHt0aGlzLl9wYXJlbnRXaW5kb3cuZGV2aWNlUGl4ZWxSYXRpb31kcHB4KWApLHRoaXMuX3Jlc29sdXRpb25NZWRpYU1hdGNoTGlzdC5hZGRMaXN0ZW5lcih0aGlzLl9vdXRlckxpc3RlbmVyKSl9Y2xlYXJMaXN0ZW5lcigpe3RoaXMuX3Jlc29sdXRpb25NZWRpYU1hdGNoTGlzdCYmdGhpcy5fb3V0ZXJMaXN0ZW5lciYmKHRoaXMuX3Jlc29sdXRpb25NZWRpYU1hdGNoTGlzdC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9vdXRlckxpc3RlbmVyKSx0aGlzLl9yZXNvbHV0aW9uTWVkaWFNYXRjaExpc3Q9dm9pZCAwLHRoaXMuX291dGVyTGlzdGVuZXI9dm9pZCAwKX19fSw3Nzk6KGUsdCxpKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTGlua1Byb3ZpZGVyU2VydmljZT12b2lkIDA7Y29uc3Qgcz1pKDg0NCk7Y2xhc3MgciBleHRlbmRzIHMuRGlzcG9zYWJsZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5saW5rUHJvdmlkZXJzPVtdLHRoaXMucmVnaXN0ZXIoKDAscy50b0Rpc3Bvc2FibGUpKCgoKT0+dGhpcy5saW5rUHJvdmlkZXJzLmxlbmd0aD0wKSkpfXJlZ2lzdGVyTGlua1Byb3ZpZGVyKGUpe3JldHVybiB0aGlzLmxpbmtQcm92aWRlcnMucHVzaChlKSx7ZGlzcG9zZTooKT0+e2NvbnN0IHQ9dGhpcy5saW5rUHJvdmlkZXJzLmluZGV4T2YoZSk7LTEhPT10JiZ0aGlzLmxpbmtQcm92aWRlcnMuc3BsaWNlKHQsMSl9fX19dC5MaW5rUHJvdmlkZXJTZXJ2aWNlPXJ9LDg5MzQ6ZnVuY3Rpb24oZSx0LGkpe3ZhciBzPXRoaXMmJnRoaXMuX19kZWNvcmF0ZXx8ZnVuY3Rpb24oZSx0LGkscyl7dmFyIHIsbj1hcmd1bWVudHMubGVuZ3RoLG89bjwzP3Q6bnVsbD09PXM/cz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsaSk6cztpZihcIm9iamVjdFwiPT10eXBlb2YgUmVmbGVjdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSlvPVJlZmxlY3QuZGVjb3JhdGUoZSx0LGkscyk7ZWxzZSBmb3IodmFyIGE9ZS5sZW5ndGgtMTthPj0wO2EtLSkocj1lW2FdKSYmKG89KG48Mz9yKG8pOm4+Mz9yKHQsaSxvKTpyKHQsaSkpfHxvKTtyZXR1cm4gbj4zJiZvJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLG8pLG99LHI9dGhpcyYmdGhpcy5fX3BhcmFtfHxmdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihpLHMpe3QoaSxzLGUpfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Nb3VzZVNlcnZpY2U9dm9pZCAwO2NvbnN0IG49aSg0NzI1KSxvPWkoOTgwNik7bGV0IGE9dC5Nb3VzZVNlcnZpY2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl9yZW5kZXJTZXJ2aWNlPWUsdGhpcy5fY2hhclNpemVTZXJ2aWNlPXR9Z2V0Q29vcmRzKGUsdCxpLHMscil7cmV0dXJuKDAsby5nZXRDb29yZHMpKHdpbmRvdyxlLHQsaSxzLHRoaXMuX2NoYXJTaXplU2VydmljZS5oYXNWYWxpZFNpemUsdGhpcy5fcmVuZGVyU2VydmljZS5kaW1lbnNpb25zLmNzcy5jZWxsLndpZHRoLHRoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC5oZWlnaHQscil9Z2V0TW91c2VSZXBvcnRDb29yZHMoZSx0KXtjb25zdCBpPSgwLG8uZ2V0Q29vcmRzUmVsYXRpdmVUb0VsZW1lbnQpKHdpbmRvdyxlLHQpO2lmKHRoaXMuX2NoYXJTaXplU2VydmljZS5oYXNWYWxpZFNpemUpcmV0dXJuIGlbMF09TWF0aC5taW4oTWF0aC5tYXgoaVswXSwwKSx0aGlzLl9yZW5kZXJTZXJ2aWNlLmRpbWVuc2lvbnMuY3NzLmNhbnZhcy53aWR0aC0xKSxpWzFdPU1hdGgubWluKE1hdGgubWF4KGlbMV0sMCksdGhpcy5fcmVuZGVyU2VydmljZS5kaW1lbnNpb25zLmNzcy5jYW52YXMuaGVpZ2h0LTEpLHtjb2w6TWF0aC5mbG9vcihpWzBdL3RoaXMuX3JlbmRlclNlcnZpY2UuZGltZW5zaW9ucy5jc3MuY2VsbC53aWR0aCkscm93Ok1hdGguZmxvb3IoaVsxXS90aGlzLl9yZW5kZXJTZXJ2aWNlLmRpbWVuc2lvbnMuY3NzLmNlbGwuaGVpZ2h0KSx4Ok1hdGguZmxvb3IoaVswXSkseTpNYXRoLmZsb29yKGlbMV0pfX19O3QuTW91c2VTZXJ2aWNlPWE9cyhbcigwLG4uSVJlbmRlclNlcnZpY2UpLHIoMSxuLklDaGFyU2l6ZVNlcnZpY2UpXSxhKX0sMzIzMDpmdW5jdGlvbihlLHQsaSl7dmFyIHM9dGhpcyYmdGhpcy5fX2RlY29yYXRlfHxmdW5jdGlvbihlLHQsaSxzKXt2YXIgcixuPWFyZ3VtZW50cy5sZW5ndGgsbz1uPDM/dDpudWxsPT09cz9zPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxpKTpzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZWZsZWN0LmRlY29yYXRlKW89UmVmbGVjdC5kZWNvcmF0ZShlLHQsaSxzKTtlbHNlIGZvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTA7YS0tKShyPWVbYV0pJiYobz0objwzP3Iobyk6bj4zP3IodCxpLG8pOnIodCxpKSl8fG8pO3JldHVybiBuPjMmJm8mJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGksbyksb30scj10aGlzJiZ0aGlzLl9fcGFyYW18fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkscyl7dChpLHMsZSl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlJlbmRlclNlcnZpY2U9dm9pZCAwO2NvbnN0IG49aSg2MTkzKSxvPWkoNDcyNSksYT1pKDg0NjApLGg9aSg4NDQpLGM9aSg3MjI2KSxsPWkoMjU4NSk7bGV0IGQ9dC5SZW5kZXJTZXJ2aWNlPWNsYXNzIGV4dGVuZHMgaC5EaXNwb3NhYmxle2dldCBkaW1lbnNpb25zKCl7cmV0dXJuIHRoaXMuX3JlbmRlcmVyLnZhbHVlLmRpbWVuc2lvbnN9Y29uc3RydWN0b3IoZSx0LGkscyxyLG8sbCxkKXtzdXBlcigpLHRoaXMuX3Jvd0NvdW50PWUsdGhpcy5fY2hhclNpemVTZXJ2aWNlPXMsdGhpcy5fcmVuZGVyZXI9dGhpcy5yZWdpc3RlcihuZXcgaC5NdXRhYmxlRGlzcG9zYWJsZSksdGhpcy5fcGF1c2VkUmVzaXplVGFzaz1uZXcgYy5EZWJvdW5jZWRJZGxlVGFzayx0aGlzLl9vYnNlcnZlckRpc3Bvc2FibGU9dGhpcy5yZWdpc3RlcihuZXcgaC5NdXRhYmxlRGlzcG9zYWJsZSksdGhpcy5faXNQYXVzZWQ9ITEsdGhpcy5fbmVlZHNGdWxsUmVmcmVzaD0hMSx0aGlzLl9pc05leHRSZW5kZXJSZWRyYXdPbmx5PSEwLHRoaXMuX25lZWRzU2VsZWN0aW9uUmVmcmVzaD0hMSx0aGlzLl9jYW52YXNXaWR0aD0wLHRoaXMuX2NhbnZhc0hlaWdodD0wLHRoaXMuX3NlbGVjdGlvblN0YXRlPXtzdGFydDp2b2lkIDAsZW5kOnZvaWQgMCxjb2x1bW5TZWxlY3RNb2RlOiExfSx0aGlzLl9vbkRpbWVuc2lvbnNDaGFuZ2U9dGhpcy5yZWdpc3RlcihuZXcgYS5FdmVudEVtaXR0ZXIpLHRoaXMub25EaW1lbnNpb25zQ2hhbmdlPXRoaXMuX29uRGltZW5zaW9uc0NoYW5nZS5ldmVudCx0aGlzLl9vblJlbmRlcmVkVmlld3BvcnRDaGFuZ2U9dGhpcy5yZWdpc3RlcihuZXcgYS5FdmVudEVtaXR0ZXIpLHRoaXMub25SZW5kZXJlZFZpZXdwb3J0Q2hhbmdlPXRoaXMuX29uUmVuZGVyZWRWaWV3cG9ydENoYW5nZS5ldmVudCx0aGlzLl9vblJlbmRlcj10aGlzLnJlZ2lzdGVyKG5ldyBhLkV2ZW50RW1pdHRlciksdGhpcy5vblJlbmRlcj10aGlzLl9vblJlbmRlci5ldmVudCx0aGlzLl9vblJlZnJlc2hSZXF1ZXN0PXRoaXMucmVnaXN0ZXIobmV3IGEuRXZlbnRFbWl0dGVyKSx0aGlzLm9uUmVmcmVzaFJlcXVlc3Q9dGhpcy5fb25SZWZyZXNoUmVxdWVzdC5ldmVudCx0aGlzLl9yZW5kZXJEZWJvdW5jZXI9bmV3IG4uUmVuZGVyRGVib3VuY2VyKCgoZSx0KT0+dGhpcy5fcmVuZGVyUm93cyhlLHQpKSxsKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX3JlbmRlckRlYm91bmNlciksdGhpcy5yZWdpc3RlcihsLm9uRHByQ2hhbmdlKCgoKT0+dGhpcy5oYW5kbGVEZXZpY2VQaXhlbFJhdGlvQ2hhbmdlKCkpKSksdGhpcy5yZWdpc3RlcihvLm9uUmVzaXplKCgoKT0+dGhpcy5fZnVsbFJlZnJlc2goKSkpKSx0aGlzLnJlZ2lzdGVyKG8uYnVmZmVycy5vbkJ1ZmZlckFjdGl2YXRlKCgoKT0+dGhpcy5fcmVuZGVyZXIudmFsdWU/LmNsZWFyKCkpKSksdGhpcy5yZWdpc3RlcihpLm9uT3B0aW9uQ2hhbmdlKCgoKT0+dGhpcy5faGFuZGxlT3B0aW9uc0NoYW5nZWQoKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX2NoYXJTaXplU2VydmljZS5vbkNoYXJTaXplQ2hhbmdlKCgoKT0+dGhpcy5oYW5kbGVDaGFyU2l6ZUNoYW5nZWQoKSkpKSx0aGlzLnJlZ2lzdGVyKHIub25EZWNvcmF0aW9uUmVnaXN0ZXJlZCgoKCk9PnRoaXMuX2Z1bGxSZWZyZXNoKCkpKSksdGhpcy5yZWdpc3RlcihyLm9uRGVjb3JhdGlvblJlbW92ZWQoKCgpPT50aGlzLl9mdWxsUmVmcmVzaCgpKSkpLHRoaXMucmVnaXN0ZXIoaS5vbk11bHRpcGxlT3B0aW9uQ2hhbmdlKFtcImN1c3RvbUdseXBoc1wiLFwiZHJhd0JvbGRUZXh0SW5CcmlnaHRDb2xvcnNcIixcImxldHRlclNwYWNpbmdcIixcImxpbmVIZWlnaHRcIixcImZvbnRGYW1pbHlcIixcImZvbnRTaXplXCIsXCJmb250V2VpZ2h0XCIsXCJmb250V2VpZ2h0Qm9sZFwiLFwibWluaW11bUNvbnRyYXN0UmF0aW9cIixcInJlc2NhbGVPdmVybGFwcGluZ0dseXBoc1wiXSwoKCk9Pnt0aGlzLmNsZWFyKCksdGhpcy5oYW5kbGVSZXNpemUoby5jb2xzLG8ucm93cyksdGhpcy5fZnVsbFJlZnJlc2goKX0pKSksdGhpcy5yZWdpc3RlcihpLm9uTXVsdGlwbGVPcHRpb25DaGFuZ2UoW1wiY3Vyc29yQmxpbmtcIixcImN1cnNvclN0eWxlXCJdLCgoKT0+dGhpcy5yZWZyZXNoUm93cyhvLmJ1ZmZlci55LG8uYnVmZmVyLnksITApKSkpLHRoaXMucmVnaXN0ZXIoZC5vbkNoYW5nZUNvbG9ycygoKCk9PnRoaXMuX2Z1bGxSZWZyZXNoKCkpKSksdGhpcy5fcmVnaXN0ZXJJbnRlcnNlY3Rpb25PYnNlcnZlcihsLndpbmRvdyx0KSx0aGlzLnJlZ2lzdGVyKGwub25XaW5kb3dDaGFuZ2UoKGU9PnRoaXMuX3JlZ2lzdGVySW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZSx0KSkpKX1fcmVnaXN0ZXJJbnRlcnNlY3Rpb25PYnNlcnZlcihlLHQpe2lmKFwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcImluIGUpe2NvbnN0IGk9bmV3IGUuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGU9PnRoaXMuX2hhbmRsZUludGVyc2VjdGlvbkNoYW5nZShlW2UubGVuZ3RoLTFdKSkse3RocmVzaG9sZDowfSk7aS5vYnNlcnZlKHQpLHRoaXMuX29ic2VydmVyRGlzcG9zYWJsZS52YWx1ZT0oMCxoLnRvRGlzcG9zYWJsZSkoKCgpPT5pLmRpc2Nvbm5lY3QoKSkpfX1faGFuZGxlSW50ZXJzZWN0aW9uQ2hhbmdlKGUpe3RoaXMuX2lzUGF1c2VkPXZvaWQgMD09PWUuaXNJbnRlcnNlY3Rpbmc/MD09PWUuaW50ZXJzZWN0aW9uUmF0aW86IWUuaXNJbnRlcnNlY3RpbmcsdGhpcy5faXNQYXVzZWR8fHRoaXMuX2NoYXJTaXplU2VydmljZS5oYXNWYWxpZFNpemV8fHRoaXMuX2NoYXJTaXplU2VydmljZS5tZWFzdXJlKCksIXRoaXMuX2lzUGF1c2VkJiZ0aGlzLl9uZWVkc0Z1bGxSZWZyZXNoJiYodGhpcy5fcGF1c2VkUmVzaXplVGFzay5mbHVzaCgpLHRoaXMucmVmcmVzaFJvd3MoMCx0aGlzLl9yb3dDb3VudC0xKSx0aGlzLl9uZWVkc0Z1bGxSZWZyZXNoPSExKX1yZWZyZXNoUm93cyhlLHQsaT0hMSl7dGhpcy5faXNQYXVzZWQ/dGhpcy5fbmVlZHNGdWxsUmVmcmVzaD0hMDooaXx8KHRoaXMuX2lzTmV4dFJlbmRlclJlZHJhd09ubHk9ITEpLHRoaXMuX3JlbmRlckRlYm91bmNlci5yZWZyZXNoKGUsdCx0aGlzLl9yb3dDb3VudCkpfV9yZW5kZXJSb3dzKGUsdCl7dGhpcy5fcmVuZGVyZXIudmFsdWUmJihlPU1hdGgubWluKGUsdGhpcy5fcm93Q291bnQtMSksdD1NYXRoLm1pbih0LHRoaXMuX3Jvd0NvdW50LTEpLHRoaXMuX3JlbmRlcmVyLnZhbHVlLnJlbmRlclJvd3MoZSx0KSx0aGlzLl9uZWVkc1NlbGVjdGlvblJlZnJlc2gmJih0aGlzLl9yZW5kZXJlci52YWx1ZS5oYW5kbGVTZWxlY3Rpb25DaGFuZ2VkKHRoaXMuX3NlbGVjdGlvblN0YXRlLnN0YXJ0LHRoaXMuX3NlbGVjdGlvblN0YXRlLmVuZCx0aGlzLl9zZWxlY3Rpb25TdGF0ZS5jb2x1bW5TZWxlY3RNb2RlKSx0aGlzLl9uZWVkc1NlbGVjdGlvblJlZnJlc2g9ITEpLHRoaXMuX2lzTmV4dFJlbmRlclJlZHJhd09ubHl8fHRoaXMuX29uUmVuZGVyZWRWaWV3cG9ydENoYW5nZS5maXJlKHtzdGFydDplLGVuZDp0fSksdGhpcy5fb25SZW5kZXIuZmlyZSh7c3RhcnQ6ZSxlbmQ6dH0pLHRoaXMuX2lzTmV4dFJlbmRlclJlZHJhd09ubHk9ITApfXJlc2l6ZShlLHQpe3RoaXMuX3Jvd0NvdW50PXQsdGhpcy5fZmlyZU9uQ2FudmFzUmVzaXplKCl9X2hhbmRsZU9wdGlvbnNDaGFuZ2VkKCl7dGhpcy5fcmVuZGVyZXIudmFsdWUmJih0aGlzLnJlZnJlc2hSb3dzKDAsdGhpcy5fcm93Q291bnQtMSksdGhpcy5fZmlyZU9uQ2FudmFzUmVzaXplKCkpfV9maXJlT25DYW52YXNSZXNpemUoKXt0aGlzLl9yZW5kZXJlci52YWx1ZSYmKHRoaXMuX3JlbmRlcmVyLnZhbHVlLmRpbWVuc2lvbnMuY3NzLmNhbnZhcy53aWR0aD09PXRoaXMuX2NhbnZhc1dpZHRoJiZ0aGlzLl9yZW5kZXJlci52YWx1ZS5kaW1lbnNpb25zLmNzcy5jYW52YXMuaGVpZ2h0PT09dGhpcy5fY2FudmFzSGVpZ2h0fHx0aGlzLl9vbkRpbWVuc2lvbnNDaGFuZ2UuZmlyZSh0aGlzLl9yZW5kZXJlci52YWx1ZS5kaW1lbnNpb25zKSl9aGFzUmVuZGVyZXIoKXtyZXR1cm4hIXRoaXMuX3JlbmRlcmVyLnZhbHVlfXNldFJlbmRlcmVyKGUpe3RoaXMuX3JlbmRlcmVyLnZhbHVlPWUsdGhpcy5fcmVuZGVyZXIudmFsdWUmJih0aGlzLl9yZW5kZXJlci52YWx1ZS5vblJlcXVlc3RSZWRyYXcoKGU9PnRoaXMucmVmcmVzaFJvd3MoZS5zdGFydCxlLmVuZCwhMCkpKSx0aGlzLl9uZWVkc1NlbGVjdGlvblJlZnJlc2g9ITAsdGhpcy5fZnVsbFJlZnJlc2goKSl9YWRkUmVmcmVzaENhbGxiYWNrKGUpe3JldHVybiB0aGlzLl9yZW5kZXJEZWJvdW5jZXIuYWRkUmVmcmVzaENhbGxiYWNrKGUpfV9mdWxsUmVmcmVzaCgpe3RoaXMuX2lzUGF1c2VkP3RoaXMuX25lZWRzRnVsbFJlZnJlc2g9ITA6dGhpcy5yZWZyZXNoUm93cygwLHRoaXMuX3Jvd0NvdW50LTEpfWNsZWFyVGV4dHVyZUF0bGFzKCl7dGhpcy5fcmVuZGVyZXIudmFsdWUmJih0aGlzLl9yZW5kZXJlci52YWx1ZS5jbGVhclRleHR1cmVBdGxhcz8uKCksdGhpcy5fZnVsbFJlZnJlc2goKSl9aGFuZGxlRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZSgpe3RoaXMuX2NoYXJTaXplU2VydmljZS5tZWFzdXJlKCksdGhpcy5fcmVuZGVyZXIudmFsdWUmJih0aGlzLl9yZW5kZXJlci52YWx1ZS5oYW5kbGVEZXZpY2VQaXhlbFJhdGlvQ2hhbmdlKCksdGhpcy5yZWZyZXNoUm93cygwLHRoaXMuX3Jvd0NvdW50LTEpKX1oYW5kbGVSZXNpemUoZSx0KXt0aGlzLl9yZW5kZXJlci52YWx1ZSYmKHRoaXMuX2lzUGF1c2VkP3RoaXMuX3BhdXNlZFJlc2l6ZVRhc2suc2V0KCgoKT0+dGhpcy5fcmVuZGVyZXIudmFsdWU/LmhhbmRsZVJlc2l6ZShlLHQpKSk6dGhpcy5fcmVuZGVyZXIudmFsdWUuaGFuZGxlUmVzaXplKGUsdCksdGhpcy5fZnVsbFJlZnJlc2goKSl9aGFuZGxlQ2hhclNpemVDaGFuZ2VkKCl7dGhpcy5fcmVuZGVyZXIudmFsdWU/LmhhbmRsZUNoYXJTaXplQ2hhbmdlZCgpfWhhbmRsZUJsdXIoKXt0aGlzLl9yZW5kZXJlci52YWx1ZT8uaGFuZGxlQmx1cigpfWhhbmRsZUZvY3VzKCl7dGhpcy5fcmVuZGVyZXIudmFsdWU/LmhhbmRsZUZvY3VzKCl9aGFuZGxlU2VsZWN0aW9uQ2hhbmdlZChlLHQsaSl7dGhpcy5fc2VsZWN0aW9uU3RhdGUuc3RhcnQ9ZSx0aGlzLl9zZWxlY3Rpb25TdGF0ZS5lbmQ9dCx0aGlzLl9zZWxlY3Rpb25TdGF0ZS5jb2x1bW5TZWxlY3RNb2RlPWksdGhpcy5fcmVuZGVyZXIudmFsdWU/LmhhbmRsZVNlbGVjdGlvbkNoYW5nZWQoZSx0LGkpfWhhbmRsZUN1cnNvck1vdmUoKXt0aGlzLl9yZW5kZXJlci52YWx1ZT8uaGFuZGxlQ3Vyc29yTW92ZSgpfWNsZWFyKCl7dGhpcy5fcmVuZGVyZXIudmFsdWU/LmNsZWFyKCl9fTt0LlJlbmRlclNlcnZpY2U9ZD1zKFtyKDIsbC5JT3B0aW9uc1NlcnZpY2UpLHIoMyxvLklDaGFyU2l6ZVNlcnZpY2UpLHIoNCxsLklEZWNvcmF0aW9uU2VydmljZSkscig1LGwuSUJ1ZmZlclNlcnZpY2UpLHIoNixvLklDb3JlQnJvd3NlclNlcnZpY2UpLHIoNyxvLklUaGVtZVNlcnZpY2UpXSxkKX0sOTMxMjpmdW5jdGlvbihlLHQsaSl7dmFyIHM9dGhpcyYmdGhpcy5fX2RlY29yYXRlfHxmdW5jdGlvbihlLHQsaSxzKXt2YXIgcixuPWFyZ3VtZW50cy5sZW5ndGgsbz1uPDM/dDpudWxsPT09cz9zPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxpKTpzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZWZsZWN0LmRlY29yYXRlKW89UmVmbGVjdC5kZWNvcmF0ZShlLHQsaSxzKTtlbHNlIGZvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTA7YS0tKShyPWVbYV0pJiYobz0objwzP3Iobyk6bj4zP3IodCxpLG8pOnIodCxpKSl8fG8pO3JldHVybiBuPjMmJm8mJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGksbyksb30scj10aGlzJiZ0aGlzLl9fcGFyYW18fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkscyl7dChpLHMsZSl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlNlbGVjdGlvblNlcnZpY2U9dm9pZCAwO2NvbnN0IG49aSg5ODA2KSxvPWkoOTUwNCksYT1pKDQ1NiksaD1pKDQ3MjUpLGM9aSg4NDYwKSxsPWkoODQ0KSxkPWkoNjExNCksXz1pKDQ4NDEpLHU9aSg1MTEpLGY9aSgyNTg1KSx2PVN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSxwPW5ldyBSZWdFeHAodixcImdcIik7bGV0IGc9dC5TZWxlY3Rpb25TZXJ2aWNlPWNsYXNzIGV4dGVuZHMgbC5EaXNwb3NhYmxle2NvbnN0cnVjdG9yKGUsdCxpLHMscixuLG8saCxkKXtzdXBlcigpLHRoaXMuX2VsZW1lbnQ9ZSx0aGlzLl9zY3JlZW5FbGVtZW50PXQsdGhpcy5fbGlua2lmaWVyPWksdGhpcy5fYnVmZmVyU2VydmljZT1zLHRoaXMuX2NvcmVTZXJ2aWNlPXIsdGhpcy5fbW91c2VTZXJ2aWNlPW4sdGhpcy5fb3B0aW9uc1NlcnZpY2U9byx0aGlzLl9yZW5kZXJTZXJ2aWNlPWgsdGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlPWQsdGhpcy5fZHJhZ1Njcm9sbEFtb3VudD0wLHRoaXMuX2VuYWJsZWQ9ITAsdGhpcy5fd29ya0NlbGw9bmV3IHUuQ2VsbERhdGEsdGhpcy5fbW91c2VEb3duVGltZVN0YW1wPTAsdGhpcy5fb2xkSGFzU2VsZWN0aW9uPSExLHRoaXMuX29sZFNlbGVjdGlvblN0YXJ0PXZvaWQgMCx0aGlzLl9vbGRTZWxlY3Rpb25FbmQ9dm9pZCAwLHRoaXMuX29uTGludXhNb3VzZVNlbGVjdGlvbj10aGlzLnJlZ2lzdGVyKG5ldyBjLkV2ZW50RW1pdHRlciksdGhpcy5vbkxpbnV4TW91c2VTZWxlY3Rpb249dGhpcy5fb25MaW51eE1vdXNlU2VsZWN0aW9uLmV2ZW50LHRoaXMuX29uUmVkcmF3UmVxdWVzdD10aGlzLnJlZ2lzdGVyKG5ldyBjLkV2ZW50RW1pdHRlciksdGhpcy5vblJlcXVlc3RSZWRyYXc9dGhpcy5fb25SZWRyYXdSZXF1ZXN0LmV2ZW50LHRoaXMuX29uU2VsZWN0aW9uQ2hhbmdlPXRoaXMucmVnaXN0ZXIobmV3IGMuRXZlbnRFbWl0dGVyKSx0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlPXRoaXMuX29uU2VsZWN0aW9uQ2hhbmdlLmV2ZW50LHRoaXMuX29uUmVxdWVzdFNjcm9sbExpbmVzPXRoaXMucmVnaXN0ZXIobmV3IGMuRXZlbnRFbWl0dGVyKSx0aGlzLm9uUmVxdWVzdFNjcm9sbExpbmVzPXRoaXMuX29uUmVxdWVzdFNjcm9sbExpbmVzLmV2ZW50LHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyPWU9PnRoaXMuX2hhbmRsZU1vdXNlTW92ZShlKSx0aGlzLl9tb3VzZVVwTGlzdGVuZXI9ZT0+dGhpcy5faGFuZGxlTW91c2VVcChlKSx0aGlzLl9jb3JlU2VydmljZS5vblVzZXJJbnB1dCgoKCk9Pnt0aGlzLmhhc1NlbGVjdGlvbiYmdGhpcy5jbGVhclNlbGVjdGlvbigpfSkpLHRoaXMuX3RyaW1MaXN0ZW5lcj10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci5saW5lcy5vblRyaW0oKGU9PnRoaXMuX2hhbmRsZVRyaW0oZSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVycy5vbkJ1ZmZlckFjdGl2YXRlKChlPT50aGlzLl9oYW5kbGVCdWZmZXJBY3RpdmF0ZShlKSkpKSx0aGlzLmVuYWJsZSgpLHRoaXMuX21vZGVsPW5ldyBhLlNlbGVjdGlvbk1vZGVsKHRoaXMuX2J1ZmZlclNlcnZpY2UpLHRoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGU9MCx0aGlzLnJlZ2lzdGVyKCgwLGwudG9EaXNwb3NhYmxlKSgoKCk9Pnt0aGlzLl9yZW1vdmVNb3VzZURvd25MaXN0ZW5lcnMoKX0pKSl9cmVzZXQoKXt0aGlzLmNsZWFyU2VsZWN0aW9uKCl9ZGlzYWJsZSgpe3RoaXMuY2xlYXJTZWxlY3Rpb24oKSx0aGlzLl9lbmFibGVkPSExfWVuYWJsZSgpe3RoaXMuX2VuYWJsZWQ9ITB9Z2V0IHNlbGVjdGlvblN0YXJ0KCl7cmV0dXJuIHRoaXMuX21vZGVsLmZpbmFsU2VsZWN0aW9uU3RhcnR9Z2V0IHNlbGVjdGlvbkVuZCgpe3JldHVybiB0aGlzLl9tb2RlbC5maW5hbFNlbGVjdGlvbkVuZH1nZXQgaGFzU2VsZWN0aW9uKCl7Y29uc3QgZT10aGlzLl9tb2RlbC5maW5hbFNlbGVjdGlvblN0YXJ0LHQ9dGhpcy5fbW9kZWwuZmluYWxTZWxlY3Rpb25FbmQ7cmV0dXJuISghZXx8IXR8fGVbMF09PT10WzBdJiZlWzFdPT09dFsxXSl9Z2V0IHNlbGVjdGlvblRleHQoKXtjb25zdCBlPXRoaXMuX21vZGVsLmZpbmFsU2VsZWN0aW9uU3RhcnQsdD10aGlzLl9tb2RlbC5maW5hbFNlbGVjdGlvbkVuZDtpZighZXx8IXQpcmV0dXJuXCJcIjtjb25zdCBpPXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLHM9W107aWYoMz09PXRoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGUpe2lmKGVbMF09PT10WzBdKXJldHVyblwiXCI7Y29uc3Qgcj1lWzBdPHRbMF0/ZVswXTp0WzBdLG49ZVswXTx0WzBdP3RbMF06ZVswXTtmb3IobGV0IG89ZVsxXTtvPD10WzFdO28rKyl7Y29uc3QgZT1pLnRyYW5zbGF0ZUJ1ZmZlckxpbmVUb1N0cmluZyhvLCEwLHIsbik7cy5wdXNoKGUpfX1lbHNle2NvbnN0IHI9ZVsxXT09PXRbMV0/dFswXTp2b2lkIDA7cy5wdXNoKGkudHJhbnNsYXRlQnVmZmVyTGluZVRvU3RyaW5nKGVbMV0sITAsZVswXSxyKSk7Zm9yKGxldCByPWVbMV0rMTtyPD10WzFdLTE7cisrKXtjb25zdCBlPWkubGluZXMuZ2V0KHIpLHQ9aS50cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmcociwhMCk7ZT8uaXNXcmFwcGVkP3Nbcy5sZW5ndGgtMV0rPXQ6cy5wdXNoKHQpfWlmKGVbMV0hPT10WzFdKXtjb25zdCBlPWkubGluZXMuZ2V0KHRbMV0pLHI9aS50cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmcodFsxXSwhMCwwLHRbMF0pO2UmJmUuaXNXcmFwcGVkP3Nbcy5sZW5ndGgtMV0rPXI6cy5wdXNoKHIpfX1yZXR1cm4gcy5tYXAoKGU9PmUucmVwbGFjZShwLFwiIFwiKSkpLmpvaW4oZC5pc1dpbmRvd3M/XCJcXHJcXG5cIjpcIlxcblwiKX1jbGVhclNlbGVjdGlvbigpe3RoaXMuX21vZGVsLmNsZWFyU2VsZWN0aW9uKCksdGhpcy5fcmVtb3ZlTW91c2VEb3duTGlzdGVuZXJzKCksdGhpcy5yZWZyZXNoKCksdGhpcy5fb25TZWxlY3Rpb25DaGFuZ2UuZmlyZSgpfXJlZnJlc2goZSl7dGhpcy5fcmVmcmVzaEFuaW1hdGlvbkZyYW1lfHwodGhpcy5fcmVmcmVzaEFuaW1hdGlvbkZyYW1lPXRoaXMuX2NvcmVCcm93c2VyU2VydmljZS53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgoKT0+dGhpcy5fcmVmcmVzaCgpKSkpLGQuaXNMaW51eCYmZSYmdGhpcy5zZWxlY3Rpb25UZXh0Lmxlbmd0aCYmdGhpcy5fb25MaW51eE1vdXNlU2VsZWN0aW9uLmZpcmUodGhpcy5zZWxlY3Rpb25UZXh0KX1fcmVmcmVzaCgpe3RoaXMuX3JlZnJlc2hBbmltYXRpb25GcmFtZT12b2lkIDAsdGhpcy5fb25SZWRyYXdSZXF1ZXN0LmZpcmUoe3N0YXJ0OnRoaXMuX21vZGVsLmZpbmFsU2VsZWN0aW9uU3RhcnQsZW5kOnRoaXMuX21vZGVsLmZpbmFsU2VsZWN0aW9uRW5kLGNvbHVtblNlbGVjdE1vZGU6Mz09PXRoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGV9KX1faXNDbGlja0luU2VsZWN0aW9uKGUpe2NvbnN0IHQ9dGhpcy5fZ2V0TW91c2VCdWZmZXJDb29yZHMoZSksaT10aGlzLl9tb2RlbC5maW5hbFNlbGVjdGlvblN0YXJ0LHM9dGhpcy5fbW9kZWwuZmluYWxTZWxlY3Rpb25FbmQ7cmV0dXJuISEoaSYmcyYmdCkmJnRoaXMuX2FyZUNvb3Jkc0luU2VsZWN0aW9uKHQsaSxzKX1pc0NlbGxJblNlbGVjdGlvbihlLHQpe2NvbnN0IGk9dGhpcy5fbW9kZWwuZmluYWxTZWxlY3Rpb25TdGFydCxzPXRoaXMuX21vZGVsLmZpbmFsU2VsZWN0aW9uRW5kO3JldHVybiEoIWl8fCFzKSYmdGhpcy5fYXJlQ29vcmRzSW5TZWxlY3Rpb24oW2UsdF0saSxzKX1fYXJlQ29vcmRzSW5TZWxlY3Rpb24oZSx0LGkpe3JldHVybiBlWzFdPnRbMV0mJmVbMV08aVsxXXx8dFsxXT09PWlbMV0mJmVbMV09PT10WzFdJiZlWzBdPj10WzBdJiZlWzBdPGlbMF18fHRbMV08aVsxXSYmZVsxXT09PWlbMV0mJmVbMF08aVswXXx8dFsxXTxpWzFdJiZlWzFdPT09dFsxXSYmZVswXT49dFswXX1fc2VsZWN0V29yZEF0Q3Vyc29yKGUsdCl7Y29uc3QgaT10aGlzLl9saW5raWZpZXIuY3VycmVudExpbms/Lmxpbms/LnJhbmdlO2lmKGkpcmV0dXJuIHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0PVtpLnN0YXJ0LngtMSxpLnN0YXJ0LnktMV0sdGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnRMZW5ndGg9KDAsXy5nZXRSYW5nZUxlbmd0aCkoaSx0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpLHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZD12b2lkIDAsITA7Y29uc3Qgcz10aGlzLl9nZXRNb3VzZUJ1ZmZlckNvb3JkcyhlKTtyZXR1cm4hIXMmJih0aGlzLl9zZWxlY3RXb3JkQXQocyx0KSx0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmQ9dm9pZCAwLCEwKX1zZWxlY3RBbGwoKXt0aGlzLl9tb2RlbC5pc1NlbGVjdEFsbEFjdGl2ZT0hMCx0aGlzLnJlZnJlc2goKSx0aGlzLl9vblNlbGVjdGlvbkNoYW5nZS5maXJlKCl9c2VsZWN0TGluZXMoZSx0KXt0aGlzLl9tb2RlbC5jbGVhclNlbGVjdGlvbigpLGU9TWF0aC5tYXgoZSwwKSx0PU1hdGgubWluKHQsdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIubGluZXMubGVuZ3RoLTEpLHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0PVswLGVdLHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZD1bdGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLHRdLHRoaXMucmVmcmVzaCgpLHRoaXMuX29uU2VsZWN0aW9uQ2hhbmdlLmZpcmUoKX1faGFuZGxlVHJpbShlKXt0aGlzLl9tb2RlbC5oYW5kbGVUcmltKGUpJiZ0aGlzLnJlZnJlc2goKX1fZ2V0TW91c2VCdWZmZXJDb29yZHMoZSl7Y29uc3QgdD10aGlzLl9tb3VzZVNlcnZpY2UuZ2V0Q29vcmRzKGUsdGhpcy5fc2NyZWVuRWxlbWVudCx0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMsdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLCEwKTtpZih0KXJldHVybiB0WzBdLS0sdFsxXS0tLHRbMV0rPXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLnlkaXNwLHR9X2dldE1vdXNlRXZlbnRTY3JvbGxBbW91bnQoZSl7bGV0IHQ9KDAsbi5nZXRDb29yZHNSZWxhdGl2ZVRvRWxlbWVudCkodGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlLndpbmRvdyxlLHRoaXMuX3NjcmVlbkVsZW1lbnQpWzFdO2NvbnN0IGk9dGhpcy5fcmVuZGVyU2VydmljZS5kaW1lbnNpb25zLmNzcy5jYW52YXMuaGVpZ2h0O3JldHVybiB0Pj0wJiZ0PD1pPzA6KHQ+aSYmKHQtPWkpLHQ9TWF0aC5taW4oTWF0aC5tYXgodCwtNTApLDUwKSx0Lz01MCx0L01hdGguYWJzKHQpK01hdGgucm91bmQoMTQqdCkpfXNob3VsZEZvcmNlU2VsZWN0aW9uKGUpe3JldHVybiBkLmlzTWFjP2UuYWx0S2V5JiZ0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLm1hY09wdGlvbkNsaWNrRm9yY2VzU2VsZWN0aW9uOmUuc2hpZnRLZXl9aGFuZGxlTW91c2VEb3duKGUpe2lmKHRoaXMuX21vdXNlRG93blRpbWVTdGFtcD1lLnRpbWVTdGFtcCwoMiE9PWUuYnV0dG9ufHwhdGhpcy5oYXNTZWxlY3Rpb24pJiYwPT09ZS5idXR0b24pe2lmKCF0aGlzLl9lbmFibGVkKXtpZighdGhpcy5zaG91bGRGb3JjZVNlbGVjdGlvbihlKSlyZXR1cm47ZS5zdG9wUHJvcGFnYXRpb24oKX1lLnByZXZlbnREZWZhdWx0KCksdGhpcy5fZHJhZ1Njcm9sbEFtb3VudD0wLHRoaXMuX2VuYWJsZWQmJmUuc2hpZnRLZXk/dGhpcy5faGFuZGxlSW5jcmVtZW50YWxDbGljayhlKToxPT09ZS5kZXRhaWw/dGhpcy5faGFuZGxlU2luZ2xlQ2xpY2soZSk6Mj09PWUuZGV0YWlsP3RoaXMuX2hhbmRsZURvdWJsZUNsaWNrKGUpOjM9PT1lLmRldGFpbCYmdGhpcy5faGFuZGxlVHJpcGxlQ2xpY2soZSksdGhpcy5fYWRkTW91c2VEb3duTGlzdGVuZXJzKCksdGhpcy5yZWZyZXNoKCEwKX19X2FkZE1vdXNlRG93bkxpc3RlbmVycygpe3RoaXMuX3NjcmVlbkVsZW1lbnQub3duZXJEb2N1bWVudCYmKHRoaXMuX3NjcmVlbkVsZW1lbnQub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpLHRoaXMuX3NjcmVlbkVsZW1lbnQub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMuX21vdXNlVXBMaXN0ZW5lcikpLHRoaXMuX2RyYWdTY3JvbGxJbnRlcnZhbFRpbWVyPXRoaXMuX2NvcmVCcm93c2VyU2VydmljZS53aW5kb3cuc2V0SW50ZXJ2YWwoKCgpPT50aGlzLl9kcmFnU2Nyb2xsKCkpLDUwKX1fcmVtb3ZlTW91c2VEb3duTGlzdGVuZXJzKCl7dGhpcy5fc2NyZWVuRWxlbWVudC5vd25lckRvY3VtZW50JiYodGhpcy5fc2NyZWVuRWxlbWVudC5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lciksdGhpcy5fc2NyZWVuRWxlbWVudC5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5fbW91c2VVcExpc3RlbmVyKSksdGhpcy5fY29yZUJyb3dzZXJTZXJ2aWNlLndpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2RyYWdTY3JvbGxJbnRlcnZhbFRpbWVyKSx0aGlzLl9kcmFnU2Nyb2xsSW50ZXJ2YWxUaW1lcj12b2lkIDB9X2hhbmRsZUluY3JlbWVudGFsQ2xpY2soZSl7dGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnQmJih0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmQ9dGhpcy5fZ2V0TW91c2VCdWZmZXJDb29yZHMoZSkpfV9oYW5kbGVTaW5nbGVDbGljayhlKXtpZih0aGlzLl9tb2RlbC5zZWxlY3Rpb25TdGFydExlbmd0aD0wLHRoaXMuX21vZGVsLmlzU2VsZWN0QWxsQWN0aXZlPSExLHRoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGU9dGhpcy5zaG91bGRDb2x1bW5TZWxlY3QoZSk/MzowLHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0PXRoaXMuX2dldE1vdXNlQnVmZmVyQ29vcmRzKGUpLCF0aGlzLl9tb2RlbC5zZWxlY3Rpb25TdGFydClyZXR1cm47dGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kPXZvaWQgMDtjb25zdCB0PXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLmxpbmVzLmdldCh0aGlzLl9tb2RlbC5zZWxlY3Rpb25TdGFydFsxXSk7dCYmdC5sZW5ndGghPT10aGlzLl9tb2RlbC5zZWxlY3Rpb25TdGFydFswXSYmMD09PXQuaGFzV2lkdGgodGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnRbMF0pJiZ0aGlzLl9tb2RlbC5zZWxlY3Rpb25TdGFydFswXSsrfV9oYW5kbGVEb3VibGVDbGljayhlKXt0aGlzLl9zZWxlY3RXb3JkQXRDdXJzb3IoZSwhMCkmJih0aGlzLl9hY3RpdmVTZWxlY3Rpb25Nb2RlPTEpfV9oYW5kbGVUcmlwbGVDbGljayhlKXtjb25zdCB0PXRoaXMuX2dldE1vdXNlQnVmZmVyQ29vcmRzKGUpO3QmJih0aGlzLl9hY3RpdmVTZWxlY3Rpb25Nb2RlPTIsdGhpcy5fc2VsZWN0TGluZUF0KHRbMV0pKX1zaG91bGRDb2x1bW5TZWxlY3QoZSl7cmV0dXJuIGUuYWx0S2V5JiYhKGQuaXNNYWMmJnRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMubWFjT3B0aW9uQ2xpY2tGb3JjZXNTZWxlY3Rpb24pfV9oYW5kbGVNb3VzZU1vdmUoZSl7aWYoZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwhdGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnQpcmV0dXJuO2NvbnN0IHQ9dGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kP1t0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMF0sdGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kWzFdXTpudWxsO2lmKHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZD10aGlzLl9nZXRNb3VzZUJ1ZmZlckNvb3JkcyhlKSwhdGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kKXJldHVybiB2b2lkIHRoaXMucmVmcmVzaCghMCk7Mj09PXRoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGU/dGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kWzFdPHRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0WzFdP3RoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFswXT0wOnRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFswXT10aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHM6MT09PXRoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGUmJnRoaXMuX3NlbGVjdFRvV29yZEF0KHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZCksdGhpcy5fZHJhZ1Njcm9sbEFtb3VudD10aGlzLl9nZXRNb3VzZUV2ZW50U2Nyb2xsQW1vdW50KGUpLDMhPT10aGlzLl9hY3RpdmVTZWxlY3Rpb25Nb2RlJiYodGhpcy5fZHJhZ1Njcm9sbEFtb3VudD4wP3RoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFswXT10aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHM6dGhpcy5fZHJhZ1Njcm9sbEFtb3VudDwwJiYodGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kWzBdPTApKTtjb25zdCBpPXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyO2lmKHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFsxXTxpLmxpbmVzLmxlbmd0aCl7Y29uc3QgZT1pLmxpbmVzLmdldCh0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMV0pO2UmJjA9PT1lLmhhc1dpZHRoKHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFswXSkmJnRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFswXTx0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMmJnRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZFswXSsrfXQmJnRbMF09PT10aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMF0mJnRbMV09PT10aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMV18fHRoaXMucmVmcmVzaCghMCl9X2RyYWdTY3JvbGwoKXtpZih0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmQmJnRoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0JiZ0aGlzLl9kcmFnU2Nyb2xsQW1vdW50KXt0aGlzLl9vblJlcXVlc3RTY3JvbGxMaW5lcy5maXJlKHthbW91bnQ6dGhpcy5fZHJhZ1Njcm9sbEFtb3VudCxzdXBwcmVzc1Njcm9sbEV2ZW50OiExfSk7Y29uc3QgZT10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlcjt0aGlzLl9kcmFnU2Nyb2xsQW1vdW50PjA/KDMhPT10aGlzLl9hY3RpdmVTZWxlY3Rpb25Nb2RlJiYodGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kWzBdPXRoaXMuX2J1ZmZlclNlcnZpY2UuY29scyksdGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kWzFdPU1hdGgubWluKGUueWRpc3ArdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLGUubGluZXMubGVuZ3RoLTEpKTooMyE9PXRoaXMuX2FjdGl2ZVNlbGVjdGlvbk1vZGUmJih0aGlzLl9tb2RlbC5zZWxlY3Rpb25FbmRbMF09MCksdGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kWzFdPWUueWRpc3ApLHRoaXMucmVmcmVzaCgpfX1faGFuZGxlTW91c2VVcChlKXtjb25zdCB0PWUudGltZVN0YW1wLXRoaXMuX21vdXNlRG93blRpbWVTdGFtcDtpZih0aGlzLl9yZW1vdmVNb3VzZURvd25MaXN0ZW5lcnMoKSx0aGlzLnNlbGVjdGlvblRleHQubGVuZ3RoPD0xJiZ0PDUwMCYmZS5hbHRLZXkmJnRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuYWx0Q2xpY2tNb3Zlc0N1cnNvcil7aWYodGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIueWJhc2U9PT10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci55ZGlzcCl7Y29uc3QgdD10aGlzLl9tb3VzZVNlcnZpY2UuZ2V0Q29vcmRzKGUsdGhpcy5fZWxlbWVudCx0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMsdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLCExKTtpZih0JiZ2b2lkIDAhPT10WzBdJiZ2b2lkIDAhPT10WzFdKXtjb25zdCBlPSgwLG8ubW92ZVRvQ2VsbFNlcXVlbmNlKSh0WzBdLTEsdFsxXS0xLHRoaXMuX2J1ZmZlclNlcnZpY2UsdGhpcy5fY29yZVNlcnZpY2UuZGVjUHJpdmF0ZU1vZGVzLmFwcGxpY2F0aW9uQ3Vyc29yS2V5cyk7dGhpcy5fY29yZVNlcnZpY2UudHJpZ2dlckRhdGFFdmVudChlLCEwKX19fWVsc2UgdGhpcy5fZmlyZUV2ZW50SWZTZWxlY3Rpb25DaGFuZ2VkKCl9X2ZpcmVFdmVudElmU2VsZWN0aW9uQ2hhbmdlZCgpe2NvbnN0IGU9dGhpcy5fbW9kZWwuZmluYWxTZWxlY3Rpb25TdGFydCx0PXRoaXMuX21vZGVsLmZpbmFsU2VsZWN0aW9uRW5kLGk9ISghZXx8IXR8fGVbMF09PT10WzBdJiZlWzFdPT09dFsxXSk7aT9lJiZ0JiYodGhpcy5fb2xkU2VsZWN0aW9uU3RhcnQmJnRoaXMuX29sZFNlbGVjdGlvbkVuZCYmZVswXT09PXRoaXMuX29sZFNlbGVjdGlvblN0YXJ0WzBdJiZlWzFdPT09dGhpcy5fb2xkU2VsZWN0aW9uU3RhcnRbMV0mJnRbMF09PT10aGlzLl9vbGRTZWxlY3Rpb25FbmRbMF0mJnRbMV09PT10aGlzLl9vbGRTZWxlY3Rpb25FbmRbMV18fHRoaXMuX2ZpcmVPblNlbGVjdGlvbkNoYW5nZShlLHQsaSkpOnRoaXMuX29sZEhhc1NlbGVjdGlvbiYmdGhpcy5fZmlyZU9uU2VsZWN0aW9uQ2hhbmdlKGUsdCxpKX1fZmlyZU9uU2VsZWN0aW9uQ2hhbmdlKGUsdCxpKXt0aGlzLl9vbGRTZWxlY3Rpb25TdGFydD1lLHRoaXMuX29sZFNlbGVjdGlvbkVuZD10LHRoaXMuX29sZEhhc1NlbGVjdGlvbj1pLHRoaXMuX29uU2VsZWN0aW9uQ2hhbmdlLmZpcmUoKX1faGFuZGxlQnVmZmVyQWN0aXZhdGUoZSl7dGhpcy5jbGVhclNlbGVjdGlvbigpLHRoaXMuX3RyaW1MaXN0ZW5lci5kaXNwb3NlKCksdGhpcy5fdHJpbUxpc3RlbmVyPWUuYWN0aXZlQnVmZmVyLmxpbmVzLm9uVHJpbSgoZT0+dGhpcy5faGFuZGxlVHJpbShlKSkpfV9jb252ZXJ0Vmlld3BvcnRDb2xUb0NoYXJhY3RlckluZGV4KGUsdCl7bGV0IGk9dDtmb3IobGV0IHM9MDt0Pj1zO3MrKyl7Y29uc3Qgcj1lLmxvYWRDZWxsKHMsdGhpcy5fd29ya0NlbGwpLmdldENoYXJzKCkubGVuZ3RoOzA9PT10aGlzLl93b3JrQ2VsbC5nZXRXaWR0aCgpP2ktLTpyPjEmJnQhPT1zJiYoaSs9ci0xKX1yZXR1cm4gaX1zZXRTZWxlY3Rpb24oZSx0LGkpe3RoaXMuX21vZGVsLmNsZWFyU2VsZWN0aW9uKCksdGhpcy5fcmVtb3ZlTW91c2VEb3duTGlzdGVuZXJzKCksdGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnQ9W2UsdF0sdGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnRMZW5ndGg9aSx0aGlzLnJlZnJlc2goKSx0aGlzLl9maXJlRXZlbnRJZlNlbGVjdGlvbkNoYW5nZWQoKX1yaWdodENsaWNrU2VsZWN0KGUpe3RoaXMuX2lzQ2xpY2tJblNlbGVjdGlvbihlKXx8KHRoaXMuX3NlbGVjdFdvcmRBdEN1cnNvcihlLCExKSYmdGhpcy5yZWZyZXNoKCEwKSx0aGlzLl9maXJlRXZlbnRJZlNlbGVjdGlvbkNoYW5nZWQoKSl9X2dldFdvcmRBdChlLHQsaT0hMCxzPSEwKXtpZihlWzBdPj10aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpcmV0dXJuO2NvbnN0IHI9dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIsbj1yLmxpbmVzLmdldChlWzFdKTtpZighbilyZXR1cm47Y29uc3Qgbz1yLnRyYW5zbGF0ZUJ1ZmZlckxpbmVUb1N0cmluZyhlWzFdLCExKTtsZXQgYT10aGlzLl9jb252ZXJ0Vmlld3BvcnRDb2xUb0NoYXJhY3RlckluZGV4KG4sZVswXSksaD1hO2NvbnN0IGM9ZVswXS1hO2xldCBsPTAsZD0wLF89MCx1PTA7aWYoXCIgXCI9PT1vLmNoYXJBdChhKSl7Zm9yKDthPjAmJlwiIFwiPT09by5jaGFyQXQoYS0xKTspYS0tO2Zvcig7aDxvLmxlbmd0aCYmXCIgXCI9PT1vLmNoYXJBdChoKzEpOyloKyt9ZWxzZXtsZXQgdD1lWzBdLGk9ZVswXTswPT09bi5nZXRXaWR0aCh0KSYmKGwrKyx0LS0pLDI9PT1uLmdldFdpZHRoKGkpJiYoZCsrLGkrKyk7Y29uc3Qgcz1uLmdldFN0cmluZyhpKS5sZW5ndGg7Zm9yKHM+MSYmKHUrPXMtMSxoKz1zLTEpO3Q+MCYmYT4wJiYhdGhpcy5faXNDaGFyV29yZFNlcGFyYXRvcihuLmxvYWRDZWxsKHQtMSx0aGlzLl93b3JrQ2VsbCkpOyl7bi5sb2FkQ2VsbCh0LTEsdGhpcy5fd29ya0NlbGwpO2NvbnN0IGU9dGhpcy5fd29ya0NlbGwuZ2V0Q2hhcnMoKS5sZW5ndGg7MD09PXRoaXMuX3dvcmtDZWxsLmdldFdpZHRoKCk/KGwrKyx0LS0pOmU+MSYmKF8rPWUtMSxhLT1lLTEpLGEtLSx0LS19Zm9yKDtpPG4ubGVuZ3RoJiZoKzE8by5sZW5ndGgmJiF0aGlzLl9pc0NoYXJXb3JkU2VwYXJhdG9yKG4ubG9hZENlbGwoaSsxLHRoaXMuX3dvcmtDZWxsKSk7KXtuLmxvYWRDZWxsKGkrMSx0aGlzLl93b3JrQ2VsbCk7Y29uc3QgZT10aGlzLl93b3JrQ2VsbC5nZXRDaGFycygpLmxlbmd0aDsyPT09dGhpcy5fd29ya0NlbGwuZ2V0V2lkdGgoKT8oZCsrLGkrKyk6ZT4xJiYodSs9ZS0xLGgrPWUtMSksaCsrLGkrK319aCsrO2xldCBmPWErYy1sK18sdj1NYXRoLm1pbih0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMsaC1hK2wrZC1fLXUpO2lmKHR8fFwiXCIhPT1vLnNsaWNlKGEsaCkudHJpbSgpKXtpZihpJiYwPT09ZiYmMzIhPT1uLmdldENvZGVQb2ludCgwKSl7Y29uc3QgdD1yLmxpbmVzLmdldChlWzFdLTEpO2lmKHQmJm4uaXNXcmFwcGVkJiYzMiE9PXQuZ2V0Q29kZVBvaW50KHRoaXMuX2J1ZmZlclNlcnZpY2UuY29scy0xKSl7Y29uc3QgdD10aGlzLl9nZXRXb3JkQXQoW3RoaXMuX2J1ZmZlclNlcnZpY2UuY29scy0xLGVbMV0tMV0sITEsITAsITEpO2lmKHQpe2NvbnN0IGU9dGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLXQuc3RhcnQ7Zi09ZSx2Kz1lfX19aWYocyYmZit2PT09dGhpcy5fYnVmZmVyU2VydmljZS5jb2xzJiYzMiE9PW4uZ2V0Q29kZVBvaW50KHRoaXMuX2J1ZmZlclNlcnZpY2UuY29scy0xKSl7Y29uc3QgdD1yLmxpbmVzLmdldChlWzFdKzEpO2lmKHQ/LmlzV3JhcHBlZCYmMzIhPT10LmdldENvZGVQb2ludCgwKSl7Y29uc3QgdD10aGlzLl9nZXRXb3JkQXQoWzAsZVsxXSsxXSwhMSwhMSwhMCk7dCYmKHYrPXQubGVuZ3RoKX19cmV0dXJue3N0YXJ0OmYsbGVuZ3RoOnZ9fX1fc2VsZWN0V29yZEF0KGUsdCl7Y29uc3QgaT10aGlzLl9nZXRXb3JkQXQoZSx0KTtpZihpKXtmb3IoO2kuc3RhcnQ8MDspaS5zdGFydCs9dGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLGVbMV0tLTt0aGlzLl9tb2RlbC5zZWxlY3Rpb25TdGFydD1baS5zdGFydCxlWzFdXSx0aGlzLl9tb2RlbC5zZWxlY3Rpb25TdGFydExlbmd0aD1pLmxlbmd0aH19X3NlbGVjdFRvV29yZEF0KGUpe2NvbnN0IHQ9dGhpcy5fZ2V0V29yZEF0KGUsITApO2lmKHQpe2xldCBpPWVbMV07Zm9yKDt0LnN0YXJ0PDA7KXQuc3RhcnQrPXRoaXMuX2J1ZmZlclNlcnZpY2UuY29scyxpLS07aWYoIXRoaXMuX21vZGVsLmFyZVNlbGVjdGlvblZhbHVlc1JldmVyc2VkKCkpZm9yKDt0LnN0YXJ0K3QubGVuZ3RoPnRoaXMuX2J1ZmZlclNlcnZpY2UuY29sczspdC5sZW5ndGgtPXRoaXMuX2J1ZmZlclNlcnZpY2UuY29scyxpKys7dGhpcy5fbW9kZWwuc2VsZWN0aW9uRW5kPVt0aGlzLl9tb2RlbC5hcmVTZWxlY3Rpb25WYWx1ZXNSZXZlcnNlZCgpP3Quc3RhcnQ6dC5zdGFydCt0Lmxlbmd0aCxpXX19X2lzQ2hhcldvcmRTZXBhcmF0b3IoZSl7cmV0dXJuIDAhPT1lLmdldFdpZHRoKCkmJnRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMud29yZFNlcGFyYXRvci5pbmRleE9mKGUuZ2V0Q2hhcnMoKSk+PTB9X3NlbGVjdExpbmVBdChlKXtjb25zdCB0PXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLmdldFdyYXBwZWRSYW5nZUZvckxpbmUoZSksaT17c3RhcnQ6e3g6MCx5OnQuZmlyc3R9LGVuZDp7eDp0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMtMSx5OnQubGFzdH19O3RoaXMuX21vZGVsLnNlbGVjdGlvblN0YXJ0PVswLHQuZmlyc3RdLHRoaXMuX21vZGVsLnNlbGVjdGlvbkVuZD12b2lkIDAsdGhpcy5fbW9kZWwuc2VsZWN0aW9uU3RhcnRMZW5ndGg9KDAsXy5nZXRSYW5nZUxlbmd0aCkoaSx0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpfX07dC5TZWxlY3Rpb25TZXJ2aWNlPWc9cyhbcigzLGYuSUJ1ZmZlclNlcnZpY2UpLHIoNCxmLklDb3JlU2VydmljZSkscig1LGguSU1vdXNlU2VydmljZSkscig2LGYuSU9wdGlvbnNTZXJ2aWNlKSxyKDcsaC5JUmVuZGVyU2VydmljZSkscig4LGguSUNvcmVCcm93c2VyU2VydmljZSldLGcpfSw0NzI1OihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LklMaW5rUHJvdmlkZXJTZXJ2aWNlPXQuSVRoZW1lU2VydmljZT10LklDaGFyYWN0ZXJKb2luZXJTZXJ2aWNlPXQuSVNlbGVjdGlvblNlcnZpY2U9dC5JUmVuZGVyU2VydmljZT10LklNb3VzZVNlcnZpY2U9dC5JQ29yZUJyb3dzZXJTZXJ2aWNlPXQuSUNoYXJTaXplU2VydmljZT12b2lkIDA7Y29uc3Qgcz1pKDgzNDMpO3QuSUNoYXJTaXplU2VydmljZT0oMCxzLmNyZWF0ZURlY29yYXRvcikoXCJDaGFyU2l6ZVNlcnZpY2VcIiksdC5JQ29yZUJyb3dzZXJTZXJ2aWNlPSgwLHMuY3JlYXRlRGVjb3JhdG9yKShcIkNvcmVCcm93c2VyU2VydmljZVwiKSx0LklNb3VzZVNlcnZpY2U9KDAscy5jcmVhdGVEZWNvcmF0b3IpKFwiTW91c2VTZXJ2aWNlXCIpLHQuSVJlbmRlclNlcnZpY2U9KDAscy5jcmVhdGVEZWNvcmF0b3IpKFwiUmVuZGVyU2VydmljZVwiKSx0LklTZWxlY3Rpb25TZXJ2aWNlPSgwLHMuY3JlYXRlRGVjb3JhdG9yKShcIlNlbGVjdGlvblNlcnZpY2VcIiksdC5JQ2hhcmFjdGVySm9pbmVyU2VydmljZT0oMCxzLmNyZWF0ZURlY29yYXRvcikoXCJDaGFyYWN0ZXJKb2luZXJTZXJ2aWNlXCIpLHQuSVRoZW1lU2VydmljZT0oMCxzLmNyZWF0ZURlY29yYXRvcikoXCJUaGVtZVNlcnZpY2VcIiksdC5JTGlua1Byb3ZpZGVyU2VydmljZT0oMCxzLmNyZWF0ZURlY29yYXRvcikoXCJMaW5rUHJvdmlkZXJTZXJ2aWNlXCIpfSw2NzMxOmZ1bmN0aW9uKGUsdCxpKXt2YXIgcz10aGlzJiZ0aGlzLl9fZGVjb3JhdGV8fGZ1bmN0aW9uKGUsdCxpLHMpe3ZhciByLG49YXJndW1lbnRzLmxlbmd0aCxvPW48Mz90Om51bGw9PT1zP3M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGkpOnM7aWYoXCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3QmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUpbz1SZWZsZWN0LmRlY29yYXRlKGUsdCxpLHMpO2Vsc2UgZm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MDthLS0pKHI9ZVthXSkmJihvPShuPDM/cihvKTpuPjM/cih0LGksbyk6cih0LGkpKXx8byk7cmV0dXJuIG4+MyYmbyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSxvKSxvfSxyPXRoaXMmJnRoaXMuX19wYXJhbXx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oaSxzKXt0KGkscyxlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVGhlbWVTZXJ2aWNlPXQuREVGQVVMVF9BTlNJX0NPTE9SUz12b2lkIDA7Y29uc3Qgbj1pKDcyMzkpLG89aSg4MDU1KSxhPWkoODQ2MCksaD1pKDg0NCksYz1pKDI1ODUpLGw9by5jc3MudG9Db2xvcihcIiNmZmZmZmZcIiksZD1vLmNzcy50b0NvbG9yKFwiIzAwMDAwMFwiKSxfPW8uY3NzLnRvQ29sb3IoXCIjZmZmZmZmXCIpLHU9by5jc3MudG9Db2xvcihcIiMwMDAwMDBcIiksZj17Y3NzOlwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpXCIscmdiYTo0Mjk0OTY3MTE3fTt0LkRFRkFVTFRfQU5TSV9DT0xPUlM9T2JqZWN0LmZyZWV6ZSgoKCk9Pntjb25zdCBlPVtvLmNzcy50b0NvbG9yKFwiIzJlMzQzNlwiKSxvLmNzcy50b0NvbG9yKFwiI2NjMDAwMFwiKSxvLmNzcy50b0NvbG9yKFwiIzRlOWEwNlwiKSxvLmNzcy50b0NvbG9yKFwiI2M0YTAwMFwiKSxvLmNzcy50b0NvbG9yKFwiIzM0NjVhNFwiKSxvLmNzcy50b0NvbG9yKFwiIzc1NTA3YlwiKSxvLmNzcy50b0NvbG9yKFwiIzA2OTg5YVwiKSxvLmNzcy50b0NvbG9yKFwiI2QzZDdjZlwiKSxvLmNzcy50b0NvbG9yKFwiIzU1NTc1M1wiKSxvLmNzcy50b0NvbG9yKFwiI2VmMjkyOVwiKSxvLmNzcy50b0NvbG9yKFwiIzhhZTIzNFwiKSxvLmNzcy50b0NvbG9yKFwiI2ZjZTk0ZlwiKSxvLmNzcy50b0NvbG9yKFwiIzcyOWZjZlwiKSxvLmNzcy50b0NvbG9yKFwiI2FkN2ZhOFwiKSxvLmNzcy50b0NvbG9yKFwiIzM0ZTJlMlwiKSxvLmNzcy50b0NvbG9yKFwiI2VlZWVlY1wiKV0sdD1bMCw5NSwxMzUsMTc1LDIxNSwyNTVdO2ZvcihsZXQgaT0wO2k8MjE2O2krKyl7Y29uc3Qgcz10W2kvMzYlNnwwXSxyPXRbaS82JTZ8MF0sbj10W2klNl07ZS5wdXNoKHtjc3M6by5jaGFubmVscy50b0NzcyhzLHIsbikscmdiYTpvLmNoYW5uZWxzLnRvUmdiYShzLHIsbil9KX1mb3IobGV0IHQ9MDt0PDI0O3QrKyl7Y29uc3QgaT04KzEwKnQ7ZS5wdXNoKHtjc3M6by5jaGFubmVscy50b0NzcyhpLGksaSkscmdiYTpvLmNoYW5uZWxzLnRvUmdiYShpLGksaSl9KX1yZXR1cm4gZX0pKCkpO2xldCB2PXQuVGhlbWVTZXJ2aWNlPWNsYXNzIGV4dGVuZHMgaC5EaXNwb3NhYmxle2dldCBjb2xvcnMoKXtyZXR1cm4gdGhpcy5fY29sb3JzfWNvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5fb3B0aW9uc1NlcnZpY2U9ZSx0aGlzLl9jb250cmFzdENhY2hlPW5ldyBuLkNvbG9yQ29udHJhc3RDYWNoZSx0aGlzLl9oYWxmQ29udHJhc3RDYWNoZT1uZXcgbi5Db2xvckNvbnRyYXN0Q2FjaGUsdGhpcy5fb25DaGFuZ2VDb2xvcnM9dGhpcy5yZWdpc3RlcihuZXcgYS5FdmVudEVtaXR0ZXIpLHRoaXMub25DaGFuZ2VDb2xvcnM9dGhpcy5fb25DaGFuZ2VDb2xvcnMuZXZlbnQsdGhpcy5fY29sb3JzPXtmb3JlZ3JvdW5kOmwsYmFja2dyb3VuZDpkLGN1cnNvcjpfLGN1cnNvckFjY2VudDp1LHNlbGVjdGlvbkZvcmVncm91bmQ6dm9pZCAwLHNlbGVjdGlvbkJhY2tncm91bmRUcmFuc3BhcmVudDpmLHNlbGVjdGlvbkJhY2tncm91bmRPcGFxdWU6by5jb2xvci5ibGVuZChkLGYpLHNlbGVjdGlvbkluYWN0aXZlQmFja2dyb3VuZFRyYW5zcGFyZW50OmYsc2VsZWN0aW9uSW5hY3RpdmVCYWNrZ3JvdW5kT3BhcXVlOm8uY29sb3IuYmxlbmQoZCxmKSxhbnNpOnQuREVGQVVMVF9BTlNJX0NPTE9SUy5zbGljZSgpLGNvbnRyYXN0Q2FjaGU6dGhpcy5fY29udHJhc3RDYWNoZSxoYWxmQ29udHJhc3RDYWNoZTp0aGlzLl9oYWxmQ29udHJhc3RDYWNoZX0sdGhpcy5fdXBkYXRlUmVzdG9yZUNvbG9ycygpLHRoaXMuX3NldFRoZW1lKHRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMudGhlbWUpLHRoaXMucmVnaXN0ZXIodGhpcy5fb3B0aW9uc1NlcnZpY2Uub25TcGVjaWZpY09wdGlvbkNoYW5nZShcIm1pbmltdW1Db250cmFzdFJhdGlvXCIsKCgpPT50aGlzLl9jb250cmFzdENhY2hlLmNsZWFyKCkpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9vcHRpb25zU2VydmljZS5vblNwZWNpZmljT3B0aW9uQ2hhbmdlKFwidGhlbWVcIiwoKCk9PnRoaXMuX3NldFRoZW1lKHRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMudGhlbWUpKSkpfV9zZXRUaGVtZShlPXt9KXtjb25zdCBpPXRoaXMuX2NvbG9ycztpZihpLmZvcmVncm91bmQ9cChlLmZvcmVncm91bmQsbCksaS5iYWNrZ3JvdW5kPXAoZS5iYWNrZ3JvdW5kLGQpLGkuY3Vyc29yPXAoZS5jdXJzb3IsXyksaS5jdXJzb3JBY2NlbnQ9cChlLmN1cnNvckFjY2VudCx1KSxpLnNlbGVjdGlvbkJhY2tncm91bmRUcmFuc3BhcmVudD1wKGUuc2VsZWN0aW9uQmFja2dyb3VuZCxmKSxpLnNlbGVjdGlvbkJhY2tncm91bmRPcGFxdWU9by5jb2xvci5ibGVuZChpLmJhY2tncm91bmQsaS5zZWxlY3Rpb25CYWNrZ3JvdW5kVHJhbnNwYXJlbnQpLGkuc2VsZWN0aW9uSW5hY3RpdmVCYWNrZ3JvdW5kVHJhbnNwYXJlbnQ9cChlLnNlbGVjdGlvbkluYWN0aXZlQmFja2dyb3VuZCxpLnNlbGVjdGlvbkJhY2tncm91bmRUcmFuc3BhcmVudCksaS5zZWxlY3Rpb25JbmFjdGl2ZUJhY2tncm91bmRPcGFxdWU9by5jb2xvci5ibGVuZChpLmJhY2tncm91bmQsaS5zZWxlY3Rpb25JbmFjdGl2ZUJhY2tncm91bmRUcmFuc3BhcmVudCksaS5zZWxlY3Rpb25Gb3JlZ3JvdW5kPWUuc2VsZWN0aW9uRm9yZWdyb3VuZD9wKGUuc2VsZWN0aW9uRm9yZWdyb3VuZCxvLk5VTExfQ09MT1IpOnZvaWQgMCxpLnNlbGVjdGlvbkZvcmVncm91bmQ9PT1vLk5VTExfQ09MT1ImJihpLnNlbGVjdGlvbkZvcmVncm91bmQ9dm9pZCAwKSxvLmNvbG9yLmlzT3BhcXVlKGkuc2VsZWN0aW9uQmFja2dyb3VuZFRyYW5zcGFyZW50KSl7Y29uc3QgZT0uMztpLnNlbGVjdGlvbkJhY2tncm91bmRUcmFuc3BhcmVudD1vLmNvbG9yLm9wYWNpdHkoaS5zZWxlY3Rpb25CYWNrZ3JvdW5kVHJhbnNwYXJlbnQsZSl9aWYoby5jb2xvci5pc09wYXF1ZShpLnNlbGVjdGlvbkluYWN0aXZlQmFja2dyb3VuZFRyYW5zcGFyZW50KSl7Y29uc3QgZT0uMztpLnNlbGVjdGlvbkluYWN0aXZlQmFja2dyb3VuZFRyYW5zcGFyZW50PW8uY29sb3Iub3BhY2l0eShpLnNlbGVjdGlvbkluYWN0aXZlQmFja2dyb3VuZFRyYW5zcGFyZW50LGUpfWlmKGkuYW5zaT10LkRFRkFVTFRfQU5TSV9DT0xPUlMuc2xpY2UoKSxpLmFuc2lbMF09cChlLmJsYWNrLHQuREVGQVVMVF9BTlNJX0NPTE9SU1swXSksaS5hbnNpWzFdPXAoZS5yZWQsdC5ERUZBVUxUX0FOU0lfQ09MT1JTWzFdKSxpLmFuc2lbMl09cChlLmdyZWVuLHQuREVGQVVMVF9BTlNJX0NPTE9SU1syXSksaS5hbnNpWzNdPXAoZS55ZWxsb3csdC5ERUZBVUxUX0FOU0lfQ09MT1JTWzNdKSxpLmFuc2lbNF09cChlLmJsdWUsdC5ERUZBVUxUX0FOU0lfQ09MT1JTWzRdKSxpLmFuc2lbNV09cChlLm1hZ2VudGEsdC5ERUZBVUxUX0FOU0lfQ09MT1JTWzVdKSxpLmFuc2lbNl09cChlLmN5YW4sdC5ERUZBVUxUX0FOU0lfQ09MT1JTWzZdKSxpLmFuc2lbN109cChlLndoaXRlLHQuREVGQVVMVF9BTlNJX0NPTE9SU1s3XSksaS5hbnNpWzhdPXAoZS5icmlnaHRCbGFjayx0LkRFRkFVTFRfQU5TSV9DT0xPUlNbOF0pLGkuYW5zaVs5XT1wKGUuYnJpZ2h0UmVkLHQuREVGQVVMVF9BTlNJX0NPTE9SU1s5XSksaS5hbnNpWzEwXT1wKGUuYnJpZ2h0R3JlZW4sdC5ERUZBVUxUX0FOU0lfQ09MT1JTWzEwXSksaS5hbnNpWzExXT1wKGUuYnJpZ2h0WWVsbG93LHQuREVGQVVMVF9BTlNJX0NPTE9SU1sxMV0pLGkuYW5zaVsxMl09cChlLmJyaWdodEJsdWUsdC5ERUZBVUxUX0FOU0lfQ09MT1JTWzEyXSksaS5hbnNpWzEzXT1wKGUuYnJpZ2h0TWFnZW50YSx0LkRFRkFVTFRfQU5TSV9DT0xPUlNbMTNdKSxpLmFuc2lbMTRdPXAoZS5icmlnaHRDeWFuLHQuREVGQVVMVF9BTlNJX0NPTE9SU1sxNF0pLGkuYW5zaVsxNV09cChlLmJyaWdodFdoaXRlLHQuREVGQVVMVF9BTlNJX0NPTE9SU1sxNV0pLGUuZXh0ZW5kZWRBbnNpKXtjb25zdCBzPU1hdGgubWluKGkuYW5zaS5sZW5ndGgtMTYsZS5leHRlbmRlZEFuc2kubGVuZ3RoKTtmb3IobGV0IHI9MDtyPHM7cisrKWkuYW5zaVtyKzE2XT1wKGUuZXh0ZW5kZWRBbnNpW3JdLHQuREVGQVVMVF9BTlNJX0NPTE9SU1tyKzE2XSl9dGhpcy5fY29udHJhc3RDYWNoZS5jbGVhcigpLHRoaXMuX2hhbGZDb250cmFzdENhY2hlLmNsZWFyKCksdGhpcy5fdXBkYXRlUmVzdG9yZUNvbG9ycygpLHRoaXMuX29uQ2hhbmdlQ29sb3JzLmZpcmUodGhpcy5jb2xvcnMpfXJlc3RvcmVDb2xvcihlKXt0aGlzLl9yZXN0b3JlQ29sb3IoZSksdGhpcy5fb25DaGFuZ2VDb2xvcnMuZmlyZSh0aGlzLmNvbG9ycyl9X3Jlc3RvcmVDb2xvcihlKXtpZih2b2lkIDAhPT1lKXN3aXRjaChlKXtjYXNlIDI1Njp0aGlzLl9jb2xvcnMuZm9yZWdyb3VuZD10aGlzLl9yZXN0b3JlQ29sb3JzLmZvcmVncm91bmQ7YnJlYWs7Y2FzZSAyNTc6dGhpcy5fY29sb3JzLmJhY2tncm91bmQ9dGhpcy5fcmVzdG9yZUNvbG9ycy5iYWNrZ3JvdW5kO2JyZWFrO2Nhc2UgMjU4OnRoaXMuX2NvbG9ycy5jdXJzb3I9dGhpcy5fcmVzdG9yZUNvbG9ycy5jdXJzb3I7YnJlYWs7ZGVmYXVsdDp0aGlzLl9jb2xvcnMuYW5zaVtlXT10aGlzLl9yZXN0b3JlQ29sb3JzLmFuc2lbZV19ZWxzZSBmb3IobGV0IGU9MDtlPHRoaXMuX3Jlc3RvcmVDb2xvcnMuYW5zaS5sZW5ndGg7KytlKXRoaXMuX2NvbG9ycy5hbnNpW2VdPXRoaXMuX3Jlc3RvcmVDb2xvcnMuYW5zaVtlXX1tb2RpZnlDb2xvcnMoZSl7ZSh0aGlzLl9jb2xvcnMpLHRoaXMuX29uQ2hhbmdlQ29sb3JzLmZpcmUodGhpcy5jb2xvcnMpfV91cGRhdGVSZXN0b3JlQ29sb3JzKCl7dGhpcy5fcmVzdG9yZUNvbG9ycz17Zm9yZWdyb3VuZDp0aGlzLl9jb2xvcnMuZm9yZWdyb3VuZCxiYWNrZ3JvdW5kOnRoaXMuX2NvbG9ycy5iYWNrZ3JvdW5kLGN1cnNvcjp0aGlzLl9jb2xvcnMuY3Vyc29yLGFuc2k6dGhpcy5fY29sb3JzLmFuc2kuc2xpY2UoKX19fTtmdW5jdGlvbiBwKGUsdCl7aWYodm9pZCAwIT09ZSl0cnl7cmV0dXJuIG8uY3NzLnRvQ29sb3IoZSl9Y2F0Y2h7fXJldHVybiB0fXQuVGhlbWVTZXJ2aWNlPXY9cyhbcigwLGMuSU9wdGlvbnNTZXJ2aWNlKV0sdil9LDYzNDk6KGUsdCxpKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuQ2lyY3VsYXJMaXN0PXZvaWQgMDtjb25zdCBzPWkoODQ2MCkscj1pKDg0NCk7Y2xhc3MgbiBleHRlbmRzIHIuRGlzcG9zYWJsZXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuX21heExlbmd0aD1lLHRoaXMub25EZWxldGVFbWl0dGVyPXRoaXMucmVnaXN0ZXIobmV3IHMuRXZlbnRFbWl0dGVyKSx0aGlzLm9uRGVsZXRlPXRoaXMub25EZWxldGVFbWl0dGVyLmV2ZW50LHRoaXMub25JbnNlcnRFbWl0dGVyPXRoaXMucmVnaXN0ZXIobmV3IHMuRXZlbnRFbWl0dGVyKSx0aGlzLm9uSW5zZXJ0PXRoaXMub25JbnNlcnRFbWl0dGVyLmV2ZW50LHRoaXMub25UcmltRW1pdHRlcj10aGlzLnJlZ2lzdGVyKG5ldyBzLkV2ZW50RW1pdHRlciksdGhpcy5vblRyaW09dGhpcy5vblRyaW1FbWl0dGVyLmV2ZW50LHRoaXMuX2FycmF5PW5ldyBBcnJheSh0aGlzLl9tYXhMZW5ndGgpLHRoaXMuX3N0YXJ0SW5kZXg9MCx0aGlzLl9sZW5ndGg9MH1nZXQgbWF4TGVuZ3RoKCl7cmV0dXJuIHRoaXMuX21heExlbmd0aH1zZXQgbWF4TGVuZ3RoKGUpe2lmKHRoaXMuX21heExlbmd0aD09PWUpcmV0dXJuO2NvbnN0IHQ9bmV3IEFycmF5KGUpO2ZvcihsZXQgaT0wO2k8TWF0aC5taW4oZSx0aGlzLmxlbmd0aCk7aSsrKXRbaV09dGhpcy5fYXJyYXlbdGhpcy5fZ2V0Q3ljbGljSW5kZXgoaSldO3RoaXMuX2FycmF5PXQsdGhpcy5fbWF4TGVuZ3RoPWUsdGhpcy5fc3RhcnRJbmRleD0wfWdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5fbGVuZ3RofXNldCBsZW5ndGgoZSl7aWYoZT50aGlzLl9sZW5ndGgpZm9yKGxldCB0PXRoaXMuX2xlbmd0aDt0PGU7dCsrKXRoaXMuX2FycmF5W3RdPXZvaWQgMDt0aGlzLl9sZW5ndGg9ZX1nZXQoZSl7cmV0dXJuIHRoaXMuX2FycmF5W3RoaXMuX2dldEN5Y2xpY0luZGV4KGUpXX1zZXQoZSx0KXt0aGlzLl9hcnJheVt0aGlzLl9nZXRDeWNsaWNJbmRleChlKV09dH1wdXNoKGUpe3RoaXMuX2FycmF5W3RoaXMuX2dldEN5Y2xpY0luZGV4KHRoaXMuX2xlbmd0aCldPWUsdGhpcy5fbGVuZ3RoPT09dGhpcy5fbWF4TGVuZ3RoPyh0aGlzLl9zdGFydEluZGV4PSsrdGhpcy5fc3RhcnRJbmRleCV0aGlzLl9tYXhMZW5ndGgsdGhpcy5vblRyaW1FbWl0dGVyLmZpcmUoMSkpOnRoaXMuX2xlbmd0aCsrfXJlY3ljbGUoKXtpZih0aGlzLl9sZW5ndGghPT10aGlzLl9tYXhMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgcmVjeWNsZSB3aGVuIHRoZSBidWZmZXIgaXMgZnVsbFwiKTtyZXR1cm4gdGhpcy5fc3RhcnRJbmRleD0rK3RoaXMuX3N0YXJ0SW5kZXgldGhpcy5fbWF4TGVuZ3RoLHRoaXMub25UcmltRW1pdHRlci5maXJlKDEpLHRoaXMuX2FycmF5W3RoaXMuX2dldEN5Y2xpY0luZGV4KHRoaXMuX2xlbmd0aC0xKV19Z2V0IGlzRnVsbCgpe3JldHVybiB0aGlzLl9sZW5ndGg9PT10aGlzLl9tYXhMZW5ndGh9cG9wKCl7cmV0dXJuIHRoaXMuX2FycmF5W3RoaXMuX2dldEN5Y2xpY0luZGV4KHRoaXMuX2xlbmd0aC0tLTEpXX1zcGxpY2UoZSx0LC4uLmkpe2lmKHQpe2ZvcihsZXQgaT1lO2k8dGhpcy5fbGVuZ3RoLXQ7aSsrKXRoaXMuX2FycmF5W3RoaXMuX2dldEN5Y2xpY0luZGV4KGkpXT10aGlzLl9hcnJheVt0aGlzLl9nZXRDeWNsaWNJbmRleChpK3QpXTt0aGlzLl9sZW5ndGgtPXQsdGhpcy5vbkRlbGV0ZUVtaXR0ZXIuZmlyZSh7aW5kZXg6ZSxhbW91bnQ6dH0pfWZvcihsZXQgdD10aGlzLl9sZW5ndGgtMTt0Pj1lO3QtLSl0aGlzLl9hcnJheVt0aGlzLl9nZXRDeWNsaWNJbmRleCh0K2kubGVuZ3RoKV09dGhpcy5fYXJyYXlbdGhpcy5fZ2V0Q3ljbGljSW5kZXgodCldO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGg7dCsrKXRoaXMuX2FycmF5W3RoaXMuX2dldEN5Y2xpY0luZGV4KGUrdCldPWlbdF07aWYoaS5sZW5ndGgmJnRoaXMub25JbnNlcnRFbWl0dGVyLmZpcmUoe2luZGV4OmUsYW1vdW50OmkubGVuZ3RofSksdGhpcy5fbGVuZ3RoK2kubGVuZ3RoPnRoaXMuX21heExlbmd0aCl7Y29uc3QgZT10aGlzLl9sZW5ndGgraS5sZW5ndGgtdGhpcy5fbWF4TGVuZ3RoO3RoaXMuX3N0YXJ0SW5kZXgrPWUsdGhpcy5fbGVuZ3RoPXRoaXMuX21heExlbmd0aCx0aGlzLm9uVHJpbUVtaXR0ZXIuZmlyZShlKX1lbHNlIHRoaXMuX2xlbmd0aCs9aS5sZW5ndGh9dHJpbVN0YXJ0KGUpe2U+dGhpcy5fbGVuZ3RoJiYoZT10aGlzLl9sZW5ndGgpLHRoaXMuX3N0YXJ0SW5kZXgrPWUsdGhpcy5fbGVuZ3RoLT1lLHRoaXMub25UcmltRW1pdHRlci5maXJlKGUpfXNoaWZ0RWxlbWVudHMoZSx0LGkpe2lmKCEodDw9MCkpe2lmKGU8MHx8ZT49dGhpcy5fbGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInN0YXJ0IGFyZ3VtZW50IG91dCBvZiByYW5nZVwiKTtpZihlK2k8MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2hpZnQgZWxlbWVudHMgaW4gbGlzdCBiZXlvbmQgaW5kZXggMFwiKTtpZihpPjApe2ZvcihsZXQgcz10LTE7cz49MDtzLS0pdGhpcy5zZXQoZStzK2ksdGhpcy5nZXQoZStzKSk7Y29uc3Qgcz1lK3QraS10aGlzLl9sZW5ndGg7aWYocz4wKWZvcih0aGlzLl9sZW5ndGgrPXM7dGhpcy5fbGVuZ3RoPnRoaXMuX21heExlbmd0aDspdGhpcy5fbGVuZ3RoLS0sdGhpcy5fc3RhcnRJbmRleCsrLHRoaXMub25UcmltRW1pdHRlci5maXJlKDEpfWVsc2UgZm9yKGxldCBzPTA7czx0O3MrKyl0aGlzLnNldChlK3MraSx0aGlzLmdldChlK3MpKX19X2dldEN5Y2xpY0luZGV4KGUpe3JldHVybih0aGlzLl9zdGFydEluZGV4K2UpJXRoaXMuX21heExlbmd0aH19dC5DaXJjdWxhckxpc3Q9bn0sMTQzOTooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY2xvbmU9dm9pZCAwLHQuY2xvbmU9ZnVuY3Rpb24gZSh0LGk9NSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpcmV0dXJuIHQ7Y29uc3Qgcz1BcnJheS5pc0FycmF5KHQpP1tdOnt9O2Zvcihjb25zdCByIGluIHQpc1tyXT1pPD0xP3Rbcl06dFtyXSYmZSh0W3JdLGktMSk7cmV0dXJuIHN9fSw4MDU1OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jb250cmFzdFJhdGlvPXQudG9QYWRkZWRIZXg9dC5yZ2JhPXQucmdiPXQuY3NzPXQuY29sb3I9dC5jaGFubmVscz10Lk5VTExfQ09MT1I9dm9pZCAwO2xldCBpPTAscz0wLHI9MCxuPTA7dmFyIG8sYSxoLGMsbDtmdW5jdGlvbiBkKGUpe2NvbnN0IHQ9ZS50b1N0cmluZygxNik7cmV0dXJuIHQubGVuZ3RoPDI/XCIwXCIrdDp0fWZ1bmN0aW9uIF8oZSx0KXtyZXR1cm4gZTx0Pyh0Ky4wNSkvKGUrLjA1KTooZSsuMDUpLyh0Ky4wNSl9dC5OVUxMX0NPTE9SPXtjc3M6XCIjMDAwMDAwMDBcIixyZ2JhOjB9LGZ1bmN0aW9uKGUpe2UudG9Dc3M9ZnVuY3Rpb24oZSx0LGkscyl7cmV0dXJuIHZvaWQgMCE9PXM/YCMke2QoZSl9JHtkKHQpfSR7ZChpKX0ke2Qocyl9YDpgIyR7ZChlKX0ke2QodCl9JHtkKGkpfWB9LGUudG9SZ2JhPWZ1bmN0aW9uKGUsdCxpLHM9MjU1KXtyZXR1cm4oZTw8MjR8dDw8MTZ8aTw8OHxzKT4+PjB9LGUudG9Db2xvcj1mdW5jdGlvbih0LGkscyxyKXtyZXR1cm57Y3NzOmUudG9Dc3ModCxpLHMscikscmdiYTplLnRvUmdiYSh0LGkscyxyKX19fShvfHwodC5jaGFubmVscz1vPXt9KSksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlLHQpe3JldHVybiBuPU1hdGgucm91bmQoMjU1KnQpLFtpLHMscl09bC50b0NoYW5uZWxzKGUucmdiYSkse2NzczpvLnRvQ3NzKGkscyxyLG4pLHJnYmE6by50b1JnYmEoaSxzLHIsbil9fWUuYmxlbmQ9ZnVuY3Rpb24oZSx0KXtpZihuPSgyNTUmdC5yZ2JhKS8yNTUsMT09PW4pcmV0dXJue2Nzczp0LmNzcyxyZ2JhOnQucmdiYX07Y29uc3QgYT10LnJnYmE+PjI0JjI1NSxoPXQucmdiYT4+MTYmMjU1LGM9dC5yZ2JhPj44JjI1NSxsPWUucmdiYT4+MjQmMjU1LGQ9ZS5yZ2JhPj4xNiYyNTUsXz1lLnJnYmE+PjgmMjU1O3JldHVybiBpPWwrTWF0aC5yb3VuZCgoYS1sKSpuKSxzPWQrTWF0aC5yb3VuZCgoaC1kKSpuKSxyPV8rTWF0aC5yb3VuZCgoYy1fKSpuKSx7Y3NzOm8udG9Dc3MoaSxzLHIpLHJnYmE6by50b1JnYmEoaSxzLHIpfX0sZS5pc09wYXF1ZT1mdW5jdGlvbihlKXtyZXR1cm4gMjU1PT0oMjU1JmUucmdiYSl9LGUuZW5zdXJlQ29udHJhc3RSYXRpbz1mdW5jdGlvbihlLHQsaSl7Y29uc3Qgcz1sLmVuc3VyZUNvbnRyYXN0UmF0aW8oZS5yZ2JhLHQucmdiYSxpKTtpZihzKXJldHVybiBvLnRvQ29sb3Iocz4+MjQmMjU1LHM+PjE2JjI1NSxzPj44JjI1NSl9LGUub3BhcXVlPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9KDI1NXxlLnJnYmEpPj4+MDtyZXR1cm5baSxzLHJdPWwudG9DaGFubmVscyh0KSx7Y3NzOm8udG9Dc3MoaSxzLHIpLHJnYmE6dH19LGUub3BhY2l0eT10LGUubXVsdGlwbHlPcGFjaXR5PWZ1bmN0aW9uKGUsaSl7cmV0dXJuIG49MjU1JmUucmdiYSx0KGUsbippLzI1NSl9LGUudG9Db2xvclJHQj1mdW5jdGlvbihlKXtyZXR1cm5bZS5yZ2JhPj4yNCYyNTUsZS5yZ2JhPj4xNiYyNTUsZS5yZ2JhPj44JjI1NV19fShhfHwodC5jb2xvcj1hPXt9KSksZnVuY3Rpb24oZSl7bGV0IHQsYTt0cnl7Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2Uud2lkdGg9MSxlLmhlaWdodD0xO2NvbnN0IGk9ZS5nZXRDb250ZXh0KFwiMmRcIix7d2lsbFJlYWRGcmVxdWVudGx5OiEwfSk7aSYmKHQ9aSx0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cImNvcHlcIixhPXQuY3JlYXRlTGluZWFyR3JhZGllbnQoMCwwLDEsMSkpfWNhdGNoe31lLnRvQ29sb3I9ZnVuY3Rpb24oZSl7aWYoZS5tYXRjaCgvI1tcXGRhLWZdezMsOH0vaSkpc3dpdGNoKGUubGVuZ3RoKXtjYXNlIDQ6cmV0dXJuIGk9cGFyc2VJbnQoZS5zbGljZSgxLDIpLnJlcGVhdCgyKSwxNikscz1wYXJzZUludChlLnNsaWNlKDIsMykucmVwZWF0KDIpLDE2KSxyPXBhcnNlSW50KGUuc2xpY2UoMyw0KS5yZXBlYXQoMiksMTYpLG8udG9Db2xvcihpLHMscik7Y2FzZSA1OnJldHVybiBpPXBhcnNlSW50KGUuc2xpY2UoMSwyKS5yZXBlYXQoMiksMTYpLHM9cGFyc2VJbnQoZS5zbGljZSgyLDMpLnJlcGVhdCgyKSwxNikscj1wYXJzZUludChlLnNsaWNlKDMsNCkucmVwZWF0KDIpLDE2KSxuPXBhcnNlSW50KGUuc2xpY2UoNCw1KS5yZXBlYXQoMiksMTYpLG8udG9Db2xvcihpLHMscixuKTtjYXNlIDc6cmV0dXJue2NzczplLHJnYmE6KHBhcnNlSW50KGUuc2xpY2UoMSksMTYpPDw4fDI1NSk+Pj4wfTtjYXNlIDk6cmV0dXJue2NzczplLHJnYmE6cGFyc2VJbnQoZS5zbGljZSgxKSwxNik+Pj4wfX1jb25zdCBoPWUubWF0Y2goL3JnYmE/XFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyooLFxccyooMHwxfFxcZD9cXC4oXFxkKykpXFxzKik/XFwpLyk7aWYoaClyZXR1cm4gaT1wYXJzZUludChoWzFdKSxzPXBhcnNlSW50KGhbMl0pLHI9cGFyc2VJbnQoaFszXSksbj1NYXRoLnJvdW5kKDI1NSoodm9pZCAwPT09aFs1XT8xOnBhcnNlRmxvYXQoaFs1XSkpKSxvLnRvQ29sb3IoaSxzLHIsbik7aWYoIXR8fCFhKXRocm93IG5ldyBFcnJvcihcImNzcy50b0NvbG9yOiBVbnN1cHBvcnRlZCBjc3MgZm9ybWF0XCIpO2lmKHQuZmlsbFN0eWxlPWEsdC5maWxsU3R5bGU9ZSxcInN0cmluZ1wiIT10eXBlb2YgdC5maWxsU3R5bGUpdGhyb3cgbmV3IEVycm9yKFwiY3NzLnRvQ29sb3I6IFVuc3VwcG9ydGVkIGNzcyBmb3JtYXRcIik7aWYodC5maWxsUmVjdCgwLDAsMSwxKSxbaSxzLHIsbl09dC5nZXRJbWFnZURhdGEoMCwwLDEsMSkuZGF0YSwyNTUhPT1uKXRocm93IG5ldyBFcnJvcihcImNzcy50b0NvbG9yOiBVbnN1cHBvcnRlZCBjc3MgZm9ybWF0XCIpO3JldHVybntyZ2JhOm8udG9SZ2JhKGkscyxyLG4pLGNzczplfX19KGh8fCh0LmNzcz1oPXt9KSksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlLHQsaSl7Y29uc3Qgcz1lLzI1NSxyPXQvMjU1LG49aS8yNTU7cmV0dXJuLjIxMjYqKHM8PS4wMzkyOD9zLzEyLjkyOk1hdGgucG93KChzKy4wNTUpLzEuMDU1LDIuNCkpKy43MTUyKihyPD0uMDM5Mjg/ci8xMi45MjpNYXRoLnBvdygocisuMDU1KS8xLjA1NSwyLjQpKSsuMDcyMioobjw9LjAzOTI4P24vMTIuOTI6TWF0aC5wb3coKG4rLjA1NSkvMS4wNTUsMi40KSl9ZS5yZWxhdGl2ZUx1bWluYW5jZT1mdW5jdGlvbihlKXtyZXR1cm4gdChlPj4xNiYyNTUsZT4+OCYyNTUsMjU1JmUpfSxlLnJlbGF0aXZlTHVtaW5hbmNlMj10fShjfHwodC5yZ2I9Yz17fSkpLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSx0LGkpe2NvbnN0IHM9ZT4+MjQmMjU1LHI9ZT4+MTYmMjU1LG49ZT4+OCYyNTU7bGV0IG89dD4+MjQmMjU1LGE9dD4+MTYmMjU1LGg9dD4+OCYyNTUsbD1fKGMucmVsYXRpdmVMdW1pbmFuY2UyKG8sYSxoKSxjLnJlbGF0aXZlTHVtaW5hbmNlMihzLHIsbikpO2Zvcig7bDxpJiYobz4wfHxhPjB8fGg+MCk7KW8tPU1hdGgubWF4KDAsTWF0aC5jZWlsKC4xKm8pKSxhLT1NYXRoLm1heCgwLE1hdGguY2VpbCguMSphKSksaC09TWF0aC5tYXgoMCxNYXRoLmNlaWwoLjEqaCkpLGw9XyhjLnJlbGF0aXZlTHVtaW5hbmNlMihvLGEsaCksYy5yZWxhdGl2ZUx1bWluYW5jZTIocyxyLG4pKTtyZXR1cm4obzw8MjR8YTw8MTZ8aDw8OHwyNTUpPj4+MH1mdW5jdGlvbiBhKGUsdCxpKXtjb25zdCBzPWU+PjI0JjI1NSxyPWU+PjE2JjI1NSxuPWU+PjgmMjU1O2xldCBvPXQ+PjI0JjI1NSxhPXQ+PjE2JjI1NSxoPXQ+PjgmMjU1LGw9XyhjLnJlbGF0aXZlTHVtaW5hbmNlMihvLGEsaCksYy5yZWxhdGl2ZUx1bWluYW5jZTIocyxyLG4pKTtmb3IoO2w8aSYmKG88MjU1fHxhPDI1NXx8aDwyNTUpOylvPU1hdGgubWluKDI1NSxvK01hdGguY2VpbCguMSooMjU1LW8pKSksYT1NYXRoLm1pbigyNTUsYStNYXRoLmNlaWwoLjEqKDI1NS1hKSkpLGg9TWF0aC5taW4oMjU1LGgrTWF0aC5jZWlsKC4xKigyNTUtaCkpKSxsPV8oYy5yZWxhdGl2ZUx1bWluYW5jZTIobyxhLGgpLGMucmVsYXRpdmVMdW1pbmFuY2UyKHMscixuKSk7cmV0dXJuKG88PDI0fGE8PDE2fGg8PDh8MjU1KT4+PjB9ZS5ibGVuZD1mdW5jdGlvbihlLHQpe2lmKG49KDI1NSZ0KS8yNTUsMT09PW4pcmV0dXJuIHQ7Y29uc3QgYT10Pj4yNCYyNTUsaD10Pj4xNiYyNTUsYz10Pj44JjI1NSxsPWU+PjI0JjI1NSxkPWU+PjE2JjI1NSxfPWU+PjgmMjU1O3JldHVybiBpPWwrTWF0aC5yb3VuZCgoYS1sKSpuKSxzPWQrTWF0aC5yb3VuZCgoaC1kKSpuKSxyPV8rTWF0aC5yb3VuZCgoYy1fKSpuKSxvLnRvUmdiYShpLHMscil9LGUuZW5zdXJlQ29udHJhc3RSYXRpbz1mdW5jdGlvbihlLGkscyl7Y29uc3Qgcj1jLnJlbGF0aXZlTHVtaW5hbmNlKGU+PjgpLG49Yy5yZWxhdGl2ZUx1bWluYW5jZShpPj44KTtpZihfKHIsbik8cyl7aWYobjxyKXtjb25zdCBuPXQoZSxpLHMpLG89XyhyLGMucmVsYXRpdmVMdW1pbmFuY2Uobj4+OCkpO2lmKG88cyl7Y29uc3QgdD1hKGUsaSxzKTtyZXR1cm4gbz5fKHIsYy5yZWxhdGl2ZUx1bWluYW5jZSh0Pj44KSk/bjp0fXJldHVybiBufWNvbnN0IG89YShlLGkscyksaD1fKHIsYy5yZWxhdGl2ZUx1bWluYW5jZShvPj44KSk7aWYoaDxzKXtjb25zdCBuPXQoZSxpLHMpO3JldHVybiBoPl8ocixjLnJlbGF0aXZlTHVtaW5hbmNlKG4+PjgpKT9vOm59cmV0dXJuIG99fSxlLnJlZHVjZUx1bWluYW5jZT10LGUuaW5jcmVhc2VMdW1pbmFuY2U9YSxlLnRvQ2hhbm5lbHM9ZnVuY3Rpb24oZSl7cmV0dXJuW2U+PjI0JjI1NSxlPj4xNiYyNTUsZT4+OCYyNTUsMjU1JmVdfX0obHx8KHQucmdiYT1sPXt9KSksdC50b1BhZGRlZEhleD1kLHQuY29udHJhc3RSYXRpbz1ffSw4OTY5OihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkNvcmVUZXJtaW5hbD12b2lkIDA7Y29uc3Qgcz1pKDg0NCkscj1pKDI1ODUpLG49aSg0MzQ4KSxvPWkoNzg2NiksYT1pKDc0NCksaD1pKDczMDIpLGM9aSg2OTc1KSxsPWkoODQ2MCksZD1pKDE3NTMpLF89aSgxNDgwKSx1PWkoNzk5NCksZj1pKDkyODIpLHY9aSg1NDM1KSxwPWkoNTk4MSksZz1pKDI2NjApO2xldCBtPSExO2NsYXNzIFMgZXh0ZW5kcyBzLkRpc3Bvc2FibGV7Z2V0IG9uU2Nyb2xsKCl7cmV0dXJuIHRoaXMuX29uU2Nyb2xsQXBpfHwodGhpcy5fb25TY3JvbGxBcGk9dGhpcy5yZWdpc3RlcihuZXcgbC5FdmVudEVtaXR0ZXIpLHRoaXMuX29uU2Nyb2xsLmV2ZW50KChlPT57dGhpcy5fb25TY3JvbGxBcGk/LmZpcmUoZS5wb3NpdGlvbil9KSkpLHRoaXMuX29uU2Nyb2xsQXBpLmV2ZW50fWdldCBjb2xzKCl7cmV0dXJuIHRoaXMuX2J1ZmZlclNlcnZpY2UuY29sc31nZXQgcm93cygpe3JldHVybiB0aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3N9Z2V0IGJ1ZmZlcnMoKXtyZXR1cm4gdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXJzfWdldCBvcHRpb25zKCl7cmV0dXJuIHRoaXMub3B0aW9uc1NlcnZpY2Uub3B0aW9uc31zZXQgb3B0aW9ucyhlKXtmb3IoY29uc3QgdCBpbiBlKXRoaXMub3B0aW9uc1NlcnZpY2Uub3B0aW9uc1t0XT1lW3RdfWNvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5fd2luZG93c1dyYXBwaW5nSGV1cmlzdGljcz10aGlzLnJlZ2lzdGVyKG5ldyBzLk11dGFibGVEaXNwb3NhYmxlKSx0aGlzLl9vbkJpbmFyeT10aGlzLnJlZ2lzdGVyKG5ldyBsLkV2ZW50RW1pdHRlciksdGhpcy5vbkJpbmFyeT10aGlzLl9vbkJpbmFyeS5ldmVudCx0aGlzLl9vbkRhdGE9dGhpcy5yZWdpc3RlcihuZXcgbC5FdmVudEVtaXR0ZXIpLHRoaXMub25EYXRhPXRoaXMuX29uRGF0YS5ldmVudCx0aGlzLl9vbkxpbmVGZWVkPXRoaXMucmVnaXN0ZXIobmV3IGwuRXZlbnRFbWl0dGVyKSx0aGlzLm9uTGluZUZlZWQ9dGhpcy5fb25MaW5lRmVlZC5ldmVudCx0aGlzLl9vblJlc2l6ZT10aGlzLnJlZ2lzdGVyKG5ldyBsLkV2ZW50RW1pdHRlciksdGhpcy5vblJlc2l6ZT10aGlzLl9vblJlc2l6ZS5ldmVudCx0aGlzLl9vbldyaXRlUGFyc2VkPXRoaXMucmVnaXN0ZXIobmV3IGwuRXZlbnRFbWl0dGVyKSx0aGlzLm9uV3JpdGVQYXJzZWQ9dGhpcy5fb25Xcml0ZVBhcnNlZC5ldmVudCx0aGlzLl9vblNjcm9sbD10aGlzLnJlZ2lzdGVyKG5ldyBsLkV2ZW50RW1pdHRlciksdGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2U9bmV3IG4uSW5zdGFudGlhdGlvblNlcnZpY2UsdGhpcy5vcHRpb25zU2VydmljZT10aGlzLnJlZ2lzdGVyKG5ldyBoLk9wdGlvbnNTZXJ2aWNlKGUpKSx0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5zZXRTZXJ2aWNlKHIuSU9wdGlvbnNTZXJ2aWNlLHRoaXMub3B0aW9uc1NlcnZpY2UpLHRoaXMuX2J1ZmZlclNlcnZpY2U9dGhpcy5yZWdpc3Rlcih0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5jcmVhdGVJbnN0YW5jZShhLkJ1ZmZlclNlcnZpY2UpKSx0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5zZXRTZXJ2aWNlKHIuSUJ1ZmZlclNlcnZpY2UsdGhpcy5fYnVmZmVyU2VydmljZSksdGhpcy5fbG9nU2VydmljZT10aGlzLnJlZ2lzdGVyKHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKG8uTG9nU2VydmljZSkpLHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLnNldFNlcnZpY2Uoci5JTG9nU2VydmljZSx0aGlzLl9sb2dTZXJ2aWNlKSx0aGlzLmNvcmVTZXJ2aWNlPXRoaXMucmVnaXN0ZXIodGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2UuY3JlYXRlSW5zdGFuY2UoYy5Db3JlU2VydmljZSkpLHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLnNldFNlcnZpY2Uoci5JQ29yZVNlcnZpY2UsdGhpcy5jb3JlU2VydmljZSksdGhpcy5jb3JlTW91c2VTZXJ2aWNlPXRoaXMucmVnaXN0ZXIodGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2UuY3JlYXRlSW5zdGFuY2UoZC5Db3JlTW91c2VTZXJ2aWNlKSksdGhpcy5faW5zdGFudGlhdGlvblNlcnZpY2Uuc2V0U2VydmljZShyLklDb3JlTW91c2VTZXJ2aWNlLHRoaXMuY29yZU1vdXNlU2VydmljZSksdGhpcy51bmljb2RlU2VydmljZT10aGlzLnJlZ2lzdGVyKHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKF8uVW5pY29kZVNlcnZpY2UpKSx0aGlzLl9pbnN0YW50aWF0aW9uU2VydmljZS5zZXRTZXJ2aWNlKHIuSVVuaWNvZGVTZXJ2aWNlLHRoaXMudW5pY29kZVNlcnZpY2UpLHRoaXMuX2NoYXJzZXRTZXJ2aWNlPXRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKHUuQ2hhcnNldFNlcnZpY2UpLHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLnNldFNlcnZpY2Uoci5JQ2hhcnNldFNlcnZpY2UsdGhpcy5fY2hhcnNldFNlcnZpY2UpLHRoaXMuX29zY0xpbmtTZXJ2aWNlPXRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLmNyZWF0ZUluc3RhbmNlKGcuT3NjTGlua1NlcnZpY2UpLHRoaXMuX2luc3RhbnRpYXRpb25TZXJ2aWNlLnNldFNlcnZpY2Uoci5JT3NjTGlua1NlcnZpY2UsdGhpcy5fb3NjTGlua1NlcnZpY2UpLHRoaXMuX2lucHV0SGFuZGxlcj10aGlzLnJlZ2lzdGVyKG5ldyB2LklucHV0SGFuZGxlcih0aGlzLl9idWZmZXJTZXJ2aWNlLHRoaXMuX2NoYXJzZXRTZXJ2aWNlLHRoaXMuY29yZVNlcnZpY2UsdGhpcy5fbG9nU2VydmljZSx0aGlzLm9wdGlvbnNTZXJ2aWNlLHRoaXMuX29zY0xpbmtTZXJ2aWNlLHRoaXMuY29yZU1vdXNlU2VydmljZSx0aGlzLnVuaWNvZGVTZXJ2aWNlKSksdGhpcy5yZWdpc3RlcigoMCxsLmZvcndhcmRFdmVudCkodGhpcy5faW5wdXRIYW5kbGVyLm9uTGluZUZlZWQsdGhpcy5fb25MaW5lRmVlZCkpLHRoaXMucmVnaXN0ZXIodGhpcy5faW5wdXRIYW5kbGVyKSx0aGlzLnJlZ2lzdGVyKCgwLGwuZm9yd2FyZEV2ZW50KSh0aGlzLl9idWZmZXJTZXJ2aWNlLm9uUmVzaXplLHRoaXMuX29uUmVzaXplKSksdGhpcy5yZWdpc3RlcigoMCxsLmZvcndhcmRFdmVudCkodGhpcy5jb3JlU2VydmljZS5vbkRhdGEsdGhpcy5fb25EYXRhKSksdGhpcy5yZWdpc3RlcigoMCxsLmZvcndhcmRFdmVudCkodGhpcy5jb3JlU2VydmljZS5vbkJpbmFyeSx0aGlzLl9vbkJpbmFyeSkpLHRoaXMucmVnaXN0ZXIodGhpcy5jb3JlU2VydmljZS5vblJlcXVlc3RTY3JvbGxUb0JvdHRvbSgoKCk9PnRoaXMuc2Nyb2xsVG9Cb3R0b20oKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuY29yZVNlcnZpY2Uub25Vc2VySW5wdXQoKCgpPT50aGlzLl93cml0ZUJ1ZmZlci5oYW5kbGVVc2VySW5wdXQoKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMub3B0aW9uc1NlcnZpY2Uub25NdWx0aXBsZU9wdGlvbkNoYW5nZShbXCJ3aW5kb3dzTW9kZVwiLFwid2luZG93c1B0eVwiXSwoKCk9PnRoaXMuX2hhbmRsZVdpbmRvd3NQdHlPcHRpb25DaGFuZ2UoKSkpKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX2J1ZmZlclNlcnZpY2Uub25TY3JvbGwoKGU9Pnt0aGlzLl9vblNjcm9sbC5maXJlKHtwb3NpdGlvbjp0aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci55ZGlzcCxzb3VyY2U6MH0pLHRoaXMuX2lucHV0SGFuZGxlci5tYXJrUmFuZ2VEaXJ0eSh0aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci5zY3JvbGxUb3AsdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIuc2Nyb2xsQm90dG9tKX0pKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9pbnB1dEhhbmRsZXIub25TY3JvbGwoKGU9Pnt0aGlzLl9vblNjcm9sbC5maXJlKHtwb3NpdGlvbjp0aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci55ZGlzcCxzb3VyY2U6MH0pLHRoaXMuX2lucHV0SGFuZGxlci5tYXJrUmFuZ2VEaXJ0eSh0aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci5zY3JvbGxUb3AsdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIuc2Nyb2xsQm90dG9tKX0pKSksdGhpcy5fd3JpdGVCdWZmZXI9dGhpcy5yZWdpc3RlcihuZXcgcC5Xcml0ZUJ1ZmZlcigoKGUsdCk9PnRoaXMuX2lucHV0SGFuZGxlci5wYXJzZShlLHQpKSkpLHRoaXMucmVnaXN0ZXIoKDAsbC5mb3J3YXJkRXZlbnQpKHRoaXMuX3dyaXRlQnVmZmVyLm9uV3JpdGVQYXJzZWQsdGhpcy5fb25Xcml0ZVBhcnNlZCkpfXdyaXRlKGUsdCl7dGhpcy5fd3JpdGVCdWZmZXIud3JpdGUoZSx0KX13cml0ZVN5bmMoZSx0KXt0aGlzLl9sb2dTZXJ2aWNlLmxvZ0xldmVsPD1yLkxvZ0xldmVsRW51bS5XQVJOJiYhbSYmKHRoaXMuX2xvZ1NlcnZpY2Uud2FybihcIndyaXRlU3luYyBpcyB1bnJlbGlhYmxlIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbi5cIiksbT0hMCksdGhpcy5fd3JpdGVCdWZmZXIud3JpdGVTeW5jKGUsdCl9aW5wdXQoZSx0PSEwKXt0aGlzLmNvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQoZSx0KX1yZXNpemUoZSx0KXtpc05hTihlKXx8aXNOYU4odCl8fChlPU1hdGgubWF4KGUsYS5NSU5JTVVNX0NPTFMpLHQ9TWF0aC5tYXgodCxhLk1JTklNVU1fUk9XUyksdGhpcy5fYnVmZmVyU2VydmljZS5yZXNpemUoZSx0KSl9c2Nyb2xsKGUsdD0hMSl7dGhpcy5fYnVmZmVyU2VydmljZS5zY3JvbGwoZSx0KX1zY3JvbGxMaW5lcyhlLHQsaSl7dGhpcy5fYnVmZmVyU2VydmljZS5zY3JvbGxMaW5lcyhlLHQsaSl9c2Nyb2xsUGFnZXMoZSl7dGhpcy5zY3JvbGxMaW5lcyhlKih0aGlzLnJvd3MtMSkpfXNjcm9sbFRvVG9wKCl7dGhpcy5zY3JvbGxMaW5lcygtdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIueWRpc3ApfXNjcm9sbFRvQm90dG9tKCl7dGhpcy5zY3JvbGxMaW5lcyh0aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci55YmFzZS10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci55ZGlzcCl9c2Nyb2xsVG9MaW5lKGUpe2NvbnN0IHQ9ZS10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci55ZGlzcDswIT09dCYmdGhpcy5zY3JvbGxMaW5lcyh0KX1yZWdpc3RlckVzY0hhbmRsZXIoZSx0KXtyZXR1cm4gdGhpcy5faW5wdXRIYW5kbGVyLnJlZ2lzdGVyRXNjSGFuZGxlcihlLHQpfXJlZ2lzdGVyRGNzSGFuZGxlcihlLHQpe3JldHVybiB0aGlzLl9pbnB1dEhhbmRsZXIucmVnaXN0ZXJEY3NIYW5kbGVyKGUsdCl9cmVnaXN0ZXJDc2lIYW5kbGVyKGUsdCl7cmV0dXJuIHRoaXMuX2lucHV0SGFuZGxlci5yZWdpc3RlckNzaUhhbmRsZXIoZSx0KX1yZWdpc3Rlck9zY0hhbmRsZXIoZSx0KXtyZXR1cm4gdGhpcy5faW5wdXRIYW5kbGVyLnJlZ2lzdGVyT3NjSGFuZGxlcihlLHQpfV9zZXR1cCgpe3RoaXMuX2hhbmRsZVdpbmRvd3NQdHlPcHRpb25DaGFuZ2UoKX1yZXNldCgpe3RoaXMuX2lucHV0SGFuZGxlci5yZXNldCgpLHRoaXMuX2J1ZmZlclNlcnZpY2UucmVzZXQoKSx0aGlzLl9jaGFyc2V0U2VydmljZS5yZXNldCgpLHRoaXMuY29yZVNlcnZpY2UucmVzZXQoKSx0aGlzLmNvcmVNb3VzZVNlcnZpY2UucmVzZXQoKX1faGFuZGxlV2luZG93c1B0eU9wdGlvbkNoYW5nZSgpe2xldCBlPSExO2NvbnN0IHQ9dGhpcy5vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLndpbmRvd3NQdHk7dCYmdm9pZCAwIT09dC5idWlsZE51bWJlciYmdm9pZCAwIT09dC5idWlsZE51bWJlcj9lPSEhKFwiY29ucHR5XCI9PT10LmJhY2tlbmQmJnQuYnVpbGROdW1iZXI8MjEzNzYpOnRoaXMub3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy53aW5kb3dzTW9kZSYmKGU9ITApLGU/dGhpcy5fZW5hYmxlV2luZG93c1dyYXBwaW5nSGV1cmlzdGljcygpOnRoaXMuX3dpbmRvd3NXcmFwcGluZ0hldXJpc3RpY3MuY2xlYXIoKX1fZW5hYmxlV2luZG93c1dyYXBwaW5nSGV1cmlzdGljcygpe2lmKCF0aGlzLl93aW5kb3dzV3JhcHBpbmdIZXVyaXN0aWNzLnZhbHVlKXtjb25zdCBlPVtdO2UucHVzaCh0aGlzLm9uTGluZUZlZWQoZi51cGRhdGVXaW5kb3dzTW9kZVdyYXBwZWRTdGF0ZS5iaW5kKG51bGwsdGhpcy5fYnVmZmVyU2VydmljZSkpKSxlLnB1c2godGhpcy5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiSFwifSwoKCk9PigoMCxmLnVwZGF0ZVdpbmRvd3NNb2RlV3JhcHBlZFN0YXRlKSh0aGlzLl9idWZmZXJTZXJ2aWNlKSwhMSkpKSksdGhpcy5fd2luZG93c1dyYXBwaW5nSGV1cmlzdGljcy52YWx1ZT0oMCxzLnRvRGlzcG9zYWJsZSkoKCgpPT57Zm9yKGNvbnN0IHQgb2YgZSl0LmRpc3Bvc2UoKX0pKX19fXQuQ29yZVRlcm1pbmFsPVN9LDg0NjA6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnJ1bkFuZFN1YnNjcmliZT10LmZvcndhcmRFdmVudD10LkV2ZW50RW1pdHRlcj12b2lkIDAsdC5FdmVudEVtaXR0ZXI9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLl9saXN0ZW5lcnM9W10sdGhpcy5fZGlzcG9zZWQ9ITF9Z2V0IGV2ZW50KCl7cmV0dXJuIHRoaXMuX2V2ZW50fHwodGhpcy5fZXZlbnQ9ZT0+KHRoaXMuX2xpc3RlbmVycy5wdXNoKGUpLHtkaXNwb3NlOigpPT57aWYoIXRoaXMuX2Rpc3Bvc2VkKWZvcihsZXQgdD0wO3Q8dGhpcy5fbGlzdGVuZXJzLmxlbmd0aDt0KyspaWYodGhpcy5fbGlzdGVuZXJzW3RdPT09ZSlyZXR1cm4gdm9pZCB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKHQsMSl9fSkpLHRoaXMuX2V2ZW50fWZpcmUoZSx0KXtjb25zdCBpPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5fbGlzdGVuZXJzLmxlbmd0aDtlKyspaS5wdXNoKHRoaXMuX2xpc3RlbmVyc1tlXSk7Zm9yKGxldCBzPTA7czxpLmxlbmd0aDtzKyspaVtzXS5jYWxsKHZvaWQgMCxlLHQpfWRpc3Bvc2UoKXt0aGlzLmNsZWFyTGlzdGVuZXJzKCksdGhpcy5fZGlzcG9zZWQ9ITB9Y2xlYXJMaXN0ZW5lcnMoKXt0aGlzLl9saXN0ZW5lcnMmJih0aGlzLl9saXN0ZW5lcnMubGVuZ3RoPTApfX0sdC5mb3J3YXJkRXZlbnQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSgoZT0+dC5maXJlKGUpKSl9LHQucnVuQW5kU3Vic2NyaWJlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQodm9pZCAwKSxlKChlPT50KGUpKSl9fSw1NDM1OmZ1bmN0aW9uKGUsdCxpKXt2YXIgcz10aGlzJiZ0aGlzLl9fZGVjb3JhdGV8fGZ1bmN0aW9uKGUsdCxpLHMpe3ZhciByLG49YXJndW1lbnRzLmxlbmd0aCxvPW48Mz90Om51bGw9PT1zP3M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGkpOnM7aWYoXCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3QmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUpbz1SZWZsZWN0LmRlY29yYXRlKGUsdCxpLHMpO2Vsc2UgZm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MDthLS0pKHI9ZVthXSkmJihvPShuPDM/cihvKTpuPjM/cih0LGksbyk6cih0LGkpKXx8byk7cmV0dXJuIG4+MyYmbyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSxvKSxvfSxyPXRoaXMmJnRoaXMuX19wYXJhbXx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oaSxzKXt0KGkscyxlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuSW5wdXRIYW5kbGVyPXQuV2luZG93c09wdGlvbnNSZXBvcnRUeXBlPXZvaWQgMDtjb25zdCBuPWkoMjU4NCksbz1pKDcxMTYpLGE9aSgyMDE1KSxoPWkoODQ0KSxjPWkoNDgyKSxsPWkoODQzNyksZD1pKDg0NjApLF89aSg2NDMpLHU9aSg1MTEpLGY9aSgzNzM0KSx2PWkoMjU4NSkscD1pKDE0ODApLGc9aSg2MjQyKSxtPWkoNjM1MSksUz1pKDU5NDEpLEM9e1wiKFwiOjAsXCIpXCI6MSxcIipcIjoyLFwiK1wiOjMsXCItXCI6MSxcIi5cIjoyfSxiPTEzMTA3MjtmdW5jdGlvbiB3KGUsdCl7aWYoZT4yNClyZXR1cm4gdC5zZXRXaW5MaW5lc3x8ITE7c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm4hIXQucmVzdG9yZVdpbjtjYXNlIDI6cmV0dXJuISF0Lm1pbmltaXplV2luO2Nhc2UgMzpyZXR1cm4hIXQuc2V0V2luUG9zaXRpb247Y2FzZSA0OnJldHVybiEhdC5zZXRXaW5TaXplUGl4ZWxzO2Nhc2UgNTpyZXR1cm4hIXQucmFpc2VXaW47Y2FzZSA2OnJldHVybiEhdC5sb3dlcldpbjtjYXNlIDc6cmV0dXJuISF0LnJlZnJlc2hXaW47Y2FzZSA4OnJldHVybiEhdC5zZXRXaW5TaXplQ2hhcnM7Y2FzZSA5OnJldHVybiEhdC5tYXhpbWl6ZVdpbjtjYXNlIDEwOnJldHVybiEhdC5mdWxsc2NyZWVuV2luO2Nhc2UgMTE6cmV0dXJuISF0LmdldFdpblN0YXRlO2Nhc2UgMTM6cmV0dXJuISF0LmdldFdpblBvc2l0aW9uO2Nhc2UgMTQ6cmV0dXJuISF0LmdldFdpblNpemVQaXhlbHM7Y2FzZSAxNTpyZXR1cm4hIXQuZ2V0U2NyZWVuU2l6ZVBpeGVscztjYXNlIDE2OnJldHVybiEhdC5nZXRDZWxsU2l6ZVBpeGVscztjYXNlIDE4OnJldHVybiEhdC5nZXRXaW5TaXplQ2hhcnM7Y2FzZSAxOTpyZXR1cm4hIXQuZ2V0U2NyZWVuU2l6ZUNoYXJzO2Nhc2UgMjA6cmV0dXJuISF0LmdldEljb25UaXRsZTtjYXNlIDIxOnJldHVybiEhdC5nZXRXaW5UaXRsZTtjYXNlIDIyOnJldHVybiEhdC5wdXNoVGl0bGU7Y2FzZSAyMzpyZXR1cm4hIXQucG9wVGl0bGU7Y2FzZSAyNDpyZXR1cm4hIXQuc2V0V2luTGluZXN9cmV0dXJuITF9dmFyIHk7IWZ1bmN0aW9uKGUpe2VbZS5HRVRfV0lOX1NJWkVfUElYRUxTPTBdPVwiR0VUX1dJTl9TSVpFX1BJWEVMU1wiLGVbZS5HRVRfQ0VMTF9TSVpFX1BJWEVMUz0xXT1cIkdFVF9DRUxMX1NJWkVfUElYRUxTXCJ9KHl8fCh0LldpbmRvd3NPcHRpb25zUmVwb3J0VHlwZT15PXt9KSk7bGV0IEU9MDtjbGFzcyBrIGV4dGVuZHMgaC5EaXNwb3NhYmxle2dldEF0dHJEYXRhKCl7cmV0dXJuIHRoaXMuX2N1ckF0dHJEYXRhfWNvbnN0cnVjdG9yKGUsdCxpLHMscixoLF8sZix2PW5ldyBhLkVzY2FwZVNlcXVlbmNlUGFyc2VyKXtzdXBlcigpLHRoaXMuX2J1ZmZlclNlcnZpY2U9ZSx0aGlzLl9jaGFyc2V0U2VydmljZT10LHRoaXMuX2NvcmVTZXJ2aWNlPWksdGhpcy5fbG9nU2VydmljZT1zLHRoaXMuX29wdGlvbnNTZXJ2aWNlPXIsdGhpcy5fb3NjTGlua1NlcnZpY2U9aCx0aGlzLl9jb3JlTW91c2VTZXJ2aWNlPV8sdGhpcy5fdW5pY29kZVNlcnZpY2U9Zix0aGlzLl9wYXJzZXI9dix0aGlzLl9wYXJzZUJ1ZmZlcj1uZXcgVWludDMyQXJyYXkoNDA5NiksdGhpcy5fc3RyaW5nRGVjb2Rlcj1uZXcgYy5TdHJpbmdUb1V0ZjMyLHRoaXMuX3V0ZjhEZWNvZGVyPW5ldyBjLlV0ZjhUb1V0ZjMyLHRoaXMuX3dvcmtDZWxsPW5ldyB1LkNlbGxEYXRhLHRoaXMuX3dpbmRvd1RpdGxlPVwiXCIsdGhpcy5faWNvbk5hbWU9XCJcIix0aGlzLl93aW5kb3dUaXRsZVN0YWNrPVtdLHRoaXMuX2ljb25OYW1lU3RhY2s9W10sdGhpcy5fY3VyQXR0ckRhdGE9bC5ERUZBVUxUX0FUVFJfREFUQS5jbG9uZSgpLHRoaXMuX2VyYXNlQXR0ckRhdGFJbnRlcm5hbD1sLkRFRkFVTFRfQVRUUl9EQVRBLmNsb25lKCksdGhpcy5fb25SZXF1ZXN0QmVsbD10aGlzLnJlZ2lzdGVyKG5ldyBkLkV2ZW50RW1pdHRlciksdGhpcy5vblJlcXVlc3RCZWxsPXRoaXMuX29uUmVxdWVzdEJlbGwuZXZlbnQsdGhpcy5fb25SZXF1ZXN0UmVmcmVzaFJvd3M9dGhpcy5yZWdpc3RlcihuZXcgZC5FdmVudEVtaXR0ZXIpLHRoaXMub25SZXF1ZXN0UmVmcmVzaFJvd3M9dGhpcy5fb25SZXF1ZXN0UmVmcmVzaFJvd3MuZXZlbnQsdGhpcy5fb25SZXF1ZXN0UmVzZXQ9dGhpcy5yZWdpc3RlcihuZXcgZC5FdmVudEVtaXR0ZXIpLHRoaXMub25SZXF1ZXN0UmVzZXQ9dGhpcy5fb25SZXF1ZXN0UmVzZXQuZXZlbnQsdGhpcy5fb25SZXF1ZXN0U2VuZEZvY3VzPXRoaXMucmVnaXN0ZXIobmV3IGQuRXZlbnRFbWl0dGVyKSx0aGlzLm9uUmVxdWVzdFNlbmRGb2N1cz10aGlzLl9vblJlcXVlc3RTZW5kRm9jdXMuZXZlbnQsdGhpcy5fb25SZXF1ZXN0U3luY1Njcm9sbEJhcj10aGlzLnJlZ2lzdGVyKG5ldyBkLkV2ZW50RW1pdHRlciksdGhpcy5vblJlcXVlc3RTeW5jU2Nyb2xsQmFyPXRoaXMuX29uUmVxdWVzdFN5bmNTY3JvbGxCYXIuZXZlbnQsdGhpcy5fb25SZXF1ZXN0V2luZG93c09wdGlvbnNSZXBvcnQ9dGhpcy5yZWdpc3RlcihuZXcgZC5FdmVudEVtaXR0ZXIpLHRoaXMub25SZXF1ZXN0V2luZG93c09wdGlvbnNSZXBvcnQ9dGhpcy5fb25SZXF1ZXN0V2luZG93c09wdGlvbnNSZXBvcnQuZXZlbnQsdGhpcy5fb25BMTF5Q2hhcj10aGlzLnJlZ2lzdGVyKG5ldyBkLkV2ZW50RW1pdHRlciksdGhpcy5vbkExMXlDaGFyPXRoaXMuX29uQTExeUNoYXIuZXZlbnQsdGhpcy5fb25BMTF5VGFiPXRoaXMucmVnaXN0ZXIobmV3IGQuRXZlbnRFbWl0dGVyKSx0aGlzLm9uQTExeVRhYj10aGlzLl9vbkExMXlUYWIuZXZlbnQsdGhpcy5fb25DdXJzb3JNb3ZlPXRoaXMucmVnaXN0ZXIobmV3IGQuRXZlbnRFbWl0dGVyKSx0aGlzLm9uQ3Vyc29yTW92ZT10aGlzLl9vbkN1cnNvck1vdmUuZXZlbnQsdGhpcy5fb25MaW5lRmVlZD10aGlzLnJlZ2lzdGVyKG5ldyBkLkV2ZW50RW1pdHRlciksdGhpcy5vbkxpbmVGZWVkPXRoaXMuX29uTGluZUZlZWQuZXZlbnQsdGhpcy5fb25TY3JvbGw9dGhpcy5yZWdpc3RlcihuZXcgZC5FdmVudEVtaXR0ZXIpLHRoaXMub25TY3JvbGw9dGhpcy5fb25TY3JvbGwuZXZlbnQsdGhpcy5fb25UaXRsZUNoYW5nZT10aGlzLnJlZ2lzdGVyKG5ldyBkLkV2ZW50RW1pdHRlciksdGhpcy5vblRpdGxlQ2hhbmdlPXRoaXMuX29uVGl0bGVDaGFuZ2UuZXZlbnQsdGhpcy5fb25Db2xvcj10aGlzLnJlZ2lzdGVyKG5ldyBkLkV2ZW50RW1pdHRlciksdGhpcy5vbkNvbG9yPXRoaXMuX29uQ29sb3IuZXZlbnQsdGhpcy5fcGFyc2VTdGFjaz17cGF1c2VkOiExLGN1cnNvclN0YXJ0WDowLGN1cnNvclN0YXJ0WTowLGRlY29kZWRMZW5ndGg6MCxwb3NpdGlvbjowfSx0aGlzLl9zcGVjaWFsQ29sb3JzPVsyNTYsMjU3LDI1OF0sdGhpcy5yZWdpc3Rlcih0aGlzLl9wYXJzZXIpLHRoaXMuX2RpcnR5Um93VHJhY2tlcj1uZXcgTCh0aGlzLl9idWZmZXJTZXJ2aWNlKSx0aGlzLl9hY3RpdmVCdWZmZXI9dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIsdGhpcy5yZWdpc3Rlcih0aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlcnMub25CdWZmZXJBY3RpdmF0ZSgoZT0+dGhpcy5fYWN0aXZlQnVmZmVyPWUuYWN0aXZlQnVmZmVyKSkpLHRoaXMuX3BhcnNlci5zZXRDc2lIYW5kbGVyRmFsbGJhY2soKChlLHQpPT57dGhpcy5fbG9nU2VydmljZS5kZWJ1ZyhcIlVua25vd24gQ1NJIGNvZGU6IFwiLHtpZGVudGlmaWVyOnRoaXMuX3BhcnNlci5pZGVudFRvU3RyaW5nKGUpLHBhcmFtczp0LnRvQXJyYXkoKX0pfSkpLHRoaXMuX3BhcnNlci5zZXRFc2NIYW5kbGVyRmFsbGJhY2soKGU9Pnt0aGlzLl9sb2dTZXJ2aWNlLmRlYnVnKFwiVW5rbm93biBFU0MgY29kZTogXCIse2lkZW50aWZpZXI6dGhpcy5fcGFyc2VyLmlkZW50VG9TdHJpbmcoZSl9KX0pKSx0aGlzLl9wYXJzZXIuc2V0RXhlY3V0ZUhhbmRsZXJGYWxsYmFjaygoZT0+e3RoaXMuX2xvZ1NlcnZpY2UuZGVidWcoXCJVbmtub3duIEVYRUNVVEUgY29kZTogXCIse2NvZGU6ZX0pfSkpLHRoaXMuX3BhcnNlci5zZXRPc2NIYW5kbGVyRmFsbGJhY2soKChlLHQsaSk9Pnt0aGlzLl9sb2dTZXJ2aWNlLmRlYnVnKFwiVW5rbm93biBPU0MgY29kZTogXCIse2lkZW50aWZpZXI6ZSxhY3Rpb246dCxkYXRhOml9KX0pKSx0aGlzLl9wYXJzZXIuc2V0RGNzSGFuZGxlckZhbGxiYWNrKCgoZSx0LGkpPT57XCJIT09LXCI9PT10JiYoaT1pLnRvQXJyYXkoKSksdGhpcy5fbG9nU2VydmljZS5kZWJ1ZyhcIlVua25vd24gRENTIGNvZGU6IFwiLHtpZGVudGlmaWVyOnRoaXMuX3BhcnNlci5pZGVudFRvU3RyaW5nKGUpLGFjdGlvbjp0LHBheWxvYWQ6aX0pfSkpLHRoaXMuX3BhcnNlci5zZXRQcmludEhhbmRsZXIoKChlLHQsaSk9PnRoaXMucHJpbnQoZSx0LGkpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7ZmluYWw6XCJAXCJ9LChlPT50aGlzLmluc2VydENoYXJzKGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7aW50ZXJtZWRpYXRlczpcIiBcIixmaW5hbDpcIkBcIn0sKGU9PnRoaXMuc2Nyb2xsTGVmdChlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiQVwifSwoZT0+dGhpcy5jdXJzb3JVcChlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ludGVybWVkaWF0ZXM6XCIgXCIsZmluYWw6XCJBXCJ9LChlPT50aGlzLnNjcm9sbFJpZ2h0KGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7ZmluYWw6XCJCXCJ9LChlPT50aGlzLmN1cnNvckRvd24oZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcIkNcIn0sKGU9PnRoaXMuY3Vyc29yRm9yd2FyZChlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiRFwifSwoZT0+dGhpcy5jdXJzb3JCYWNrd2FyZChlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiRVwifSwoZT0+dGhpcy5jdXJzb3JOZXh0TGluZShlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiRlwifSwoZT0+dGhpcy5jdXJzb3JQcmVjZWRpbmdMaW5lKGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7ZmluYWw6XCJHXCJ9LChlPT50aGlzLmN1cnNvckNoYXJBYnNvbHV0ZShlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiSFwifSwoZT0+dGhpcy5jdXJzb3JQb3NpdGlvbihlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiSVwifSwoZT0+dGhpcy5jdXJzb3JGb3J3YXJkVGFiKGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7ZmluYWw6XCJKXCJ9LChlPT50aGlzLmVyYXNlSW5EaXNwbGF5KGUsITEpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7cHJlZml4OlwiP1wiLGZpbmFsOlwiSlwifSwoZT0+dGhpcy5lcmFzZUluRGlzcGxheShlLCEwKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiS1wifSwoZT0+dGhpcy5lcmFzZUluTGluZShlLCExKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe3ByZWZpeDpcIj9cIixmaW5hbDpcIktcIn0sKGU9PnRoaXMuZXJhc2VJbkxpbmUoZSwhMCkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcIkxcIn0sKGU9PnRoaXMuaW5zZXJ0TGluZXMoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcIk1cIn0sKGU9PnRoaXMuZGVsZXRlTGluZXMoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcIlBcIn0sKGU9PnRoaXMuZGVsZXRlQ2hhcnMoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcIlNcIn0sKGU9PnRoaXMuc2Nyb2xsVXAoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcIlRcIn0sKGU9PnRoaXMuc2Nyb2xsRG93bihlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiWFwifSwoZT0+dGhpcy5lcmFzZUNoYXJzKGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7ZmluYWw6XCJaXCJ9LChlPT50aGlzLmN1cnNvckJhY2t3YXJkVGFiKGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7ZmluYWw6XCJgXCJ9LChlPT50aGlzLmNoYXJQb3NBYnNvbHV0ZShlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiYVwifSwoZT0+dGhpcy5oUG9zaXRpb25SZWxhdGl2ZShlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiYlwifSwoZT0+dGhpcy5yZXBlYXRQcmVjZWRpbmdDaGFyYWN0ZXIoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcImNcIn0sKGU9PnRoaXMuc2VuZERldmljZUF0dHJpYnV0ZXNQcmltYXJ5KGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7cHJlZml4OlwiPlwiLGZpbmFsOlwiY1wifSwoZT0+dGhpcy5zZW5kRGV2aWNlQXR0cmlidXRlc1NlY29uZGFyeShlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiZFwifSwoZT0+dGhpcy5saW5lUG9zQWJzb2x1dGUoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcImVcIn0sKGU9PnRoaXMudlBvc2l0aW9uUmVsYXRpdmUoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcImZcIn0sKGU9PnRoaXMuaFZQb3NpdGlvbihlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiZ1wifSwoZT0+dGhpcy50YWJDbGVhcihlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwiaFwifSwoZT0+dGhpcy5zZXRNb2RlKGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7cHJlZml4OlwiP1wiLGZpbmFsOlwiaFwifSwoZT0+dGhpcy5zZXRNb2RlUHJpdmF0ZShlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwibFwifSwoZT0+dGhpcy5yZXNldE1vZGUoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtwcmVmaXg6XCI/XCIsZmluYWw6XCJsXCJ9LChlPT50aGlzLnJlc2V0TW9kZVByaXZhdGUoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcIm1cIn0sKGU9PnRoaXMuY2hhckF0dHJpYnV0ZXMoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcIm5cIn0sKGU9PnRoaXMuZGV2aWNlU3RhdHVzKGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7cHJlZml4OlwiP1wiLGZpbmFsOlwiblwifSwoZT0+dGhpcy5kZXZpY2VTdGF0dXNQcml2YXRlKGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7aW50ZXJtZWRpYXRlczpcIiFcIixmaW5hbDpcInBcIn0sKGU9PnRoaXMuc29mdFJlc2V0KGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7aW50ZXJtZWRpYXRlczpcIiBcIixmaW5hbDpcInFcIn0sKGU9PnRoaXMuc2V0Q3Vyc29yU3R5bGUoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcInJcIn0sKGU9PnRoaXMuc2V0U2Nyb2xsUmVnaW9uKGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7ZmluYWw6XCJzXCJ9LChlPT50aGlzLnNhdmVDdXJzb3IoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtmaW5hbDpcInRcIn0sKGU9PnRoaXMud2luZG93T3B0aW9ucyhlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ZpbmFsOlwidVwifSwoZT0+dGhpcy5yZXN0b3JlQ3Vyc29yKGUpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7aW50ZXJtZWRpYXRlczpcIidcIixmaW5hbDpcIn1cIn0sKGU9PnRoaXMuaW5zZXJ0Q29sdW1ucyhlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ludGVybWVkaWF0ZXM6XCInXCIsZmluYWw6XCJ+XCJ9LChlPT50aGlzLmRlbGV0ZUNvbHVtbnMoZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJDc2lIYW5kbGVyKHtpbnRlcm1lZGlhdGVzOidcIicsZmluYWw6XCJxXCJ9LChlPT50aGlzLnNlbGVjdFByb3RlY3RlZChlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoe2ludGVybWVkaWF0ZXM6XCIkXCIsZmluYWw6XCJwXCJ9LChlPT50aGlzLnJlcXVlc3RNb2RlKGUsITApKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcih7cHJlZml4OlwiP1wiLGludGVybWVkaWF0ZXM6XCIkXCIsZmluYWw6XCJwXCJ9LChlPT50aGlzLnJlcXVlc3RNb2RlKGUsITEpKSksdGhpcy5fcGFyc2VyLnNldEV4ZWN1dGVIYW5kbGVyKG4uQzAuQkVMLCgoKT0+dGhpcy5iZWxsKCkpKSx0aGlzLl9wYXJzZXIuc2V0RXhlY3V0ZUhhbmRsZXIobi5DMC5MRiwoKCk9PnRoaXMubGluZUZlZWQoKSkpLHRoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihuLkMwLlZULCgoKT0+dGhpcy5saW5lRmVlZCgpKSksdGhpcy5fcGFyc2VyLnNldEV4ZWN1dGVIYW5kbGVyKG4uQzAuRkYsKCgpPT50aGlzLmxpbmVGZWVkKCkpKSx0aGlzLl9wYXJzZXIuc2V0RXhlY3V0ZUhhbmRsZXIobi5DMC5DUiwoKCk9PnRoaXMuY2FycmlhZ2VSZXR1cm4oKSkpLHRoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihuLkMwLkJTLCgoKT0+dGhpcy5iYWNrc3BhY2UoKSkpLHRoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihuLkMwLkhULCgoKT0+dGhpcy50YWIoKSkpLHRoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihuLkMwLlNPLCgoKT0+dGhpcy5zaGlmdE91dCgpKSksdGhpcy5fcGFyc2VyLnNldEV4ZWN1dGVIYW5kbGVyKG4uQzAuU0ksKCgpPT50aGlzLnNoaWZ0SW4oKSkpLHRoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihuLkMxLklORCwoKCk9PnRoaXMuaW5kZXgoKSkpLHRoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihuLkMxLk5FTCwoKCk9PnRoaXMubmV4dExpbmUoKSkpLHRoaXMuX3BhcnNlci5zZXRFeGVjdXRlSGFuZGxlcihuLkMxLkhUUywoKCk9PnRoaXMudGFiU2V0KCkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJPc2NIYW5kbGVyKDAsbmV3IGcuT3NjSGFuZGxlcigoZT0+KHRoaXMuc2V0VGl0bGUoZSksdGhpcy5zZXRJY29uTmFtZShlKSwhMCkpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyT3NjSGFuZGxlcigxLG5ldyBnLk9zY0hhbmRsZXIoKGU9PnRoaXMuc2V0SWNvbk5hbWUoZSkpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyT3NjSGFuZGxlcigyLG5ldyBnLk9zY0hhbmRsZXIoKGU9PnRoaXMuc2V0VGl0bGUoZSkpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyT3NjSGFuZGxlcig0LG5ldyBnLk9zY0hhbmRsZXIoKGU9PnRoaXMuc2V0T3JSZXBvcnRJbmRleGVkQ29sb3IoZSkpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyT3NjSGFuZGxlcig4LG5ldyBnLk9zY0hhbmRsZXIoKGU9PnRoaXMuc2V0SHlwZXJsaW5rKGUpKSkpLHRoaXMuX3BhcnNlci5yZWdpc3Rlck9zY0hhbmRsZXIoMTAsbmV3IGcuT3NjSGFuZGxlcigoZT0+dGhpcy5zZXRPclJlcG9ydEZnQ29sb3IoZSkpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyT3NjSGFuZGxlcigxMSxuZXcgZy5Pc2NIYW5kbGVyKChlPT50aGlzLnNldE9yUmVwb3J0QmdDb2xvcihlKSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJPc2NIYW5kbGVyKDEyLG5ldyBnLk9zY0hhbmRsZXIoKGU9PnRoaXMuc2V0T3JSZXBvcnRDdXJzb3JDb2xvcihlKSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJPc2NIYW5kbGVyKDEwNCxuZXcgZy5Pc2NIYW5kbGVyKChlPT50aGlzLnJlc3RvcmVJbmRleGVkQ29sb3IoZSkpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyT3NjSGFuZGxlcigxMTAsbmV3IGcuT3NjSGFuZGxlcigoZT0+dGhpcy5yZXN0b3JlRmdDb2xvcihlKSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJPc2NIYW5kbGVyKDExMSxuZXcgZy5Pc2NIYW5kbGVyKChlPT50aGlzLnJlc3RvcmVCZ0NvbG9yKGUpKSkpLHRoaXMuX3BhcnNlci5yZWdpc3Rlck9zY0hhbmRsZXIoMTEyLG5ldyBnLk9zY0hhbmRsZXIoKGU9PnRoaXMucmVzdG9yZUN1cnNvckNvbG9yKGUpKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckVzY0hhbmRsZXIoe2ZpbmFsOlwiN1wifSwoKCk9PnRoaXMuc2F2ZUN1cnNvcigpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyRXNjSGFuZGxlcih7ZmluYWw6XCI4XCJ9LCgoKT0+dGhpcy5yZXN0b3JlQ3Vyc29yKCkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJFc2NIYW5kbGVyKHtmaW5hbDpcIkRcIn0sKCgpPT50aGlzLmluZGV4KCkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJFc2NIYW5kbGVyKHtmaW5hbDpcIkVcIn0sKCgpPT50aGlzLm5leHRMaW5lKCkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJFc2NIYW5kbGVyKHtmaW5hbDpcIkhcIn0sKCgpPT50aGlzLnRhYlNldCgpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyRXNjSGFuZGxlcih7ZmluYWw6XCJNXCJ9LCgoKT0+dGhpcy5yZXZlcnNlSW5kZXgoKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckVzY0hhbmRsZXIoe2ZpbmFsOlwiPVwifSwoKCk9PnRoaXMua2V5cGFkQXBwbGljYXRpb25Nb2RlKCkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJFc2NIYW5kbGVyKHtmaW5hbDpcIj5cIn0sKCgpPT50aGlzLmtleXBhZE51bWVyaWNNb2RlKCkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJFc2NIYW5kbGVyKHtmaW5hbDpcImNcIn0sKCgpPT50aGlzLmZ1bGxSZXNldCgpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyRXNjSGFuZGxlcih7ZmluYWw6XCJuXCJ9LCgoKT0+dGhpcy5zZXRnTGV2ZWwoMikpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJFc2NIYW5kbGVyKHtmaW5hbDpcIm9cIn0sKCgpPT50aGlzLnNldGdMZXZlbCgzKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckVzY0hhbmRsZXIoe2ZpbmFsOlwifFwifSwoKCk9PnRoaXMuc2V0Z0xldmVsKDMpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyRXNjSGFuZGxlcih7ZmluYWw6XCJ9XCJ9LCgoKT0+dGhpcy5zZXRnTGV2ZWwoMikpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJFc2NIYW5kbGVyKHtmaW5hbDpcIn5cIn0sKCgpPT50aGlzLnNldGdMZXZlbCgxKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckVzY0hhbmRsZXIoe2ludGVybWVkaWF0ZXM6XCIlXCIsZmluYWw6XCJAXCJ9LCgoKT0+dGhpcy5zZWxlY3REZWZhdWx0Q2hhcnNldCgpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyRXNjSGFuZGxlcih7aW50ZXJtZWRpYXRlczpcIiVcIixmaW5hbDpcIkdcIn0sKCgpPT50aGlzLnNlbGVjdERlZmF1bHRDaGFyc2V0KCkpKTtmb3IoY29uc3QgZSBpbiBvLkNIQVJTRVRTKXRoaXMuX3BhcnNlci5yZWdpc3RlckVzY0hhbmRsZXIoe2ludGVybWVkaWF0ZXM6XCIoXCIsZmluYWw6ZX0sKCgpPT50aGlzLnNlbGVjdENoYXJzZXQoXCIoXCIrZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJFc2NIYW5kbGVyKHtpbnRlcm1lZGlhdGVzOlwiKVwiLGZpbmFsOmV9LCgoKT0+dGhpcy5zZWxlY3RDaGFyc2V0KFwiKVwiK2UpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyRXNjSGFuZGxlcih7aW50ZXJtZWRpYXRlczpcIipcIixmaW5hbDplfSwoKCk9PnRoaXMuc2VsZWN0Q2hhcnNldChcIipcIitlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckVzY0hhbmRsZXIoe2ludGVybWVkaWF0ZXM6XCIrXCIsZmluYWw6ZX0sKCgpPT50aGlzLnNlbGVjdENoYXJzZXQoXCIrXCIrZSkpKSx0aGlzLl9wYXJzZXIucmVnaXN0ZXJFc2NIYW5kbGVyKHtpbnRlcm1lZGlhdGVzOlwiLVwiLGZpbmFsOmV9LCgoKT0+dGhpcy5zZWxlY3RDaGFyc2V0KFwiLVwiK2UpKSksdGhpcy5fcGFyc2VyLnJlZ2lzdGVyRXNjSGFuZGxlcih7aW50ZXJtZWRpYXRlczpcIi5cIixmaW5hbDplfSwoKCk9PnRoaXMuc2VsZWN0Q2hhcnNldChcIi5cIitlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckVzY0hhbmRsZXIoe2ludGVybWVkaWF0ZXM6XCIvXCIsZmluYWw6ZX0sKCgpPT50aGlzLnNlbGVjdENoYXJzZXQoXCIvXCIrZSkpKTt0aGlzLl9wYXJzZXIucmVnaXN0ZXJFc2NIYW5kbGVyKHtpbnRlcm1lZGlhdGVzOlwiI1wiLGZpbmFsOlwiOFwifSwoKCk9PnRoaXMuc2NyZWVuQWxpZ25tZW50UGF0dGVybigpKSksdGhpcy5fcGFyc2VyLnNldEVycm9ySGFuZGxlcigoZT0+KHRoaXMuX2xvZ1NlcnZpY2UuZXJyb3IoXCJQYXJzaW5nIGVycm9yOiBcIixlKSxlKSkpLHRoaXMuX3BhcnNlci5yZWdpc3RlckRjc0hhbmRsZXIoe2ludGVybWVkaWF0ZXM6XCIkXCIsZmluYWw6XCJxXCJ9LG5ldyBtLkRjc0hhbmRsZXIoKChlLHQpPT50aGlzLnJlcXVlc3RTdGF0dXNTdHJpbmcoZSx0KSkpKX1fcHJlc2VydmVTdGFjayhlLHQsaSxzKXt0aGlzLl9wYXJzZVN0YWNrLnBhdXNlZD0hMCx0aGlzLl9wYXJzZVN0YWNrLmN1cnNvclN0YXJ0WD1lLHRoaXMuX3BhcnNlU3RhY2suY3Vyc29yU3RhcnRZPXQsdGhpcy5fcGFyc2VTdGFjay5kZWNvZGVkTGVuZ3RoPWksdGhpcy5fcGFyc2VTdGFjay5wb3NpdGlvbj1zfV9sb2dTbG93UmVzb2x2aW5nQXN5bmMoZSl7dGhpcy5fbG9nU2VydmljZS5sb2dMZXZlbDw9di5Mb2dMZXZlbEVudW0uV0FSTiYmUHJvbWlzZS5yYWNlKFtlLG5ldyBQcm9taXNlKCgoZSx0KT0+c2V0VGltZW91dCgoKCk9PnQoXCIjU0xPV19USU1FT1VUXCIpKSw1ZTMpKSldKS5jYXRjaCgoZT0+e2lmKFwiI1NMT1dfVElNRU9VVFwiIT09ZSl0aHJvdyBlO2NvbnNvbGUud2FybihcImFzeW5jIHBhcnNlciBoYW5kbGVyIHRha2luZyBsb25nZXIgdGhhbiA1MDAwIG1zXCIpfSkpfV9nZXRDdXJyZW50TGlua0lkKCl7cmV0dXJuIHRoaXMuX2N1ckF0dHJEYXRhLmV4dGVuZGVkLnVybElkfXBhcnNlKGUsdCl7bGV0IGkscz10aGlzLl9hY3RpdmVCdWZmZXIueCxyPXRoaXMuX2FjdGl2ZUJ1ZmZlci55LG49MDtjb25zdCBvPXRoaXMuX3BhcnNlU3RhY2sucGF1c2VkO2lmKG8pe2lmKGk9dGhpcy5fcGFyc2VyLnBhcnNlKHRoaXMuX3BhcnNlQnVmZmVyLHRoaXMuX3BhcnNlU3RhY2suZGVjb2RlZExlbmd0aCx0KSlyZXR1cm4gdGhpcy5fbG9nU2xvd1Jlc29sdmluZ0FzeW5jKGkpLGk7cz10aGlzLl9wYXJzZVN0YWNrLmN1cnNvclN0YXJ0WCxyPXRoaXMuX3BhcnNlU3RhY2suY3Vyc29yU3RhcnRZLHRoaXMuX3BhcnNlU3RhY2sucGF1c2VkPSExLGUubGVuZ3RoPmImJihuPXRoaXMuX3BhcnNlU3RhY2sucG9zaXRpb24rYil9aWYodGhpcy5fbG9nU2VydmljZS5sb2dMZXZlbDw9di5Mb2dMZXZlbEVudW0uREVCVUcmJnRoaXMuX2xvZ1NlcnZpY2UuZGVidWcoXCJwYXJzaW5nIGRhdGFcIisoXCJzdHJpbmdcIj09dHlwZW9mIGU/YCBcIiR7ZX1cImA6YCBcIiR7QXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGUsKGU9PlN0cmluZy5mcm9tQ2hhckNvZGUoZSkpKS5qb2luKFwiXCIpfVwiYCksXCJzdHJpbmdcIj09dHlwZW9mIGU/ZS5zcGxpdChcIlwiKS5tYXAoKGU9PmUuY2hhckNvZGVBdCgwKSkpOmUpLHRoaXMuX3BhcnNlQnVmZmVyLmxlbmd0aDxlLmxlbmd0aCYmdGhpcy5fcGFyc2VCdWZmZXIubGVuZ3RoPGImJih0aGlzLl9wYXJzZUJ1ZmZlcj1uZXcgVWludDMyQXJyYXkoTWF0aC5taW4oZS5sZW5ndGgsYikpKSxvfHx0aGlzLl9kaXJ0eVJvd1RyYWNrZXIuY2xlYXJSYW5nZSgpLGUubGVuZ3RoPmIpZm9yKGxldCB0PW47dDxlLmxlbmd0aDt0Kz1iKXtjb25zdCBuPXQrYjxlLmxlbmd0aD90K2I6ZS5sZW5ndGgsbz1cInN0cmluZ1wiPT10eXBlb2YgZT90aGlzLl9zdHJpbmdEZWNvZGVyLmRlY29kZShlLnN1YnN0cmluZyh0LG4pLHRoaXMuX3BhcnNlQnVmZmVyKTp0aGlzLl91dGY4RGVjb2Rlci5kZWNvZGUoZS5zdWJhcnJheSh0LG4pLHRoaXMuX3BhcnNlQnVmZmVyKTtpZihpPXRoaXMuX3BhcnNlci5wYXJzZSh0aGlzLl9wYXJzZUJ1ZmZlcixvKSlyZXR1cm4gdGhpcy5fcHJlc2VydmVTdGFjayhzLHIsbyx0KSx0aGlzLl9sb2dTbG93UmVzb2x2aW5nQXN5bmMoaSksaX1lbHNlIGlmKCFvKXtjb25zdCB0PVwic3RyaW5nXCI9PXR5cGVvZiBlP3RoaXMuX3N0cmluZ0RlY29kZXIuZGVjb2RlKGUsdGhpcy5fcGFyc2VCdWZmZXIpOnRoaXMuX3V0ZjhEZWNvZGVyLmRlY29kZShlLHRoaXMuX3BhcnNlQnVmZmVyKTtpZihpPXRoaXMuX3BhcnNlci5wYXJzZSh0aGlzLl9wYXJzZUJ1ZmZlcix0KSlyZXR1cm4gdGhpcy5fcHJlc2VydmVTdGFjayhzLHIsdCwwKSx0aGlzLl9sb2dTbG93UmVzb2x2aW5nQXN5bmMoaSksaX10aGlzLl9hY3RpdmVCdWZmZXIueD09PXMmJnRoaXMuX2FjdGl2ZUJ1ZmZlci55PT09cnx8dGhpcy5fb25DdXJzb3JNb3ZlLmZpcmUoKTtjb25zdCBhPXRoaXMuX2RpcnR5Um93VHJhY2tlci5lbmQrKHRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLnliYXNlLXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLnlkaXNwKSxoPXRoaXMuX2RpcnR5Um93VHJhY2tlci5zdGFydCsodGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIueWJhc2UtdGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIueWRpc3ApO2g8dGhpcy5fYnVmZmVyU2VydmljZS5yb3dzJiZ0aGlzLl9vblJlcXVlc3RSZWZyZXNoUm93cy5maXJlKE1hdGgubWluKGgsdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLTEpLE1hdGgubWluKGEsdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLTEpKX1wcmludChlLHQsaSl7bGV0IHMscjtjb25zdCBuPXRoaXMuX2NoYXJzZXRTZXJ2aWNlLmNoYXJzZXQsbz10aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLnNjcmVlblJlYWRlck1vZGUsYT10aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMsaD10aGlzLl9jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXMud3JhcGFyb3VuZCxkPXRoaXMuX2NvcmVTZXJ2aWNlLm1vZGVzLmluc2VydE1vZGUsdT10aGlzLl9jdXJBdHRyRGF0YTtsZXQgZj10aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuZ2V0KHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSt0aGlzLl9hY3RpdmVCdWZmZXIueSk7dGhpcy5fZGlydHlSb3dUcmFja2VyLm1hcmtEaXJ0eSh0aGlzLl9hY3RpdmVCdWZmZXIueSksdGhpcy5fYWN0aXZlQnVmZmVyLngmJmktdD4wJiYyPT09Zi5nZXRXaWR0aCh0aGlzLl9hY3RpdmVCdWZmZXIueC0xKSYmZi5zZXRDZWxsRnJvbUNvZGVwb2ludCh0aGlzLl9hY3RpdmVCdWZmZXIueC0xLDAsMSx1KTtsZXQgdj10aGlzLl9wYXJzZXIucHJlY2VkaW5nSm9pblN0YXRlO2ZvcihsZXQgZz10O2c8aTsrK2cpe2lmKHM9ZVtnXSxzPDEyNyYmbil7Y29uc3QgZT1uW1N0cmluZy5mcm9tQ2hhckNvZGUocyldO2UmJihzPWUuY2hhckNvZGVBdCgwKSl9Y29uc3QgdD10aGlzLl91bmljb2RlU2VydmljZS5jaGFyUHJvcGVydGllcyhzLHYpO3I9cC5Vbmljb2RlU2VydmljZS5leHRyYWN0V2lkdGgodCk7Y29uc3QgaT1wLlVuaWNvZGVTZXJ2aWNlLmV4dHJhY3RTaG91bGRKb2luKHQpLG09aT9wLlVuaWNvZGVTZXJ2aWNlLmV4dHJhY3RXaWR0aCh2KTowO2lmKHY9dCxvJiZ0aGlzLl9vbkExMXlDaGFyLmZpcmUoKDAsYy5zdHJpbmdGcm9tQ29kZVBvaW50KShzKSksdGhpcy5fZ2V0Q3VycmVudExpbmtJZCgpJiZ0aGlzLl9vc2NMaW5rU2VydmljZS5hZGRMaW5lVG9MaW5rKHRoaXMuX2dldEN1cnJlbnRMaW5rSWQoKSx0aGlzLl9hY3RpdmVCdWZmZXIueWJhc2UrdGhpcy5fYWN0aXZlQnVmZmVyLnkpLHRoaXMuX2FjdGl2ZUJ1ZmZlci54K3ItbT5hKWlmKGgpe2NvbnN0IGU9ZjtsZXQgdD10aGlzLl9hY3RpdmVCdWZmZXIueC1tO2Zvcih0aGlzLl9hY3RpdmVCdWZmZXIueD1tLHRoaXMuX2FjdGl2ZUJ1ZmZlci55KyssdGhpcy5fYWN0aXZlQnVmZmVyLnk9PT10aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tKzE/KHRoaXMuX2FjdGl2ZUJ1ZmZlci55LS0sdGhpcy5fYnVmZmVyU2VydmljZS5zY3JvbGwodGhpcy5fZXJhc2VBdHRyRGF0YSgpLCEwKSk6KHRoaXMuX2FjdGl2ZUJ1ZmZlci55Pj10aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3MmJih0aGlzLl9hY3RpdmVCdWZmZXIueT10aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3MtMSksdGhpcy5fYWN0aXZlQnVmZmVyLmxpbmVzLmdldCh0aGlzLl9hY3RpdmVCdWZmZXIueWJhc2UrdGhpcy5fYWN0aXZlQnVmZmVyLnkpLmlzV3JhcHBlZD0hMCksZj10aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuZ2V0KHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSt0aGlzLl9hY3RpdmVCdWZmZXIueSksbT4wJiZmIGluc3RhbmNlb2YgbC5CdWZmZXJMaW5lJiZmLmNvcHlDZWxsc0Zyb20oZSx0LDAsbSwhMSk7dDxhOyllLnNldENlbGxGcm9tQ29kZXBvaW50KHQrKywwLDEsdSl9ZWxzZSBpZih0aGlzLl9hY3RpdmVCdWZmZXIueD1hLTEsMj09PXIpY29udGludWU7aWYoaSYmdGhpcy5fYWN0aXZlQnVmZmVyLngpe2NvbnN0IGU9Zi5nZXRXaWR0aCh0aGlzLl9hY3RpdmVCdWZmZXIueC0xKT8xOjI7Zi5hZGRDb2RlcG9pbnRUb0NlbGwodGhpcy5fYWN0aXZlQnVmZmVyLngtZSxzLHIpO2ZvcihsZXQgZT1yLW07LS1lPj0wOylmLnNldENlbGxGcm9tQ29kZXBvaW50KHRoaXMuX2FjdGl2ZUJ1ZmZlci54KyssMCwwLHUpfWVsc2UgaWYoZCYmKGYuaW5zZXJ0Q2VsbHModGhpcy5fYWN0aXZlQnVmZmVyLngsci1tLHRoaXMuX2FjdGl2ZUJ1ZmZlci5nZXROdWxsQ2VsbCh1KSksMj09PWYuZ2V0V2lkdGgoYS0xKSYmZi5zZXRDZWxsRnJvbUNvZGVwb2ludChhLTEsXy5OVUxMX0NFTExfQ09ERSxfLk5VTExfQ0VMTF9XSURUSCx1KSksZi5zZXRDZWxsRnJvbUNvZGVwb2ludCh0aGlzLl9hY3RpdmVCdWZmZXIueCsrLHMscix1KSxyPjApZm9yKDstLXI7KWYuc2V0Q2VsbEZyb21Db2RlcG9pbnQodGhpcy5fYWN0aXZlQnVmZmVyLngrKywwLDAsdSl9dGhpcy5fcGFyc2VyLnByZWNlZGluZ0pvaW5TdGF0ZT12LHRoaXMuX2FjdGl2ZUJ1ZmZlci54PGEmJmktdD4wJiYwPT09Zi5nZXRXaWR0aCh0aGlzLl9hY3RpdmVCdWZmZXIueCkmJiFmLmhhc0NvbnRlbnQodGhpcy5fYWN0aXZlQnVmZmVyLngpJiZmLnNldENlbGxGcm9tQ29kZXBvaW50KHRoaXMuX2FjdGl2ZUJ1ZmZlci54LDAsMSx1KSx0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya0RpcnR5KHRoaXMuX2FjdGl2ZUJ1ZmZlci55KX1yZWdpc3RlckNzaUhhbmRsZXIoZSx0KXtyZXR1cm5cInRcIiE9PWUuZmluYWx8fGUucHJlZml4fHxlLmludGVybWVkaWF0ZXM/dGhpcy5fcGFyc2VyLnJlZ2lzdGVyQ3NpSGFuZGxlcihlLHQpOnRoaXMuX3BhcnNlci5yZWdpc3RlckNzaUhhbmRsZXIoZSwoZT0+IXcoZS5wYXJhbXNbMF0sdGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy53aW5kb3dPcHRpb25zKXx8dChlKSkpfXJlZ2lzdGVyRGNzSGFuZGxlcihlLHQpe3JldHVybiB0aGlzLl9wYXJzZXIucmVnaXN0ZXJEY3NIYW5kbGVyKGUsbmV3IG0uRGNzSGFuZGxlcih0KSl9cmVnaXN0ZXJFc2NIYW5kbGVyKGUsdCl7cmV0dXJuIHRoaXMuX3BhcnNlci5yZWdpc3RlckVzY0hhbmRsZXIoZSx0KX1yZWdpc3Rlck9zY0hhbmRsZXIoZSx0KXtyZXR1cm4gdGhpcy5fcGFyc2VyLnJlZ2lzdGVyT3NjSGFuZGxlcihlLG5ldyBnLk9zY0hhbmRsZXIodCkpfWJlbGwoKXtyZXR1cm4gdGhpcy5fb25SZXF1ZXN0QmVsbC5maXJlKCksITB9bGluZUZlZWQoKXtyZXR1cm4gdGhpcy5fZGlydHlSb3dUcmFja2VyLm1hcmtEaXJ0eSh0aGlzLl9hY3RpdmVCdWZmZXIueSksdGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5jb252ZXJ0RW9sJiYodGhpcy5fYWN0aXZlQnVmZmVyLng9MCksdGhpcy5fYWN0aXZlQnVmZmVyLnkrKyx0aGlzLl9hY3RpdmVCdWZmZXIueT09PXRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxCb3R0b20rMT8odGhpcy5fYWN0aXZlQnVmZmVyLnktLSx0aGlzLl9idWZmZXJTZXJ2aWNlLnNjcm9sbCh0aGlzLl9lcmFzZUF0dHJEYXRhKCkpKTp0aGlzLl9hY3RpdmVCdWZmZXIueT49dGhpcy5fYnVmZmVyU2VydmljZS5yb3dzP3RoaXMuX2FjdGl2ZUJ1ZmZlci55PXRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cy0xOnRoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy5nZXQodGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlK3RoaXMuX2FjdGl2ZUJ1ZmZlci55KS5pc1dyYXBwZWQ9ITEsdGhpcy5fYWN0aXZlQnVmZmVyLng+PXRoaXMuX2J1ZmZlclNlcnZpY2UuY29scyYmdGhpcy5fYWN0aXZlQnVmZmVyLngtLSx0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya0RpcnR5KHRoaXMuX2FjdGl2ZUJ1ZmZlci55KSx0aGlzLl9vbkxpbmVGZWVkLmZpcmUoKSwhMH1jYXJyaWFnZVJldHVybigpe3JldHVybiB0aGlzLl9hY3RpdmVCdWZmZXIueD0wLCEwfWJhY2tzcGFjZSgpe2lmKCF0aGlzLl9jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXMucmV2ZXJzZVdyYXBhcm91bmQpcmV0dXJuIHRoaXMuX3Jlc3RyaWN0Q3Vyc29yKCksdGhpcy5fYWN0aXZlQnVmZmVyLng+MCYmdGhpcy5fYWN0aXZlQnVmZmVyLngtLSwhMDtpZih0aGlzLl9yZXN0cmljdEN1cnNvcih0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpLHRoaXMuX2FjdGl2ZUJ1ZmZlci54PjApdGhpcy5fYWN0aXZlQnVmZmVyLngtLTtlbHNlIGlmKDA9PT10aGlzLl9hY3RpdmVCdWZmZXIueCYmdGhpcy5fYWN0aXZlQnVmZmVyLnk+dGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcCYmdGhpcy5fYWN0aXZlQnVmZmVyLnk8PXRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxCb3R0b20mJnRoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy5nZXQodGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlK3RoaXMuX2FjdGl2ZUJ1ZmZlci55KT8uaXNXcmFwcGVkKXt0aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuZ2V0KHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSt0aGlzLl9hY3RpdmVCdWZmZXIueSkuaXNXcmFwcGVkPSExLHRoaXMuX2FjdGl2ZUJ1ZmZlci55LS0sdGhpcy5fYWN0aXZlQnVmZmVyLng9dGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLTE7Y29uc3QgZT10aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuZ2V0KHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSt0aGlzLl9hY3RpdmVCdWZmZXIueSk7ZS5oYXNXaWR0aCh0aGlzLl9hY3RpdmVCdWZmZXIueCkmJiFlLmhhc0NvbnRlbnQodGhpcy5fYWN0aXZlQnVmZmVyLngpJiZ0aGlzLl9hY3RpdmVCdWZmZXIueC0tfXJldHVybiB0aGlzLl9yZXN0cmljdEN1cnNvcigpLCEwfXRhYigpe2lmKHRoaXMuX2FjdGl2ZUJ1ZmZlci54Pj10aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpcmV0dXJuITA7Y29uc3QgZT10aGlzLl9hY3RpdmVCdWZmZXIueDtyZXR1cm4gdGhpcy5fYWN0aXZlQnVmZmVyLng9dGhpcy5fYWN0aXZlQnVmZmVyLm5leHRTdG9wKCksdGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5zY3JlZW5SZWFkZXJNb2RlJiZ0aGlzLl9vbkExMXlUYWIuZmlyZSh0aGlzLl9hY3RpdmVCdWZmZXIueC1lKSwhMH1zaGlmdE91dCgpe3JldHVybiB0aGlzLl9jaGFyc2V0U2VydmljZS5zZXRnTGV2ZWwoMSksITB9c2hpZnRJbigpe3JldHVybiB0aGlzLl9jaGFyc2V0U2VydmljZS5zZXRnTGV2ZWwoMCksITB9X3Jlc3RyaWN0Q3Vyc29yKGU9dGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLTEpe3RoaXMuX2FjdGl2ZUJ1ZmZlci54PU1hdGgubWluKGUsTWF0aC5tYXgoMCx0aGlzLl9hY3RpdmVCdWZmZXIueCkpLHRoaXMuX2FjdGl2ZUJ1ZmZlci55PXRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5vcmlnaW4/TWF0aC5taW4odGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbEJvdHRvbSxNYXRoLm1heCh0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsVG9wLHRoaXMuX2FjdGl2ZUJ1ZmZlci55KSk6TWF0aC5taW4odGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLTEsTWF0aC5tYXgoMCx0aGlzLl9hY3RpdmVCdWZmZXIueSkpLHRoaXMuX2RpcnR5Um93VHJhY2tlci5tYXJrRGlydHkodGhpcy5fYWN0aXZlQnVmZmVyLnkpfV9zZXRDdXJzb3IoZSx0KXt0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya0RpcnR5KHRoaXMuX2FjdGl2ZUJ1ZmZlci55KSx0aGlzLl9jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXMub3JpZ2luPyh0aGlzLl9hY3RpdmVCdWZmZXIueD1lLHRoaXMuX2FjdGl2ZUJ1ZmZlci55PXRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxUb3ArdCk6KHRoaXMuX2FjdGl2ZUJ1ZmZlci54PWUsdGhpcy5fYWN0aXZlQnVmZmVyLnk9dCksdGhpcy5fcmVzdHJpY3RDdXJzb3IoKSx0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya0RpcnR5KHRoaXMuX2FjdGl2ZUJ1ZmZlci55KX1fbW92ZUN1cnNvcihlLHQpe3RoaXMuX3Jlc3RyaWN0Q3Vyc29yKCksdGhpcy5fc2V0Q3Vyc29yKHRoaXMuX2FjdGl2ZUJ1ZmZlci54K2UsdGhpcy5fYWN0aXZlQnVmZmVyLnkrdCl9Y3Vyc29yVXAoZSl7Y29uc3QgdD10aGlzLl9hY3RpdmVCdWZmZXIueS10aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsVG9wO3JldHVybiB0Pj0wP3RoaXMuX21vdmVDdXJzb3IoMCwtTWF0aC5taW4odCxlLnBhcmFtc1swXXx8MSkpOnRoaXMuX21vdmVDdXJzb3IoMCwtKGUucGFyYW1zWzBdfHwxKSksITB9Y3Vyc29yRG93bihlKXtjb25zdCB0PXRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxCb3R0b20tdGhpcy5fYWN0aXZlQnVmZmVyLnk7cmV0dXJuIHQ+PTA/dGhpcy5fbW92ZUN1cnNvcigwLE1hdGgubWluKHQsZS5wYXJhbXNbMF18fDEpKTp0aGlzLl9tb3ZlQ3Vyc29yKDAsZS5wYXJhbXNbMF18fDEpLCEwfWN1cnNvckZvcndhcmQoZSl7cmV0dXJuIHRoaXMuX21vdmVDdXJzb3IoZS5wYXJhbXNbMF18fDEsMCksITB9Y3Vyc29yQmFja3dhcmQoZSl7cmV0dXJuIHRoaXMuX21vdmVDdXJzb3IoLShlLnBhcmFtc1swXXx8MSksMCksITB9Y3Vyc29yTmV4dExpbmUoZSl7cmV0dXJuIHRoaXMuY3Vyc29yRG93bihlKSx0aGlzLl9hY3RpdmVCdWZmZXIueD0wLCEwfWN1cnNvclByZWNlZGluZ0xpbmUoZSl7cmV0dXJuIHRoaXMuY3Vyc29yVXAoZSksdGhpcy5fYWN0aXZlQnVmZmVyLng9MCwhMH1jdXJzb3JDaGFyQWJzb2x1dGUoZSl7cmV0dXJuIHRoaXMuX3NldEN1cnNvcigoZS5wYXJhbXNbMF18fDEpLTEsdGhpcy5fYWN0aXZlQnVmZmVyLnkpLCEwfWN1cnNvclBvc2l0aW9uKGUpe3JldHVybiB0aGlzLl9zZXRDdXJzb3IoZS5sZW5ndGg+PTI/KGUucGFyYW1zWzFdfHwxKS0xOjAsKGUucGFyYW1zWzBdfHwxKS0xKSwhMH1jaGFyUG9zQWJzb2x1dGUoZSl7cmV0dXJuIHRoaXMuX3NldEN1cnNvcigoZS5wYXJhbXNbMF18fDEpLTEsdGhpcy5fYWN0aXZlQnVmZmVyLnkpLCEwfWhQb3NpdGlvblJlbGF0aXZlKGUpe3JldHVybiB0aGlzLl9tb3ZlQ3Vyc29yKGUucGFyYW1zWzBdfHwxLDApLCEwfWxpbmVQb3NBYnNvbHV0ZShlKXtyZXR1cm4gdGhpcy5fc2V0Q3Vyc29yKHRoaXMuX2FjdGl2ZUJ1ZmZlci54LChlLnBhcmFtc1swXXx8MSktMSksITB9dlBvc2l0aW9uUmVsYXRpdmUoZSl7cmV0dXJuIHRoaXMuX21vdmVDdXJzb3IoMCxlLnBhcmFtc1swXXx8MSksITB9aFZQb3NpdGlvbihlKXtyZXR1cm4gdGhpcy5jdXJzb3JQb3NpdGlvbihlKSwhMH10YWJDbGVhcihlKXtjb25zdCB0PWUucGFyYW1zWzBdO3JldHVybiAwPT09dD9kZWxldGUgdGhpcy5fYWN0aXZlQnVmZmVyLnRhYnNbdGhpcy5fYWN0aXZlQnVmZmVyLnhdOjM9PT10JiYodGhpcy5fYWN0aXZlQnVmZmVyLnRhYnM9e30pLCEwfWN1cnNvckZvcndhcmRUYWIoZSl7aWYodGhpcy5fYWN0aXZlQnVmZmVyLng+PXRoaXMuX2J1ZmZlclNlcnZpY2UuY29scylyZXR1cm4hMDtsZXQgdD1lLnBhcmFtc1swXXx8MTtmb3IoO3QtLTspdGhpcy5fYWN0aXZlQnVmZmVyLng9dGhpcy5fYWN0aXZlQnVmZmVyLm5leHRTdG9wKCk7cmV0dXJuITB9Y3Vyc29yQmFja3dhcmRUYWIoZSl7aWYodGhpcy5fYWN0aXZlQnVmZmVyLng+PXRoaXMuX2J1ZmZlclNlcnZpY2UuY29scylyZXR1cm4hMDtsZXQgdD1lLnBhcmFtc1swXXx8MTtmb3IoO3QtLTspdGhpcy5fYWN0aXZlQnVmZmVyLng9dGhpcy5fYWN0aXZlQnVmZmVyLnByZXZTdG9wKCk7cmV0dXJuITB9c2VsZWN0UHJvdGVjdGVkKGUpe2NvbnN0IHQ9ZS5wYXJhbXNbMF07cmV0dXJuIDE9PT10JiYodGhpcy5fY3VyQXR0ckRhdGEuYmd8PTUzNjg3MDkxMiksMiE9PXQmJjAhPT10fHwodGhpcy5fY3VyQXR0ckRhdGEuYmcmPS01MzY4NzA5MTMpLCEwfV9lcmFzZUluQnVmZmVyTGluZShlLHQsaSxzPSExLHI9ITEpe2NvbnN0IG49dGhpcy5fYWN0aXZlQnVmZmVyLmxpbmVzLmdldCh0aGlzLl9hY3RpdmVCdWZmZXIueWJhc2UrZSk7bi5yZXBsYWNlQ2VsbHModCxpLHRoaXMuX2FjdGl2ZUJ1ZmZlci5nZXROdWxsQ2VsbCh0aGlzLl9lcmFzZUF0dHJEYXRhKCkpLHIpLHMmJihuLmlzV3JhcHBlZD0hMSl9X3Jlc2V0QnVmZmVyTGluZShlLHQ9ITEpe2NvbnN0IGk9dGhpcy5fYWN0aXZlQnVmZmVyLmxpbmVzLmdldCh0aGlzLl9hY3RpdmVCdWZmZXIueWJhc2UrZSk7aSYmKGkuZmlsbCh0aGlzLl9hY3RpdmVCdWZmZXIuZ2V0TnVsbENlbGwodGhpcy5fZXJhc2VBdHRyRGF0YSgpKSx0KSx0aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci5jbGVhck1hcmtlcnModGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlK2UpLGkuaXNXcmFwcGVkPSExKX1lcmFzZUluRGlzcGxheShlLHQ9ITEpe2xldCBpO3N3aXRjaCh0aGlzLl9yZXN0cmljdEN1cnNvcih0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpLGUucGFyYW1zWzBdKXtjYXNlIDA6Zm9yKGk9dGhpcy5fYWN0aXZlQnVmZmVyLnksdGhpcy5fZGlydHlSb3dUcmFja2VyLm1hcmtEaXJ0eShpKSx0aGlzLl9lcmFzZUluQnVmZmVyTGluZShpKyssdGhpcy5fYWN0aXZlQnVmZmVyLngsdGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLDA9PT10aGlzLl9hY3RpdmVCdWZmZXIueCx0KTtpPHRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cztpKyspdGhpcy5fcmVzZXRCdWZmZXJMaW5lKGksdCk7dGhpcy5fZGlydHlSb3dUcmFja2VyLm1hcmtEaXJ0eShpKTticmVhaztjYXNlIDE6Zm9yKGk9dGhpcy5fYWN0aXZlQnVmZmVyLnksdGhpcy5fZGlydHlSb3dUcmFja2VyLm1hcmtEaXJ0eShpKSx0aGlzLl9lcmFzZUluQnVmZmVyTGluZShpLDAsdGhpcy5fYWN0aXZlQnVmZmVyLngrMSwhMCx0KSx0aGlzLl9hY3RpdmVCdWZmZXIueCsxPj10aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMmJih0aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuZ2V0KGkrMSkuaXNXcmFwcGVkPSExKTtpLS07KXRoaXMuX3Jlc2V0QnVmZmVyTGluZShpLHQpO3RoaXMuX2RpcnR5Um93VHJhY2tlci5tYXJrRGlydHkoMCk7YnJlYWs7Y2FzZSAyOmZvcihpPXRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cyx0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya0RpcnR5KGktMSk7aS0tOyl0aGlzLl9yZXNldEJ1ZmZlckxpbmUoaSx0KTt0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya0RpcnR5KDApO2JyZWFrO2Nhc2UgMzpjb25zdCBlPXRoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy5sZW5ndGgtdGhpcy5fYnVmZmVyU2VydmljZS5yb3dzO2U+MCYmKHRoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy50cmltU3RhcnQoZSksdGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlPU1hdGgubWF4KHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZS1lLDApLHRoaXMuX2FjdGl2ZUJ1ZmZlci55ZGlzcD1NYXRoLm1heCh0aGlzLl9hY3RpdmVCdWZmZXIueWRpc3AtZSwwKSx0aGlzLl9vblNjcm9sbC5maXJlKDApKX1yZXR1cm4hMH1lcmFzZUluTGluZShlLHQ9ITEpe3N3aXRjaCh0aGlzLl9yZXN0cmljdEN1cnNvcih0aGlzLl9idWZmZXJTZXJ2aWNlLmNvbHMpLGUucGFyYW1zWzBdKXtjYXNlIDA6dGhpcy5fZXJhc2VJbkJ1ZmZlckxpbmUodGhpcy5fYWN0aXZlQnVmZmVyLnksdGhpcy5fYWN0aXZlQnVmZmVyLngsdGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLDA9PT10aGlzLl9hY3RpdmVCdWZmZXIueCx0KTticmVhaztjYXNlIDE6dGhpcy5fZXJhc2VJbkJ1ZmZlckxpbmUodGhpcy5fYWN0aXZlQnVmZmVyLnksMCx0aGlzLl9hY3RpdmVCdWZmZXIueCsxLCExLHQpO2JyZWFrO2Nhc2UgMjp0aGlzLl9lcmFzZUluQnVmZmVyTGluZSh0aGlzLl9hY3RpdmVCdWZmZXIueSwwLHRoaXMuX2J1ZmZlclNlcnZpY2UuY29scywhMCx0KX1yZXR1cm4gdGhpcy5fZGlydHlSb3dUcmFja2VyLm1hcmtEaXJ0eSh0aGlzLl9hY3RpdmVCdWZmZXIueSksITB9aW5zZXJ0TGluZXMoZSl7dGhpcy5fcmVzdHJpY3RDdXJzb3IoKTtsZXQgdD1lLnBhcmFtc1swXXx8MTtpZih0aGlzLl9hY3RpdmVCdWZmZXIueT50aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tfHx0aGlzLl9hY3RpdmVCdWZmZXIueTx0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsVG9wKXJldHVybiEwO2NvbnN0IGk9dGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlK3RoaXMuX2FjdGl2ZUJ1ZmZlci55LHM9dGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLTEtdGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbEJvdHRvbSxyPXRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cy0xK3RoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZS1zKzE7Zm9yKDt0LS07KXRoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy5zcGxpY2Uoci0xLDEpLHRoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy5zcGxpY2UoaSwwLHRoaXMuX2FjdGl2ZUJ1ZmZlci5nZXRCbGFua0xpbmUodGhpcy5fZXJhc2VBdHRyRGF0YSgpKSk7cmV0dXJuIHRoaXMuX2RpcnR5Um93VHJhY2tlci5tYXJrUmFuZ2VEaXJ0eSh0aGlzLl9hY3RpdmVCdWZmZXIueSx0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tKSx0aGlzLl9hY3RpdmVCdWZmZXIueD0wLCEwfWRlbGV0ZUxpbmVzKGUpe3RoaXMuX3Jlc3RyaWN0Q3Vyc29yKCk7bGV0IHQ9ZS5wYXJhbXNbMF18fDE7aWYodGhpcy5fYWN0aXZlQnVmZmVyLnk+dGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbEJvdHRvbXx8dGhpcy5fYWN0aXZlQnVmZmVyLnk8dGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcClyZXR1cm4hMDtjb25zdCBpPXRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSt0aGlzLl9hY3RpdmVCdWZmZXIueTtsZXQgcztmb3Iocz10aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3MtMS10aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tLHM9dGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLTErdGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlLXM7dC0tOyl0aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuc3BsaWNlKGksMSksdGhpcy5fYWN0aXZlQnVmZmVyLmxpbmVzLnNwbGljZShzLDAsdGhpcy5fYWN0aXZlQnVmZmVyLmdldEJsYW5rTGluZSh0aGlzLl9lcmFzZUF0dHJEYXRhKCkpKTtyZXR1cm4gdGhpcy5fZGlydHlSb3dUcmFja2VyLm1hcmtSYW5nZURpcnR5KHRoaXMuX2FjdGl2ZUJ1ZmZlci55LHRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxCb3R0b20pLHRoaXMuX2FjdGl2ZUJ1ZmZlci54PTAsITB9aW5zZXJ0Q2hhcnMoZSl7dGhpcy5fcmVzdHJpY3RDdXJzb3IoKTtjb25zdCB0PXRoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy5nZXQodGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlK3RoaXMuX2FjdGl2ZUJ1ZmZlci55KTtyZXR1cm4gdCYmKHQuaW5zZXJ0Q2VsbHModGhpcy5fYWN0aXZlQnVmZmVyLngsZS5wYXJhbXNbMF18fDEsdGhpcy5fYWN0aXZlQnVmZmVyLmdldE51bGxDZWxsKHRoaXMuX2VyYXNlQXR0ckRhdGEoKSkpLHRoaXMuX2RpcnR5Um93VHJhY2tlci5tYXJrRGlydHkodGhpcy5fYWN0aXZlQnVmZmVyLnkpKSwhMH1kZWxldGVDaGFycyhlKXt0aGlzLl9yZXN0cmljdEN1cnNvcigpO2NvbnN0IHQ9dGhpcy5fYWN0aXZlQnVmZmVyLmxpbmVzLmdldCh0aGlzLl9hY3RpdmVCdWZmZXIueWJhc2UrdGhpcy5fYWN0aXZlQnVmZmVyLnkpO3JldHVybiB0JiYodC5kZWxldGVDZWxscyh0aGlzLl9hY3RpdmVCdWZmZXIueCxlLnBhcmFtc1swXXx8MSx0aGlzLl9hY3RpdmVCdWZmZXIuZ2V0TnVsbENlbGwodGhpcy5fZXJhc2VBdHRyRGF0YSgpKSksdGhpcy5fZGlydHlSb3dUcmFja2VyLm1hcmtEaXJ0eSh0aGlzLl9hY3RpdmVCdWZmZXIueSkpLCEwfXNjcm9sbFVwKGUpe2xldCB0PWUucGFyYW1zWzBdfHwxO2Zvcig7dC0tOyl0aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuc3BsaWNlKHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSt0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsVG9wLDEpLHRoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy5zcGxpY2UodGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlK3RoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxCb3R0b20sMCx0aGlzLl9hY3RpdmVCdWZmZXIuZ2V0QmxhbmtMaW5lKHRoaXMuX2VyYXNlQXR0ckRhdGEoKSkpO3JldHVybiB0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya1JhbmdlRGlydHkodGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcCx0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tKSwhMH1zY3JvbGxEb3duKGUpe2xldCB0PWUucGFyYW1zWzBdfHwxO2Zvcig7dC0tOyl0aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuc3BsaWNlKHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSt0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tLDEpLHRoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy5zcGxpY2UodGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlK3RoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxUb3AsMCx0aGlzLl9hY3RpdmVCdWZmZXIuZ2V0QmxhbmtMaW5lKGwuREVGQVVMVF9BVFRSX0RBVEEpKTtyZXR1cm4gdGhpcy5fZGlydHlSb3dUcmFja2VyLm1hcmtSYW5nZURpcnR5KHRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxUb3AsdGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbEJvdHRvbSksITB9c2Nyb2xsTGVmdChlKXtpZih0aGlzLl9hY3RpdmVCdWZmZXIueT50aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tfHx0aGlzLl9hY3RpdmVCdWZmZXIueTx0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsVG9wKXJldHVybiEwO2NvbnN0IHQ9ZS5wYXJhbXNbMF18fDE7Zm9yKGxldCBlPXRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxUb3A7ZTw9dGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbEJvdHRvbTsrK2Upe2NvbnN0IGk9dGhpcy5fYWN0aXZlQnVmZmVyLmxpbmVzLmdldCh0aGlzLl9hY3RpdmVCdWZmZXIueWJhc2UrZSk7aS5kZWxldGVDZWxscygwLHQsdGhpcy5fYWN0aXZlQnVmZmVyLmdldE51bGxDZWxsKHRoaXMuX2VyYXNlQXR0ckRhdGEoKSkpLGkuaXNXcmFwcGVkPSExfXJldHVybiB0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya1JhbmdlRGlydHkodGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcCx0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tKSwhMH1zY3JvbGxSaWdodChlKXtpZih0aGlzLl9hY3RpdmVCdWZmZXIueT50aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tfHx0aGlzLl9hY3RpdmVCdWZmZXIueTx0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsVG9wKXJldHVybiEwO2NvbnN0IHQ9ZS5wYXJhbXNbMF18fDE7Zm9yKGxldCBlPXRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxUb3A7ZTw9dGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbEJvdHRvbTsrK2Upe2NvbnN0IGk9dGhpcy5fYWN0aXZlQnVmZmVyLmxpbmVzLmdldCh0aGlzLl9hY3RpdmVCdWZmZXIueWJhc2UrZSk7aS5pbnNlcnRDZWxscygwLHQsdGhpcy5fYWN0aXZlQnVmZmVyLmdldE51bGxDZWxsKHRoaXMuX2VyYXNlQXR0ckRhdGEoKSkpLGkuaXNXcmFwcGVkPSExfXJldHVybiB0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya1JhbmdlRGlydHkodGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcCx0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tKSwhMH1pbnNlcnRDb2x1bW5zKGUpe2lmKHRoaXMuX2FjdGl2ZUJ1ZmZlci55PnRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxCb3R0b218fHRoaXMuX2FjdGl2ZUJ1ZmZlci55PHRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxUb3ApcmV0dXJuITA7Y29uc3QgdD1lLnBhcmFtc1swXXx8MTtmb3IobGV0IGU9dGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcDtlPD10aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tOysrZSl7Y29uc3QgaT10aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuZ2V0KHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZStlKTtpLmluc2VydENlbGxzKHRoaXMuX2FjdGl2ZUJ1ZmZlci54LHQsdGhpcy5fYWN0aXZlQnVmZmVyLmdldE51bGxDZWxsKHRoaXMuX2VyYXNlQXR0ckRhdGEoKSkpLGkuaXNXcmFwcGVkPSExfXJldHVybiB0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya1JhbmdlRGlydHkodGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcCx0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tKSwhMH1kZWxldGVDb2x1bW5zKGUpe2lmKHRoaXMuX2FjdGl2ZUJ1ZmZlci55PnRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxCb3R0b218fHRoaXMuX2FjdGl2ZUJ1ZmZlci55PHRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxUb3ApcmV0dXJuITA7Y29uc3QgdD1lLnBhcmFtc1swXXx8MTtmb3IobGV0IGU9dGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcDtlPD10aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tOysrZSl7Y29uc3QgaT10aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuZ2V0KHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZStlKTtpLmRlbGV0ZUNlbGxzKHRoaXMuX2FjdGl2ZUJ1ZmZlci54LHQsdGhpcy5fYWN0aXZlQnVmZmVyLmdldE51bGxDZWxsKHRoaXMuX2VyYXNlQXR0ckRhdGEoKSkpLGkuaXNXcmFwcGVkPSExfXJldHVybiB0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya1JhbmdlRGlydHkodGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcCx0aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tKSwhMH1lcmFzZUNoYXJzKGUpe3RoaXMuX3Jlc3RyaWN0Q3Vyc29yKCk7Y29uc3QgdD10aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuZ2V0KHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSt0aGlzLl9hY3RpdmVCdWZmZXIueSk7cmV0dXJuIHQmJih0LnJlcGxhY2VDZWxscyh0aGlzLl9hY3RpdmVCdWZmZXIueCx0aGlzLl9hY3RpdmVCdWZmZXIueCsoZS5wYXJhbXNbMF18fDEpLHRoaXMuX2FjdGl2ZUJ1ZmZlci5nZXROdWxsQ2VsbCh0aGlzLl9lcmFzZUF0dHJEYXRhKCkpKSx0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya0RpcnR5KHRoaXMuX2FjdGl2ZUJ1ZmZlci55KSksITB9cmVwZWF0UHJlY2VkaW5nQ2hhcmFjdGVyKGUpe2NvbnN0IHQ9dGhpcy5fcGFyc2VyLnByZWNlZGluZ0pvaW5TdGF0ZTtpZighdClyZXR1cm4hMDtjb25zdCBpPWUucGFyYW1zWzBdfHwxLHM9cC5Vbmljb2RlU2VydmljZS5leHRyYWN0V2lkdGgodCkscj10aGlzLl9hY3RpdmVCdWZmZXIueC1zLG49dGhpcy5fYWN0aXZlQnVmZmVyLmxpbmVzLmdldCh0aGlzLl9hY3RpdmVCdWZmZXIueWJhc2UrdGhpcy5fYWN0aXZlQnVmZmVyLnkpLmdldFN0cmluZyhyKSxvPW5ldyBVaW50MzJBcnJheShuLmxlbmd0aCppKTtsZXQgYT0wO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7KXtjb25zdCB0PW4uY29kZVBvaW50QXQoZSl8fDA7b1thKytdPXQsZSs9dD42NTUzNT8yOjF9bGV0IGg9YTtmb3IobGV0IGU9MTtlPGk7KytlKW8uY29weVdpdGhpbihoLDAsYSksaCs9YTtyZXR1cm4gdGhpcy5wcmludChvLDAsaCksITB9c2VuZERldmljZUF0dHJpYnV0ZXNQcmltYXJ5KGUpe3JldHVybiBlLnBhcmFtc1swXT4wfHwodGhpcy5faXMoXCJ4dGVybVwiKXx8dGhpcy5faXMoXCJyeHZ0LXVuaWNvZGVcIil8fHRoaXMuX2lzKFwic2NyZWVuXCIpP3RoaXMuX2NvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQobi5DMC5FU0MrXCJbPzE7MmNcIik6dGhpcy5faXMoXCJsaW51eFwiKSYmdGhpcy5fY29yZVNlcnZpY2UudHJpZ2dlckRhdGFFdmVudChuLkMwLkVTQytcIls/NmNcIikpLCEwfXNlbmREZXZpY2VBdHRyaWJ1dGVzU2Vjb25kYXJ5KGUpe3JldHVybiBlLnBhcmFtc1swXT4wfHwodGhpcy5faXMoXCJ4dGVybVwiKT90aGlzLl9jb3JlU2VydmljZS50cmlnZ2VyRGF0YUV2ZW50KG4uQzAuRVNDK1wiWz4wOzI3NjswY1wiKTp0aGlzLl9pcyhcInJ4dnQtdW5pY29kZVwiKT90aGlzLl9jb3JlU2VydmljZS50cmlnZ2VyRGF0YUV2ZW50KG4uQzAuRVNDK1wiWz44NTs5NTswY1wiKTp0aGlzLl9pcyhcImxpbnV4XCIpP3RoaXMuX2NvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQoZS5wYXJhbXNbMF0rXCJjXCIpOnRoaXMuX2lzKFwic2NyZWVuXCIpJiZ0aGlzLl9jb3JlU2VydmljZS50cmlnZ2VyRGF0YUV2ZW50KG4uQzAuRVNDK1wiWz44Mzs0MDAwMzswY1wiKSksITB9X2lzKGUpe3JldHVybiAwPT09KHRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMudGVybU5hbWUrXCJcIikuaW5kZXhPZihlKX1zZXRNb2RlKGUpe2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXN3aXRjaChlLnBhcmFtc1t0XSl7Y2FzZSA0OnRoaXMuX2NvcmVTZXJ2aWNlLm1vZGVzLmluc2VydE1vZGU9ITA7YnJlYWs7Y2FzZSAyMDp0aGlzLl9vcHRpb25zU2VydmljZS5vcHRpb25zLmNvbnZlcnRFb2w9ITB9cmV0dXJuITB9c2V0TW9kZVByaXZhdGUoZSl7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspc3dpdGNoKGUucGFyYW1zW3RdKXtjYXNlIDE6dGhpcy5fY29yZVNlcnZpY2UuZGVjUHJpdmF0ZU1vZGVzLmFwcGxpY2F0aW9uQ3Vyc29yS2V5cz0hMDticmVhaztjYXNlIDI6dGhpcy5fY2hhcnNldFNlcnZpY2Uuc2V0Z0NoYXJzZXQoMCxvLkRFRkFVTFRfQ0hBUlNFVCksdGhpcy5fY2hhcnNldFNlcnZpY2Uuc2V0Z0NoYXJzZXQoMSxvLkRFRkFVTFRfQ0hBUlNFVCksdGhpcy5fY2hhcnNldFNlcnZpY2Uuc2V0Z0NoYXJzZXQoMixvLkRFRkFVTFRfQ0hBUlNFVCksdGhpcy5fY2hhcnNldFNlcnZpY2Uuc2V0Z0NoYXJzZXQoMyxvLkRFRkFVTFRfQ0hBUlNFVCk7YnJlYWs7Y2FzZSAzOnRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMud2luZG93T3B0aW9ucy5zZXRXaW5MaW5lcyYmKHRoaXMuX2J1ZmZlclNlcnZpY2UucmVzaXplKDEzMix0aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3MpLHRoaXMuX29uUmVxdWVzdFJlc2V0LmZpcmUoKSk7YnJlYWs7Y2FzZSA2OnRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5vcmlnaW49ITAsdGhpcy5fc2V0Q3Vyc29yKDAsMCk7YnJlYWs7Y2FzZSA3OnRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy53cmFwYXJvdW5kPSEwO2JyZWFrO2Nhc2UgMTI6dGhpcy5fb3B0aW9uc1NlcnZpY2Uub3B0aW9ucy5jdXJzb3JCbGluaz0hMDticmVhaztjYXNlIDQ1OnRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5yZXZlcnNlV3JhcGFyb3VuZD0hMDticmVhaztjYXNlIDY2OnRoaXMuX2xvZ1NlcnZpY2UuZGVidWcoXCJTZXJpYWwgcG9ydCByZXF1ZXN0ZWQgYXBwbGljYXRpb24ga2V5cGFkLlwiKSx0aGlzLl9jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXMuYXBwbGljYXRpb25LZXlwYWQ9ITAsdGhpcy5fb25SZXF1ZXN0U3luY1Njcm9sbEJhci5maXJlKCk7YnJlYWs7Y2FzZSA5OnRoaXMuX2NvcmVNb3VzZVNlcnZpY2UuYWN0aXZlUHJvdG9jb2w9XCJYMTBcIjticmVhaztjYXNlIDFlMzp0aGlzLl9jb3JlTW91c2VTZXJ2aWNlLmFjdGl2ZVByb3RvY29sPVwiVlQyMDBcIjticmVhaztjYXNlIDEwMDI6dGhpcy5fY29yZU1vdXNlU2VydmljZS5hY3RpdmVQcm90b2NvbD1cIkRSQUdcIjticmVhaztjYXNlIDEwMDM6dGhpcy5fY29yZU1vdXNlU2VydmljZS5hY3RpdmVQcm90b2NvbD1cIkFOWVwiO2JyZWFrO2Nhc2UgMTAwNDp0aGlzLl9jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXMuc2VuZEZvY3VzPSEwLHRoaXMuX29uUmVxdWVzdFNlbmRGb2N1cy5maXJlKCk7YnJlYWs7Y2FzZSAxMDA1OnRoaXMuX2xvZ1NlcnZpY2UuZGVidWcoXCJERUNTRVQgMTAwNSBub3Qgc3VwcG9ydGVkIChzZWUgIzI1MDcpXCIpO2JyZWFrO2Nhc2UgMTAwNjp0aGlzLl9jb3JlTW91c2VTZXJ2aWNlLmFjdGl2ZUVuY29kaW5nPVwiU0dSXCI7YnJlYWs7Y2FzZSAxMDE1OnRoaXMuX2xvZ1NlcnZpY2UuZGVidWcoXCJERUNTRVQgMTAxNSBub3Qgc3VwcG9ydGVkIChzZWUgIzI1MDcpXCIpO2JyZWFrO2Nhc2UgMTAxNjp0aGlzLl9jb3JlTW91c2VTZXJ2aWNlLmFjdGl2ZUVuY29kaW5nPVwiU0dSX1BJWEVMU1wiO2JyZWFrO2Nhc2UgMjU6dGhpcy5fY29yZVNlcnZpY2UuaXNDdXJzb3JIaWRkZW49ITE7YnJlYWs7Y2FzZSAxMDQ4OnRoaXMuc2F2ZUN1cnNvcigpO2JyZWFrO2Nhc2UgMTA0OTp0aGlzLnNhdmVDdXJzb3IoKTtjYXNlIDQ3OmNhc2UgMTA0Nzp0aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlcnMuYWN0aXZhdGVBbHRCdWZmZXIodGhpcy5fZXJhc2VBdHRyRGF0YSgpKSx0aGlzLl9jb3JlU2VydmljZS5pc0N1cnNvckluaXRpYWxpemVkPSEwLHRoaXMuX29uUmVxdWVzdFJlZnJlc2hSb3dzLmZpcmUoMCx0aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3MtMSksdGhpcy5fb25SZXF1ZXN0U3luY1Njcm9sbEJhci5maXJlKCk7YnJlYWs7Y2FzZSAyMDA0OnRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5icmFja2V0ZWRQYXN0ZU1vZGU9ITB9cmV0dXJuITB9cmVzZXRNb2RlKGUpe2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXN3aXRjaChlLnBhcmFtc1t0XSl7Y2FzZSA0OnRoaXMuX2NvcmVTZXJ2aWNlLm1vZGVzLmluc2VydE1vZGU9ITE7YnJlYWs7Y2FzZSAyMDp0aGlzLl9vcHRpb25zU2VydmljZS5vcHRpb25zLmNvbnZlcnRFb2w9ITF9cmV0dXJuITB9cmVzZXRNb2RlUHJpdmF0ZShlKXtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKylzd2l0Y2goZS5wYXJhbXNbdF0pe2Nhc2UgMTp0aGlzLl9jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXMuYXBwbGljYXRpb25DdXJzb3JLZXlzPSExO2JyZWFrO2Nhc2UgMzp0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLndpbmRvd09wdGlvbnMuc2V0V2luTGluZXMmJih0aGlzLl9idWZmZXJTZXJ2aWNlLnJlc2l6ZSg4MCx0aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3MpLHRoaXMuX29uUmVxdWVzdFJlc2V0LmZpcmUoKSk7YnJlYWs7Y2FzZSA2OnRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5vcmlnaW49ITEsdGhpcy5fc2V0Q3Vyc29yKDAsMCk7YnJlYWs7Y2FzZSA3OnRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy53cmFwYXJvdW5kPSExO2JyZWFrO2Nhc2UgMTI6dGhpcy5fb3B0aW9uc1NlcnZpY2Uub3B0aW9ucy5jdXJzb3JCbGluaz0hMTticmVhaztjYXNlIDQ1OnRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5yZXZlcnNlV3JhcGFyb3VuZD0hMTticmVhaztjYXNlIDY2OnRoaXMuX2xvZ1NlcnZpY2UuZGVidWcoXCJTd2l0Y2hpbmcgYmFjayB0byBub3JtYWwga2V5cGFkLlwiKSx0aGlzLl9jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXMuYXBwbGljYXRpb25LZXlwYWQ9ITEsdGhpcy5fb25SZXF1ZXN0U3luY1Njcm9sbEJhci5maXJlKCk7YnJlYWs7Y2FzZSA5OmNhc2UgMWUzOmNhc2UgMTAwMjpjYXNlIDEwMDM6dGhpcy5fY29yZU1vdXNlU2VydmljZS5hY3RpdmVQcm90b2NvbD1cIk5PTkVcIjticmVhaztjYXNlIDEwMDQ6dGhpcy5fY29yZVNlcnZpY2UuZGVjUHJpdmF0ZU1vZGVzLnNlbmRGb2N1cz0hMTticmVhaztjYXNlIDEwMDU6dGhpcy5fbG9nU2VydmljZS5kZWJ1ZyhcIkRFQ1JTVCAxMDA1IG5vdCBzdXBwb3J0ZWQgKHNlZSAjMjUwNylcIik7YnJlYWs7Y2FzZSAxMDA2OmNhc2UgMTAxNjp0aGlzLl9jb3JlTW91c2VTZXJ2aWNlLmFjdGl2ZUVuY29kaW5nPVwiREVGQVVMVFwiO2JyZWFrO2Nhc2UgMTAxNTp0aGlzLl9sb2dTZXJ2aWNlLmRlYnVnKFwiREVDUlNUIDEwMTUgbm90IHN1cHBvcnRlZCAoc2VlICMyNTA3KVwiKTticmVhaztjYXNlIDI1OnRoaXMuX2NvcmVTZXJ2aWNlLmlzQ3Vyc29ySGlkZGVuPSEwO2JyZWFrO2Nhc2UgMTA0ODp0aGlzLnJlc3RvcmVDdXJzb3IoKTticmVhaztjYXNlIDEwNDk6Y2FzZSA0NzpjYXNlIDEwNDc6dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXJzLmFjdGl2YXRlTm9ybWFsQnVmZmVyKCksMTA0OT09PWUucGFyYW1zW3RdJiZ0aGlzLnJlc3RvcmVDdXJzb3IoKSx0aGlzLl9jb3JlU2VydmljZS5pc0N1cnNvckluaXRpYWxpemVkPSEwLHRoaXMuX29uUmVxdWVzdFJlZnJlc2hSb3dzLmZpcmUoMCx0aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3MtMSksdGhpcy5fb25SZXF1ZXN0U3luY1Njcm9sbEJhci5maXJlKCk7YnJlYWs7Y2FzZSAyMDA0OnRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5icmFja2V0ZWRQYXN0ZU1vZGU9ITF9cmV0dXJuITB9cmVxdWVzdE1vZGUoZSx0KXtjb25zdCBpPXRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcyx7YWN0aXZlUHJvdG9jb2w6cyxhY3RpdmVFbmNvZGluZzpyfT10aGlzLl9jb3JlTW91c2VTZXJ2aWNlLG89dGhpcy5fY29yZVNlcnZpY2Use2J1ZmZlcnM6YSxjb2xzOmh9PXRoaXMuX2J1ZmZlclNlcnZpY2Use2FjdGl2ZTpjLGFsdDpsfT1hLGQ9dGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucyxfPWU9PmU/MToyLHU9ZS5wYXJhbXNbMF07cmV0dXJuIGY9dSx2PXQ/Mj09PXU/NDo0PT09dT9fKG8ubW9kZXMuaW5zZXJ0TW9kZSk6MTI9PT11PzM6MjA9PT11P18oZC5jb252ZXJ0RW9sKTowOjE9PT11P18oaS5hcHBsaWNhdGlvbkN1cnNvcktleXMpOjM9PT11P2Qud2luZG93T3B0aW9ucy5zZXRXaW5MaW5lcz84MD09PWg/MjoxMzI9PT1oPzE6MDowOjY9PT11P18oaS5vcmlnaW4pOjc9PT11P18oaS53cmFwYXJvdW5kKTo4PT09dT8zOjk9PT11P18oXCJYMTBcIj09PXMpOjEyPT09dT9fKGQuY3Vyc29yQmxpbmspOjI1PT09dT9fKCFvLmlzQ3Vyc29ySGlkZGVuKTo0NT09PXU/XyhpLnJldmVyc2VXcmFwYXJvdW5kKTo2Nj09PXU/XyhpLmFwcGxpY2F0aW9uS2V5cGFkKTo2Nz09PXU/NDoxZTM9PT11P18oXCJWVDIwMFwiPT09cyk6MTAwMj09PXU/XyhcIkRSQUdcIj09PXMpOjEwMDM9PT11P18oXCJBTllcIj09PXMpOjEwMDQ9PT11P18oaS5zZW5kRm9jdXMpOjEwMDU9PT11PzQ6MTAwNj09PXU/XyhcIlNHUlwiPT09cik6MTAxNT09PXU/NDoxMDE2PT09dT9fKFwiU0dSX1BJWEVMU1wiPT09cik6MTA0OD09PXU/MTo0Nz09PXV8fDEwNDc9PT11fHwxMDQ5PT09dT9fKGM9PT1sKToyMDA0PT09dT9fKGkuYnJhY2tldGVkUGFzdGVNb2RlKTowLG8udHJpZ2dlckRhdGFFdmVudChgJHtuLkMwLkVTQ31bJHt0P1wiXCI6XCI/XCJ9JHtmfTske3Z9JHlgKSwhMDt2YXIgZix2fV91cGRhdGVBdHRyQ29sb3IoZSx0LGkscyxyKXtyZXR1cm4gMj09PXQ/KGV8PTUwMzMxNjQ4LGUmPS0xNjc3NzIxNixlfD1mLkF0dHJpYnV0ZURhdGEuZnJvbUNvbG9yUkdCKFtpLHMscl0pKTo1PT09dCYmKGUmPS01MDMzMTkwNCxlfD0zMzU1NDQzMnwyNTUmaSksZX1fZXh0cmFjdENvbG9yKGUsdCxpKXtjb25zdCBzPVswLDAsLTEsMCwwLDBdO2xldCByPTAsbj0wO2Rve2lmKHNbbityXT1lLnBhcmFtc1t0K25dLGUuaGFzU3ViUGFyYW1zKHQrbikpe2NvbnN0IGk9ZS5nZXRTdWJQYXJhbXModCtuKTtsZXQgbz0wO2RvezU9PT1zWzFdJiYocj0xKSxzW24rbysxK3JdPWlbb119d2hpbGUoKytvPGkubGVuZ3RoJiZvK24rMStyPHMubGVuZ3RoKTticmVha31pZig1PT09c1sxXSYmbityPj0yfHwyPT09c1sxXSYmbityPj01KWJyZWFrO3NbMV0mJihyPTEpfXdoaWxlKCsrbit0PGUubGVuZ3RoJiZuK3I8cy5sZW5ndGgpO2ZvcihsZXQgZT0yO2U8cy5sZW5ndGg7KytlKS0xPT09c1tlXSYmKHNbZV09MCk7c3dpdGNoKHNbMF0pe2Nhc2UgMzg6aS5mZz10aGlzLl91cGRhdGVBdHRyQ29sb3IoaS5mZyxzWzFdLHNbM10sc1s0XSxzWzVdKTticmVhaztjYXNlIDQ4OmkuYmc9dGhpcy5fdXBkYXRlQXR0ckNvbG9yKGkuYmcsc1sxXSxzWzNdLHNbNF0sc1s1XSk7YnJlYWs7Y2FzZSA1ODppLmV4dGVuZGVkPWkuZXh0ZW5kZWQuY2xvbmUoKSxpLmV4dGVuZGVkLnVuZGVybGluZUNvbG9yPXRoaXMuX3VwZGF0ZUF0dHJDb2xvcihpLmV4dGVuZGVkLnVuZGVybGluZUNvbG9yLHNbMV0sc1szXSxzWzRdLHNbNV0pfXJldHVybiBufV9wcm9jZXNzVW5kZXJsaW5lKGUsdCl7dC5leHRlbmRlZD10LmV4dGVuZGVkLmNsb25lKCksKCF+ZXx8ZT41KSYmKGU9MSksdC5leHRlbmRlZC51bmRlcmxpbmVTdHlsZT1lLHQuZmd8PTI2ODQzNTQ1NiwwPT09ZSYmKHQuZmcmPS0yNjg0MzU0NTcpLHQudXBkYXRlRXh0ZW5kZWQoKX1fcHJvY2Vzc1NHUjAoZSl7ZS5mZz1sLkRFRkFVTFRfQVRUUl9EQVRBLmZnLGUuYmc9bC5ERUZBVUxUX0FUVFJfREFUQS5iZyxlLmV4dGVuZGVkPWUuZXh0ZW5kZWQuY2xvbmUoKSxlLmV4dGVuZGVkLnVuZGVybGluZVN0eWxlPTAsZS5leHRlbmRlZC51bmRlcmxpbmVDb2xvciY9LTY3MTA4ODY0LGUudXBkYXRlRXh0ZW5kZWQoKX1jaGFyQXR0cmlidXRlcyhlKXtpZigxPT09ZS5sZW5ndGgmJjA9PT1lLnBhcmFtc1swXSlyZXR1cm4gdGhpcy5fcHJvY2Vzc1NHUjAodGhpcy5fY3VyQXR0ckRhdGEpLCEwO2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IGk7Y29uc3Qgcz10aGlzLl9jdXJBdHRyRGF0YTtmb3IobGV0IHI9MDtyPHQ7cisrKWk9ZS5wYXJhbXNbcl0saT49MzAmJmk8PTM3PyhzLmZnJj0tNTAzMzE5MDQscy5mZ3w9MTY3NzcyMTZ8aS0zMCk6aT49NDAmJmk8PTQ3PyhzLmJnJj0tNTAzMzE5MDQscy5iZ3w9MTY3NzcyMTZ8aS00MCk6aT49OTAmJmk8PTk3PyhzLmZnJj0tNTAzMzE5MDQscy5mZ3w9MTY3NzcyMjR8aS05MCk6aT49MTAwJiZpPD0xMDc/KHMuYmcmPS01MDMzMTkwNCxzLmJnfD0xNjc3NzIyNHxpLTEwMCk6MD09PWk/dGhpcy5fcHJvY2Vzc1NHUjAocyk6MT09PWk/cy5mZ3w9MTM0MjE3NzI4OjM9PT1pP3MuYmd8PTY3MTA4ODY0OjQ9PT1pPyhzLmZnfD0yNjg0MzU0NTYsdGhpcy5fcHJvY2Vzc1VuZGVybGluZShlLmhhc1N1YlBhcmFtcyhyKT9lLmdldFN1YlBhcmFtcyhyKVswXToxLHMpKTo1PT09aT9zLmZnfD01MzY4NzA5MTI6Nz09PWk/cy5mZ3w9NjcxMDg4NjQ6OD09PWk/cy5mZ3w9MTA3Mzc0MTgyNDo5PT09aT9zLmZnfD0yMTQ3NDgzNjQ4OjI9PT1pP3MuYmd8PTEzNDIxNzcyODoyMT09PWk/dGhpcy5fcHJvY2Vzc1VuZGVybGluZSgyLHMpOjIyPT09aT8ocy5mZyY9LTEzNDIxNzcyOSxzLmJnJj0tMTM0MjE3NzI5KToyMz09PWk/cy5iZyY9LTY3MTA4ODY1OjI0PT09aT8ocy5mZyY9LTI2ODQzNTQ1Nyx0aGlzLl9wcm9jZXNzVW5kZXJsaW5lKDAscykpOjI1PT09aT9zLmZnJj0tNTM2ODcwOTEzOjI3PT09aT9zLmZnJj0tNjcxMDg4NjU6Mjg9PT1pP3MuZmcmPS0xMDczNzQxODI1OjI5PT09aT9zLmZnJj0yMTQ3NDgzNjQ3OjM5PT09aT8ocy5mZyY9LTY3MTA4ODY0LHMuZmd8PTE2Nzc3MjE1JmwuREVGQVVMVF9BVFRSX0RBVEEuZmcpOjQ5PT09aT8ocy5iZyY9LTY3MTA4ODY0LHMuYmd8PTE2Nzc3MjE1JmwuREVGQVVMVF9BVFRSX0RBVEEuYmcpOjM4PT09aXx8NDg9PT1pfHw1OD09PWk/cis9dGhpcy5fZXh0cmFjdENvbG9yKGUscixzKTo1Mz09PWk/cy5iZ3w9MTA3Mzc0MTgyNDo1NT09PWk/cy5iZyY9LTEwNzM3NDE4MjU6NTk9PT1pPyhzLmV4dGVuZGVkPXMuZXh0ZW5kZWQuY2xvbmUoKSxzLmV4dGVuZGVkLnVuZGVybGluZUNvbG9yPS0xLHMudXBkYXRlRXh0ZW5kZWQoKSk6MTAwPT09aT8ocy5mZyY9LTY3MTA4ODY0LHMuZmd8PTE2Nzc3MjE1JmwuREVGQVVMVF9BVFRSX0RBVEEuZmcscy5iZyY9LTY3MTA4ODY0LHMuYmd8PTE2Nzc3MjE1JmwuREVGQVVMVF9BVFRSX0RBVEEuYmcpOnRoaXMuX2xvZ1NlcnZpY2UuZGVidWcoXCJVbmtub3duIFNHUiBhdHRyaWJ1dGU6ICVkLlwiLGkpO3JldHVybiEwfWRldmljZVN0YXR1cyhlKXtzd2l0Y2goZS5wYXJhbXNbMF0pe2Nhc2UgNTp0aGlzLl9jb3JlU2VydmljZS50cmlnZ2VyRGF0YUV2ZW50KGAke24uQzAuRVNDfVswbmApO2JyZWFrO2Nhc2UgNjpjb25zdCBlPXRoaXMuX2FjdGl2ZUJ1ZmZlci55KzEsdD10aGlzLl9hY3RpdmVCdWZmZXIueCsxO3RoaXMuX2NvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQoYCR7bi5DMC5FU0N9WyR7ZX07JHt0fVJgKX1yZXR1cm4hMH1kZXZpY2VTdGF0dXNQcml2YXRlKGUpe2lmKDY9PT1lLnBhcmFtc1swXSl7Y29uc3QgZT10aGlzLl9hY3RpdmVCdWZmZXIueSsxLHQ9dGhpcy5fYWN0aXZlQnVmZmVyLngrMTt0aGlzLl9jb3JlU2VydmljZS50cmlnZ2VyRGF0YUV2ZW50KGAke24uQzAuRVNDfVs/JHtlfTske3R9UmApfXJldHVybiEwfXNvZnRSZXNldChlKXtyZXR1cm4gdGhpcy5fY29yZVNlcnZpY2UuaXNDdXJzb3JIaWRkZW49ITEsdGhpcy5fb25SZXF1ZXN0U3luY1Njcm9sbEJhci5maXJlKCksdGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcD0wLHRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxCb3R0b209dGhpcy5fYnVmZmVyU2VydmljZS5yb3dzLTEsdGhpcy5fY3VyQXR0ckRhdGE9bC5ERUZBVUxUX0FUVFJfREFUQS5jbG9uZSgpLHRoaXMuX2NvcmVTZXJ2aWNlLnJlc2V0KCksdGhpcy5fY2hhcnNldFNlcnZpY2UucmVzZXQoKSx0aGlzLl9hY3RpdmVCdWZmZXIuc2F2ZWRYPTAsdGhpcy5fYWN0aXZlQnVmZmVyLnNhdmVkWT10aGlzLl9hY3RpdmVCdWZmZXIueWJhc2UsdGhpcy5fYWN0aXZlQnVmZmVyLnNhdmVkQ3VyQXR0ckRhdGEuZmc9dGhpcy5fY3VyQXR0ckRhdGEuZmcsdGhpcy5fYWN0aXZlQnVmZmVyLnNhdmVkQ3VyQXR0ckRhdGEuYmc9dGhpcy5fY3VyQXR0ckRhdGEuYmcsdGhpcy5fYWN0aXZlQnVmZmVyLnNhdmVkQ2hhcnNldD10aGlzLl9jaGFyc2V0U2VydmljZS5jaGFyc2V0LHRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5vcmlnaW49ITEsITB9c2V0Q3Vyc29yU3R5bGUoZSl7Y29uc3QgdD1lLnBhcmFtc1swXXx8MTtzd2l0Y2godCl7Y2FzZSAxOmNhc2UgMjp0aGlzLl9vcHRpb25zU2VydmljZS5vcHRpb25zLmN1cnNvclN0eWxlPVwiYmxvY2tcIjticmVhaztjYXNlIDM6Y2FzZSA0OnRoaXMuX29wdGlvbnNTZXJ2aWNlLm9wdGlvbnMuY3Vyc29yU3R5bGU9XCJ1bmRlcmxpbmVcIjticmVhaztjYXNlIDU6Y2FzZSA2OnRoaXMuX29wdGlvbnNTZXJ2aWNlLm9wdGlvbnMuY3Vyc29yU3R5bGU9XCJiYXJcIn1jb25zdCBpPXQlMj09MTtyZXR1cm4gdGhpcy5fb3B0aW9uc1NlcnZpY2Uub3B0aW9ucy5jdXJzb3JCbGluaz1pLCEwfXNldFNjcm9sbFJlZ2lvbihlKXtjb25zdCB0PWUucGFyYW1zWzBdfHwxO2xldCBpO3JldHVybihlLmxlbmd0aDwyfHwoaT1lLnBhcmFtc1sxXSk+dGhpcy5fYnVmZmVyU2VydmljZS5yb3dzfHwwPT09aSkmJihpPXRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cyksaT50JiYodGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbFRvcD10LTEsdGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbEJvdHRvbT1pLTEsdGhpcy5fc2V0Q3Vyc29yKDAsMCkpLCEwfXdpbmRvd09wdGlvbnMoZSl7aWYoIXcoZS5wYXJhbXNbMF0sdGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy53aW5kb3dPcHRpb25zKSlyZXR1cm4hMDtjb25zdCB0PWUubGVuZ3RoPjE/ZS5wYXJhbXNbMV06MDtzd2l0Y2goZS5wYXJhbXNbMF0pe2Nhc2UgMTQ6MiE9PXQmJnRoaXMuX29uUmVxdWVzdFdpbmRvd3NPcHRpb25zUmVwb3J0LmZpcmUoeS5HRVRfV0lOX1NJWkVfUElYRUxTKTticmVhaztjYXNlIDE2OnRoaXMuX29uUmVxdWVzdFdpbmRvd3NPcHRpb25zUmVwb3J0LmZpcmUoeS5HRVRfQ0VMTF9TSVpFX1BJWEVMUyk7YnJlYWs7Y2FzZSAxODp0aGlzLl9idWZmZXJTZXJ2aWNlJiZ0aGlzLl9jb3JlU2VydmljZS50cmlnZ2VyRGF0YUV2ZW50KGAke24uQzAuRVNDfVs4OyR7dGhpcy5fYnVmZmVyU2VydmljZS5yb3dzfTske3RoaXMuX2J1ZmZlclNlcnZpY2UuY29sc310YCk7YnJlYWs7Y2FzZSAyMjowIT09dCYmMiE9PXR8fCh0aGlzLl93aW5kb3dUaXRsZVN0YWNrLnB1c2godGhpcy5fd2luZG93VGl0bGUpLHRoaXMuX3dpbmRvd1RpdGxlU3RhY2subGVuZ3RoPjEwJiZ0aGlzLl93aW5kb3dUaXRsZVN0YWNrLnNoaWZ0KCkpLDAhPT10JiYxIT09dHx8KHRoaXMuX2ljb25OYW1lU3RhY2sucHVzaCh0aGlzLl9pY29uTmFtZSksdGhpcy5faWNvbk5hbWVTdGFjay5sZW5ndGg+MTAmJnRoaXMuX2ljb25OYW1lU3RhY2suc2hpZnQoKSk7YnJlYWs7Y2FzZSAyMzowIT09dCYmMiE9PXR8fHRoaXMuX3dpbmRvd1RpdGxlU3RhY2subGVuZ3RoJiZ0aGlzLnNldFRpdGxlKHRoaXMuX3dpbmRvd1RpdGxlU3RhY2sucG9wKCkpLDAhPT10JiYxIT09dHx8dGhpcy5faWNvbk5hbWVTdGFjay5sZW5ndGgmJnRoaXMuc2V0SWNvbk5hbWUodGhpcy5faWNvbk5hbWVTdGFjay5wb3AoKSl9cmV0dXJuITB9c2F2ZUN1cnNvcihlKXtyZXR1cm4gdGhpcy5fYWN0aXZlQnVmZmVyLnNhdmVkWD10aGlzLl9hY3RpdmVCdWZmZXIueCx0aGlzLl9hY3RpdmVCdWZmZXIuc2F2ZWRZPXRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSt0aGlzLl9hY3RpdmVCdWZmZXIueSx0aGlzLl9hY3RpdmVCdWZmZXIuc2F2ZWRDdXJBdHRyRGF0YS5mZz10aGlzLl9jdXJBdHRyRGF0YS5mZyx0aGlzLl9hY3RpdmVCdWZmZXIuc2F2ZWRDdXJBdHRyRGF0YS5iZz10aGlzLl9jdXJBdHRyRGF0YS5iZyx0aGlzLl9hY3RpdmVCdWZmZXIuc2F2ZWRDaGFyc2V0PXRoaXMuX2NoYXJzZXRTZXJ2aWNlLmNoYXJzZXQsITB9cmVzdG9yZUN1cnNvcihlKXtyZXR1cm4gdGhpcy5fYWN0aXZlQnVmZmVyLng9dGhpcy5fYWN0aXZlQnVmZmVyLnNhdmVkWHx8MCx0aGlzLl9hY3RpdmVCdWZmZXIueT1NYXRoLm1heCh0aGlzLl9hY3RpdmVCdWZmZXIuc2F2ZWRZLXRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSwwKSx0aGlzLl9jdXJBdHRyRGF0YS5mZz10aGlzLl9hY3RpdmVCdWZmZXIuc2F2ZWRDdXJBdHRyRGF0YS5mZyx0aGlzLl9jdXJBdHRyRGF0YS5iZz10aGlzLl9hY3RpdmVCdWZmZXIuc2F2ZWRDdXJBdHRyRGF0YS5iZyx0aGlzLl9jaGFyc2V0U2VydmljZS5jaGFyc2V0PXRoaXMuX3NhdmVkQ2hhcnNldCx0aGlzLl9hY3RpdmVCdWZmZXIuc2F2ZWRDaGFyc2V0JiYodGhpcy5fY2hhcnNldFNlcnZpY2UuY2hhcnNldD10aGlzLl9hY3RpdmVCdWZmZXIuc2F2ZWRDaGFyc2V0KSx0aGlzLl9yZXN0cmljdEN1cnNvcigpLCEwfXNldFRpdGxlKGUpe3JldHVybiB0aGlzLl93aW5kb3dUaXRsZT1lLHRoaXMuX29uVGl0bGVDaGFuZ2UuZmlyZShlKSwhMH1zZXRJY29uTmFtZShlKXtyZXR1cm4gdGhpcy5faWNvbk5hbWU9ZSwhMH1zZXRPclJlcG9ydEluZGV4ZWRDb2xvcihlKXtjb25zdCB0PVtdLGk9ZS5zcGxpdChcIjtcIik7Zm9yKDtpLmxlbmd0aD4xOyl7Y29uc3QgZT1pLnNoaWZ0KCkscz1pLnNoaWZ0KCk7aWYoL15cXGQrJC8uZXhlYyhlKSl7Y29uc3QgaT1wYXJzZUludChlKTtpZihEKGkpKWlmKFwiP1wiPT09cyl0LnB1c2goe3R5cGU6MCxpbmRleDppfSk7ZWxzZXtjb25zdCBlPSgwLFMucGFyc2VDb2xvcikocyk7ZSYmdC5wdXNoKHt0eXBlOjEsaW5kZXg6aSxjb2xvcjplfSl9fX1yZXR1cm4gdC5sZW5ndGgmJnRoaXMuX29uQ29sb3IuZmlyZSh0KSwhMH1zZXRIeXBlcmxpbmsoZSl7Y29uc3QgdD1lLnNwbGl0KFwiO1wiKTtyZXR1cm4hKHQubGVuZ3RoPDIpJiYodFsxXT90aGlzLl9jcmVhdGVIeXBlcmxpbmsodFswXSx0WzFdKTohdFswXSYmdGhpcy5fZmluaXNoSHlwZXJsaW5rKCkpfV9jcmVhdGVIeXBlcmxpbmsoZSx0KXt0aGlzLl9nZXRDdXJyZW50TGlua0lkKCkmJnRoaXMuX2ZpbmlzaEh5cGVybGluaygpO2NvbnN0IGk9ZS5zcGxpdChcIjpcIik7bGV0IHM7Y29uc3Qgcj1pLmZpbmRJbmRleCgoZT0+ZS5zdGFydHNXaXRoKFwiaWQ9XCIpKSk7cmV0dXJuLTEhPT1yJiYocz1pW3JdLnNsaWNlKDMpfHx2b2lkIDApLHRoaXMuX2N1ckF0dHJEYXRhLmV4dGVuZGVkPXRoaXMuX2N1ckF0dHJEYXRhLmV4dGVuZGVkLmNsb25lKCksdGhpcy5fY3VyQXR0ckRhdGEuZXh0ZW5kZWQudXJsSWQ9dGhpcy5fb3NjTGlua1NlcnZpY2UucmVnaXN0ZXJMaW5rKHtpZDpzLHVyaTp0fSksdGhpcy5fY3VyQXR0ckRhdGEudXBkYXRlRXh0ZW5kZWQoKSwhMH1fZmluaXNoSHlwZXJsaW5rKCl7cmV0dXJuIHRoaXMuX2N1ckF0dHJEYXRhLmV4dGVuZGVkPXRoaXMuX2N1ckF0dHJEYXRhLmV4dGVuZGVkLmNsb25lKCksdGhpcy5fY3VyQXR0ckRhdGEuZXh0ZW5kZWQudXJsSWQ9MCx0aGlzLl9jdXJBdHRyRGF0YS51cGRhdGVFeHRlbmRlZCgpLCEwfV9zZXRPclJlcG9ydFNwZWNpYWxDb2xvcihlLHQpe2NvbnN0IGk9ZS5zcGxpdChcIjtcIik7Zm9yKGxldCBlPTA7ZTxpLmxlbmd0aCYmISh0Pj10aGlzLl9zcGVjaWFsQ29sb3JzLmxlbmd0aCk7KytlLCsrdClpZihcIj9cIj09PWlbZV0pdGhpcy5fb25Db2xvci5maXJlKFt7dHlwZTowLGluZGV4OnRoaXMuX3NwZWNpYWxDb2xvcnNbdF19XSk7ZWxzZXtjb25zdCBzPSgwLFMucGFyc2VDb2xvcikoaVtlXSk7cyYmdGhpcy5fb25Db2xvci5maXJlKFt7dHlwZToxLGluZGV4OnRoaXMuX3NwZWNpYWxDb2xvcnNbdF0sY29sb3I6c31dKX1yZXR1cm4hMH1zZXRPclJlcG9ydEZnQ29sb3IoZSl7cmV0dXJuIHRoaXMuX3NldE9yUmVwb3J0U3BlY2lhbENvbG9yKGUsMCl9c2V0T3JSZXBvcnRCZ0NvbG9yKGUpe3JldHVybiB0aGlzLl9zZXRPclJlcG9ydFNwZWNpYWxDb2xvcihlLDEpfXNldE9yUmVwb3J0Q3Vyc29yQ29sb3IoZSl7cmV0dXJuIHRoaXMuX3NldE9yUmVwb3J0U3BlY2lhbENvbG9yKGUsMil9cmVzdG9yZUluZGV4ZWRDb2xvcihlKXtpZighZSlyZXR1cm4gdGhpcy5fb25Db2xvci5maXJlKFt7dHlwZToyfV0pLCEwO2NvbnN0IHQ9W10saT1lLnNwbGl0KFwiO1wiKTtmb3IobGV0IGU9MDtlPGkubGVuZ3RoOysrZSlpZigvXlxcZCskLy5leGVjKGlbZV0pKXtjb25zdCBzPXBhcnNlSW50KGlbZV0pO0QocykmJnQucHVzaCh7dHlwZToyLGluZGV4OnN9KX1yZXR1cm4gdC5sZW5ndGgmJnRoaXMuX29uQ29sb3IuZmlyZSh0KSwhMH1yZXN0b3JlRmdDb2xvcihlKXtyZXR1cm4gdGhpcy5fb25Db2xvci5maXJlKFt7dHlwZToyLGluZGV4OjI1Nn1dKSwhMH1yZXN0b3JlQmdDb2xvcihlKXtyZXR1cm4gdGhpcy5fb25Db2xvci5maXJlKFt7dHlwZToyLGluZGV4OjI1N31dKSwhMH1yZXN0b3JlQ3Vyc29yQ29sb3IoZSl7cmV0dXJuIHRoaXMuX29uQ29sb3IuZmlyZShbe3R5cGU6MixpbmRleDoyNTh9XSksITB9bmV4dExpbmUoKXtyZXR1cm4gdGhpcy5fYWN0aXZlQnVmZmVyLng9MCx0aGlzLmluZGV4KCksITB9a2V5cGFkQXBwbGljYXRpb25Nb2RlKCl7cmV0dXJuIHRoaXMuX2xvZ1NlcnZpY2UuZGVidWcoXCJTZXJpYWwgcG9ydCByZXF1ZXN0ZWQgYXBwbGljYXRpb24ga2V5cGFkLlwiKSx0aGlzLl9jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXMuYXBwbGljYXRpb25LZXlwYWQ9ITAsdGhpcy5fb25SZXF1ZXN0U3luY1Njcm9sbEJhci5maXJlKCksITB9a2V5cGFkTnVtZXJpY01vZGUoKXtyZXR1cm4gdGhpcy5fbG9nU2VydmljZS5kZWJ1ZyhcIlN3aXRjaGluZyBiYWNrIHRvIG5vcm1hbCBrZXlwYWQuXCIpLHRoaXMuX2NvcmVTZXJ2aWNlLmRlY1ByaXZhdGVNb2Rlcy5hcHBsaWNhdGlvbktleXBhZD0hMSx0aGlzLl9vblJlcXVlc3RTeW5jU2Nyb2xsQmFyLmZpcmUoKSwhMH1zZWxlY3REZWZhdWx0Q2hhcnNldCgpe3JldHVybiB0aGlzLl9jaGFyc2V0U2VydmljZS5zZXRnTGV2ZWwoMCksdGhpcy5fY2hhcnNldFNlcnZpY2Uuc2V0Z0NoYXJzZXQoMCxvLkRFRkFVTFRfQ0hBUlNFVCksITB9c2VsZWN0Q2hhcnNldChlKXtyZXR1cm4gMiE9PWUubGVuZ3RoPyh0aGlzLnNlbGVjdERlZmF1bHRDaGFyc2V0KCksITApOihcIi9cIj09PWVbMF18fHRoaXMuX2NoYXJzZXRTZXJ2aWNlLnNldGdDaGFyc2V0KENbZVswXV0sby5DSEFSU0VUU1tlWzFdXXx8by5ERUZBVUxUX0NIQVJTRVQpLCEwKX1pbmRleCgpe3JldHVybiB0aGlzLl9yZXN0cmljdEN1cnNvcigpLHRoaXMuX2FjdGl2ZUJ1ZmZlci55KyssdGhpcy5fYWN0aXZlQnVmZmVyLnk9PT10aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsQm90dG9tKzE/KHRoaXMuX2FjdGl2ZUJ1ZmZlci55LS0sdGhpcy5fYnVmZmVyU2VydmljZS5zY3JvbGwodGhpcy5fZXJhc2VBdHRyRGF0YSgpKSk6dGhpcy5fYWN0aXZlQnVmZmVyLnk+PXRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cyYmKHRoaXMuX2FjdGl2ZUJ1ZmZlci55PXRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cy0xKSx0aGlzLl9yZXN0cmljdEN1cnNvcigpLCEwfXRhYlNldCgpe3JldHVybiB0aGlzLl9hY3RpdmVCdWZmZXIudGFic1t0aGlzLl9hY3RpdmVCdWZmZXIueF09ITAsITB9cmV2ZXJzZUluZGV4KCl7aWYodGhpcy5fcmVzdHJpY3RDdXJzb3IoKSx0aGlzLl9hY3RpdmVCdWZmZXIueT09PXRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxUb3Ape2NvbnN0IGU9dGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbEJvdHRvbS10aGlzLl9hY3RpdmVCdWZmZXIuc2Nyb2xsVG9wO3RoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy5zaGlmdEVsZW1lbnRzKHRoaXMuX2FjdGl2ZUJ1ZmZlci55YmFzZSt0aGlzLl9hY3RpdmVCdWZmZXIueSxlLDEpLHRoaXMuX2FjdGl2ZUJ1ZmZlci5saW5lcy5zZXQodGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlK3RoaXMuX2FjdGl2ZUJ1ZmZlci55LHRoaXMuX2FjdGl2ZUJ1ZmZlci5nZXRCbGFua0xpbmUodGhpcy5fZXJhc2VBdHRyRGF0YSgpKSksdGhpcy5fZGlydHlSb3dUcmFja2VyLm1hcmtSYW5nZURpcnR5KHRoaXMuX2FjdGl2ZUJ1ZmZlci5zY3JvbGxUb3AsdGhpcy5fYWN0aXZlQnVmZmVyLnNjcm9sbEJvdHRvbSl9ZWxzZSB0aGlzLl9hY3RpdmVCdWZmZXIueS0tLHRoaXMuX3Jlc3RyaWN0Q3Vyc29yKCk7cmV0dXJuITB9ZnVsbFJlc2V0KCl7cmV0dXJuIHRoaXMuX3BhcnNlci5yZXNldCgpLHRoaXMuX29uUmVxdWVzdFJlc2V0LmZpcmUoKSwhMH1yZXNldCgpe3RoaXMuX2N1ckF0dHJEYXRhPWwuREVGQVVMVF9BVFRSX0RBVEEuY2xvbmUoKSx0aGlzLl9lcmFzZUF0dHJEYXRhSW50ZXJuYWw9bC5ERUZBVUxUX0FUVFJfREFUQS5jbG9uZSgpfV9lcmFzZUF0dHJEYXRhKCl7cmV0dXJuIHRoaXMuX2VyYXNlQXR0ckRhdGFJbnRlcm5hbC5iZyY9LTY3MTA4ODY0LHRoaXMuX2VyYXNlQXR0ckRhdGFJbnRlcm5hbC5iZ3w9NjcxMDg4NjMmdGhpcy5fY3VyQXR0ckRhdGEuYmcsdGhpcy5fZXJhc2VBdHRyRGF0YUludGVybmFsfXNldGdMZXZlbChlKXtyZXR1cm4gdGhpcy5fY2hhcnNldFNlcnZpY2Uuc2V0Z0xldmVsKGUpLCEwfXNjcmVlbkFsaWdubWVudFBhdHRlcm4oKXtjb25zdCBlPW5ldyB1LkNlbGxEYXRhO2UuY29udGVudD0xPDwyMnxcIkVcIi5jaGFyQ29kZUF0KDApLGUuZmc9dGhpcy5fY3VyQXR0ckRhdGEuZmcsZS5iZz10aGlzLl9jdXJBdHRyRGF0YS5iZyx0aGlzLl9zZXRDdXJzb3IoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2J1ZmZlclNlcnZpY2Uucm93czsrK3Qpe2NvbnN0IGk9dGhpcy5fYWN0aXZlQnVmZmVyLnliYXNlK3RoaXMuX2FjdGl2ZUJ1ZmZlci55K3Qscz10aGlzLl9hY3RpdmVCdWZmZXIubGluZXMuZ2V0KGkpO3MmJihzLmZpbGwoZSkscy5pc1dyYXBwZWQ9ITEpfXJldHVybiB0aGlzLl9kaXJ0eVJvd1RyYWNrZXIubWFya0FsbERpcnR5KCksdGhpcy5fc2V0Q3Vyc29yKDAsMCksITB9cmVxdWVzdFN0YXR1c1N0cmluZyhlLHQpe2NvbnN0IGk9dGhpcy5fYnVmZmVyU2VydmljZS5idWZmZXIscz10aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zO3JldHVybihlPT4odGhpcy5fY29yZVNlcnZpY2UudHJpZ2dlckRhdGFFdmVudChgJHtuLkMwLkVTQ30ke2V9JHtuLkMwLkVTQ31cXFxcYCksITApKSgnXCJxJz09PWU/YFAxJHIke3RoaXMuX2N1ckF0dHJEYXRhLmlzUHJvdGVjdGVkKCk/MTowfVwicWA6J1wicCc9PT1lPydQMSRyNjE7MVwicCc6XCJyXCI9PT1lP2BQMSRyJHtpLnNjcm9sbFRvcCsxfTske2kuc2Nyb2xsQm90dG9tKzF9cmA6XCJtXCI9PT1lP1wiUDEkcjBtXCI6XCIgcVwiPT09ZT9gUDEkciR7e2Jsb2NrOjIsdW5kZXJsaW5lOjQsYmFyOjZ9W3MuY3Vyc29yU3R5bGVdLShzLmN1cnNvckJsaW5rPzE6MCl9IHFgOlwiUDAkclwiKX1tYXJrUmFuZ2VEaXJ0eShlLHQpe3RoaXMuX2RpcnR5Um93VHJhY2tlci5tYXJrUmFuZ2VEaXJ0eShlLHQpfX10LklucHV0SGFuZGxlcj1rO2xldCBMPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX2J1ZmZlclNlcnZpY2U9ZSx0aGlzLmNsZWFyUmFuZ2UoKX1jbGVhclJhbmdlKCl7dGhpcy5zdGFydD10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci55LHRoaXMuZW5kPXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyLnl9bWFya0RpcnR5KGUpe2U8dGhpcy5zdGFydD90aGlzLnN0YXJ0PWU6ZT50aGlzLmVuZCYmKHRoaXMuZW5kPWUpfW1hcmtSYW5nZURpcnR5KGUsdCl7ZT50JiYoRT1lLGU9dCx0PUUpLGU8dGhpcy5zdGFydCYmKHRoaXMuc3RhcnQ9ZSksdD50aGlzLmVuZCYmKHRoaXMuZW5kPXQpfW1hcmtBbGxEaXJ0eSgpe3RoaXMubWFya1JhbmdlRGlydHkoMCx0aGlzLl9idWZmZXJTZXJ2aWNlLnJvd3MtMSl9fTtmdW5jdGlvbiBEKGUpe3JldHVybiAwPD1lJiZlPDI1Nn1MPXMoW3IoMCx2LklCdWZmZXJTZXJ2aWNlKV0sTCl9LDg0NDooZSx0KT0+e2Z1bmN0aW9uIGkoZSl7Zm9yKGNvbnN0IHQgb2YgZSl0LmRpc3Bvc2UoKTtlLmxlbmd0aD0wfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0RGlzcG9zZUFycmF5RGlzcG9zYWJsZT10LmRpc3Bvc2VBcnJheT10LnRvRGlzcG9zYWJsZT10Lk11dGFibGVEaXNwb3NhYmxlPXQuRGlzcG9zYWJsZT12b2lkIDAsdC5EaXNwb3NhYmxlPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5fZGlzcG9zYWJsZXM9W10sdGhpcy5faXNEaXNwb3NlZD0hMX1kaXNwb3NlKCl7dGhpcy5faXNEaXNwb3NlZD0hMDtmb3IoY29uc3QgZSBvZiB0aGlzLl9kaXNwb3NhYmxlcyllLmRpc3Bvc2UoKTt0aGlzLl9kaXNwb3NhYmxlcy5sZW5ndGg9MH1yZWdpc3RlcihlKXtyZXR1cm4gdGhpcy5fZGlzcG9zYWJsZXMucHVzaChlKSxlfXVucmVnaXN0ZXIoZSl7Y29uc3QgdD10aGlzLl9kaXNwb3NhYmxlcy5pbmRleE9mKGUpOy0xIT09dCYmdGhpcy5fZGlzcG9zYWJsZXMuc3BsaWNlKHQsMSl9fSx0Lk11dGFibGVEaXNwb3NhYmxlPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5faXNEaXNwb3NlZD0hMX1nZXQgdmFsdWUoKXtyZXR1cm4gdGhpcy5faXNEaXNwb3NlZD92b2lkIDA6dGhpcy5fdmFsdWV9c2V0IHZhbHVlKGUpe3RoaXMuX2lzRGlzcG9zZWR8fGU9PT10aGlzLl92YWx1ZXx8KHRoaXMuX3ZhbHVlPy5kaXNwb3NlKCksdGhpcy5fdmFsdWU9ZSl9Y2xlYXIoKXt0aGlzLnZhbHVlPXZvaWQgMH1kaXNwb3NlKCl7dGhpcy5faXNEaXNwb3NlZD0hMCx0aGlzLl92YWx1ZT8uZGlzcG9zZSgpLHRoaXMuX3ZhbHVlPXZvaWQgMH19LHQudG9EaXNwb3NhYmxlPWZ1bmN0aW9uKGUpe3JldHVybntkaXNwb3NlOmV9fSx0LmRpc3Bvc2VBcnJheT1pLHQuZ2V0RGlzcG9zZUFycmF5RGlzcG9zYWJsZT1mdW5jdGlvbihlKXtyZXR1cm57ZGlzcG9zZTooKT0+aShlKX19fSwxNTA1OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Gb3VyS2V5TWFwPXQuVHdvS2V5TWFwPXZvaWQgMDtjbGFzcyBpe2NvbnN0cnVjdG9yKCl7dGhpcy5fZGF0YT17fX1zZXQoZSx0LGkpe3RoaXMuX2RhdGFbZV18fCh0aGlzLl9kYXRhW2VdPXt9KSx0aGlzLl9kYXRhW2VdW3RdPWl9Z2V0KGUsdCl7cmV0dXJuIHRoaXMuX2RhdGFbZV0/dGhpcy5fZGF0YVtlXVt0XTp2b2lkIDB9Y2xlYXIoKXt0aGlzLl9kYXRhPXt9fX10LlR3b0tleU1hcD1pLHQuRm91cktleU1hcD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuX2RhdGE9bmV3IGl9c2V0KGUsdCxzLHIsbil7dGhpcy5fZGF0YS5nZXQoZSx0KXx8dGhpcy5fZGF0YS5zZXQoZSx0LG5ldyBpKSx0aGlzLl9kYXRhLmdldChlLHQpLnNldChzLHIsbil9Z2V0KGUsdCxpLHMpe3JldHVybiB0aGlzLl9kYXRhLmdldChlLHQpPy5nZXQoaSxzKX1jbGVhcigpe3RoaXMuX2RhdGEuY2xlYXIoKX19fSw2MTE0OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5pc0Nocm9tZU9TPXQuaXNMaW51eD10LmlzV2luZG93cz10LmlzSXBob25lPXQuaXNJcGFkPXQuaXNNYWM9dC5nZXRTYWZhcmlWZXJzaW9uPXQuaXNTYWZhcmk9dC5pc0xlZ2FjeUVkZ2U9dC5pc0ZpcmVmb3g9dC5pc05vZGU9dm9pZCAwLHQuaXNOb2RlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiZcInRpdGxlXCJpbiBwcm9jZXNzO2NvbnN0IGk9dC5pc05vZGU/XCJub2RlXCI6bmF2aWdhdG9yLnVzZXJBZ2VudCxzPXQuaXNOb2RlP1wibm9kZVwiOm5hdmlnYXRvci5wbGF0Zm9ybTt0LmlzRmlyZWZveD1pLmluY2x1ZGVzKFwiRmlyZWZveFwiKSx0LmlzTGVnYWN5RWRnZT1pLmluY2x1ZGVzKFwiRWRnZVwiKSx0LmlzU2FmYXJpPS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoaSksdC5nZXRTYWZhcmlWZXJzaW9uPWZ1bmN0aW9uKCl7aWYoIXQuaXNTYWZhcmkpcmV0dXJuIDA7Y29uc3QgZT1pLm1hdGNoKC9WZXJzaW9uXFwvKFxcZCspLyk7cmV0dXJuIG51bGw9PT1lfHxlLmxlbmd0aDwyPzA6cGFyc2VJbnQoZVsxXSl9LHQuaXNNYWM9W1wiTWFjaW50b3NoXCIsXCJNYWNJbnRlbFwiLFwiTWFjUFBDXCIsXCJNYWM2OEtcIl0uaW5jbHVkZXMocyksdC5pc0lwYWQ9XCJpUGFkXCI9PT1zLHQuaXNJcGhvbmU9XCJpUGhvbmVcIj09PXMsdC5pc1dpbmRvd3M9W1wiV2luZG93c1wiLFwiV2luMTZcIixcIldpbjMyXCIsXCJXaW5DRVwiXS5pbmNsdWRlcyhzKSx0LmlzTGludXg9cy5pbmRleE9mKFwiTGludXhcIik+PTAsdC5pc0Nocm9tZU9TPS9cXGJDck9TXFxiLy50ZXN0KGkpfSw2MTA2OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Tb3J0ZWRMaXN0PXZvaWQgMDtsZXQgaT0wO3QuU29ydGVkTGlzdD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9nZXRLZXk9ZSx0aGlzLl9hcnJheT1bXX1jbGVhcigpe3RoaXMuX2FycmF5Lmxlbmd0aD0wfWluc2VydChlKXswIT09dGhpcy5fYXJyYXkubGVuZ3RoPyhpPXRoaXMuX3NlYXJjaCh0aGlzLl9nZXRLZXkoZSkpLHRoaXMuX2FycmF5LnNwbGljZShpLDAsZSkpOnRoaXMuX2FycmF5LnB1c2goZSl9ZGVsZXRlKGUpe2lmKDA9PT10aGlzLl9hcnJheS5sZW5ndGgpcmV0dXJuITE7Y29uc3QgdD10aGlzLl9nZXRLZXkoZSk7aWYodm9pZCAwPT09dClyZXR1cm4hMTtpZihpPXRoaXMuX3NlYXJjaCh0KSwtMT09PWkpcmV0dXJuITE7aWYodGhpcy5fZ2V0S2V5KHRoaXMuX2FycmF5W2ldKSE9PXQpcmV0dXJuITE7ZG97aWYodGhpcy5fYXJyYXlbaV09PT1lKXJldHVybiB0aGlzLl9hcnJheS5zcGxpY2UoaSwxKSwhMH13aGlsZSgrK2k8dGhpcy5fYXJyYXkubGVuZ3RoJiZ0aGlzLl9nZXRLZXkodGhpcy5fYXJyYXlbaV0pPT09dCk7cmV0dXJuITF9KmdldEtleUl0ZXJhdG9yKGUpe2lmKDAhPT10aGlzLl9hcnJheS5sZW5ndGgmJihpPXRoaXMuX3NlYXJjaChlKSwhKGk8MHx8aT49dGhpcy5fYXJyYXkubGVuZ3RoKSYmdGhpcy5fZ2V0S2V5KHRoaXMuX2FycmF5W2ldKT09PWUpKWRve3lpZWxkIHRoaXMuX2FycmF5W2ldfXdoaWxlKCsraTx0aGlzLl9hcnJheS5sZW5ndGgmJnRoaXMuX2dldEtleSh0aGlzLl9hcnJheVtpXSk9PT1lKX1mb3JFYWNoQnlLZXkoZSx0KXtpZigwIT09dGhpcy5fYXJyYXkubGVuZ3RoJiYoaT10aGlzLl9zZWFyY2goZSksIShpPDB8fGk+PXRoaXMuX2FycmF5Lmxlbmd0aCkmJnRoaXMuX2dldEtleSh0aGlzLl9hcnJheVtpXSk9PT1lKSlkb3t0KHRoaXMuX2FycmF5W2ldKX13aGlsZSgrK2k8dGhpcy5fYXJyYXkubGVuZ3RoJiZ0aGlzLl9nZXRLZXkodGhpcy5fYXJyYXlbaV0pPT09ZSl9dmFsdWVzKCl7cmV0dXJuWy4uLnRoaXMuX2FycmF5XS52YWx1ZXMoKX1fc2VhcmNoKGUpe2xldCB0PTAsaT10aGlzLl9hcnJheS5sZW5ndGgtMTtmb3IoO2k+PXQ7KXtsZXQgcz10K2k+PjE7Y29uc3Qgcj10aGlzLl9nZXRLZXkodGhpcy5fYXJyYXlbc10pO2lmKHI+ZSlpPXMtMTtlbHNle2lmKCEocjxlKSl7Zm9yKDtzPjAmJnRoaXMuX2dldEtleSh0aGlzLl9hcnJheVtzLTFdKT09PWU7KXMtLTtyZXR1cm4gc310PXMrMX19cmV0dXJuIHR9fX0sNzIyNjooZSx0LGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5EZWJvdW5jZWRJZGxlVGFzaz10LklkbGVUYXNrUXVldWU9dC5Qcmlvcml0eVRhc2tRdWV1ZT12b2lkIDA7Y29uc3Qgcz1pKDYxMTQpO2NsYXNzIHJ7Y29uc3RydWN0b3IoKXt0aGlzLl90YXNrcz1bXSx0aGlzLl9pPTB9ZW5xdWV1ZShlKXt0aGlzLl90YXNrcy5wdXNoKGUpLHRoaXMuX3N0YXJ0KCl9Zmx1c2goKXtmb3IoO3RoaXMuX2k8dGhpcy5fdGFza3MubGVuZ3RoOyl0aGlzLl90YXNrc1t0aGlzLl9pXSgpfHx0aGlzLl9pKys7dGhpcy5jbGVhcigpfWNsZWFyKCl7dGhpcy5faWRsZUNhbGxiYWNrJiYodGhpcy5fY2FuY2VsQ2FsbGJhY2sodGhpcy5faWRsZUNhbGxiYWNrKSx0aGlzLl9pZGxlQ2FsbGJhY2s9dm9pZCAwKSx0aGlzLl9pPTAsdGhpcy5fdGFza3MubGVuZ3RoPTB9X3N0YXJ0KCl7dGhpcy5faWRsZUNhbGxiYWNrfHwodGhpcy5faWRsZUNhbGxiYWNrPXRoaXMuX3JlcXVlc3RDYWxsYmFjayh0aGlzLl9wcm9jZXNzLmJpbmQodGhpcykpKX1fcHJvY2VzcyhlKXt0aGlzLl9pZGxlQ2FsbGJhY2s9dm9pZCAwO2xldCB0PTAsaT0wLHM9ZS50aW1lUmVtYWluaW5nKCkscj0wO2Zvcig7dGhpcy5faTx0aGlzLl90YXNrcy5sZW5ndGg7KXtpZih0PURhdGUubm93KCksdGhpcy5fdGFza3NbdGhpcy5faV0oKXx8dGhpcy5faSsrLHQ9TWF0aC5tYXgoMSxEYXRlLm5vdygpLXQpLGk9TWF0aC5tYXgodCxpKSxyPWUudGltZVJlbWFpbmluZygpLDEuNSppPnIpcmV0dXJuIHMtdDwtMjAmJmNvbnNvbGUud2FybihgdGFzayBxdWV1ZSBleGNlZWRlZCBhbGxvdHRlZCBkZWFkbGluZSBieSAke01hdGguYWJzKE1hdGgucm91bmQocy10KSl9bXNgKSx2b2lkIHRoaXMuX3N0YXJ0KCk7cz1yfXRoaXMuY2xlYXIoKX19Y2xhc3MgbiBleHRlbmRzIHJ7X3JlcXVlc3RDYWxsYmFjayhlKXtyZXR1cm4gc2V0VGltZW91dCgoKCk9PmUodGhpcy5fY3JlYXRlRGVhZGxpbmUoMTYpKSkpfV9jYW5jZWxDYWxsYmFjayhlKXtjbGVhclRpbWVvdXQoZSl9X2NyZWF0ZURlYWRsaW5lKGUpe2NvbnN0IHQ9RGF0ZS5ub3coKStlO3JldHVybnt0aW1lUmVtYWluaW5nOigpPT5NYXRoLm1heCgwLHQtRGF0ZS5ub3coKSl9fX10LlByaW9yaXR5VGFza1F1ZXVlPW4sdC5JZGxlVGFza1F1ZXVlPSFzLmlzTm9kZSYmXCJyZXF1ZXN0SWRsZUNhbGxiYWNrXCJpbiB3aW5kb3c/Y2xhc3MgZXh0ZW5kcyBye19yZXF1ZXN0Q2FsbGJhY2soZSl7cmV0dXJuIHJlcXVlc3RJZGxlQ2FsbGJhY2soZSl9X2NhbmNlbENhbGxiYWNrKGUpe2NhbmNlbElkbGVDYWxsYmFjayhlKX19Om4sdC5EZWJvdW5jZWRJZGxlVGFzaz1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuX3F1ZXVlPW5ldyB0LklkbGVUYXNrUXVldWV9c2V0KGUpe3RoaXMuX3F1ZXVlLmNsZWFyKCksdGhpcy5fcXVldWUuZW5xdWV1ZShlKX1mbHVzaCgpe3RoaXMuX3F1ZXVlLmZsdXNoKCl9fX0sOTI4MjooZSx0LGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC51cGRhdGVXaW5kb3dzTW9kZVdyYXBwZWRTdGF0ZT12b2lkIDA7Y29uc3Qgcz1pKDY0Myk7dC51cGRhdGVXaW5kb3dzTW9kZVdyYXBwZWRTdGF0ZT1mdW5jdGlvbihlKXtjb25zdCB0PWUuYnVmZmVyLmxpbmVzLmdldChlLmJ1ZmZlci55YmFzZStlLmJ1ZmZlci55LTEpLGk9dD8uZ2V0KGUuY29scy0xKSxyPWUuYnVmZmVyLmxpbmVzLmdldChlLmJ1ZmZlci55YmFzZStlLmJ1ZmZlci55KTtyJiZpJiYoci5pc1dyYXBwZWQ9aVtzLkNIQVJfREFUQV9DT0RFX0lOREVYXSE9PXMuTlVMTF9DRUxMX0NPREUmJmlbcy5DSEFSX0RBVEFfQ09ERV9JTkRFWF0hPT1zLldISVRFU1BBQ0VfQ0VMTF9DT0RFKX19LDM3MzQ6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkV4dGVuZGVkQXR0cnM9dC5BdHRyaWJ1dGVEYXRhPXZvaWQgMDtjbGFzcyBpe2NvbnN0cnVjdG9yKCl7dGhpcy5mZz0wLHRoaXMuYmc9MCx0aGlzLmV4dGVuZGVkPW5ldyBzfXN0YXRpYyB0b0NvbG9yUkdCKGUpe3JldHVybltlPj4+MTYmMjU1LGU+Pj44JjI1NSwyNTUmZV19c3RhdGljIGZyb21Db2xvclJHQihlKXtyZXR1cm4oMjU1JmVbMF0pPDwxNnwoMjU1JmVbMV0pPDw4fDI1NSZlWzJdfWNsb25lKCl7Y29uc3QgZT1uZXcgaTtyZXR1cm4gZS5mZz10aGlzLmZnLGUuYmc9dGhpcy5iZyxlLmV4dGVuZGVkPXRoaXMuZXh0ZW5kZWQuY2xvbmUoKSxlfWlzSW52ZXJzZSgpe3JldHVybiA2NzEwODg2NCZ0aGlzLmZnfWlzQm9sZCgpe3JldHVybiAxMzQyMTc3MjgmdGhpcy5mZ31pc1VuZGVybGluZSgpe3JldHVybiB0aGlzLmhhc0V4dGVuZGVkQXR0cnMoKSYmMCE9PXRoaXMuZXh0ZW5kZWQudW5kZXJsaW5lU3R5bGU/MToyNjg0MzU0NTYmdGhpcy5mZ31pc0JsaW5rKCl7cmV0dXJuIDUzNjg3MDkxMiZ0aGlzLmZnfWlzSW52aXNpYmxlKCl7cmV0dXJuIDEwNzM3NDE4MjQmdGhpcy5mZ31pc0l0YWxpYygpe3JldHVybiA2NzEwODg2NCZ0aGlzLmJnfWlzRGltKCl7cmV0dXJuIDEzNDIxNzcyOCZ0aGlzLmJnfWlzU3RyaWtldGhyb3VnaCgpe3JldHVybiAyMTQ3NDgzNjQ4JnRoaXMuZmd9aXNQcm90ZWN0ZWQoKXtyZXR1cm4gNTM2ODcwOTEyJnRoaXMuYmd9aXNPdmVybGluZSgpe3JldHVybiAxMDczNzQxODI0JnRoaXMuYmd9Z2V0RmdDb2xvck1vZGUoKXtyZXR1cm4gNTAzMzE2NDgmdGhpcy5mZ31nZXRCZ0NvbG9yTW9kZSgpe3JldHVybiA1MDMzMTY0OCZ0aGlzLmJnfWlzRmdSR0IoKXtyZXR1cm4gNTAzMzE2NDg9PSg1MDMzMTY0OCZ0aGlzLmZnKX1pc0JnUkdCKCl7cmV0dXJuIDUwMzMxNjQ4PT0oNTAzMzE2NDgmdGhpcy5iZyl9aXNGZ1BhbGV0dGUoKXtyZXR1cm4gMTY3NzcyMTY9PSg1MDMzMTY0OCZ0aGlzLmZnKXx8MzM1NTQ0MzI9PSg1MDMzMTY0OCZ0aGlzLmZnKX1pc0JnUGFsZXR0ZSgpe3JldHVybiAxNjc3NzIxNj09KDUwMzMxNjQ4JnRoaXMuYmcpfHwzMzU1NDQzMj09KDUwMzMxNjQ4JnRoaXMuYmcpfWlzRmdEZWZhdWx0KCl7cmV0dXJuIDA9PSg1MDMzMTY0OCZ0aGlzLmZnKX1pc0JnRGVmYXVsdCgpe3JldHVybiAwPT0oNTAzMzE2NDgmdGhpcy5iZyl9aXNBdHRyaWJ1dGVEZWZhdWx0KCl7cmV0dXJuIDA9PT10aGlzLmZnJiYwPT09dGhpcy5iZ31nZXRGZ0NvbG9yKCl7c3dpdGNoKDUwMzMxNjQ4JnRoaXMuZmcpe2Nhc2UgMTY3NzcyMTY6Y2FzZSAzMzU1NDQzMjpyZXR1cm4gMjU1JnRoaXMuZmc7Y2FzZSA1MDMzMTY0ODpyZXR1cm4gMTY3NzcyMTUmdGhpcy5mZztkZWZhdWx0OnJldHVybi0xfX1nZXRCZ0NvbG9yKCl7c3dpdGNoKDUwMzMxNjQ4JnRoaXMuYmcpe2Nhc2UgMTY3NzcyMTY6Y2FzZSAzMzU1NDQzMjpyZXR1cm4gMjU1JnRoaXMuYmc7Y2FzZSA1MDMzMTY0ODpyZXR1cm4gMTY3NzcyMTUmdGhpcy5iZztkZWZhdWx0OnJldHVybi0xfX1oYXNFeHRlbmRlZEF0dHJzKCl7cmV0dXJuIDI2ODQzNTQ1NiZ0aGlzLmJnfXVwZGF0ZUV4dGVuZGVkKCl7dGhpcy5leHRlbmRlZC5pc0VtcHR5KCk/dGhpcy5iZyY9LTI2ODQzNTQ1Nzp0aGlzLmJnfD0yNjg0MzU0NTZ9Z2V0VW5kZXJsaW5lQ29sb3IoKXtpZigyNjg0MzU0NTYmdGhpcy5iZyYmfnRoaXMuZXh0ZW5kZWQudW5kZXJsaW5lQ29sb3Ipc3dpdGNoKDUwMzMxNjQ4JnRoaXMuZXh0ZW5kZWQudW5kZXJsaW5lQ29sb3Ipe2Nhc2UgMTY3NzcyMTY6Y2FzZSAzMzU1NDQzMjpyZXR1cm4gMjU1JnRoaXMuZXh0ZW5kZWQudW5kZXJsaW5lQ29sb3I7Y2FzZSA1MDMzMTY0ODpyZXR1cm4gMTY3NzcyMTUmdGhpcy5leHRlbmRlZC51bmRlcmxpbmVDb2xvcjtkZWZhdWx0OnJldHVybiB0aGlzLmdldEZnQ29sb3IoKX1yZXR1cm4gdGhpcy5nZXRGZ0NvbG9yKCl9Z2V0VW5kZXJsaW5lQ29sb3JNb2RlKCl7cmV0dXJuIDI2ODQzNTQ1NiZ0aGlzLmJnJiZ+dGhpcy5leHRlbmRlZC51bmRlcmxpbmVDb2xvcj81MDMzMTY0OCZ0aGlzLmV4dGVuZGVkLnVuZGVybGluZUNvbG9yOnRoaXMuZ2V0RmdDb2xvck1vZGUoKX1pc1VuZGVybGluZUNvbG9yUkdCKCl7cmV0dXJuIDI2ODQzNTQ1NiZ0aGlzLmJnJiZ+dGhpcy5leHRlbmRlZC51bmRlcmxpbmVDb2xvcj81MDMzMTY0OD09KDUwMzMxNjQ4JnRoaXMuZXh0ZW5kZWQudW5kZXJsaW5lQ29sb3IpOnRoaXMuaXNGZ1JHQigpfWlzVW5kZXJsaW5lQ29sb3JQYWxldHRlKCl7cmV0dXJuIDI2ODQzNTQ1NiZ0aGlzLmJnJiZ+dGhpcy5leHRlbmRlZC51bmRlcmxpbmVDb2xvcj8xNjc3NzIxNj09KDUwMzMxNjQ4JnRoaXMuZXh0ZW5kZWQudW5kZXJsaW5lQ29sb3IpfHwzMzU1NDQzMj09KDUwMzMxNjQ4JnRoaXMuZXh0ZW5kZWQudW5kZXJsaW5lQ29sb3IpOnRoaXMuaXNGZ1BhbGV0dGUoKX1pc1VuZGVybGluZUNvbG9yRGVmYXVsdCgpe3JldHVybiAyNjg0MzU0NTYmdGhpcy5iZyYmfnRoaXMuZXh0ZW5kZWQudW5kZXJsaW5lQ29sb3I/MD09KDUwMzMxNjQ4JnRoaXMuZXh0ZW5kZWQudW5kZXJsaW5lQ29sb3IpOnRoaXMuaXNGZ0RlZmF1bHQoKX1nZXRVbmRlcmxpbmVTdHlsZSgpe3JldHVybiAyNjg0MzU0NTYmdGhpcy5mZz8yNjg0MzU0NTYmdGhpcy5iZz90aGlzLmV4dGVuZGVkLnVuZGVybGluZVN0eWxlOjE6MH1nZXRVbmRlcmxpbmVWYXJpYW50T2Zmc2V0KCl7cmV0dXJuIHRoaXMuZXh0ZW5kZWQudW5kZXJsaW5lVmFyaWFudE9mZnNldH19dC5BdHRyaWJ1dGVEYXRhPWk7Y2xhc3Mgc3tnZXQgZXh0KCl7cmV0dXJuIHRoaXMuX3VybElkPy00Njk3NjIwNDkmdGhpcy5fZXh0fHRoaXMudW5kZXJsaW5lU3R5bGU8PDI2OnRoaXMuX2V4dH1zZXQgZXh0KGUpe3RoaXMuX2V4dD1lfWdldCB1bmRlcmxpbmVTdHlsZSgpe3JldHVybiB0aGlzLl91cmxJZD81Oig0Njk3NjIwNDgmdGhpcy5fZXh0KT4+MjZ9c2V0IHVuZGVybGluZVN0eWxlKGUpe3RoaXMuX2V4dCY9LTQ2OTc2MjA0OSx0aGlzLl9leHR8PWU8PDI2JjQ2OTc2MjA0OH1nZXQgdW5kZXJsaW5lQ29sb3IoKXtyZXR1cm4gNjcxMDg4NjMmdGhpcy5fZXh0fXNldCB1bmRlcmxpbmVDb2xvcihlKXt0aGlzLl9leHQmPS02NzEwODg2NCx0aGlzLl9leHR8PTY3MTA4ODYzJmV9Z2V0IHVybElkKCl7cmV0dXJuIHRoaXMuX3VybElkfXNldCB1cmxJZChlKXt0aGlzLl91cmxJZD1lfWdldCB1bmRlcmxpbmVWYXJpYW50T2Zmc2V0KCl7Y29uc3QgZT0oMzc1ODA5NjM4NCZ0aGlzLl9leHQpPj4yOTtyZXR1cm4gZTwwPzQyOTQ5NjcyODheZTplfXNldCB1bmRlcmxpbmVWYXJpYW50T2Zmc2V0KGUpe3RoaXMuX2V4dCY9NTM2ODcwOTExLHRoaXMuX2V4dHw9ZTw8MjkmMzc1ODA5NjM4NH1jb25zdHJ1Y3RvcihlPTAsdD0wKXt0aGlzLl9leHQ9MCx0aGlzLl91cmxJZD0wLHRoaXMuX2V4dD1lLHRoaXMuX3VybElkPXR9Y2xvbmUoKXtyZXR1cm4gbmV3IHModGhpcy5fZXh0LHRoaXMuX3VybElkKX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLnVuZGVybGluZVN0eWxlJiYwPT09dGhpcy5fdXJsSWR9fXQuRXh0ZW5kZWRBdHRycz1zfSw5MDkyOihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkJ1ZmZlcj10Lk1BWF9CVUZGRVJfU0laRT12b2lkIDA7Y29uc3Qgcz1pKDYzNDkpLHI9aSg3MjI2KSxuPWkoMzczNCksbz1pKDg0MzcpLGE9aSg0NjM0KSxoPWkoNTExKSxjPWkoNjQzKSxsPWkoNDg2MyksZD1pKDcxMTYpO3QuTUFYX0JVRkZFUl9TSVpFPTQyOTQ5NjcyOTUsdC5CdWZmZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LGkpe3RoaXMuX2hhc1Njcm9sbGJhY2s9ZSx0aGlzLl9vcHRpb25zU2VydmljZT10LHRoaXMuX2J1ZmZlclNlcnZpY2U9aSx0aGlzLnlkaXNwPTAsdGhpcy55YmFzZT0wLHRoaXMueT0wLHRoaXMueD0wLHRoaXMudGFicz17fSx0aGlzLnNhdmVkWT0wLHRoaXMuc2F2ZWRYPTAsdGhpcy5zYXZlZEN1ckF0dHJEYXRhPW8uREVGQVVMVF9BVFRSX0RBVEEuY2xvbmUoKSx0aGlzLnNhdmVkQ2hhcnNldD1kLkRFRkFVTFRfQ0hBUlNFVCx0aGlzLm1hcmtlcnM9W10sdGhpcy5fbnVsbENlbGw9aC5DZWxsRGF0YS5mcm9tQ2hhckRhdGEoWzAsYy5OVUxMX0NFTExfQ0hBUixjLk5VTExfQ0VMTF9XSURUSCxjLk5VTExfQ0VMTF9DT0RFXSksdGhpcy5fd2hpdGVzcGFjZUNlbGw9aC5DZWxsRGF0YS5mcm9tQ2hhckRhdGEoWzAsYy5XSElURVNQQUNFX0NFTExfQ0hBUixjLldISVRFU1BBQ0VfQ0VMTF9XSURUSCxjLldISVRFU1BBQ0VfQ0VMTF9DT0RFXSksdGhpcy5faXNDbGVhcmluZz0hMSx0aGlzLl9tZW1vcnlDbGVhbnVwUXVldWU9bmV3IHIuSWRsZVRhc2tRdWV1ZSx0aGlzLl9tZW1vcnlDbGVhbnVwUG9zaXRpb249MCx0aGlzLl9jb2xzPXRoaXMuX2J1ZmZlclNlcnZpY2UuY29scyx0aGlzLl9yb3dzPXRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cyx0aGlzLmxpbmVzPW5ldyBzLkNpcmN1bGFyTGlzdCh0aGlzLl9nZXRDb3JyZWN0QnVmZmVyTGVuZ3RoKHRoaXMuX3Jvd3MpKSx0aGlzLnNjcm9sbFRvcD0wLHRoaXMuc2Nyb2xsQm90dG9tPXRoaXMuX3Jvd3MtMSx0aGlzLnNldHVwVGFiU3RvcHMoKX1nZXROdWxsQ2VsbChlKXtyZXR1cm4gZT8odGhpcy5fbnVsbENlbGwuZmc9ZS5mZyx0aGlzLl9udWxsQ2VsbC5iZz1lLmJnLHRoaXMuX251bGxDZWxsLmV4dGVuZGVkPWUuZXh0ZW5kZWQpOih0aGlzLl9udWxsQ2VsbC5mZz0wLHRoaXMuX251bGxDZWxsLmJnPTAsdGhpcy5fbnVsbENlbGwuZXh0ZW5kZWQ9bmV3IG4uRXh0ZW5kZWRBdHRycyksdGhpcy5fbnVsbENlbGx9Z2V0V2hpdGVzcGFjZUNlbGwoZSl7cmV0dXJuIGU/KHRoaXMuX3doaXRlc3BhY2VDZWxsLmZnPWUuZmcsdGhpcy5fd2hpdGVzcGFjZUNlbGwuYmc9ZS5iZyx0aGlzLl93aGl0ZXNwYWNlQ2VsbC5leHRlbmRlZD1lLmV4dGVuZGVkKToodGhpcy5fd2hpdGVzcGFjZUNlbGwuZmc9MCx0aGlzLl93aGl0ZXNwYWNlQ2VsbC5iZz0wLHRoaXMuX3doaXRlc3BhY2VDZWxsLmV4dGVuZGVkPW5ldyBuLkV4dGVuZGVkQXR0cnMpLHRoaXMuX3doaXRlc3BhY2VDZWxsfWdldEJsYW5rTGluZShlLHQpe3JldHVybiBuZXcgby5CdWZmZXJMaW5lKHRoaXMuX2J1ZmZlclNlcnZpY2UuY29scyx0aGlzLmdldE51bGxDZWxsKGUpLHQpfWdldCBoYXNTY3JvbGxiYWNrKCl7cmV0dXJuIHRoaXMuX2hhc1Njcm9sbGJhY2smJnRoaXMubGluZXMubWF4TGVuZ3RoPnRoaXMuX3Jvd3N9Z2V0IGlzQ3Vyc29ySW5WaWV3cG9ydCgpe2NvbnN0IGU9dGhpcy55YmFzZSt0aGlzLnktdGhpcy55ZGlzcDtyZXR1cm4gZT49MCYmZTx0aGlzLl9yb3dzfV9nZXRDb3JyZWN0QnVmZmVyTGVuZ3RoKGUpe2lmKCF0aGlzLl9oYXNTY3JvbGxiYWNrKXJldHVybiBlO2NvbnN0IGk9ZSt0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLnNjcm9sbGJhY2s7cmV0dXJuIGk+dC5NQVhfQlVGRkVSX1NJWkU/dC5NQVhfQlVGRkVSX1NJWkU6aX1maWxsVmlld3BvcnRSb3dzKGUpe2lmKDA9PT10aGlzLmxpbmVzLmxlbmd0aCl7dm9pZCAwPT09ZSYmKGU9by5ERUZBVUxUX0FUVFJfREFUQSk7bGV0IHQ9dGhpcy5fcm93cztmb3IoO3QtLTspdGhpcy5saW5lcy5wdXNoKHRoaXMuZ2V0QmxhbmtMaW5lKGUpKX19Y2xlYXIoKXt0aGlzLnlkaXNwPTAsdGhpcy55YmFzZT0wLHRoaXMueT0wLHRoaXMueD0wLHRoaXMubGluZXM9bmV3IHMuQ2lyY3VsYXJMaXN0KHRoaXMuX2dldENvcnJlY3RCdWZmZXJMZW5ndGgodGhpcy5fcm93cykpLHRoaXMuc2Nyb2xsVG9wPTAsdGhpcy5zY3JvbGxCb3R0b209dGhpcy5fcm93cy0xLHRoaXMuc2V0dXBUYWJTdG9wcygpfXJlc2l6ZShlLHQpe2NvbnN0IGk9dGhpcy5nZXROdWxsQ2VsbChvLkRFRkFVTFRfQVRUUl9EQVRBKTtsZXQgcz0wO2NvbnN0IHI9dGhpcy5fZ2V0Q29ycmVjdEJ1ZmZlckxlbmd0aCh0KTtpZihyPnRoaXMubGluZXMubWF4TGVuZ3RoJiYodGhpcy5saW5lcy5tYXhMZW5ndGg9ciksdGhpcy5saW5lcy5sZW5ndGg+MCl7aWYodGhpcy5fY29sczxlKWZvcihsZXQgdD0wO3Q8dGhpcy5saW5lcy5sZW5ndGg7dCsrKXMrPSt0aGlzLmxpbmVzLmdldCh0KS5yZXNpemUoZSxpKTtsZXQgbj0wO2lmKHRoaXMuX3Jvd3M8dClmb3IobGV0IHM9dGhpcy5fcm93cztzPHQ7cysrKXRoaXMubGluZXMubGVuZ3RoPHQrdGhpcy55YmFzZSYmKHRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMud2luZG93c01vZGV8fHZvaWQgMCE9PXRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMud2luZG93c1B0eS5iYWNrZW5kfHx2b2lkIDAhPT10aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLndpbmRvd3NQdHkuYnVpbGROdW1iZXI/dGhpcy5saW5lcy5wdXNoKG5ldyBvLkJ1ZmZlckxpbmUoZSxpKSk6dGhpcy55YmFzZT4wJiZ0aGlzLmxpbmVzLmxlbmd0aDw9dGhpcy55YmFzZSt0aGlzLnkrbisxPyh0aGlzLnliYXNlLS0sbisrLHRoaXMueWRpc3A+MCYmdGhpcy55ZGlzcC0tKTp0aGlzLmxpbmVzLnB1c2gobmV3IG8uQnVmZmVyTGluZShlLGkpKSk7ZWxzZSBmb3IobGV0IGU9dGhpcy5fcm93cztlPnQ7ZS0tKXRoaXMubGluZXMubGVuZ3RoPnQrdGhpcy55YmFzZSYmKHRoaXMubGluZXMubGVuZ3RoPnRoaXMueWJhc2UrdGhpcy55KzE/dGhpcy5saW5lcy5wb3AoKToodGhpcy55YmFzZSsrLHRoaXMueWRpc3ArKykpO2lmKHI8dGhpcy5saW5lcy5tYXhMZW5ndGgpe2NvbnN0IGU9dGhpcy5saW5lcy5sZW5ndGgtcjtlPjAmJih0aGlzLmxpbmVzLnRyaW1TdGFydChlKSx0aGlzLnliYXNlPU1hdGgubWF4KHRoaXMueWJhc2UtZSwwKSx0aGlzLnlkaXNwPU1hdGgubWF4KHRoaXMueWRpc3AtZSwwKSx0aGlzLnNhdmVkWT1NYXRoLm1heCh0aGlzLnNhdmVkWS1lLDApKSx0aGlzLmxpbmVzLm1heExlbmd0aD1yfXRoaXMueD1NYXRoLm1pbih0aGlzLngsZS0xKSx0aGlzLnk9TWF0aC5taW4odGhpcy55LHQtMSksbiYmKHRoaXMueSs9biksdGhpcy5zYXZlZFg9TWF0aC5taW4odGhpcy5zYXZlZFgsZS0xKSx0aGlzLnNjcm9sbFRvcD0wfWlmKHRoaXMuc2Nyb2xsQm90dG9tPXQtMSx0aGlzLl9pc1JlZmxvd0VuYWJsZWQmJih0aGlzLl9yZWZsb3coZSx0KSx0aGlzLl9jb2xzPmUpKWZvcihsZXQgdD0wO3Q8dGhpcy5saW5lcy5sZW5ndGg7dCsrKXMrPSt0aGlzLmxpbmVzLmdldCh0KS5yZXNpemUoZSxpKTt0aGlzLl9jb2xzPWUsdGhpcy5fcm93cz10LHRoaXMuX21lbW9yeUNsZWFudXBRdWV1ZS5jbGVhcigpLHM+LjEqdGhpcy5saW5lcy5sZW5ndGgmJih0aGlzLl9tZW1vcnlDbGVhbnVwUG9zaXRpb249MCx0aGlzLl9tZW1vcnlDbGVhbnVwUXVldWUuZW5xdWV1ZSgoKCk9PnRoaXMuX2JhdGNoZWRNZW1vcnlDbGVhbnVwKCkpKSl9X2JhdGNoZWRNZW1vcnlDbGVhbnVwKCl7bGV0IGU9ITA7dGhpcy5fbWVtb3J5Q2xlYW51cFBvc2l0aW9uPj10aGlzLmxpbmVzLmxlbmd0aCYmKHRoaXMuX21lbW9yeUNsZWFudXBQb3NpdGlvbj0wLGU9ITEpO2xldCB0PTA7Zm9yKDt0aGlzLl9tZW1vcnlDbGVhbnVwUG9zaXRpb248dGhpcy5saW5lcy5sZW5ndGg7KWlmKHQrPXRoaXMubGluZXMuZ2V0KHRoaXMuX21lbW9yeUNsZWFudXBQb3NpdGlvbisrKS5jbGVhbnVwTWVtb3J5KCksdD4xMDApcmV0dXJuITA7cmV0dXJuIGV9Z2V0IF9pc1JlZmxvd0VuYWJsZWQoKXtjb25zdCBlPXRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMud2luZG93c1B0eTtyZXR1cm4gZSYmZS5idWlsZE51bWJlcj90aGlzLl9oYXNTY3JvbGxiYWNrJiZcImNvbnB0eVwiPT09ZS5iYWNrZW5kJiZlLmJ1aWxkTnVtYmVyPj0yMTM3Njp0aGlzLl9oYXNTY3JvbGxiYWNrJiYhdGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy53aW5kb3dzTW9kZX1fcmVmbG93KGUsdCl7dGhpcy5fY29scyE9PWUmJihlPnRoaXMuX2NvbHM/dGhpcy5fcmVmbG93TGFyZ2VyKGUsdCk6dGhpcy5fcmVmbG93U21hbGxlcihlLHQpKX1fcmVmbG93TGFyZ2VyKGUsdCl7Y29uc3QgaT0oMCxhLnJlZmxvd0xhcmdlckdldExpbmVzVG9SZW1vdmUpKHRoaXMubGluZXMsdGhpcy5fY29scyxlLHRoaXMueWJhc2UrdGhpcy55LHRoaXMuZ2V0TnVsbENlbGwoby5ERUZBVUxUX0FUVFJfREFUQSkpO2lmKGkubGVuZ3RoPjApe2NvbnN0IHM9KDAsYS5yZWZsb3dMYXJnZXJDcmVhdGVOZXdMYXlvdXQpKHRoaXMubGluZXMsaSk7KDAsYS5yZWZsb3dMYXJnZXJBcHBseU5ld0xheW91dCkodGhpcy5saW5lcyxzLmxheW91dCksdGhpcy5fcmVmbG93TGFyZ2VyQWRqdXN0Vmlld3BvcnQoZSx0LHMuY291bnRSZW1vdmVkKX19X3JlZmxvd0xhcmdlckFkanVzdFZpZXdwb3J0KGUsdCxpKXtjb25zdCBzPXRoaXMuZ2V0TnVsbENlbGwoby5ERUZBVUxUX0FUVFJfREFUQSk7bGV0IHI9aTtmb3IoO3ItLSA+MDspMD09PXRoaXMueWJhc2U/KHRoaXMueT4wJiZ0aGlzLnktLSx0aGlzLmxpbmVzLmxlbmd0aDx0JiZ0aGlzLmxpbmVzLnB1c2gobmV3IG8uQnVmZmVyTGluZShlLHMpKSk6KHRoaXMueWRpc3A9PT10aGlzLnliYXNlJiZ0aGlzLnlkaXNwLS0sdGhpcy55YmFzZS0tKTt0aGlzLnNhdmVkWT1NYXRoLm1heCh0aGlzLnNhdmVkWS1pLDApfV9yZWZsb3dTbWFsbGVyKGUsdCl7Y29uc3QgaT10aGlzLmdldE51bGxDZWxsKG8uREVGQVVMVF9BVFRSX0RBVEEpLHM9W107bGV0IHI9MDtmb3IobGV0IG49dGhpcy5saW5lcy5sZW5ndGgtMTtuPj0wO24tLSl7bGV0IGg9dGhpcy5saW5lcy5nZXQobik7aWYoIWh8fCFoLmlzV3JhcHBlZCYmaC5nZXRUcmltbWVkTGVuZ3RoKCk8PWUpY29udGludWU7Y29uc3QgYz1baF07Zm9yKDtoLmlzV3JhcHBlZCYmbj4wOyloPXRoaXMubGluZXMuZ2V0KC0tbiksYy51bnNoaWZ0KGgpO2NvbnN0IGw9dGhpcy55YmFzZSt0aGlzLnk7aWYobD49biYmbDxuK2MubGVuZ3RoKWNvbnRpbnVlO2NvbnN0IGQ9Y1tjLmxlbmd0aC0xXS5nZXRUcmltbWVkTGVuZ3RoKCksXz0oMCxhLnJlZmxvd1NtYWxsZXJHZXROZXdMaW5lTGVuZ3RocykoYyx0aGlzLl9jb2xzLGUpLHU9Xy5sZW5ndGgtYy5sZW5ndGg7bGV0IGY7Zj0wPT09dGhpcy55YmFzZSYmdGhpcy55IT09dGhpcy5saW5lcy5sZW5ndGgtMT9NYXRoLm1heCgwLHRoaXMueS10aGlzLmxpbmVzLm1heExlbmd0aCt1KTpNYXRoLm1heCgwLHRoaXMubGluZXMubGVuZ3RoLXRoaXMubGluZXMubWF4TGVuZ3RoK3UpO2NvbnN0IHY9W107Zm9yKGxldCBlPTA7ZTx1O2UrKyl7Y29uc3QgZT10aGlzLmdldEJsYW5rTGluZShvLkRFRkFVTFRfQVRUUl9EQVRBLCEwKTt2LnB1c2goZSl9di5sZW5ndGg+MCYmKHMucHVzaCh7c3RhcnQ6bitjLmxlbmd0aCtyLG5ld0xpbmVzOnZ9KSxyKz12Lmxlbmd0aCksYy5wdXNoKC4uLnYpO2xldCBwPV8ubGVuZ3RoLTEsZz1fW3BdOzA9PT1nJiYocC0tLGc9X1twXSk7bGV0IG09Yy5sZW5ndGgtdS0xLFM9ZDtmb3IoO20+PTA7KXtjb25zdCBlPU1hdGgubWluKFMsZyk7aWYodm9pZCAwPT09Y1twXSlicmVhaztpZihjW3BdLmNvcHlDZWxsc0Zyb20oY1ttXSxTLWUsZy1lLGUsITApLGctPWUsMD09PWcmJihwLS0sZz1fW3BdKSxTLT1lLDA9PT1TKXttLS07Y29uc3QgZT1NYXRoLm1heChtLDApO1M9KDAsYS5nZXRXcmFwcGVkTGluZVRyaW1tZWRMZW5ndGgpKGMsZSx0aGlzLl9jb2xzKX19Zm9yKGxldCB0PTA7dDxjLmxlbmd0aDt0KyspX1t0XTxlJiZjW3RdLnNldENlbGwoX1t0XSxpKTtsZXQgQz11LWY7Zm9yKDtDLS0gPjA7KTA9PT10aGlzLnliYXNlP3RoaXMueTx0LTE/KHRoaXMueSsrLHRoaXMubGluZXMucG9wKCkpOih0aGlzLnliYXNlKyssdGhpcy55ZGlzcCsrKTp0aGlzLnliYXNlPE1hdGgubWluKHRoaXMubGluZXMubWF4TGVuZ3RoLHRoaXMubGluZXMubGVuZ3RoK3IpLXQmJih0aGlzLnliYXNlPT09dGhpcy55ZGlzcCYmdGhpcy55ZGlzcCsrLHRoaXMueWJhc2UrKyk7dGhpcy5zYXZlZFk9TWF0aC5taW4odGhpcy5zYXZlZFkrdSx0aGlzLnliYXNlK3QtMSl9aWYocy5sZW5ndGg+MCl7Y29uc3QgZT1bXSx0PVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5saW5lcy5sZW5ndGg7ZSsrKXQucHVzaCh0aGlzLmxpbmVzLmdldChlKSk7Y29uc3QgaT10aGlzLmxpbmVzLmxlbmd0aDtsZXQgbj1pLTEsbz0wLGE9c1tvXTt0aGlzLmxpbmVzLmxlbmd0aD1NYXRoLm1pbih0aGlzLmxpbmVzLm1heExlbmd0aCx0aGlzLmxpbmVzLmxlbmd0aCtyKTtsZXQgaD0wO2ZvcihsZXQgYz1NYXRoLm1pbih0aGlzLmxpbmVzLm1heExlbmd0aC0xLGkrci0xKTtjPj0wO2MtLSlpZihhJiZhLnN0YXJ0Pm4raCl7Zm9yKGxldCBlPWEubmV3TGluZXMubGVuZ3RoLTE7ZT49MDtlLS0pdGhpcy5saW5lcy5zZXQoYy0tLGEubmV3TGluZXNbZV0pO2MrKyxlLnB1c2goe2luZGV4Om4rMSxhbW91bnQ6YS5uZXdMaW5lcy5sZW5ndGh9KSxoKz1hLm5ld0xpbmVzLmxlbmd0aCxhPXNbKytvXX1lbHNlIHRoaXMubGluZXMuc2V0KGMsdFtuLS1dKTtsZXQgYz0wO2ZvcihsZXQgdD1lLmxlbmd0aC0xO3Q+PTA7dC0tKWVbdF0uaW5kZXgrPWMsdGhpcy5saW5lcy5vbkluc2VydEVtaXR0ZXIuZmlyZShlW3RdKSxjKz1lW3RdLmFtb3VudDtjb25zdCBsPU1hdGgubWF4KDAsaStyLXRoaXMubGluZXMubWF4TGVuZ3RoKTtsPjAmJnRoaXMubGluZXMub25UcmltRW1pdHRlci5maXJlKGwpfX10cmFuc2xhdGVCdWZmZXJMaW5lVG9TdHJpbmcoZSx0LGk9MCxzKXtjb25zdCByPXRoaXMubGluZXMuZ2V0KGUpO3JldHVybiByP3IudHJhbnNsYXRlVG9TdHJpbmcodCxpLHMpOlwiXCJ9Z2V0V3JhcHBlZFJhbmdlRm9yTGluZShlKXtsZXQgdD1lLGk9ZTtmb3IoO3Q+MCYmdGhpcy5saW5lcy5nZXQodCkuaXNXcmFwcGVkOyl0LS07Zm9yKDtpKzE8dGhpcy5saW5lcy5sZW5ndGgmJnRoaXMubGluZXMuZ2V0KGkrMSkuaXNXcmFwcGVkOylpKys7cmV0dXJue2ZpcnN0OnQsbGFzdDppfX1zZXR1cFRhYlN0b3BzKGUpe2ZvcihudWxsIT1lP3RoaXMudGFic1tlXXx8KGU9dGhpcy5wcmV2U3RvcChlKSk6KHRoaXMudGFicz17fSxlPTApO2U8dGhpcy5fY29scztlKz10aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLnRhYlN0b3BXaWR0aCl0aGlzLnRhYnNbZV09ITB9cHJldlN0b3AoZSl7Zm9yKG51bGw9PWUmJihlPXRoaXMueCk7IXRoaXMudGFic1stLWVdJiZlPjA7KTtyZXR1cm4gZT49dGhpcy5fY29scz90aGlzLl9jb2xzLTE6ZTwwPzA6ZX1uZXh0U3RvcChlKXtmb3IobnVsbD09ZSYmKGU9dGhpcy54KTshdGhpcy50YWJzWysrZV0mJmU8dGhpcy5fY29sczspO3JldHVybiBlPj10aGlzLl9jb2xzP3RoaXMuX2NvbHMtMTplPDA/MDplfWNsZWFyTWFya2VycyhlKXt0aGlzLl9pc0NsZWFyaW5nPSEwO2ZvcihsZXQgdD0wO3Q8dGhpcy5tYXJrZXJzLmxlbmd0aDt0KyspdGhpcy5tYXJrZXJzW3RdLmxpbmU9PT1lJiYodGhpcy5tYXJrZXJzW3RdLmRpc3Bvc2UoKSx0aGlzLm1hcmtlcnMuc3BsaWNlKHQtLSwxKSk7dGhpcy5faXNDbGVhcmluZz0hMX1jbGVhckFsbE1hcmtlcnMoKXt0aGlzLl9pc0NsZWFyaW5nPSEwO2ZvcihsZXQgZT0wO2U8dGhpcy5tYXJrZXJzLmxlbmd0aDtlKyspdGhpcy5tYXJrZXJzW2VdLmRpc3Bvc2UoKSx0aGlzLm1hcmtlcnMuc3BsaWNlKGUtLSwxKTt0aGlzLl9pc0NsZWFyaW5nPSExfWFkZE1hcmtlcihlKXtjb25zdCB0PW5ldyBsLk1hcmtlcihlKTtyZXR1cm4gdGhpcy5tYXJrZXJzLnB1c2godCksdC5yZWdpc3Rlcih0aGlzLmxpbmVzLm9uVHJpbSgoZT0+e3QubGluZS09ZSx0LmxpbmU8MCYmdC5kaXNwb3NlKCl9KSkpLHQucmVnaXN0ZXIodGhpcy5saW5lcy5vbkluc2VydCgoZT0+e3QubGluZT49ZS5pbmRleCYmKHQubGluZSs9ZS5hbW91bnQpfSkpKSx0LnJlZ2lzdGVyKHRoaXMubGluZXMub25EZWxldGUoKGU9Pnt0LmxpbmU+PWUuaW5kZXgmJnQubGluZTxlLmluZGV4K2UuYW1vdW50JiZ0LmRpc3Bvc2UoKSx0LmxpbmU+ZS5pbmRleCYmKHQubGluZS09ZS5hbW91bnQpfSkpKSx0LnJlZ2lzdGVyKHQub25EaXNwb3NlKCgoKT0+dGhpcy5fcmVtb3ZlTWFya2VyKHQpKSkpLHR9X3JlbW92ZU1hcmtlcihlKXt0aGlzLl9pc0NsZWFyaW5nfHx0aGlzLm1hcmtlcnMuc3BsaWNlKHRoaXMubWFya2Vycy5pbmRleE9mKGUpLDEpfX19LDg0Mzc6KGUsdCxpKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuQnVmZmVyTGluZT10LkRFRkFVTFRfQVRUUl9EQVRBPXZvaWQgMDtjb25zdCBzPWkoMzczNCkscj1pKDUxMSksbj1pKDY0Myksbz1pKDQ4Mik7dC5ERUZBVUxUX0FUVFJfREFUQT1PYmplY3QuZnJlZXplKG5ldyBzLkF0dHJpYnV0ZURhdGEpO2xldCBhPTA7Y2xhc3MgaHtjb25zdHJ1Y3RvcihlLHQsaT0hMSl7dGhpcy5pc1dyYXBwZWQ9aSx0aGlzLl9jb21iaW5lZD17fSx0aGlzLl9leHRlbmRlZEF0dHJzPXt9LHRoaXMuX2RhdGE9bmV3IFVpbnQzMkFycmF5KDMqZSk7Y29uc3Qgcz10fHxyLkNlbGxEYXRhLmZyb21DaGFyRGF0YShbMCxuLk5VTExfQ0VMTF9DSEFSLG4uTlVMTF9DRUxMX1dJRFRILG4uTlVMTF9DRUxMX0NPREVdKTtmb3IobGV0IHQ9MDt0PGU7Kyt0KXRoaXMuc2V0Q2VsbCh0LHMpO3RoaXMubGVuZ3RoPWV9Z2V0KGUpe2NvbnN0IHQ9dGhpcy5fZGF0YVszKmUrMF0saT0yMDk3MTUxJnQ7cmV0dXJuW3RoaXMuX2RhdGFbMyplKzFdLDIwOTcxNTImdD90aGlzLl9jb21iaW5lZFtlXTppPygwLG8uc3RyaW5nRnJvbUNvZGVQb2ludCkoaSk6XCJcIix0Pj4yMiwyMDk3MTUyJnQ/dGhpcy5fY29tYmluZWRbZV0uY2hhckNvZGVBdCh0aGlzLl9jb21iaW5lZFtlXS5sZW5ndGgtMSk6aV19c2V0KGUsdCl7dGhpcy5fZGF0YVszKmUrMV09dFtuLkNIQVJfREFUQV9BVFRSX0lOREVYXSx0W24uQ0hBUl9EQVRBX0NIQVJfSU5ERVhdLmxlbmd0aD4xPyh0aGlzLl9jb21iaW5lZFtlXT10WzFdLHRoaXMuX2RhdGFbMyplKzBdPTIwOTcxNTJ8ZXx0W24uQ0hBUl9EQVRBX1dJRFRIX0lOREVYXTw8MjIpOnRoaXMuX2RhdGFbMyplKzBdPXRbbi5DSEFSX0RBVEFfQ0hBUl9JTkRFWF0uY2hhckNvZGVBdCgwKXx0W24uQ0hBUl9EQVRBX1dJRFRIX0lOREVYXTw8MjJ9Z2V0V2lkdGgoZSl7cmV0dXJuIHRoaXMuX2RhdGFbMyplKzBdPj4yMn1oYXNXaWR0aChlKXtyZXR1cm4gMTI1ODI5MTImdGhpcy5fZGF0YVszKmUrMF19Z2V0RmcoZSl7cmV0dXJuIHRoaXMuX2RhdGFbMyplKzFdfWdldEJnKGUpe3JldHVybiB0aGlzLl9kYXRhWzMqZSsyXX1oYXNDb250ZW50KGUpe3JldHVybiA0MTk0MzAzJnRoaXMuX2RhdGFbMyplKzBdfWdldENvZGVQb2ludChlKXtjb25zdCB0PXRoaXMuX2RhdGFbMyplKzBdO3JldHVybiAyMDk3MTUyJnQ/dGhpcy5fY29tYmluZWRbZV0uY2hhckNvZGVBdCh0aGlzLl9jb21iaW5lZFtlXS5sZW5ndGgtMSk6MjA5NzE1MSZ0fWlzQ29tYmluZWQoZSl7cmV0dXJuIDIwOTcxNTImdGhpcy5fZGF0YVszKmUrMF19Z2V0U3RyaW5nKGUpe2NvbnN0IHQ9dGhpcy5fZGF0YVszKmUrMF07cmV0dXJuIDIwOTcxNTImdD90aGlzLl9jb21iaW5lZFtlXToyMDk3MTUxJnQ/KDAsby5zdHJpbmdGcm9tQ29kZVBvaW50KSgyMDk3MTUxJnQpOlwiXCJ9aXNQcm90ZWN0ZWQoZSl7cmV0dXJuIDUzNjg3MDkxMiZ0aGlzLl9kYXRhWzMqZSsyXX1sb2FkQ2VsbChlLHQpe3JldHVybiBhPTMqZSx0LmNvbnRlbnQ9dGhpcy5fZGF0YVthKzBdLHQuZmc9dGhpcy5fZGF0YVthKzFdLHQuYmc9dGhpcy5fZGF0YVthKzJdLDIwOTcxNTImdC5jb250ZW50JiYodC5jb21iaW5lZERhdGE9dGhpcy5fY29tYmluZWRbZV0pLDI2ODQzNTQ1NiZ0LmJnJiYodC5leHRlbmRlZD10aGlzLl9leHRlbmRlZEF0dHJzW2VdKSx0fXNldENlbGwoZSx0KXsyMDk3MTUyJnQuY29udGVudCYmKHRoaXMuX2NvbWJpbmVkW2VdPXQuY29tYmluZWREYXRhKSwyNjg0MzU0NTYmdC5iZyYmKHRoaXMuX2V4dGVuZGVkQXR0cnNbZV09dC5leHRlbmRlZCksdGhpcy5fZGF0YVszKmUrMF09dC5jb250ZW50LHRoaXMuX2RhdGFbMyplKzFdPXQuZmcsdGhpcy5fZGF0YVszKmUrMl09dC5iZ31zZXRDZWxsRnJvbUNvZGVwb2ludChlLHQsaSxzKXsyNjg0MzU0NTYmcy5iZyYmKHRoaXMuX2V4dGVuZGVkQXR0cnNbZV09cy5leHRlbmRlZCksdGhpcy5fZGF0YVszKmUrMF09dHxpPDwyMix0aGlzLl9kYXRhWzMqZSsxXT1zLmZnLHRoaXMuX2RhdGFbMyplKzJdPXMuYmd9YWRkQ29kZXBvaW50VG9DZWxsKGUsdCxpKXtsZXQgcz10aGlzLl9kYXRhWzMqZSswXTsyMDk3MTUyJnM/dGhpcy5fY29tYmluZWRbZV0rPSgwLG8uc3RyaW5nRnJvbUNvZGVQb2ludCkodCk6MjA5NzE1MSZzPyh0aGlzLl9jb21iaW5lZFtlXT0oMCxvLnN0cmluZ0Zyb21Db2RlUG9pbnQpKDIwOTcxNTEmcykrKDAsby5zdHJpbmdGcm9tQ29kZVBvaW50KSh0KSxzJj0tMjA5NzE1MixzfD0yMDk3MTUyKTpzPXR8MTw8MjIsaSYmKHMmPS0xMjU4MjkxMyxzfD1pPDwyMiksdGhpcy5fZGF0YVszKmUrMF09c31pbnNlcnRDZWxscyhlLHQsaSl7aWYoKGUlPXRoaXMubGVuZ3RoKSYmMj09PXRoaXMuZ2V0V2lkdGgoZS0xKSYmdGhpcy5zZXRDZWxsRnJvbUNvZGVwb2ludChlLTEsMCwxLGkpLHQ8dGhpcy5sZW5ndGgtZSl7Y29uc3Qgcz1uZXcgci5DZWxsRGF0YTtmb3IobGV0IGk9dGhpcy5sZW5ndGgtZS10LTE7aT49MDstLWkpdGhpcy5zZXRDZWxsKGUrdCtpLHRoaXMubG9hZENlbGwoZStpLHMpKTtmb3IobGV0IHM9MDtzPHQ7KytzKXRoaXMuc2V0Q2VsbChlK3MsaSl9ZWxzZSBmb3IobGV0IHQ9ZTt0PHRoaXMubGVuZ3RoOysrdCl0aGlzLnNldENlbGwodCxpKTsyPT09dGhpcy5nZXRXaWR0aCh0aGlzLmxlbmd0aC0xKSYmdGhpcy5zZXRDZWxsRnJvbUNvZGVwb2ludCh0aGlzLmxlbmd0aC0xLDAsMSxpKX1kZWxldGVDZWxscyhlLHQsaSl7aWYoZSU9dGhpcy5sZW5ndGgsdDx0aGlzLmxlbmd0aC1lKXtjb25zdCBzPW5ldyByLkNlbGxEYXRhO2ZvcihsZXQgaT0wO2k8dGhpcy5sZW5ndGgtZS10OysraSl0aGlzLnNldENlbGwoZStpLHRoaXMubG9hZENlbGwoZSt0K2kscykpO2ZvcihsZXQgZT10aGlzLmxlbmd0aC10O2U8dGhpcy5sZW5ndGg7KytlKXRoaXMuc2V0Q2VsbChlLGkpfWVsc2UgZm9yKGxldCB0PWU7dDx0aGlzLmxlbmd0aDsrK3QpdGhpcy5zZXRDZWxsKHQsaSk7ZSYmMj09PXRoaXMuZ2V0V2lkdGgoZS0xKSYmdGhpcy5zZXRDZWxsRnJvbUNvZGVwb2ludChlLTEsMCwxLGkpLDAhPT10aGlzLmdldFdpZHRoKGUpfHx0aGlzLmhhc0NvbnRlbnQoZSl8fHRoaXMuc2V0Q2VsbEZyb21Db2RlcG9pbnQoZSwwLDEsaSl9cmVwbGFjZUNlbGxzKGUsdCxpLHM9ITEpe2lmKHMpZm9yKGUmJjI9PT10aGlzLmdldFdpZHRoKGUtMSkmJiF0aGlzLmlzUHJvdGVjdGVkKGUtMSkmJnRoaXMuc2V0Q2VsbEZyb21Db2RlcG9pbnQoZS0xLDAsMSxpKSx0PHRoaXMubGVuZ3RoJiYyPT09dGhpcy5nZXRXaWR0aCh0LTEpJiYhdGhpcy5pc1Byb3RlY3RlZCh0KSYmdGhpcy5zZXRDZWxsRnJvbUNvZGVwb2ludCh0LDAsMSxpKTtlPHQmJmU8dGhpcy5sZW5ndGg7KXRoaXMuaXNQcm90ZWN0ZWQoZSl8fHRoaXMuc2V0Q2VsbChlLGkpLGUrKztlbHNlIGZvcihlJiYyPT09dGhpcy5nZXRXaWR0aChlLTEpJiZ0aGlzLnNldENlbGxGcm9tQ29kZXBvaW50KGUtMSwwLDEsaSksdDx0aGlzLmxlbmd0aCYmMj09PXRoaXMuZ2V0V2lkdGgodC0xKSYmdGhpcy5zZXRDZWxsRnJvbUNvZGVwb2ludCh0LDAsMSxpKTtlPHQmJmU8dGhpcy5sZW5ndGg7KXRoaXMuc2V0Q2VsbChlKyssaSl9cmVzaXplKGUsdCl7aWYoZT09PXRoaXMubGVuZ3RoKXJldHVybiA0KnRoaXMuX2RhdGEubGVuZ3RoKjI8dGhpcy5fZGF0YS5idWZmZXIuYnl0ZUxlbmd0aDtjb25zdCBpPTMqZTtpZihlPnRoaXMubGVuZ3RoKXtpZih0aGlzLl9kYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoPj00KmkpdGhpcy5fZGF0YT1uZXcgVWludDMyQXJyYXkodGhpcy5fZGF0YS5idWZmZXIsMCxpKTtlbHNle2NvbnN0IGU9bmV3IFVpbnQzMkFycmF5KGkpO2Uuc2V0KHRoaXMuX2RhdGEpLHRoaXMuX2RhdGE9ZX1mb3IobGV0IGk9dGhpcy5sZW5ndGg7aTxlOysraSl0aGlzLnNldENlbGwoaSx0KX1lbHNle3RoaXMuX2RhdGE9dGhpcy5fZGF0YS5zdWJhcnJheSgwLGkpO2NvbnN0IHQ9T2JqZWN0LmtleXModGhpcy5fY29tYmluZWQpO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXtjb25zdCBzPXBhcnNlSW50KHRbaV0sMTApO3M+PWUmJmRlbGV0ZSB0aGlzLl9jb21iaW5lZFtzXX1jb25zdCBzPU9iamVjdC5rZXlzKHRoaXMuX2V4dGVuZGVkQXR0cnMpO2ZvcihsZXQgdD0wO3Q8cy5sZW5ndGg7dCsrKXtjb25zdCBpPXBhcnNlSW50KHNbdF0sMTApO2k+PWUmJmRlbGV0ZSB0aGlzLl9leHRlbmRlZEF0dHJzW2ldfX1yZXR1cm4gdGhpcy5sZW5ndGg9ZSw0KmkqMjx0aGlzLl9kYXRhLmJ1ZmZlci5ieXRlTGVuZ3RofWNsZWFudXBNZW1vcnkoKXtpZig0KnRoaXMuX2RhdGEubGVuZ3RoKjI8dGhpcy5fZGF0YS5idWZmZXIuYnl0ZUxlbmd0aCl7Y29uc3QgZT1uZXcgVWludDMyQXJyYXkodGhpcy5fZGF0YS5sZW5ndGgpO3JldHVybiBlLnNldCh0aGlzLl9kYXRhKSx0aGlzLl9kYXRhPWUsMX1yZXR1cm4gMH1maWxsKGUsdD0hMSl7aWYodClmb3IobGV0IHQ9MDt0PHRoaXMubGVuZ3RoOysrdCl0aGlzLmlzUHJvdGVjdGVkKHQpfHx0aGlzLnNldENlbGwodCxlKTtlbHNle3RoaXMuX2NvbWJpbmVkPXt9LHRoaXMuX2V4dGVuZGVkQXR0cnM9e307Zm9yKGxldCB0PTA7dDx0aGlzLmxlbmd0aDsrK3QpdGhpcy5zZXRDZWxsKHQsZSl9fWNvcHlGcm9tKGUpe3RoaXMubGVuZ3RoIT09ZS5sZW5ndGg/dGhpcy5fZGF0YT1uZXcgVWludDMyQXJyYXkoZS5fZGF0YSk6dGhpcy5fZGF0YS5zZXQoZS5fZGF0YSksdGhpcy5sZW5ndGg9ZS5sZW5ndGgsdGhpcy5fY29tYmluZWQ9e307Zm9yKGNvbnN0IHQgaW4gZS5fY29tYmluZWQpdGhpcy5fY29tYmluZWRbdF09ZS5fY29tYmluZWRbdF07dGhpcy5fZXh0ZW5kZWRBdHRycz17fTtmb3IoY29uc3QgdCBpbiBlLl9leHRlbmRlZEF0dHJzKXRoaXMuX2V4dGVuZGVkQXR0cnNbdF09ZS5fZXh0ZW5kZWRBdHRyc1t0XTt0aGlzLmlzV3JhcHBlZD1lLmlzV3JhcHBlZH1jbG9uZSgpe2NvbnN0IGU9bmV3IGgoMCk7ZS5fZGF0YT1uZXcgVWludDMyQXJyYXkodGhpcy5fZGF0YSksZS5sZW5ndGg9dGhpcy5sZW5ndGg7Zm9yKGNvbnN0IHQgaW4gdGhpcy5fY29tYmluZWQpZS5fY29tYmluZWRbdF09dGhpcy5fY29tYmluZWRbdF07Zm9yKGNvbnN0IHQgaW4gdGhpcy5fZXh0ZW5kZWRBdHRycyllLl9leHRlbmRlZEF0dHJzW3RdPXRoaXMuX2V4dGVuZGVkQXR0cnNbdF07cmV0dXJuIGUuaXNXcmFwcGVkPXRoaXMuaXNXcmFwcGVkLGV9Z2V0VHJpbW1lZExlbmd0aCgpe2ZvcihsZXQgZT10aGlzLmxlbmd0aC0xO2U+PTA7LS1lKWlmKDQxOTQzMDMmdGhpcy5fZGF0YVszKmUrMF0pcmV0dXJuIGUrKHRoaXMuX2RhdGFbMyplKzBdPj4yMik7cmV0dXJuIDB9Z2V0Tm9CZ1RyaW1tZWRMZW5ndGgoKXtmb3IobGV0IGU9dGhpcy5sZW5ndGgtMTtlPj0wOy0tZSlpZig0MTk0MzAzJnRoaXMuX2RhdGFbMyplKzBdfHw1MDMzMTY0OCZ0aGlzLl9kYXRhWzMqZSsyXSlyZXR1cm4gZSsodGhpcy5fZGF0YVszKmUrMF0+PjIyKTtyZXR1cm4gMH1jb3B5Q2VsbHNGcm9tKGUsdCxpLHMscil7Y29uc3Qgbj1lLl9kYXRhO2lmKHIpZm9yKGxldCByPXMtMTtyPj0wO3ItLSl7Zm9yKGxldCBlPTA7ZTwzO2UrKyl0aGlzLl9kYXRhWzMqKGkrcikrZV09blszKih0K3IpK2VdOzI2ODQzNTQ1NiZuWzMqKHQrcikrMl0mJih0aGlzLl9leHRlbmRlZEF0dHJzW2krcl09ZS5fZXh0ZW5kZWRBdHRyc1t0K3JdKX1lbHNlIGZvcihsZXQgcj0wO3I8cztyKyspe2ZvcihsZXQgZT0wO2U8MztlKyspdGhpcy5fZGF0YVszKihpK3IpK2VdPW5bMyoodCtyKStlXTsyNjg0MzU0NTYmblszKih0K3IpKzJdJiYodGhpcy5fZXh0ZW5kZWRBdHRyc1tpK3JdPWUuX2V4dGVuZGVkQXR0cnNbdCtyXSl9Y29uc3Qgbz1PYmplY3Qua2V5cyhlLl9jb21iaW5lZCk7Zm9yKGxldCBzPTA7czxvLmxlbmd0aDtzKyspe2NvbnN0IHI9cGFyc2VJbnQob1tzXSwxMCk7cj49dCYmKHRoaXMuX2NvbWJpbmVkW3ItdCtpXT1lLl9jb21iaW5lZFtyXSl9fXRyYW5zbGF0ZVRvU3RyaW5nKGUsdCxpLHMpe3Q9dD8/MCxpPWk/P3RoaXMubGVuZ3RoLGUmJihpPU1hdGgubWluKGksdGhpcy5nZXRUcmltbWVkTGVuZ3RoKCkpKSxzJiYocy5sZW5ndGg9MCk7bGV0IHI9XCJcIjtmb3IoO3Q8aTspe2NvbnN0IGU9dGhpcy5fZGF0YVszKnQrMF0saT0yMDk3MTUxJmUsYT0yMDk3MTUyJmU/dGhpcy5fY29tYmluZWRbdF06aT8oMCxvLnN0cmluZ0Zyb21Db2RlUG9pbnQpKGkpOm4uV0hJVEVTUEFDRV9DRUxMX0NIQVI7aWYocis9YSxzKWZvcihsZXQgZT0wO2U8YS5sZW5ndGg7KytlKXMucHVzaCh0KTt0Kz1lPj4yMnx8MX1yZXR1cm4gcyYmcy5wdXNoKHQpLHJ9fXQuQnVmZmVyTGluZT1ofSw0ODQxOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRSYW5nZUxlbmd0aD12b2lkIDAsdC5nZXRSYW5nZUxlbmd0aD1mdW5jdGlvbihlLHQpe2lmKGUuc3RhcnQueT5lLmVuZC55KXRocm93IG5ldyBFcnJvcihgQnVmZmVyIHJhbmdlIGVuZCAoJHtlLmVuZC54fSwgJHtlLmVuZC55fSkgY2Fubm90IGJlIGJlZm9yZSBzdGFydCAoJHtlLnN0YXJ0Lnh9LCAke2Uuc3RhcnQueX0pYCk7cmV0dXJuIHQqKGUuZW5kLnktZS5zdGFydC55KSsoZS5lbmQueC1lLnN0YXJ0LngrMSl9fSw0NjM0OihlLHQpPT57ZnVuY3Rpb24gaShlLHQsaSl7aWYodD09PWUubGVuZ3RoLTEpcmV0dXJuIGVbdF0uZ2V0VHJpbW1lZExlbmd0aCgpO2NvbnN0IHM9IWVbdF0uaGFzQ29udGVudChpLTEpJiYxPT09ZVt0XS5nZXRXaWR0aChpLTEpLHI9Mj09PWVbdCsxXS5nZXRXaWR0aCgwKTtyZXR1cm4gcyYmcj9pLTE6aX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldFdyYXBwZWRMaW5lVHJpbW1lZExlbmd0aD10LnJlZmxvd1NtYWxsZXJHZXROZXdMaW5lTGVuZ3Rocz10LnJlZmxvd0xhcmdlckFwcGx5TmV3TGF5b3V0PXQucmVmbG93TGFyZ2VyQ3JlYXRlTmV3TGF5b3V0PXQucmVmbG93TGFyZ2VyR2V0TGluZXNUb1JlbW92ZT12b2lkIDAsdC5yZWZsb3dMYXJnZXJHZXRMaW5lc1RvUmVtb3ZlPWZ1bmN0aW9uKGUsdCxzLHIsbil7Y29uc3Qgbz1bXTtmb3IobGV0IGE9MDthPGUubGVuZ3RoLTE7YSsrKXtsZXQgaD1hLGM9ZS5nZXQoKytoKTtpZighYy5pc1dyYXBwZWQpY29udGludWU7Y29uc3QgbD1bZS5nZXQoYSldO2Zvcig7aDxlLmxlbmd0aCYmYy5pc1dyYXBwZWQ7KWwucHVzaChjKSxjPWUuZ2V0KCsraCk7aWYocj49YSYmcjxoKXthKz1sLmxlbmd0aC0xO2NvbnRpbnVlfWxldCBkPTAsXz1pKGwsZCx0KSx1PTEsZj0wO2Zvcig7dTxsLmxlbmd0aDspe2NvbnN0IGU9aShsLHUsdCkscj1lLWYsbz1zLV8sYT1NYXRoLm1pbihyLG8pO2xbZF0uY29weUNlbGxzRnJvbShsW3VdLGYsXyxhLCExKSxfKz1hLF89PT1zJiYoZCsrLF89MCksZis9YSxmPT09ZSYmKHUrKyxmPTApLDA9PT1fJiYwIT09ZCYmMj09PWxbZC0xXS5nZXRXaWR0aChzLTEpJiYobFtkXS5jb3B5Q2VsbHNGcm9tKGxbZC0xXSxzLTEsXysrLDEsITEpLGxbZC0xXS5zZXRDZWxsKHMtMSxuKSl9bFtkXS5yZXBsYWNlQ2VsbHMoXyxzLG4pO2xldCB2PTA7Zm9yKGxldCBlPWwubGVuZ3RoLTE7ZT4wJiYoZT5kfHwwPT09bFtlXS5nZXRUcmltbWVkTGVuZ3RoKCkpO2UtLSl2Kys7dj4wJiYoby5wdXNoKGErbC5sZW5ndGgtdiksby5wdXNoKHYpKSxhKz1sLmxlbmd0aC0xfXJldHVybiBvfSx0LnJlZmxvd0xhcmdlckNyZWF0ZU5ld0xheW91dD1mdW5jdGlvbihlLHQpe2NvbnN0IGk9W107bGV0IHM9MCxyPXRbc10sbj0wO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7bysrKWlmKHI9PT1vKXtjb25zdCBpPXRbKytzXTtlLm9uRGVsZXRlRW1pdHRlci5maXJlKHtpbmRleDpvLW4sYW1vdW50Oml9KSxvKz1pLTEsbis9aSxyPXRbKytzXX1lbHNlIGkucHVzaChvKTtyZXR1cm57bGF5b3V0OmksY291bnRSZW1vdmVkOm59fSx0LnJlZmxvd0xhcmdlckFwcGx5TmV3TGF5b3V0PWZ1bmN0aW9uKGUsdCl7Y29uc3QgaT1bXTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKylpLnB1c2goZS5nZXQodFtzXSkpO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGg7dCsrKWUuc2V0KHQsaVt0XSk7ZS5sZW5ndGg9dC5sZW5ndGh9LHQucmVmbG93U21hbGxlckdldE5ld0xpbmVMZW5ndGhzPWZ1bmN0aW9uKGUsdCxzKXtjb25zdCByPVtdLG49ZS5tYXAoKChzLHIpPT5pKGUscix0KSkpLnJlZHVjZSgoKGUsdCk9PmUrdCkpO2xldCBvPTAsYT0wLGg9MDtmb3IoO2g8bjspe2lmKG4taDxzKXtyLnB1c2gobi1oKTticmVha31vKz1zO2NvbnN0IGM9aShlLGEsdCk7bz5jJiYoby09YyxhKyspO2NvbnN0IGw9Mj09PWVbYV0uZ2V0V2lkdGgoby0xKTtsJiZvLS07Y29uc3QgZD1sP3MtMTpzO3IucHVzaChkKSxoKz1kfXJldHVybiByfSx0LmdldFdyYXBwZWRMaW5lVHJpbW1lZExlbmd0aD1pfSw1Mjk1OihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkJ1ZmZlclNldD12b2lkIDA7Y29uc3Qgcz1pKDg0NjApLHI9aSg4NDQpLG49aSg5MDkyKTtjbGFzcyBvIGV4dGVuZHMgci5EaXNwb3NhYmxle2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSx0aGlzLl9vcHRpb25zU2VydmljZT1lLHRoaXMuX2J1ZmZlclNlcnZpY2U9dCx0aGlzLl9vbkJ1ZmZlckFjdGl2YXRlPXRoaXMucmVnaXN0ZXIobmV3IHMuRXZlbnRFbWl0dGVyKSx0aGlzLm9uQnVmZmVyQWN0aXZhdGU9dGhpcy5fb25CdWZmZXJBY3RpdmF0ZS5ldmVudCx0aGlzLnJlc2V0KCksdGhpcy5yZWdpc3Rlcih0aGlzLl9vcHRpb25zU2VydmljZS5vblNwZWNpZmljT3B0aW9uQ2hhbmdlKFwic2Nyb2xsYmFja1wiLCgoKT0+dGhpcy5yZXNpemUodGhpcy5fYnVmZmVyU2VydmljZS5jb2xzLHRoaXMuX2J1ZmZlclNlcnZpY2Uucm93cykpKSksdGhpcy5yZWdpc3Rlcih0aGlzLl9vcHRpb25zU2VydmljZS5vblNwZWNpZmljT3B0aW9uQ2hhbmdlKFwidGFiU3RvcFdpZHRoXCIsKCgpPT50aGlzLnNldHVwVGFiU3RvcHMoKSkpKX1yZXNldCgpe3RoaXMuX25vcm1hbD1uZXcgbi5CdWZmZXIoITAsdGhpcy5fb3B0aW9uc1NlcnZpY2UsdGhpcy5fYnVmZmVyU2VydmljZSksdGhpcy5fbm9ybWFsLmZpbGxWaWV3cG9ydFJvd3MoKSx0aGlzLl9hbHQ9bmV3IG4uQnVmZmVyKCExLHRoaXMuX29wdGlvbnNTZXJ2aWNlLHRoaXMuX2J1ZmZlclNlcnZpY2UpLHRoaXMuX2FjdGl2ZUJ1ZmZlcj10aGlzLl9ub3JtYWwsdGhpcy5fb25CdWZmZXJBY3RpdmF0ZS5maXJlKHthY3RpdmVCdWZmZXI6dGhpcy5fbm9ybWFsLGluYWN0aXZlQnVmZmVyOnRoaXMuX2FsdH0pLHRoaXMuc2V0dXBUYWJTdG9wcygpfWdldCBhbHQoKXtyZXR1cm4gdGhpcy5fYWx0fWdldCBhY3RpdmUoKXtyZXR1cm4gdGhpcy5fYWN0aXZlQnVmZmVyfWdldCBub3JtYWwoKXtyZXR1cm4gdGhpcy5fbm9ybWFsfWFjdGl2YXRlTm9ybWFsQnVmZmVyKCl7dGhpcy5fYWN0aXZlQnVmZmVyIT09dGhpcy5fbm9ybWFsJiYodGhpcy5fbm9ybWFsLng9dGhpcy5fYWx0LngsdGhpcy5fbm9ybWFsLnk9dGhpcy5fYWx0LnksdGhpcy5fYWx0LmNsZWFyQWxsTWFya2VycygpLHRoaXMuX2FsdC5jbGVhcigpLHRoaXMuX2FjdGl2ZUJ1ZmZlcj10aGlzLl9ub3JtYWwsdGhpcy5fb25CdWZmZXJBY3RpdmF0ZS5maXJlKHthY3RpdmVCdWZmZXI6dGhpcy5fbm9ybWFsLGluYWN0aXZlQnVmZmVyOnRoaXMuX2FsdH0pKX1hY3RpdmF0ZUFsdEJ1ZmZlcihlKXt0aGlzLl9hY3RpdmVCdWZmZXIhPT10aGlzLl9hbHQmJih0aGlzLl9hbHQuZmlsbFZpZXdwb3J0Um93cyhlKSx0aGlzLl9hbHQueD10aGlzLl9ub3JtYWwueCx0aGlzLl9hbHQueT10aGlzLl9ub3JtYWwueSx0aGlzLl9hY3RpdmVCdWZmZXI9dGhpcy5fYWx0LHRoaXMuX29uQnVmZmVyQWN0aXZhdGUuZmlyZSh7YWN0aXZlQnVmZmVyOnRoaXMuX2FsdCxpbmFjdGl2ZUJ1ZmZlcjp0aGlzLl9ub3JtYWx9KSl9cmVzaXplKGUsdCl7dGhpcy5fbm9ybWFsLnJlc2l6ZShlLHQpLHRoaXMuX2FsdC5yZXNpemUoZSx0KSx0aGlzLnNldHVwVGFiU3RvcHMoZSl9c2V0dXBUYWJTdG9wcyhlKXt0aGlzLl9ub3JtYWwuc2V0dXBUYWJTdG9wcyhlKSx0aGlzLl9hbHQuc2V0dXBUYWJTdG9wcyhlKX19dC5CdWZmZXJTZXQ9b30sNTExOihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkNlbGxEYXRhPXZvaWQgMDtjb25zdCBzPWkoNDgyKSxyPWkoNjQzKSxuPWkoMzczNCk7Y2xhc3MgbyBleHRlbmRzIG4uQXR0cmlidXRlRGF0YXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5jb250ZW50PTAsdGhpcy5mZz0wLHRoaXMuYmc9MCx0aGlzLmV4dGVuZGVkPW5ldyBuLkV4dGVuZGVkQXR0cnMsdGhpcy5jb21iaW5lZERhdGE9XCJcIn1zdGF0aWMgZnJvbUNoYXJEYXRhKGUpe2NvbnN0IHQ9bmV3IG87cmV0dXJuIHQuc2V0RnJvbUNoYXJEYXRhKGUpLHR9aXNDb21iaW5lZCgpe3JldHVybiAyMDk3MTUyJnRoaXMuY29udGVudH1nZXRXaWR0aCgpe3JldHVybiB0aGlzLmNvbnRlbnQ+PjIyfWdldENoYXJzKCl7cmV0dXJuIDIwOTcxNTImdGhpcy5jb250ZW50P3RoaXMuY29tYmluZWREYXRhOjIwOTcxNTEmdGhpcy5jb250ZW50PygwLHMuc3RyaW5nRnJvbUNvZGVQb2ludCkoMjA5NzE1MSZ0aGlzLmNvbnRlbnQpOlwiXCJ9Z2V0Q29kZSgpe3JldHVybiB0aGlzLmlzQ29tYmluZWQoKT90aGlzLmNvbWJpbmVkRGF0YS5jaGFyQ29kZUF0KHRoaXMuY29tYmluZWREYXRhLmxlbmd0aC0xKToyMDk3MTUxJnRoaXMuY29udGVudH1zZXRGcm9tQ2hhckRhdGEoZSl7dGhpcy5mZz1lW3IuQ0hBUl9EQVRBX0FUVFJfSU5ERVhdLHRoaXMuYmc9MDtsZXQgdD0hMTtpZihlW3IuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdLmxlbmd0aD4yKXQ9ITA7ZWxzZSBpZigyPT09ZVtyLkNIQVJfREFUQV9DSEFSX0lOREVYXS5sZW5ndGgpe2NvbnN0IGk9ZVtyLkNIQVJfREFUQV9DSEFSX0lOREVYXS5jaGFyQ29kZUF0KDApO2lmKDU1Mjk2PD1pJiZpPD01NjMxOSl7Y29uc3Qgcz1lW3IuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdLmNoYXJDb2RlQXQoMSk7NTYzMjA8PXMmJnM8PTU3MzQzP3RoaXMuY29udGVudD0xMDI0KihpLTU1Mjk2KStzLTU2MzIwKzY1NTM2fGVbci5DSEFSX0RBVEFfV0lEVEhfSU5ERVhdPDwyMjp0PSEwfWVsc2UgdD0hMH1lbHNlIHRoaXMuY29udGVudD1lW3IuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdLmNoYXJDb2RlQXQoMCl8ZVtyLkNIQVJfREFUQV9XSURUSF9JTkRFWF08PDIyO3QmJih0aGlzLmNvbWJpbmVkRGF0YT1lW3IuQ0hBUl9EQVRBX0NIQVJfSU5ERVhdLHRoaXMuY29udGVudD0yMDk3MTUyfGVbci5DSEFSX0RBVEFfV0lEVEhfSU5ERVhdPDwyMil9Z2V0QXNDaGFyRGF0YSgpe3JldHVyblt0aGlzLmZnLHRoaXMuZ2V0Q2hhcnMoKSx0aGlzLmdldFdpZHRoKCksdGhpcy5nZXRDb2RlKCldfX10LkNlbGxEYXRhPW99LDY0MzooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuV0hJVEVTUEFDRV9DRUxMX0NPREU9dC5XSElURVNQQUNFX0NFTExfV0lEVEg9dC5XSElURVNQQUNFX0NFTExfQ0hBUj10Lk5VTExfQ0VMTF9DT0RFPXQuTlVMTF9DRUxMX1dJRFRIPXQuTlVMTF9DRUxMX0NIQVI9dC5DSEFSX0RBVEFfQ09ERV9JTkRFWD10LkNIQVJfREFUQV9XSURUSF9JTkRFWD10LkNIQVJfREFUQV9DSEFSX0lOREVYPXQuQ0hBUl9EQVRBX0FUVFJfSU5ERVg9dC5ERUZBVUxUX0VYVD10LkRFRkFVTFRfQVRUUj10LkRFRkFVTFRfQ09MT1I9dm9pZCAwLHQuREVGQVVMVF9DT0xPUj0wLHQuREVGQVVMVF9BVFRSPTI1Nnx0LkRFRkFVTFRfQ09MT1I8PDksdC5ERUZBVUxUX0VYVD0wLHQuQ0hBUl9EQVRBX0FUVFJfSU5ERVg9MCx0LkNIQVJfREFUQV9DSEFSX0lOREVYPTEsdC5DSEFSX0RBVEFfV0lEVEhfSU5ERVg9Mix0LkNIQVJfREFUQV9DT0RFX0lOREVYPTMsdC5OVUxMX0NFTExfQ0hBUj1cIlwiLHQuTlVMTF9DRUxMX1dJRFRIPTEsdC5OVUxMX0NFTExfQ09ERT0wLHQuV0hJVEVTUEFDRV9DRUxMX0NIQVI9XCIgXCIsdC5XSElURVNQQUNFX0NFTExfV0lEVEg9MSx0LldISVRFU1BBQ0VfQ0VMTF9DT0RFPTMyfSw0ODYzOihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1hcmtlcj12b2lkIDA7Y29uc3Qgcz1pKDg0NjApLHI9aSg4NDQpO2NsYXNzIG57Z2V0IGlkKCl7cmV0dXJuIHRoaXMuX2lkfWNvbnN0cnVjdG9yKGUpe3RoaXMubGluZT1lLHRoaXMuaXNEaXNwb3NlZD0hMSx0aGlzLl9kaXNwb3NhYmxlcz1bXSx0aGlzLl9pZD1uLl9uZXh0SWQrKyx0aGlzLl9vbkRpc3Bvc2U9dGhpcy5yZWdpc3RlcihuZXcgcy5FdmVudEVtaXR0ZXIpLHRoaXMub25EaXNwb3NlPXRoaXMuX29uRGlzcG9zZS5ldmVudH1kaXNwb3NlKCl7dGhpcy5pc0Rpc3Bvc2VkfHwodGhpcy5pc0Rpc3Bvc2VkPSEwLHRoaXMubGluZT0tMSx0aGlzLl9vbkRpc3Bvc2UuZmlyZSgpLCgwLHIuZGlzcG9zZUFycmF5KSh0aGlzLl9kaXNwb3NhYmxlcyksdGhpcy5fZGlzcG9zYWJsZXMubGVuZ3RoPTApfXJlZ2lzdGVyKGUpe3JldHVybiB0aGlzLl9kaXNwb3NhYmxlcy5wdXNoKGUpLGV9fXQuTWFya2VyPW4sbi5fbmV4dElkPTF9LDcxMTY6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkRFRkFVTFRfQ0hBUlNFVD10LkNIQVJTRVRTPXZvaWQgMCx0LkNIQVJTRVRTPXt9LHQuREVGQVVMVF9DSEFSU0VUPXQuQ0hBUlNFVFMuQix0LkNIQVJTRVRTWzBdPXtcImBcIjpcIuKXhlwiLGE6XCLilpJcIixiOlwi4pCJXCIsYzpcIuKQjFwiLGQ6XCLikI1cIixlOlwi4pCKXCIsZjpcIsKwXCIsZzpcIsKxXCIsaDpcIuKQpFwiLGk6XCLikItcIixqOlwi4pSYXCIsazpcIuKUkFwiLGw6XCLilIxcIixtOlwi4pSUXCIsbjpcIuKUvFwiLG86XCLijrpcIixwOlwi4o67XCIscTpcIuKUgFwiLHI6XCLijrxcIixzOlwi4o69XCIsdDpcIuKUnFwiLHU6XCLilKRcIix2Olwi4pS0XCIsdzpcIuKUrFwiLHg6XCLilIJcIix5Olwi4omkXCIsejpcIuKJpVwiLFwie1wiOlwiz4BcIixcInxcIjpcIuKJoFwiLFwifVwiOlwiwqNcIixcIn5cIjpcIsK3XCJ9LHQuQ0hBUlNFVFMuQT17XCIjXCI6XCLCo1wifSx0LkNIQVJTRVRTLkI9dm9pZCAwLHQuQ0hBUlNFVFNbNF09e1wiI1wiOlwiwqNcIixcIkBcIjpcIsK+XCIsXCJbXCI6XCJpalwiLFwiXFxcXFwiOlwiwr1cIixcIl1cIjpcInxcIixcIntcIjpcIsKoXCIsXCJ8XCI6XCJmXCIsXCJ9XCI6XCLCvFwiLFwiflwiOlwiwrRcIn0sdC5DSEFSU0VUUy5DPXQuQ0hBUlNFVFNbNV09e1wiW1wiOlwiw4RcIixcIlxcXFxcIjpcIsOWXCIsXCJdXCI6XCLDhVwiLFwiXlwiOlwiw5xcIixcImBcIjpcIsOpXCIsXCJ7XCI6XCLDpFwiLFwifFwiOlwiw7ZcIixcIn1cIjpcIsOlXCIsXCJ+XCI6XCLDvFwifSx0LkNIQVJTRVRTLlI9e1wiI1wiOlwiwqNcIixcIkBcIjpcIsOgXCIsXCJbXCI6XCLCsFwiLFwiXFxcXFwiOlwiw6dcIixcIl1cIjpcIsKnXCIsXCJ7XCI6XCLDqVwiLFwifFwiOlwiw7lcIixcIn1cIjpcIsOoXCIsXCJ+XCI6XCLCqFwifSx0LkNIQVJTRVRTLlE9e1wiQFwiOlwiw6BcIixcIltcIjpcIsOiXCIsXCJcXFxcXCI6XCLDp1wiLFwiXVwiOlwiw6pcIixcIl5cIjpcIsOuXCIsXCJgXCI6XCLDtFwiLFwie1wiOlwiw6lcIixcInxcIjpcIsO5XCIsXCJ9XCI6XCLDqFwiLFwiflwiOlwiw7tcIn0sdC5DSEFSU0VUUy5LPXtcIkBcIjpcIsKnXCIsXCJbXCI6XCLDhFwiLFwiXFxcXFwiOlwiw5ZcIixcIl1cIjpcIsOcXCIsXCJ7XCI6XCLDpFwiLFwifFwiOlwiw7ZcIixcIn1cIjpcIsO8XCIsXCJ+XCI6XCLDn1wifSx0LkNIQVJTRVRTLlk9e1wiI1wiOlwiwqNcIixcIkBcIjpcIsKnXCIsXCJbXCI6XCLCsFwiLFwiXFxcXFwiOlwiw6dcIixcIl1cIjpcIsOpXCIsXCJgXCI6XCLDuVwiLFwie1wiOlwiw6BcIixcInxcIjpcIsOyXCIsXCJ9XCI6XCLDqFwiLFwiflwiOlwiw6xcIn0sdC5DSEFSU0VUUy5FPXQuQ0hBUlNFVFNbNl09e1wiQFwiOlwiw4RcIixcIltcIjpcIsOGXCIsXCJcXFxcXCI6XCLDmFwiLFwiXVwiOlwiw4VcIixcIl5cIjpcIsOcXCIsXCJgXCI6XCLDpFwiLFwie1wiOlwiw6ZcIixcInxcIjpcIsO4XCIsXCJ9XCI6XCLDpVwiLFwiflwiOlwiw7xcIn0sdC5DSEFSU0VUUy5aPXtcIiNcIjpcIsKjXCIsXCJAXCI6XCLCp1wiLFwiW1wiOlwiwqFcIixcIlxcXFxcIjpcIsORXCIsXCJdXCI6XCLCv1wiLFwie1wiOlwiwrBcIixcInxcIjpcIsOxXCIsXCJ9XCI6XCLDp1wifSx0LkNIQVJTRVRTLkg9dC5DSEFSU0VUU1s3XT17XCJAXCI6XCLDiVwiLFwiW1wiOlwiw4RcIixcIlxcXFxcIjpcIsOWXCIsXCJdXCI6XCLDhVwiLFwiXlwiOlwiw5xcIixcImBcIjpcIsOpXCIsXCJ7XCI6XCLDpFwiLFwifFwiOlwiw7ZcIixcIn1cIjpcIsOlXCIsXCJ+XCI6XCLDvFwifSx0LkNIQVJTRVRTW1wiPVwiXT17XCIjXCI6XCLDuVwiLFwiQFwiOlwiw6BcIixcIltcIjpcIsOpXCIsXCJcXFxcXCI6XCLDp1wiLFwiXVwiOlwiw6pcIixcIl5cIjpcIsOuXCIsXzpcIsOoXCIsXCJgXCI6XCLDtFwiLFwie1wiOlwiw6RcIixcInxcIjpcIsO2XCIsXCJ9XCI6XCLDvFwiLFwiflwiOlwiw7tcIn19LDI1ODQ6KGUsdCk9Pnt2YXIgaSxzLHI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5DMV9FU0NBUEVEPXQuQzE9dC5DMD12b2lkIDAsZnVuY3Rpb24oZSl7ZS5OVUw9XCJcXDBcIixlLlNPSD1cIlx1MDAwMVwiLGUuU1RYPVwiXHUwMDAyXCIsZS5FVFg9XCJcdTAwMDNcIixlLkVPVD1cIlx1MDAwNFwiLGUuRU5RPVwiXHUwMDA1XCIsZS5BQ0s9XCJcdTAwMDZcIixlLkJFTD1cIlx1MDAwN1wiLGUuQlM9XCJcXGJcIixlLkhUPVwiXFx0XCIsZS5MRj1cIlxcblwiLGUuVlQ9XCJcXHZcIixlLkZGPVwiXFxmXCIsZS5DUj1cIlxcclwiLGUuU089XCJcdTAwMGVcIixlLlNJPVwiXHUwMDBmXCIsZS5ETEU9XCJcdTAwMTBcIixlLkRDMT1cIlx1MDAxMVwiLGUuREMyPVwiXHUwMDEyXCIsZS5EQzM9XCJcdTAwMTNcIixlLkRDND1cIlx1MDAxNFwiLGUuTkFLPVwiXHUwMDE1XCIsZS5TWU49XCJcdTAwMTZcIixlLkVUQj1cIlx1MDAxN1wiLGUuQ0FOPVwiXHUwMDE4XCIsZS5FTT1cIlx1MDAxOVwiLGUuU1VCPVwiXHUwMDFhXCIsZS5FU0M9XCJcdTAwMWJcIixlLkZTPVwiXHUwMDFjXCIsZS5HUz1cIlx1MDAxZFwiLGUuUlM9XCJcdTAwMWVcIixlLlVTPVwiXHUwMDFmXCIsZS5TUD1cIiBcIixlLkRFTD1cIn9cIn0oaXx8KHQuQzA9aT17fSkpLGZ1bmN0aW9uKGUpe2UuUEFEPVwiwoBcIixlLkhPUD1cIsKBXCIsZS5CUEg9XCLCglwiLGUuTkJIPVwiwoNcIixlLklORD1cIsKEXCIsZS5ORUw9XCLChVwiLGUuU1NBPVwiwoZcIixlLkVTQT1cIsKHXCIsZS5IVFM9XCLCiFwiLGUuSFRKPVwiwolcIixlLlZUUz1cIsKKXCIsZS5QTEQ9XCLCi1wiLGUuUExVPVwiwoxcIixlLlJJPVwiwo1cIixlLlNTMj1cIsKOXCIsZS5TUzM9XCLCj1wiLGUuRENTPVwiwpBcIixlLlBVMT1cIsKRXCIsZS5QVTI9XCLCklwiLGUuU1RTPVwiwpNcIixlLkNDSD1cIsKUXCIsZS5NVz1cIsKVXCIsZS5TUEE9XCLCllwiLGUuRVBBPVwiwpdcIixlLlNPUz1cIsKYXCIsZS5TR0NJPVwiwplcIixlLlNDST1cIsKaXCIsZS5DU0k9XCLCm1wiLGUuU1Q9XCLCnFwiLGUuT1NDPVwiwp1cIixlLlBNPVwiwp5cIixlLkFQQz1cIsKfXCJ9KHN8fCh0LkMxPXM9e30pKSxmdW5jdGlvbihlKXtlLlNUPWAke2kuRVNDfVxcXFxgfShyfHwodC5DMV9FU0NBUEVEPXI9e30pKX0sNzM5OTooZSx0LGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5ldmFsdWF0ZUtleWJvYXJkRXZlbnQ9dm9pZCAwO2NvbnN0IHM9aSgyNTg0KSxyPXs0ODpbXCIwXCIsXCIpXCJdLDQ5OltcIjFcIixcIiFcIl0sNTA6W1wiMlwiLFwiQFwiXSw1MTpbXCIzXCIsXCIjXCJdLDUyOltcIjRcIixcIiRcIl0sNTM6W1wiNVwiLFwiJVwiXSw1NDpbXCI2XCIsXCJeXCJdLDU1OltcIjdcIixcIiZcIl0sNTY6W1wiOFwiLFwiKlwiXSw1NzpbXCI5XCIsXCIoXCJdLDE4NjpbXCI7XCIsXCI6XCJdLDE4NzpbXCI9XCIsXCIrXCJdLDE4ODpbXCIsXCIsXCI8XCJdLDE4OTpbXCItXCIsXCJfXCJdLDE5MDpbXCIuXCIsXCI+XCJdLDE5MTpbXCIvXCIsXCI/XCJdLDE5MjpbXCJgXCIsXCJ+XCJdLDIxOTpbXCJbXCIsXCJ7XCJdLDIyMDpbXCJcXFxcXCIsXCJ8XCJdLDIyMTpbXCJdXCIsXCJ9XCJdLDIyMjpbXCInXCIsJ1wiJ119O3QuZXZhbHVhdGVLZXlib2FyZEV2ZW50PWZ1bmN0aW9uKGUsdCxpLG4pe2NvbnN0IG89e3R5cGU6MCxjYW5jZWw6ITEsa2V5OnZvaWQgMH0sYT0oZS5zaGlmdEtleT8xOjApfChlLmFsdEtleT8yOjApfChlLmN0cmxLZXk/NDowKXwoZS5tZXRhS2V5Pzg6MCk7c3dpdGNoKGUua2V5Q29kZSl7Y2FzZSAwOlwiVUlLZXlJbnB1dFVwQXJyb3dcIj09PWUua2V5P28ua2V5PXQ/cy5DMC5FU0MrXCJPQVwiOnMuQzAuRVNDK1wiW0FcIjpcIlVJS2V5SW5wdXRMZWZ0QXJyb3dcIj09PWUua2V5P28ua2V5PXQ/cy5DMC5FU0MrXCJPRFwiOnMuQzAuRVNDK1wiW0RcIjpcIlVJS2V5SW5wdXRSaWdodEFycm93XCI9PT1lLmtleT9vLmtleT10P3MuQzAuRVNDK1wiT0NcIjpzLkMwLkVTQytcIltDXCI6XCJVSUtleUlucHV0RG93bkFycm93XCI9PT1lLmtleSYmKG8ua2V5PXQ/cy5DMC5FU0MrXCJPQlwiOnMuQzAuRVNDK1wiW0JcIik7YnJlYWs7Y2FzZSA4Om8ua2V5PWUuY3RybEtleT9cIlxcYlwiOnMuQzAuREVMLGUuYWx0S2V5JiYoby5rZXk9cy5DMC5FU0Mrby5rZXkpO2JyZWFrO2Nhc2UgOTppZihlLnNoaWZ0S2V5KXtvLmtleT1zLkMwLkVTQytcIltaXCI7YnJlYWt9by5rZXk9cy5DMC5IVCxvLmNhbmNlbD0hMDticmVhaztjYXNlIDEzOm8ua2V5PWUuYWx0S2V5P3MuQzAuRVNDK3MuQzAuQ1I6cy5DMC5DUixvLmNhbmNlbD0hMDticmVhaztjYXNlIDI3Om8ua2V5PXMuQzAuRVNDLGUuYWx0S2V5JiYoby5rZXk9cy5DMC5FU0Mrcy5DMC5FU0MpLG8uY2FuY2VsPSEwO2JyZWFrO2Nhc2UgMzc6aWYoZS5tZXRhS2V5KWJyZWFrO2E/KG8ua2V5PXMuQzAuRVNDK1wiWzE7XCIrKGErMSkrXCJEXCIsby5rZXk9PT1zLkMwLkVTQytcIlsxOzNEXCImJihvLmtleT1zLkMwLkVTQysoaT9cImJcIjpcIlsxOzVEXCIpKSk6by5rZXk9dD9zLkMwLkVTQytcIk9EXCI6cy5DMC5FU0MrXCJbRFwiO2JyZWFrO2Nhc2UgMzk6aWYoZS5tZXRhS2V5KWJyZWFrO2E/KG8ua2V5PXMuQzAuRVNDK1wiWzE7XCIrKGErMSkrXCJDXCIsby5rZXk9PT1zLkMwLkVTQytcIlsxOzNDXCImJihvLmtleT1zLkMwLkVTQysoaT9cImZcIjpcIlsxOzVDXCIpKSk6by5rZXk9dD9zLkMwLkVTQytcIk9DXCI6cy5DMC5FU0MrXCJbQ1wiO2JyZWFrO2Nhc2UgMzg6aWYoZS5tZXRhS2V5KWJyZWFrO2E/KG8ua2V5PXMuQzAuRVNDK1wiWzE7XCIrKGErMSkrXCJBXCIsaXx8by5rZXkhPT1zLkMwLkVTQytcIlsxOzNBXCJ8fChvLmtleT1zLkMwLkVTQytcIlsxOzVBXCIpKTpvLmtleT10P3MuQzAuRVNDK1wiT0FcIjpzLkMwLkVTQytcIltBXCI7YnJlYWs7Y2FzZSA0MDppZihlLm1ldGFLZXkpYnJlYWs7YT8oby5rZXk9cy5DMC5FU0MrXCJbMTtcIisoYSsxKStcIkJcIixpfHxvLmtleSE9PXMuQzAuRVNDK1wiWzE7M0JcInx8KG8ua2V5PXMuQzAuRVNDK1wiWzE7NUJcIikpOm8ua2V5PXQ/cy5DMC5FU0MrXCJPQlwiOnMuQzAuRVNDK1wiW0JcIjticmVhaztjYXNlIDQ1OmUuc2hpZnRLZXl8fGUuY3RybEtleXx8KG8ua2V5PXMuQzAuRVNDK1wiWzJ+XCIpO2JyZWFrO2Nhc2UgNDY6by5rZXk9YT9zLkMwLkVTQytcIlszO1wiKyhhKzEpK1wiflwiOnMuQzAuRVNDK1wiWzN+XCI7YnJlYWs7Y2FzZSAzNjpvLmtleT1hP3MuQzAuRVNDK1wiWzE7XCIrKGErMSkrXCJIXCI6dD9zLkMwLkVTQytcIk9IXCI6cy5DMC5FU0MrXCJbSFwiO2JyZWFrO2Nhc2UgMzU6by5rZXk9YT9zLkMwLkVTQytcIlsxO1wiKyhhKzEpK1wiRlwiOnQ/cy5DMC5FU0MrXCJPRlwiOnMuQzAuRVNDK1wiW0ZcIjticmVhaztjYXNlIDMzOmUuc2hpZnRLZXk/by50eXBlPTI6ZS5jdHJsS2V5P28ua2V5PXMuQzAuRVNDK1wiWzU7XCIrKGErMSkrXCJ+XCI6by5rZXk9cy5DMC5FU0MrXCJbNX5cIjticmVhaztjYXNlIDM0OmUuc2hpZnRLZXk/by50eXBlPTM6ZS5jdHJsS2V5P28ua2V5PXMuQzAuRVNDK1wiWzY7XCIrKGErMSkrXCJ+XCI6by5rZXk9cy5DMC5FU0MrXCJbNn5cIjticmVhaztjYXNlIDExMjpvLmtleT1hP3MuQzAuRVNDK1wiWzE7XCIrKGErMSkrXCJQXCI6cy5DMC5FU0MrXCJPUFwiO2JyZWFrO2Nhc2UgMTEzOm8ua2V5PWE/cy5DMC5FU0MrXCJbMTtcIisoYSsxKStcIlFcIjpzLkMwLkVTQytcIk9RXCI7YnJlYWs7Y2FzZSAxMTQ6by5rZXk9YT9zLkMwLkVTQytcIlsxO1wiKyhhKzEpK1wiUlwiOnMuQzAuRVNDK1wiT1JcIjticmVhaztjYXNlIDExNTpvLmtleT1hP3MuQzAuRVNDK1wiWzE7XCIrKGErMSkrXCJTXCI6cy5DMC5FU0MrXCJPU1wiO2JyZWFrO2Nhc2UgMTE2Om8ua2V5PWE/cy5DMC5FU0MrXCJbMTU7XCIrKGErMSkrXCJ+XCI6cy5DMC5FU0MrXCJbMTV+XCI7YnJlYWs7Y2FzZSAxMTc6by5rZXk9YT9zLkMwLkVTQytcIlsxNztcIisoYSsxKStcIn5cIjpzLkMwLkVTQytcIlsxN35cIjticmVhaztjYXNlIDExODpvLmtleT1hP3MuQzAuRVNDK1wiWzE4O1wiKyhhKzEpK1wiflwiOnMuQzAuRVNDK1wiWzE4flwiO2JyZWFrO2Nhc2UgMTE5Om8ua2V5PWE/cy5DMC5FU0MrXCJbMTk7XCIrKGErMSkrXCJ+XCI6cy5DMC5FU0MrXCJbMTl+XCI7YnJlYWs7Y2FzZSAxMjA6by5rZXk9YT9zLkMwLkVTQytcIlsyMDtcIisoYSsxKStcIn5cIjpzLkMwLkVTQytcIlsyMH5cIjticmVhaztjYXNlIDEyMTpvLmtleT1hP3MuQzAuRVNDK1wiWzIxO1wiKyhhKzEpK1wiflwiOnMuQzAuRVNDK1wiWzIxflwiO2JyZWFrO2Nhc2UgMTIyOm8ua2V5PWE/cy5DMC5FU0MrXCJbMjM7XCIrKGErMSkrXCJ+XCI6cy5DMC5FU0MrXCJbMjN+XCI7YnJlYWs7Y2FzZSAxMjM6by5rZXk9YT9zLkMwLkVTQytcIlsyNDtcIisoYSsxKStcIn5cIjpzLkMwLkVTQytcIlsyNH5cIjticmVhaztkZWZhdWx0OmlmKCFlLmN0cmxLZXl8fGUuc2hpZnRLZXl8fGUuYWx0S2V5fHxlLm1ldGFLZXkpaWYoaSYmIW58fCFlLmFsdEtleXx8ZS5tZXRhS2V5KSFpfHxlLmFsdEtleXx8ZS5jdHJsS2V5fHxlLnNoaWZ0S2V5fHwhZS5tZXRhS2V5P2Uua2V5JiYhZS5jdHJsS2V5JiYhZS5hbHRLZXkmJiFlLm1ldGFLZXkmJmUua2V5Q29kZT49NDgmJjE9PT1lLmtleS5sZW5ndGg/by5rZXk9ZS5rZXk6ZS5rZXkmJmUuY3RybEtleSYmKFwiX1wiPT09ZS5rZXkmJihvLmtleT1zLkMwLlVTKSxcIkBcIj09PWUua2V5JiYoby5rZXk9cy5DMC5OVUwpKTo2NT09PWUua2V5Q29kZSYmKG8udHlwZT0xKTtlbHNle2NvbnN0IHQ9cltlLmtleUNvZGVdLGk9dD8uW2Uuc2hpZnRLZXk/MTowXTtpZihpKW8ua2V5PXMuQzAuRVNDK2k7ZWxzZSBpZihlLmtleUNvZGU+PTY1JiZlLmtleUNvZGU8PTkwKXtjb25zdCB0PWUuY3RybEtleT9lLmtleUNvZGUtNjQ6ZS5rZXlDb2RlKzMyO2xldCBpPVN0cmluZy5mcm9tQ2hhckNvZGUodCk7ZS5zaGlmdEtleSYmKGk9aS50b1VwcGVyQ2FzZSgpKSxvLmtleT1zLkMwLkVTQytpfWVsc2UgaWYoMzI9PT1lLmtleUNvZGUpby5rZXk9cy5DMC5FU0MrKGUuY3RybEtleT9zLkMwLk5VTDpcIiBcIik7ZWxzZSBpZihcIkRlYWRcIj09PWUua2V5JiZlLmNvZGUuc3RhcnRzV2l0aChcIktleVwiKSl7bGV0IHQ9ZS5jb2RlLnNsaWNlKDMsNCk7ZS5zaGlmdEtleXx8KHQ9dC50b0xvd2VyQ2FzZSgpKSxvLmtleT1zLkMwLkVTQyt0LG8uY2FuY2VsPSEwfX1lbHNlIGUua2V5Q29kZT49NjUmJmUua2V5Q29kZTw9OTA/by5rZXk9U3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUtNjQpOjMyPT09ZS5rZXlDb2RlP28ua2V5PXMuQzAuTlVMOmUua2V5Q29kZT49NTEmJmUua2V5Q29kZTw9NTU/by5rZXk9U3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUtNTErMjcpOjU2PT09ZS5rZXlDb2RlP28ua2V5PXMuQzAuREVMOjIxOT09PWUua2V5Q29kZT9vLmtleT1zLkMwLkVTQzoyMjA9PT1lLmtleUNvZGU/by5rZXk9cy5DMC5GUzoyMjE9PT1lLmtleUNvZGUmJihvLmtleT1zLkMwLkdTKX1yZXR1cm4gb319LDQ4MjooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVXRmOFRvVXRmMzI9dC5TdHJpbmdUb1V0ZjMyPXQudXRmMzJUb1N0cmluZz10LnN0cmluZ0Zyb21Db2RlUG9pbnQ9dm9pZCAwLHQuc3RyaW5nRnJvbUNvZGVQb2ludD1mdW5jdGlvbihlKXtyZXR1cm4gZT42NTUzNT8oZS09NjU1MzYsU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NisoZT4+MTApKStTdHJpbmcuZnJvbUNoYXJDb2RlKGUlMTAyNCs1NjMyMCkpOlN0cmluZy5mcm9tQ2hhckNvZGUoZSl9LHQudXRmMzJUb1N0cmluZz1mdW5jdGlvbihlLHQ9MCxpPWUubGVuZ3RoKXtsZXQgcz1cIlwiO2ZvcihsZXQgcj10O3I8aTsrK3Ipe2xldCB0PWVbcl07dD42NTUzNT8odC09NjU1MzYscys9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NisodD4+MTApKStTdHJpbmcuZnJvbUNoYXJDb2RlKHQlMTAyNCs1NjMyMCkpOnMrPVN0cmluZy5mcm9tQ2hhckNvZGUodCl9cmV0dXJuIHN9LHQuU3RyaW5nVG9VdGYzMj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuX2ludGVyaW09MH1jbGVhcigpe3RoaXMuX2ludGVyaW09MH1kZWNvZGUoZSx0KXtjb25zdCBpPWUubGVuZ3RoO2lmKCFpKXJldHVybiAwO2xldCBzPTAscj0wO2lmKHRoaXMuX2ludGVyaW0pe2NvbnN0IGk9ZS5jaGFyQ29kZUF0KHIrKyk7NTYzMjA8PWkmJmk8PTU3MzQzP3RbcysrXT0xMDI0Kih0aGlzLl9pbnRlcmltLTU1Mjk2KStpLTU2MzIwKzY1NTM2Oih0W3MrK109dGhpcy5faW50ZXJpbSx0W3MrK109aSksdGhpcy5faW50ZXJpbT0wfWZvcihsZXQgbj1yO248aTsrK24pe2NvbnN0IHI9ZS5jaGFyQ29kZUF0KG4pO2lmKDU1Mjk2PD1yJiZyPD01NjMxOSl7aWYoKytuPj1pKXJldHVybiB0aGlzLl9pbnRlcmltPXIscztjb25zdCBvPWUuY2hhckNvZGVBdChuKTs1NjMyMDw9byYmbzw9NTczNDM/dFtzKytdPTEwMjQqKHItNTUyOTYpK28tNTYzMjArNjU1MzY6KHRbcysrXT1yLHRbcysrXT1vKX1lbHNlIDY1Mjc5IT09ciYmKHRbcysrXT1yKX1yZXR1cm4gc319LHQuVXRmOFRvVXRmMzI9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmludGVyaW09bmV3IFVpbnQ4QXJyYXkoMyl9Y2xlYXIoKXt0aGlzLmludGVyaW0uZmlsbCgwKX1kZWNvZGUoZSx0KXtjb25zdCBpPWUubGVuZ3RoO2lmKCFpKXJldHVybiAwO2xldCBzLHIsbixvLGE9MCxoPTAsYz0wO2lmKHRoaXMuaW50ZXJpbVswXSl7bGV0IHM9ITEscj10aGlzLmludGVyaW1bMF07ciY9MTkyPT0oMjI0JnIpPzMxOjIyND09KDI0MCZyKT8xNTo3O2xldCBuLG89MDtmb3IoOyhuPTYzJnRoaXMuaW50ZXJpbVsrK29dKSYmbzw0OylyPDw9NixyfD1uO2NvbnN0IGg9MTkyPT0oMjI0JnRoaXMuaW50ZXJpbVswXSk/MjoyMjQ9PSgyNDAmdGhpcy5pbnRlcmltWzBdKT8zOjQsbD1oLW87Zm9yKDtjPGw7KXtpZihjPj1pKXJldHVybiAwO2lmKG49ZVtjKytdLDEyOCE9KDE5MiZuKSl7Yy0tLHM9ITA7YnJlYWt9dGhpcy5pbnRlcmltW28rK109bixyPDw9NixyfD02MyZufXN8fCgyPT09aD9yPDEyOD9jLS06dFthKytdPXI6Mz09PWg/cjwyMDQ4fHxyPj01NTI5NiYmcjw9NTczNDN8fDY1Mjc5PT09cnx8KHRbYSsrXT1yKTpyPDY1NTM2fHxyPjExMTQxMTF8fCh0W2ErK109cikpLHRoaXMuaW50ZXJpbS5maWxsKDApfWNvbnN0IGw9aS00O2xldCBkPWM7Zm9yKDtkPGk7KXtmb3IoOyEoIShkPGwpfHwxMjgmKHM9ZVtkXSl8fDEyOCYocj1lW2QrMV0pfHwxMjgmKG49ZVtkKzJdKXx8MTI4JihvPWVbZCszXSkpOyl0W2ErK109cyx0W2ErK109cix0W2ErK109bix0W2ErK109byxkKz00O2lmKHM9ZVtkKytdLHM8MTI4KXRbYSsrXT1zO2Vsc2UgaWYoMTkyPT0oMjI0JnMpKXtpZihkPj1pKXJldHVybiB0aGlzLmludGVyaW1bMF09cyxhO2lmKHI9ZVtkKytdLDEyOCE9KDE5MiZyKSl7ZC0tO2NvbnRpbnVlfWlmKGg9KDMxJnMpPDw2fDYzJnIsaDwxMjgpe2QtLTtjb250aW51ZX10W2ErK109aH1lbHNlIGlmKDIyND09KDI0MCZzKSl7aWYoZD49aSlyZXR1cm4gdGhpcy5pbnRlcmltWzBdPXMsYTtpZihyPWVbZCsrXSwxMjghPSgxOTImcikpe2QtLTtjb250aW51ZX1pZihkPj1pKXJldHVybiB0aGlzLmludGVyaW1bMF09cyx0aGlzLmludGVyaW1bMV09cixhO2lmKG49ZVtkKytdLDEyOCE9KDE5MiZuKSl7ZC0tO2NvbnRpbnVlfWlmKGg9KDE1JnMpPDwxMnwoNjMmcik8PDZ8NjMmbixoPDIwNDh8fGg+PTU1Mjk2JiZoPD01NzM0M3x8NjUyNzk9PT1oKWNvbnRpbnVlO3RbYSsrXT1ofWVsc2UgaWYoMjQwPT0oMjQ4JnMpKXtpZihkPj1pKXJldHVybiB0aGlzLmludGVyaW1bMF09cyxhO2lmKHI9ZVtkKytdLDEyOCE9KDE5MiZyKSl7ZC0tO2NvbnRpbnVlfWlmKGQ+PWkpcmV0dXJuIHRoaXMuaW50ZXJpbVswXT1zLHRoaXMuaW50ZXJpbVsxXT1yLGE7aWYobj1lW2QrK10sMTI4IT0oMTkyJm4pKXtkLS07Y29udGludWV9aWYoZD49aSlyZXR1cm4gdGhpcy5pbnRlcmltWzBdPXMsdGhpcy5pbnRlcmltWzFdPXIsdGhpcy5pbnRlcmltWzJdPW4sYTtpZihvPWVbZCsrXSwxMjghPSgxOTImbykpe2QtLTtjb250aW51ZX1pZihoPSg3JnMpPDwxOHwoNjMmcik8PDEyfCg2MyZuKTw8Nnw2MyZvLGg8NjU1MzZ8fGg+MTExNDExMSljb250aW51ZTt0W2ErK109aH19cmV0dXJuIGF9fX0sMjI1OihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlVuaWNvZGVWNj12b2lkIDA7Y29uc3Qgcz1pKDE0ODApLHI9W1s3NjgsODc5XSxbMTE1NSwxMTU4XSxbMTE2MCwxMTYxXSxbMTQyNSwxNDY5XSxbMTQ3MSwxNDcxXSxbMTQ3MywxNDc0XSxbMTQ3NiwxNDc3XSxbMTQ3OSwxNDc5XSxbMTUzNiwxNTM5XSxbMTU1MiwxNTU3XSxbMTYxMSwxNjMwXSxbMTY0OCwxNjQ4XSxbMTc1MCwxNzY0XSxbMTc2NywxNzY4XSxbMTc3MCwxNzczXSxbMTgwNywxODA3XSxbMTgwOSwxODA5XSxbMTg0MCwxODY2XSxbMTk1OCwxOTY4XSxbMjAyNywyMDM1XSxbMjMwNSwyMzA2XSxbMjM2NCwyMzY0XSxbMjM2OSwyMzc2XSxbMjM4MSwyMzgxXSxbMjM4NSwyMzg4XSxbMjQwMiwyNDAzXSxbMjQzMywyNDMzXSxbMjQ5MiwyNDkyXSxbMjQ5NywyNTAwXSxbMjUwOSwyNTA5XSxbMjUzMCwyNTMxXSxbMjU2MSwyNTYyXSxbMjYyMCwyNjIwXSxbMjYyNSwyNjI2XSxbMjYzMSwyNjMyXSxbMjYzNSwyNjM3XSxbMjY3MiwyNjczXSxbMjY4OSwyNjkwXSxbMjc0OCwyNzQ4XSxbMjc1MywyNzU3XSxbMjc1OSwyNzYwXSxbMjc2NSwyNzY1XSxbMjc4NiwyNzg3XSxbMjgxNywyODE3XSxbMjg3NiwyODc2XSxbMjg3OSwyODc5XSxbMjg4MSwyODgzXSxbMjg5MywyODkzXSxbMjkwMiwyOTAyXSxbMjk0NiwyOTQ2XSxbMzAwOCwzMDA4XSxbMzAyMSwzMDIxXSxbMzEzNCwzMTM2XSxbMzE0MiwzMTQ0XSxbMzE0NiwzMTQ5XSxbMzE1NywzMTU4XSxbMzI2MCwzMjYwXSxbMzI2MywzMjYzXSxbMzI3MCwzMjcwXSxbMzI3NiwzMjc3XSxbMzI5OCwzMjk5XSxbMzM5MywzMzk1XSxbMzQwNSwzNDA1XSxbMzUzMCwzNTMwXSxbMzUzOCwzNTQwXSxbMzU0MiwzNTQyXSxbMzYzMywzNjMzXSxbMzYzNiwzNjQyXSxbMzY1NSwzNjYyXSxbMzc2MSwzNzYxXSxbMzc2NCwzNzY5XSxbMzc3MSwzNzcyXSxbMzc4NCwzNzg5XSxbMzg2NCwzODY1XSxbMzg5MywzODkzXSxbMzg5NSwzODk1XSxbMzg5NywzODk3XSxbMzk1MywzOTY2XSxbMzk2OCwzOTcyXSxbMzk3NCwzOTc1XSxbMzk4NCwzOTkxXSxbMzk5Myw0MDI4XSxbNDAzOCw0MDM4XSxbNDE0MSw0MTQ0XSxbNDE0Niw0MTQ2XSxbNDE1MCw0MTUxXSxbNDE1Myw0MTUzXSxbNDE4NCw0MTg1XSxbNDQ0OCw0NjA3XSxbNDk1OSw0OTU5XSxbNTkwNiw1OTA4XSxbNTkzOCw1OTQwXSxbNTk3MCw1OTcxXSxbNjAwMiw2MDAzXSxbNjA2OCw2MDY5XSxbNjA3MSw2MDc3XSxbNjA4Niw2MDg2XSxbNjA4OSw2MDk5XSxbNjEwOSw2MTA5XSxbNjE1NSw2MTU3XSxbNjMxMyw2MzEzXSxbNjQzMiw2NDM0XSxbNjQzOSw2NDQwXSxbNjQ1MCw2NDUwXSxbNjQ1Nyw2NDU5XSxbNjY3OSw2NjgwXSxbNjkxMiw2OTE1XSxbNjk2NCw2OTY0XSxbNjk2Niw2OTcwXSxbNjk3Miw2OTcyXSxbNjk3OCw2OTc4XSxbNzAxOSw3MDI3XSxbNzYxNiw3NjI2XSxbNzY3OCw3Njc5XSxbODIwMyw4MjA3XSxbODIzNCw4MjM4XSxbODI4OCw4MjkxXSxbODI5OCw4MzAzXSxbODQwMCw4NDMxXSxbMTIzMzAsMTIzMzVdLFsxMjQ0MSwxMjQ0Ml0sWzQzMDE0LDQzMDE0XSxbNDMwMTksNDMwMTldLFs0MzA0NSw0MzA0Nl0sWzY0Mjg2LDY0Mjg2XSxbNjUwMjQsNjUwMzldLFs2NTA1Niw2NTA1OV0sWzY1Mjc5LDY1Mjc5XSxbNjU1MjksNjU1MzFdXSxuPVtbNjgwOTcsNjgwOTldLFs2ODEwMSw2ODEwMl0sWzY4MTA4LDY4MTExXSxbNjgxNTIsNjgxNTRdLFs2ODE1OSw2ODE1OV0sWzExOTE0MywxMTkxNDVdLFsxMTkxNTUsMTE5MTcwXSxbMTE5MTczLDExOTE3OV0sWzExOTIxMCwxMTkyMTNdLFsxMTkzNjIsMTE5MzY0XSxbOTE3NTA1LDkxNzUwNV0sWzkxNzUzNiw5MTc2MzFdLFs5MTc3NjAsOTE3OTk5XV07bGV0IG87dC5Vbmljb2RlVjY9Y2xhc3N7Y29uc3RydWN0b3IoKXtpZih0aGlzLnZlcnNpb249XCI2XCIsIW8pe289bmV3IFVpbnQ4QXJyYXkoNjU1MzYpLG8uZmlsbCgxKSxvWzBdPTAsby5maWxsKDAsMSwzMiksby5maWxsKDAsMTI3LDE2MCksby5maWxsKDIsNDM1Miw0NDQ4KSxvWzkwMDFdPTIsb1s5MDAyXT0yLG8uZmlsbCgyLDExOTA0LDQyMTkyKSxvWzEyMzUxXT0xLG8uZmlsbCgyLDQ0MDMyLDU1MjA0KSxvLmZpbGwoMiw2Mzc0NCw2NDI1Niksby5maWxsKDIsNjUwNDAsNjUwNTApLG8uZmlsbCgyLDY1MDcyLDY1MTM2KSxvLmZpbGwoMiw2NTI4MCw2NTM3Nyksby5maWxsKDIsNjU1MDQsNjU1MTEpO2ZvcihsZXQgZT0wO2U8ci5sZW5ndGg7KytlKW8uZmlsbCgwLHJbZV1bMF0scltlXVsxXSsxKX19d2N3aWR0aChlKXtyZXR1cm4gZTwzMj8wOmU8MTI3PzE6ZTw2NTUzNj9vW2VdOmZ1bmN0aW9uKGUsdCl7bGV0IGkscz0wLHI9dC5sZW5ndGgtMTtpZihlPHRbMF1bMF18fGU+dFtyXVsxXSlyZXR1cm4hMTtmb3IoO3I+PXM7KWlmKGk9cytyPj4xLGU+dFtpXVsxXSlzPWkrMTtlbHNle2lmKCEoZTx0W2ldWzBdKSlyZXR1cm4hMDtyPWktMX1yZXR1cm4hMX0oZSxuKT8wOmU+PTEzMTA3MiYmZTw9MTk2NjA1fHxlPj0xOTY2MDgmJmU8PTI2MjE0MT8yOjF9Y2hhclByb3BlcnRpZXMoZSx0KXtsZXQgaT10aGlzLndjd2lkdGgoZSkscj0wPT09aSYmMCE9PXQ7aWYocil7Y29uc3QgZT1zLlVuaWNvZGVTZXJ2aWNlLmV4dHJhY3RXaWR0aCh0KTswPT09ZT9yPSExOmU+aSYmKGk9ZSl9cmV0dXJuIHMuVW5pY29kZVNlcnZpY2UuY3JlYXRlUHJvcGVydHlWYWx1ZSgwLGkscil9fX0sNTk4MTooZSx0LGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Xcml0ZUJ1ZmZlcj12b2lkIDA7Y29uc3Qgcz1pKDg0NjApLHI9aSg4NDQpO2NsYXNzIG4gZXh0ZW5kcyByLkRpc3Bvc2FibGV7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLl9hY3Rpb249ZSx0aGlzLl93cml0ZUJ1ZmZlcj1bXSx0aGlzLl9jYWxsYmFja3M9W10sdGhpcy5fcGVuZGluZ0RhdGE9MCx0aGlzLl9idWZmZXJPZmZzZXQ9MCx0aGlzLl9pc1N5bmNXcml0aW5nPSExLHRoaXMuX3N5bmNDYWxscz0wLHRoaXMuX2RpZFVzZXJJbnB1dD0hMSx0aGlzLl9vbldyaXRlUGFyc2VkPXRoaXMucmVnaXN0ZXIobmV3IHMuRXZlbnRFbWl0dGVyKSx0aGlzLm9uV3JpdGVQYXJzZWQ9dGhpcy5fb25Xcml0ZVBhcnNlZC5ldmVudH1oYW5kbGVVc2VySW5wdXQoKXt0aGlzLl9kaWRVc2VySW5wdXQ9ITB9d3JpdGVTeW5jKGUsdCl7aWYodm9pZCAwIT09dCYmdGhpcy5fc3luY0NhbGxzPnQpcmV0dXJuIHZvaWQodGhpcy5fc3luY0NhbGxzPTApO2lmKHRoaXMuX3BlbmRpbmdEYXRhKz1lLmxlbmd0aCx0aGlzLl93cml0ZUJ1ZmZlci5wdXNoKGUpLHRoaXMuX2NhbGxiYWNrcy5wdXNoKHZvaWQgMCksdGhpcy5fc3luY0NhbGxzKyssdGhpcy5faXNTeW5jV3JpdGluZylyZXR1cm47bGV0IGk7Zm9yKHRoaXMuX2lzU3luY1dyaXRpbmc9ITA7aT10aGlzLl93cml0ZUJ1ZmZlci5zaGlmdCgpOyl7dGhpcy5fYWN0aW9uKGkpO2NvbnN0IGU9dGhpcy5fY2FsbGJhY2tzLnNoaWZ0KCk7ZSYmZSgpfXRoaXMuX3BlbmRpbmdEYXRhPTAsdGhpcy5fYnVmZmVyT2Zmc2V0PTIxNDc0ODM2NDcsdGhpcy5faXNTeW5jV3JpdGluZz0hMSx0aGlzLl9zeW5jQ2FsbHM9MH13cml0ZShlLHQpe2lmKHRoaXMuX3BlbmRpbmdEYXRhPjVlNyl0aHJvdyBuZXcgRXJyb3IoXCJ3cml0ZSBkYXRhIGRpc2NhcmRlZCwgdXNlIGZsb3cgY29udHJvbCB0byBhdm9pZCBsb3NpbmcgZGF0YVwiKTtpZighdGhpcy5fd3JpdGVCdWZmZXIubGVuZ3RoKXtpZih0aGlzLl9idWZmZXJPZmZzZXQ9MCx0aGlzLl9kaWRVc2VySW5wdXQpcmV0dXJuIHRoaXMuX2RpZFVzZXJJbnB1dD0hMSx0aGlzLl9wZW5kaW5nRGF0YSs9ZS5sZW5ndGgsdGhpcy5fd3JpdGVCdWZmZXIucHVzaChlKSx0aGlzLl9jYWxsYmFja3MucHVzaCh0KSx2b2lkIHRoaXMuX2lubmVyV3JpdGUoKTtzZXRUaW1lb3V0KCgoKT0+dGhpcy5faW5uZXJXcml0ZSgpKSl9dGhpcy5fcGVuZGluZ0RhdGErPWUubGVuZ3RoLHRoaXMuX3dyaXRlQnVmZmVyLnB1c2goZSksdGhpcy5fY2FsbGJhY2tzLnB1c2godCl9X2lubmVyV3JpdGUoZT0wLHQ9ITApe2NvbnN0IGk9ZXx8RGF0ZS5ub3coKTtmb3IoO3RoaXMuX3dyaXRlQnVmZmVyLmxlbmd0aD50aGlzLl9idWZmZXJPZmZzZXQ7KXtjb25zdCBlPXRoaXMuX3dyaXRlQnVmZmVyW3RoaXMuX2J1ZmZlck9mZnNldF0scz10aGlzLl9hY3Rpb24oZSx0KTtpZihzKXtjb25zdCBlPWU9PkRhdGUubm93KCktaT49MTI/c2V0VGltZW91dCgoKCk9PnRoaXMuX2lubmVyV3JpdGUoMCxlKSkpOnRoaXMuX2lubmVyV3JpdGUoaSxlKTtyZXR1cm4gdm9pZCBzLmNhdGNoKChlPT4ocXVldWVNaWNyb3Rhc2soKCgpPT57dGhyb3cgZX0pKSxQcm9taXNlLnJlc29sdmUoITEpKSkpLnRoZW4oZSl9Y29uc3Qgcj10aGlzLl9jYWxsYmFja3NbdGhpcy5fYnVmZmVyT2Zmc2V0XTtpZihyJiZyKCksdGhpcy5fYnVmZmVyT2Zmc2V0KyssdGhpcy5fcGVuZGluZ0RhdGEtPWUubGVuZ3RoLERhdGUubm93KCktaT49MTIpYnJlYWt9dGhpcy5fd3JpdGVCdWZmZXIubGVuZ3RoPnRoaXMuX2J1ZmZlck9mZnNldD8odGhpcy5fYnVmZmVyT2Zmc2V0PjUwJiYodGhpcy5fd3JpdGVCdWZmZXI9dGhpcy5fd3JpdGVCdWZmZXIuc2xpY2UodGhpcy5fYnVmZmVyT2Zmc2V0KSx0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzLnNsaWNlKHRoaXMuX2J1ZmZlck9mZnNldCksdGhpcy5fYnVmZmVyT2Zmc2V0PTApLHNldFRpbWVvdXQoKCgpPT50aGlzLl9pbm5lcldyaXRlKCkpKSk6KHRoaXMuX3dyaXRlQnVmZmVyLmxlbmd0aD0wLHRoaXMuX2NhbGxiYWNrcy5sZW5ndGg9MCx0aGlzLl9wZW5kaW5nRGF0YT0wLHRoaXMuX2J1ZmZlck9mZnNldD0wKSx0aGlzLl9vbldyaXRlUGFyc2VkLmZpcmUoKX19dC5Xcml0ZUJ1ZmZlcj1ufSw1OTQxOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC50b1JnYlN0cmluZz10LnBhcnNlQ29sb3I9dm9pZCAwO2NvbnN0IGk9L14oW1xcZGEtZl0pXFwvKFtcXGRhLWZdKVxcLyhbXFxkYS1mXSkkfF4oW1xcZGEtZl17Mn0pXFwvKFtcXGRhLWZdezJ9KVxcLyhbXFxkYS1mXXsyfSkkfF4oW1xcZGEtZl17M30pXFwvKFtcXGRhLWZdezN9KVxcLyhbXFxkYS1mXXszfSkkfF4oW1xcZGEtZl17NH0pXFwvKFtcXGRhLWZdezR9KVxcLyhbXFxkYS1mXXs0fSkkLyxzPS9eW1xcZGEtZl0rJC87ZnVuY3Rpb24gcihlLHQpe2NvbnN0IGk9ZS50b1N0cmluZygxNikscz1pLmxlbmd0aDwyP1wiMFwiK2k6aTtzd2l0Y2godCl7Y2FzZSA0OnJldHVybiBpWzBdO2Nhc2UgODpyZXR1cm4gcztjYXNlIDEyOnJldHVybihzK3MpLnNsaWNlKDAsMyk7ZGVmYXVsdDpyZXR1cm4gcytzfX10LnBhcnNlQ29sb3I9ZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuO2xldCB0PWUudG9Mb3dlckNhc2UoKTtpZigwPT09dC5pbmRleE9mKFwicmdiOlwiKSl7dD10LnNsaWNlKDQpO2NvbnN0IGU9aS5leGVjKHQpO2lmKGUpe2NvbnN0IHQ9ZVsxXT8xNTplWzRdPzI1NTplWzddPzQwOTU6NjU1MzU7cmV0dXJuW01hdGgucm91bmQocGFyc2VJbnQoZVsxXXx8ZVs0XXx8ZVs3XXx8ZVsxMF0sMTYpL3QqMjU1KSxNYXRoLnJvdW5kKHBhcnNlSW50KGVbMl18fGVbNV18fGVbOF18fGVbMTFdLDE2KS90KjI1NSksTWF0aC5yb3VuZChwYXJzZUludChlWzNdfHxlWzZdfHxlWzldfHxlWzEyXSwxNikvdCoyNTUpXX19ZWxzZSBpZigwPT09dC5pbmRleE9mKFwiI1wiKSYmKHQ9dC5zbGljZSgxKSxzLmV4ZWModCkmJlszLDYsOSwxMl0uaW5jbHVkZXModC5sZW5ndGgpKSl7Y29uc3QgZT10Lmxlbmd0aC8zLGk9WzAsMCwwXTtmb3IobGV0IHM9MDtzPDM7KytzKXtjb25zdCByPXBhcnNlSW50KHQuc2xpY2UoZSpzLGUqcytlKSwxNik7aVtzXT0xPT09ZT9yPDw0OjI9PT1lP3I6Mz09PWU/cj4+NDpyPj44fXJldHVybiBpfX0sdC50b1JnYlN0cmluZz1mdW5jdGlvbihlLHQ9MTYpe2NvbnN0W2kscyxuXT1lO3JldHVybmByZ2I6JHtyKGksdCl9LyR7cihzLHQpfS8ke3Iobix0KX1gfX0sNTc3MDooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuUEFZTE9BRF9MSU1JVD12b2lkIDAsdC5QQVlMT0FEX0xJTUlUPTFlN30sNjM1MTooZSx0LGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5EY3NIYW5kbGVyPXQuRGNzUGFyc2VyPXZvaWQgMDtjb25zdCBzPWkoNDgyKSxyPWkoODc0Miksbj1pKDU3NzApLG89W107dC5EY3NQYXJzZXI9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLl9oYW5kbGVycz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX2FjdGl2ZT1vLHRoaXMuX2lkZW50PTAsdGhpcy5faGFuZGxlckZiPSgpPT57fSx0aGlzLl9zdGFjaz17cGF1c2VkOiExLGxvb3BQb3NpdGlvbjowLGZhbGxUaHJvdWdoOiExfX1kaXNwb3NlKCl7dGhpcy5faGFuZGxlcnM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9oYW5kbGVyRmI9KCk9Pnt9LHRoaXMuX2FjdGl2ZT1vfXJlZ2lzdGVySGFuZGxlcihlLHQpe3ZvaWQgMD09PXRoaXMuX2hhbmRsZXJzW2VdJiYodGhpcy5faGFuZGxlcnNbZV09W10pO2NvbnN0IGk9dGhpcy5faGFuZGxlcnNbZV07cmV0dXJuIGkucHVzaCh0KSx7ZGlzcG9zZTooKT0+e2NvbnN0IGU9aS5pbmRleE9mKHQpOy0xIT09ZSYmaS5zcGxpY2UoZSwxKX19fWNsZWFySGFuZGxlcihlKXt0aGlzLl9oYW5kbGVyc1tlXSYmZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2VdfXNldEhhbmRsZXJGYWxsYmFjayhlKXt0aGlzLl9oYW5kbGVyRmI9ZX1yZXNldCgpe2lmKHRoaXMuX2FjdGl2ZS5sZW5ndGgpZm9yKGxldCBlPXRoaXMuX3N0YWNrLnBhdXNlZD90aGlzLl9zdGFjay5sb29wUG9zaXRpb24tMTp0aGlzLl9hY3RpdmUubGVuZ3RoLTE7ZT49MDstLWUpdGhpcy5fYWN0aXZlW2VdLnVuaG9vayghMSk7dGhpcy5fc3RhY2sucGF1c2VkPSExLHRoaXMuX2FjdGl2ZT1vLHRoaXMuX2lkZW50PTB9aG9vayhlLHQpe2lmKHRoaXMucmVzZXQoKSx0aGlzLl9pZGVudD1lLHRoaXMuX2FjdGl2ZT10aGlzLl9oYW5kbGVyc1tlXXx8byx0aGlzLl9hY3RpdmUubGVuZ3RoKWZvcihsZXQgZT10aGlzLl9hY3RpdmUubGVuZ3RoLTE7ZT49MDtlLS0pdGhpcy5fYWN0aXZlW2VdLmhvb2sodCk7ZWxzZSB0aGlzLl9oYW5kbGVyRmIodGhpcy5faWRlbnQsXCJIT09LXCIsdCl9cHV0KGUsdCxpKXtpZih0aGlzLl9hY3RpdmUubGVuZ3RoKWZvcihsZXQgcz10aGlzLl9hY3RpdmUubGVuZ3RoLTE7cz49MDtzLS0pdGhpcy5fYWN0aXZlW3NdLnB1dChlLHQsaSk7ZWxzZSB0aGlzLl9oYW5kbGVyRmIodGhpcy5faWRlbnQsXCJQVVRcIiwoMCxzLnV0ZjMyVG9TdHJpbmcpKGUsdCxpKSl9dW5ob29rKGUsdD0hMCl7aWYodGhpcy5fYWN0aXZlLmxlbmd0aCl7bGV0IGk9ITEscz10aGlzLl9hY3RpdmUubGVuZ3RoLTEscj0hMTtpZih0aGlzLl9zdGFjay5wYXVzZWQmJihzPXRoaXMuX3N0YWNrLmxvb3BQb3NpdGlvbi0xLGk9dCxyPXRoaXMuX3N0YWNrLmZhbGxUaHJvdWdoLHRoaXMuX3N0YWNrLnBhdXNlZD0hMSksIXImJiExPT09aSl7Zm9yKDtzPj0wJiYoaT10aGlzLl9hY3RpdmVbc10udW5ob29rKGUpLCEwIT09aSk7cy0tKWlmKGkgaW5zdGFuY2VvZiBQcm9taXNlKXJldHVybiB0aGlzLl9zdGFjay5wYXVzZWQ9ITAsdGhpcy5fc3RhY2subG9vcFBvc2l0aW9uPXMsdGhpcy5fc3RhY2suZmFsbFRocm91Z2g9ITEsaTtzLS19Zm9yKDtzPj0wO3MtLSlpZihpPXRoaXMuX2FjdGl2ZVtzXS51bmhvb2soITEpLGkgaW5zdGFuY2VvZiBQcm9taXNlKXJldHVybiB0aGlzLl9zdGFjay5wYXVzZWQ9ITAsdGhpcy5fc3RhY2subG9vcFBvc2l0aW9uPXMsdGhpcy5fc3RhY2suZmFsbFRocm91Z2g9ITAsaX1lbHNlIHRoaXMuX2hhbmRsZXJGYih0aGlzLl9pZGVudCxcIlVOSE9PS1wiLGUpO3RoaXMuX2FjdGl2ZT1vLHRoaXMuX2lkZW50PTB9fTtjb25zdCBhPW5ldyByLlBhcmFtczthLmFkZFBhcmFtKDApLHQuRGNzSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9oYW5kbGVyPWUsdGhpcy5fZGF0YT1cIlwiLHRoaXMuX3BhcmFtcz1hLHRoaXMuX2hpdExpbWl0PSExfWhvb2soZSl7dGhpcy5fcGFyYW1zPWUubGVuZ3RoPjF8fGUucGFyYW1zWzBdP2UuY2xvbmUoKTphLHRoaXMuX2RhdGE9XCJcIix0aGlzLl9oaXRMaW1pdD0hMX1wdXQoZSx0LGkpe3RoaXMuX2hpdExpbWl0fHwodGhpcy5fZGF0YSs9KDAscy51dGYzMlRvU3RyaW5nKShlLHQsaSksdGhpcy5fZGF0YS5sZW5ndGg+bi5QQVlMT0FEX0xJTUlUJiYodGhpcy5fZGF0YT1cIlwiLHRoaXMuX2hpdExpbWl0PSEwKSl9dW5ob29rKGUpe2xldCB0PSExO2lmKHRoaXMuX2hpdExpbWl0KXQ9ITE7ZWxzZSBpZihlJiYodD10aGlzLl9oYW5kbGVyKHRoaXMuX2RhdGEsdGhpcy5fcGFyYW1zKSx0IGluc3RhbmNlb2YgUHJvbWlzZSkpcmV0dXJuIHQudGhlbigoZT0+KHRoaXMuX3BhcmFtcz1hLHRoaXMuX2RhdGE9XCJcIix0aGlzLl9oaXRMaW1pdD0hMSxlKSkpO3JldHVybiB0aGlzLl9wYXJhbXM9YSx0aGlzLl9kYXRhPVwiXCIsdGhpcy5faGl0TGltaXQ9ITEsdH19fSwyMDE1OihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkVzY2FwZVNlcXVlbmNlUGFyc2VyPXQuVlQ1MDBfVFJBTlNJVElPTl9UQUJMRT10LlRyYW5zaXRpb25UYWJsZT12b2lkIDA7Y29uc3Qgcz1pKDg0NCkscj1pKDg3NDIpLG49aSg2MjQyKSxvPWkoNjM1MSk7Y2xhc3MgYXtjb25zdHJ1Y3RvcihlKXt0aGlzLnRhYmxlPW5ldyBVaW50OEFycmF5KGUpfXNldERlZmF1bHQoZSx0KXt0aGlzLnRhYmxlLmZpbGwoZTw8NHx0KX1hZGQoZSx0LGkscyl7dGhpcy50YWJsZVt0PDw4fGVdPWk8PDR8c31hZGRNYW55KGUsdCxpLHMpe2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXRoaXMudGFibGVbdDw8OHxlW3JdXT1pPDw0fHN9fXQuVHJhbnNpdGlvblRhYmxlPWE7Y29uc3QgaD0xNjA7dC5WVDUwMF9UUkFOU0lUSU9OX1RBQkxFPWZ1bmN0aW9uKCl7Y29uc3QgZT1uZXcgYSg0MDk1KSx0PUFycmF5LmFwcGx5KG51bGwsQXJyYXkoMjU2KSkubWFwKCgoZSx0KT0+dCkpLGk9KGUsaSk9PnQuc2xpY2UoZSxpKSxzPWkoMzIsMTI3KSxyPWkoMCwyNCk7ci5wdXNoKDI1KSxyLnB1c2guYXBwbHkocixpKDI4LDMyKSk7Y29uc3Qgbj1pKDAsMTQpO2xldCBvO2ZvcihvIGluIGUuc2V0RGVmYXVsdCgxLDApLGUuYWRkTWFueShzLDAsMiwwKSxuKWUuYWRkTWFueShbMjQsMjYsMTUzLDE1NF0sbywzLDApLGUuYWRkTWFueShpKDEyOCwxNDQpLG8sMywwKSxlLmFkZE1hbnkoaSgxNDQsMTUyKSxvLDMsMCksZS5hZGQoMTU2LG8sMCwwKSxlLmFkZCgyNyxvLDExLDEpLGUuYWRkKDE1NyxvLDQsOCksZS5hZGRNYW55KFsxNTIsMTU4LDE1OV0sbywwLDcpLGUuYWRkKDE1NSxvLDExLDMpLGUuYWRkKDE0NCxvLDExLDkpO3JldHVybiBlLmFkZE1hbnkociwwLDMsMCksZS5hZGRNYW55KHIsMSwzLDEpLGUuYWRkKDEyNywxLDAsMSksZS5hZGRNYW55KHIsOCwwLDgpLGUuYWRkTWFueShyLDMsMywzKSxlLmFkZCgxMjcsMywwLDMpLGUuYWRkTWFueShyLDQsMyw0KSxlLmFkZCgxMjcsNCwwLDQpLGUuYWRkTWFueShyLDYsMyw2KSxlLmFkZE1hbnkociw1LDMsNSksZS5hZGQoMTI3LDUsMCw1KSxlLmFkZE1hbnkociwyLDMsMiksZS5hZGQoMTI3LDIsMCwyKSxlLmFkZCg5MywxLDQsOCksZS5hZGRNYW55KHMsOCw1LDgpLGUuYWRkKDEyNyw4LDUsOCksZS5hZGRNYW55KFsxNTYsMjcsMjQsMjYsN10sOCw2LDApLGUuYWRkTWFueShpKDI4LDMyKSw4LDAsOCksZS5hZGRNYW55KFs4OCw5NCw5NV0sMSwwLDcpLGUuYWRkTWFueShzLDcsMCw3KSxlLmFkZE1hbnkociw3LDAsNyksZS5hZGQoMTU2LDcsMCwwKSxlLmFkZCgxMjcsNywwLDcpLGUuYWRkKDkxLDEsMTEsMyksZS5hZGRNYW55KGkoNjQsMTI3KSwzLDcsMCksZS5hZGRNYW55KGkoNDgsNjApLDMsOCw0KSxlLmFkZE1hbnkoWzYwLDYxLDYyLDYzXSwzLDksNCksZS5hZGRNYW55KGkoNDgsNjApLDQsOCw0KSxlLmFkZE1hbnkoaSg2NCwxMjcpLDQsNywwKSxlLmFkZE1hbnkoWzYwLDYxLDYyLDYzXSw0LDAsNiksZS5hZGRNYW55KGkoMzIsNjQpLDYsMCw2KSxlLmFkZCgxMjcsNiwwLDYpLGUuYWRkTWFueShpKDY0LDEyNyksNiwwLDApLGUuYWRkTWFueShpKDMyLDQ4KSwzLDksNSksZS5hZGRNYW55KGkoMzIsNDgpLDUsOSw1KSxlLmFkZE1hbnkoaSg0OCw2NCksNSwwLDYpLGUuYWRkTWFueShpKDY0LDEyNyksNSw3LDApLGUuYWRkTWFueShpKDMyLDQ4KSw0LDksNSksZS5hZGRNYW55KGkoMzIsNDgpLDEsOSwyKSxlLmFkZE1hbnkoaSgzMiw0OCksMiw5LDIpLGUuYWRkTWFueShpKDQ4LDEyNyksMiwxMCwwKSxlLmFkZE1hbnkoaSg0OCw4MCksMSwxMCwwKSxlLmFkZE1hbnkoaSg4MSw4OCksMSwxMCwwKSxlLmFkZE1hbnkoWzg5LDkwLDkyXSwxLDEwLDApLGUuYWRkTWFueShpKDk2LDEyNyksMSwxMCwwKSxlLmFkZCg4MCwxLDExLDkpLGUuYWRkTWFueShyLDksMCw5KSxlLmFkZCgxMjcsOSwwLDkpLGUuYWRkTWFueShpKDI4LDMyKSw5LDAsOSksZS5hZGRNYW55KGkoMzIsNDgpLDksOSwxMiksZS5hZGRNYW55KGkoNDgsNjApLDksOCwxMCksZS5hZGRNYW55KFs2MCw2MSw2Miw2M10sOSw5LDEwKSxlLmFkZE1hbnkociwxMSwwLDExKSxlLmFkZE1hbnkoaSgzMiwxMjgpLDExLDAsMTEpLGUuYWRkTWFueShpKDI4LDMyKSwxMSwwLDExKSxlLmFkZE1hbnkociwxMCwwLDEwKSxlLmFkZCgxMjcsMTAsMCwxMCksZS5hZGRNYW55KGkoMjgsMzIpLDEwLDAsMTApLGUuYWRkTWFueShpKDQ4LDYwKSwxMCw4LDEwKSxlLmFkZE1hbnkoWzYwLDYxLDYyLDYzXSwxMCwwLDExKSxlLmFkZE1hbnkoaSgzMiw0OCksMTAsOSwxMiksZS5hZGRNYW55KHIsMTIsMCwxMiksZS5hZGQoMTI3LDEyLDAsMTIpLGUuYWRkTWFueShpKDI4LDMyKSwxMiwwLDEyKSxlLmFkZE1hbnkoaSgzMiw0OCksMTIsOSwxMiksZS5hZGRNYW55KGkoNDgsNjQpLDEyLDAsMTEpLGUuYWRkTWFueShpKDY0LDEyNyksMTIsMTIsMTMpLGUuYWRkTWFueShpKDY0LDEyNyksMTAsMTIsMTMpLGUuYWRkTWFueShpKDY0LDEyNyksOSwxMiwxMyksZS5hZGRNYW55KHIsMTMsMTMsMTMpLGUuYWRkTWFueShzLDEzLDEzLDEzKSxlLmFkZCgxMjcsMTMsMCwxMyksZS5hZGRNYW55KFsyNywxNTYsMjQsMjZdLDEzLDE0LDApLGUuYWRkKGgsMCwyLDApLGUuYWRkKGgsOCw1LDgpLGUuYWRkKGgsNiwwLDYpLGUuYWRkKGgsMTEsMCwxMSksZS5hZGQoaCwxMywxMywxMyksZX0oKTtjbGFzcyBjIGV4dGVuZHMgcy5EaXNwb3NhYmxle2NvbnN0cnVjdG9yKGU9dC5WVDUwMF9UUkFOU0lUSU9OX1RBQkxFKXtzdXBlcigpLHRoaXMuX3RyYW5zaXRpb25zPWUsdGhpcy5fcGFyc2VTdGFjaz17c3RhdGU6MCxoYW5kbGVyczpbXSxoYW5kbGVyUG9zOjAsdHJhbnNpdGlvbjowLGNodW5rUG9zOjB9LHRoaXMuaW5pdGlhbFN0YXRlPTAsdGhpcy5jdXJyZW50U3RhdGU9dGhpcy5pbml0aWFsU3RhdGUsdGhpcy5fcGFyYW1zPW5ldyByLlBhcmFtcyx0aGlzLl9wYXJhbXMuYWRkUGFyYW0oMCksdGhpcy5fY29sbGVjdD0wLHRoaXMucHJlY2VkaW5nSm9pblN0YXRlPTAsdGhpcy5fcHJpbnRIYW5kbGVyRmI9KGUsdCxpKT0+e30sdGhpcy5fZXhlY3V0ZUhhbmRsZXJGYj1lPT57fSx0aGlzLl9jc2lIYW5kbGVyRmI9KGUsdCk9Pnt9LHRoaXMuX2VzY0hhbmRsZXJGYj1lPT57fSx0aGlzLl9lcnJvckhhbmRsZXJGYj1lPT5lLHRoaXMuX3ByaW50SGFuZGxlcj10aGlzLl9wcmludEhhbmRsZXJGYix0aGlzLl9leGVjdXRlSGFuZGxlcnM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9jc2lIYW5kbGVycz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX2VzY0hhbmRsZXJzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5yZWdpc3RlcigoMCxzLnRvRGlzcG9zYWJsZSkoKCgpPT57dGhpcy5fY3NpSGFuZGxlcnM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9leGVjdXRlSGFuZGxlcnM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9lc2NIYW5kbGVycz1PYmplY3QuY3JlYXRlKG51bGwpfSkpKSx0aGlzLl9vc2NQYXJzZXI9dGhpcy5yZWdpc3RlcihuZXcgbi5Pc2NQYXJzZXIpLHRoaXMuX2Rjc1BhcnNlcj10aGlzLnJlZ2lzdGVyKG5ldyBvLkRjc1BhcnNlciksdGhpcy5fZXJyb3JIYW5kbGVyPXRoaXMuX2Vycm9ySGFuZGxlckZiLHRoaXMucmVnaXN0ZXJFc2NIYW5kbGVyKHtmaW5hbDpcIlxcXFxcIn0sKCgpPT4hMCkpfV9pZGVudGlmaWVyKGUsdD1bNjQsMTI2XSl7bGV0IGk9MDtpZihlLnByZWZpeCl7aWYoZS5wcmVmaXgubGVuZ3RoPjEpdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgYnl0ZSBhcyBwcmVmaXggc3VwcG9ydGVkXCIpO2lmKGk9ZS5wcmVmaXguY2hhckNvZGVBdCgwKSxpJiY2MD5pfHxpPjYzKXRocm93IG5ldyBFcnJvcihcInByZWZpeCBtdXN0IGJlIGluIHJhbmdlIDB4M2MgLi4gMHgzZlwiKX1pZihlLmludGVybWVkaWF0ZXMpe2lmKGUuaW50ZXJtZWRpYXRlcy5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IHR3byBieXRlcyBhcyBpbnRlcm1lZGlhdGVzIGFyZSBzdXBwb3J0ZWRcIik7Zm9yKGxldCB0PTA7dDxlLmludGVybWVkaWF0ZXMubGVuZ3RoOysrdCl7Y29uc3Qgcz1lLmludGVybWVkaWF0ZXMuY2hhckNvZGVBdCh0KTtpZigzMj5zfHxzPjQ3KXRocm93IG5ldyBFcnJvcihcImludGVybWVkaWF0ZSBtdXN0IGJlIGluIHJhbmdlIDB4MjAgLi4gMHgyZlwiKTtpPDw9OCxpfD1zfX1pZigxIT09ZS5maW5hbC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmluYWwgbXVzdCBiZSBhIHNpbmdsZSBieXRlXCIpO2NvbnN0IHM9ZS5maW5hbC5jaGFyQ29kZUF0KDApO2lmKHRbMF0+c3x8cz50WzFdKXRocm93IG5ldyBFcnJvcihgZmluYWwgbXVzdCBiZSBpbiByYW5nZSAke3RbMF19IC4uICR7dFsxXX1gKTtyZXR1cm4gaTw8PTgsaXw9cyxpfWlkZW50VG9TdHJpbmcoZSl7Y29uc3QgdD1bXTtmb3IoO2U7KXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSZlKSksZT4+PTg7cmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4oXCJcIil9c2V0UHJpbnRIYW5kbGVyKGUpe3RoaXMuX3ByaW50SGFuZGxlcj1lfWNsZWFyUHJpbnRIYW5kbGVyKCl7dGhpcy5fcHJpbnRIYW5kbGVyPXRoaXMuX3ByaW50SGFuZGxlckZifXJlZ2lzdGVyRXNjSGFuZGxlcihlLHQpe2NvbnN0IGk9dGhpcy5faWRlbnRpZmllcihlLFs0OCwxMjZdKTt2b2lkIDA9PT10aGlzLl9lc2NIYW5kbGVyc1tpXSYmKHRoaXMuX2VzY0hhbmRsZXJzW2ldPVtdKTtjb25zdCBzPXRoaXMuX2VzY0hhbmRsZXJzW2ldO3JldHVybiBzLnB1c2godCkse2Rpc3Bvc2U6KCk9Pntjb25zdCBlPXMuaW5kZXhPZih0KTstMSE9PWUmJnMuc3BsaWNlKGUsMSl9fX1jbGVhckVzY0hhbmRsZXIoZSl7dGhpcy5fZXNjSGFuZGxlcnNbdGhpcy5faWRlbnRpZmllcihlLFs0OCwxMjZdKV0mJmRlbGV0ZSB0aGlzLl9lc2NIYW5kbGVyc1t0aGlzLl9pZGVudGlmaWVyKGUsWzQ4LDEyNl0pXX1zZXRFc2NIYW5kbGVyRmFsbGJhY2soZSl7dGhpcy5fZXNjSGFuZGxlckZiPWV9c2V0RXhlY3V0ZUhhbmRsZXIoZSx0KXt0aGlzLl9leGVjdXRlSGFuZGxlcnNbZS5jaGFyQ29kZUF0KDApXT10fWNsZWFyRXhlY3V0ZUhhbmRsZXIoZSl7dGhpcy5fZXhlY3V0ZUhhbmRsZXJzW2UuY2hhckNvZGVBdCgwKV0mJmRlbGV0ZSB0aGlzLl9leGVjdXRlSGFuZGxlcnNbZS5jaGFyQ29kZUF0KDApXX1zZXRFeGVjdXRlSGFuZGxlckZhbGxiYWNrKGUpe3RoaXMuX2V4ZWN1dGVIYW5kbGVyRmI9ZX1yZWdpc3RlckNzaUhhbmRsZXIoZSx0KXtjb25zdCBpPXRoaXMuX2lkZW50aWZpZXIoZSk7dm9pZCAwPT09dGhpcy5fY3NpSGFuZGxlcnNbaV0mJih0aGlzLl9jc2lIYW5kbGVyc1tpXT1bXSk7Y29uc3Qgcz10aGlzLl9jc2lIYW5kbGVyc1tpXTtyZXR1cm4gcy5wdXNoKHQpLHtkaXNwb3NlOigpPT57Y29uc3QgZT1zLmluZGV4T2YodCk7LTEhPT1lJiZzLnNwbGljZShlLDEpfX19Y2xlYXJDc2lIYW5kbGVyKGUpe3RoaXMuX2NzaUhhbmRsZXJzW3RoaXMuX2lkZW50aWZpZXIoZSldJiZkZWxldGUgdGhpcy5fY3NpSGFuZGxlcnNbdGhpcy5faWRlbnRpZmllcihlKV19c2V0Q3NpSGFuZGxlckZhbGxiYWNrKGUpe3RoaXMuX2NzaUhhbmRsZXJGYj1lfXJlZ2lzdGVyRGNzSGFuZGxlcihlLHQpe3JldHVybiB0aGlzLl9kY3NQYXJzZXIucmVnaXN0ZXJIYW5kbGVyKHRoaXMuX2lkZW50aWZpZXIoZSksdCl9Y2xlYXJEY3NIYW5kbGVyKGUpe3RoaXMuX2Rjc1BhcnNlci5jbGVhckhhbmRsZXIodGhpcy5faWRlbnRpZmllcihlKSl9c2V0RGNzSGFuZGxlckZhbGxiYWNrKGUpe3RoaXMuX2Rjc1BhcnNlci5zZXRIYW5kbGVyRmFsbGJhY2soZSl9cmVnaXN0ZXJPc2NIYW5kbGVyKGUsdCl7cmV0dXJuIHRoaXMuX29zY1BhcnNlci5yZWdpc3RlckhhbmRsZXIoZSx0KX1jbGVhck9zY0hhbmRsZXIoZSl7dGhpcy5fb3NjUGFyc2VyLmNsZWFySGFuZGxlcihlKX1zZXRPc2NIYW5kbGVyRmFsbGJhY2soZSl7dGhpcy5fb3NjUGFyc2VyLnNldEhhbmRsZXJGYWxsYmFjayhlKX1zZXRFcnJvckhhbmRsZXIoZSl7dGhpcy5fZXJyb3JIYW5kbGVyPWV9Y2xlYXJFcnJvckhhbmRsZXIoKXt0aGlzLl9lcnJvckhhbmRsZXI9dGhpcy5fZXJyb3JIYW5kbGVyRmJ9cmVzZXQoKXt0aGlzLmN1cnJlbnRTdGF0ZT10aGlzLmluaXRpYWxTdGF0ZSx0aGlzLl9vc2NQYXJzZXIucmVzZXQoKSx0aGlzLl9kY3NQYXJzZXIucmVzZXQoKSx0aGlzLl9wYXJhbXMucmVzZXQoKSx0aGlzLl9wYXJhbXMuYWRkUGFyYW0oMCksdGhpcy5fY29sbGVjdD0wLHRoaXMucHJlY2VkaW5nSm9pblN0YXRlPTAsMCE9PXRoaXMuX3BhcnNlU3RhY2suc3RhdGUmJih0aGlzLl9wYXJzZVN0YWNrLnN0YXRlPTIsdGhpcy5fcGFyc2VTdGFjay5oYW5kbGVycz1bXSl9X3ByZXNlcnZlU3RhY2soZSx0LGkscyxyKXt0aGlzLl9wYXJzZVN0YWNrLnN0YXRlPWUsdGhpcy5fcGFyc2VTdGFjay5oYW5kbGVycz10LHRoaXMuX3BhcnNlU3RhY2suaGFuZGxlclBvcz1pLHRoaXMuX3BhcnNlU3RhY2sudHJhbnNpdGlvbj1zLHRoaXMuX3BhcnNlU3RhY2suY2h1bmtQb3M9cn1wYXJzZShlLHQsaSl7bGV0IHMscj0wLG49MCxvPTA7aWYodGhpcy5fcGFyc2VTdGFjay5zdGF0ZSlpZigyPT09dGhpcy5fcGFyc2VTdGFjay5zdGF0ZSl0aGlzLl9wYXJzZVN0YWNrLnN0YXRlPTAsbz10aGlzLl9wYXJzZVN0YWNrLmNodW5rUG9zKzE7ZWxzZXtpZih2b2lkIDA9PT1pfHwxPT09dGhpcy5fcGFyc2VTdGFjay5zdGF0ZSl0aHJvdyB0aGlzLl9wYXJzZVN0YWNrLnN0YXRlPTEsbmV3IEVycm9yKFwiaW1wcm9wZXIgY29udGludWF0aW9uIGR1ZSB0byBwcmV2aW91cyBhc3luYyBoYW5kbGVyLCBnaXZpbmcgdXAgcGFyc2luZ1wiKTtjb25zdCB0PXRoaXMuX3BhcnNlU3RhY2suaGFuZGxlcnM7bGV0IG49dGhpcy5fcGFyc2VTdGFjay5oYW5kbGVyUG9zLTE7c3dpdGNoKHRoaXMuX3BhcnNlU3RhY2suc3RhdGUpe2Nhc2UgMzppZighMT09PWkmJm4+LTEpZm9yKDtuPj0wJiYocz10W25dKHRoaXMuX3BhcmFtcyksITAhPT1zKTtuLS0paWYocyBpbnN0YW5jZW9mIFByb21pc2UpcmV0dXJuIHRoaXMuX3BhcnNlU3RhY2suaGFuZGxlclBvcz1uLHM7dGhpcy5fcGFyc2VTdGFjay5oYW5kbGVycz1bXTticmVhaztjYXNlIDQ6aWYoITE9PT1pJiZuPi0xKWZvcig7bj49MCYmKHM9dFtuXSgpLCEwIT09cyk7bi0tKWlmKHMgaW5zdGFuY2VvZiBQcm9taXNlKXJldHVybiB0aGlzLl9wYXJzZVN0YWNrLmhhbmRsZXJQb3M9bixzO3RoaXMuX3BhcnNlU3RhY2suaGFuZGxlcnM9W107YnJlYWs7Y2FzZSA2OmlmKHI9ZVt0aGlzLl9wYXJzZVN0YWNrLmNodW5rUG9zXSxzPXRoaXMuX2Rjc1BhcnNlci51bmhvb2soMjQhPT1yJiYyNiE9PXIsaSkscylyZXR1cm4gczsyNz09PXImJih0aGlzLl9wYXJzZVN0YWNrLnRyYW5zaXRpb258PTEpLHRoaXMuX3BhcmFtcy5yZXNldCgpLHRoaXMuX3BhcmFtcy5hZGRQYXJhbSgwKSx0aGlzLl9jb2xsZWN0PTA7YnJlYWs7Y2FzZSA1OmlmKHI9ZVt0aGlzLl9wYXJzZVN0YWNrLmNodW5rUG9zXSxzPXRoaXMuX29zY1BhcnNlci5lbmQoMjQhPT1yJiYyNiE9PXIsaSkscylyZXR1cm4gczsyNz09PXImJih0aGlzLl9wYXJzZVN0YWNrLnRyYW5zaXRpb258PTEpLHRoaXMuX3BhcmFtcy5yZXNldCgpLHRoaXMuX3BhcmFtcy5hZGRQYXJhbSgwKSx0aGlzLl9jb2xsZWN0PTB9dGhpcy5fcGFyc2VTdGFjay5zdGF0ZT0wLG89dGhpcy5fcGFyc2VTdGFjay5jaHVua1BvcysxLHRoaXMucHJlY2VkaW5nSm9pblN0YXRlPTAsdGhpcy5jdXJyZW50U3RhdGU9MTUmdGhpcy5fcGFyc2VTdGFjay50cmFuc2l0aW9ufWZvcihsZXQgaT1vO2k8dDsrK2kpe3N3aXRjaChyPWVbaV0sbj10aGlzLl90cmFuc2l0aW9ucy50YWJsZVt0aGlzLmN1cnJlbnRTdGF0ZTw8OHwocjwxNjA/cjpoKV0sbj4+NCl7Y2FzZSAyOmZvcihsZXQgcz1pKzE7Oysrcyl7aWYocz49dHx8KHI9ZVtzXSk8MzJ8fHI+MTI2JiZyPGgpe3RoaXMuX3ByaW50SGFuZGxlcihlLGkscyksaT1zLTE7YnJlYWt9aWYoKytzPj10fHwocj1lW3NdKTwzMnx8cj4xMjYmJnI8aCl7dGhpcy5fcHJpbnRIYW5kbGVyKGUsaSxzKSxpPXMtMTticmVha31pZigrK3M+PXR8fChyPWVbc10pPDMyfHxyPjEyNiYmcjxoKXt0aGlzLl9wcmludEhhbmRsZXIoZSxpLHMpLGk9cy0xO2JyZWFrfWlmKCsrcz49dHx8KHI9ZVtzXSk8MzJ8fHI+MTI2JiZyPGgpe3RoaXMuX3ByaW50SGFuZGxlcihlLGkscyksaT1zLTE7YnJlYWt9fWJyZWFrO2Nhc2UgMzp0aGlzLl9leGVjdXRlSGFuZGxlcnNbcl0/dGhpcy5fZXhlY3V0ZUhhbmRsZXJzW3JdKCk6dGhpcy5fZXhlY3V0ZUhhbmRsZXJGYihyKSx0aGlzLnByZWNlZGluZ0pvaW5TdGF0ZT0wO2JyZWFrO2Nhc2UgMDpicmVhaztjYXNlIDE6aWYodGhpcy5fZXJyb3JIYW5kbGVyKHtwb3NpdGlvbjppLGNvZGU6cixjdXJyZW50U3RhdGU6dGhpcy5jdXJyZW50U3RhdGUsY29sbGVjdDp0aGlzLl9jb2xsZWN0LHBhcmFtczp0aGlzLl9wYXJhbXMsYWJvcnQ6ITF9KS5hYm9ydClyZXR1cm47YnJlYWs7Y2FzZSA3OmNvbnN0IG89dGhpcy5fY3NpSGFuZGxlcnNbdGhpcy5fY29sbGVjdDw8OHxyXTtsZXQgYT1vP28ubGVuZ3RoLTE6LTE7Zm9yKDthPj0wJiYocz1vW2FdKHRoaXMuX3BhcmFtcyksITAhPT1zKTthLS0paWYocyBpbnN0YW5jZW9mIFByb21pc2UpcmV0dXJuIHRoaXMuX3ByZXNlcnZlU3RhY2soMyxvLGEsbixpKSxzO2E8MCYmdGhpcy5fY3NpSGFuZGxlckZiKHRoaXMuX2NvbGxlY3Q8PDh8cix0aGlzLl9wYXJhbXMpLHRoaXMucHJlY2VkaW5nSm9pblN0YXRlPTA7YnJlYWs7Y2FzZSA4OmRve3N3aXRjaChyKXtjYXNlIDU5OnRoaXMuX3BhcmFtcy5hZGRQYXJhbSgwKTticmVhaztjYXNlIDU4OnRoaXMuX3BhcmFtcy5hZGRTdWJQYXJhbSgtMSk7YnJlYWs7ZGVmYXVsdDp0aGlzLl9wYXJhbXMuYWRkRGlnaXQoci00OCl9fXdoaWxlKCsraTx0JiYocj1lW2ldKT40NyYmcjw2MCk7aS0tO2JyZWFrO2Nhc2UgOTp0aGlzLl9jb2xsZWN0PDw9OCx0aGlzLl9jb2xsZWN0fD1yO2JyZWFrO2Nhc2UgMTA6Y29uc3QgYz10aGlzLl9lc2NIYW5kbGVyc1t0aGlzLl9jb2xsZWN0PDw4fHJdO2xldCBsPWM/Yy5sZW5ndGgtMTotMTtmb3IoO2w+PTAmJihzPWNbbF0oKSwhMCE9PXMpO2wtLSlpZihzIGluc3RhbmNlb2YgUHJvbWlzZSlyZXR1cm4gdGhpcy5fcHJlc2VydmVTdGFjayg0LGMsbCxuLGkpLHM7bDwwJiZ0aGlzLl9lc2NIYW5kbGVyRmIodGhpcy5fY29sbGVjdDw8OHxyKSx0aGlzLnByZWNlZGluZ0pvaW5TdGF0ZT0wO2JyZWFrO2Nhc2UgMTE6dGhpcy5fcGFyYW1zLnJlc2V0KCksdGhpcy5fcGFyYW1zLmFkZFBhcmFtKDApLHRoaXMuX2NvbGxlY3Q9MDticmVhaztjYXNlIDEyOnRoaXMuX2Rjc1BhcnNlci5ob29rKHRoaXMuX2NvbGxlY3Q8PDh8cix0aGlzLl9wYXJhbXMpO2JyZWFrO2Nhc2UgMTM6Zm9yKGxldCBzPWkrMTs7KytzKWlmKHM+PXR8fDI0PT09KHI9ZVtzXSl8fDI2PT09cnx8Mjc9PT1yfHxyPjEyNyYmcjxoKXt0aGlzLl9kY3NQYXJzZXIucHV0KGUsaSxzKSxpPXMtMTticmVha31icmVhaztjYXNlIDE0OmlmKHM9dGhpcy5fZGNzUGFyc2VyLnVuaG9vaygyNCE9PXImJjI2IT09cikscylyZXR1cm4gdGhpcy5fcHJlc2VydmVTdGFjayg2LFtdLDAsbixpKSxzOzI3PT09ciYmKG58PTEpLHRoaXMuX3BhcmFtcy5yZXNldCgpLHRoaXMuX3BhcmFtcy5hZGRQYXJhbSgwKSx0aGlzLl9jb2xsZWN0PTAsdGhpcy5wcmVjZWRpbmdKb2luU3RhdGU9MDticmVhaztjYXNlIDQ6dGhpcy5fb3NjUGFyc2VyLnN0YXJ0KCk7YnJlYWs7Y2FzZSA1OmZvcihsZXQgcz1pKzE7O3MrKylpZihzPj10fHwocj1lW3NdKTwzMnx8cj4xMjcmJnI8aCl7dGhpcy5fb3NjUGFyc2VyLnB1dChlLGkscyksaT1zLTE7YnJlYWt9YnJlYWs7Y2FzZSA2OmlmKHM9dGhpcy5fb3NjUGFyc2VyLmVuZCgyNCE9PXImJjI2IT09cikscylyZXR1cm4gdGhpcy5fcHJlc2VydmVTdGFjayg1LFtdLDAsbixpKSxzOzI3PT09ciYmKG58PTEpLHRoaXMuX3BhcmFtcy5yZXNldCgpLHRoaXMuX3BhcmFtcy5hZGRQYXJhbSgwKSx0aGlzLl9jb2xsZWN0PTAsdGhpcy5wcmVjZWRpbmdKb2luU3RhdGU9MH10aGlzLmN1cnJlbnRTdGF0ZT0xNSZufX19dC5Fc2NhcGVTZXF1ZW5jZVBhcnNlcj1jfSw2MjQyOihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk9zY0hhbmRsZXI9dC5Pc2NQYXJzZXI9dm9pZCAwO2NvbnN0IHM9aSg1NzcwKSxyPWkoNDgyKSxuPVtdO3QuT3NjUGFyc2VyPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5fc3RhdGU9MCx0aGlzLl9hY3RpdmU9bix0aGlzLl9pZD0tMSx0aGlzLl9oYW5kbGVycz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX2hhbmRsZXJGYj0oKT0+e30sdGhpcy5fc3RhY2s9e3BhdXNlZDohMSxsb29wUG9zaXRpb246MCxmYWxsVGhyb3VnaDohMX19cmVnaXN0ZXJIYW5kbGVyKGUsdCl7dm9pZCAwPT09dGhpcy5faGFuZGxlcnNbZV0mJih0aGlzLl9oYW5kbGVyc1tlXT1bXSk7Y29uc3QgaT10aGlzLl9oYW5kbGVyc1tlXTtyZXR1cm4gaS5wdXNoKHQpLHtkaXNwb3NlOigpPT57Y29uc3QgZT1pLmluZGV4T2YodCk7LTEhPT1lJiZpLnNwbGljZShlLDEpfX19Y2xlYXJIYW5kbGVyKGUpe3RoaXMuX2hhbmRsZXJzW2VdJiZkZWxldGUgdGhpcy5faGFuZGxlcnNbZV19c2V0SGFuZGxlckZhbGxiYWNrKGUpe3RoaXMuX2hhbmRsZXJGYj1lfWRpc3Bvc2UoKXt0aGlzLl9oYW5kbGVycz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX2hhbmRsZXJGYj0oKT0+e30sdGhpcy5fYWN0aXZlPW59cmVzZXQoKXtpZigyPT09dGhpcy5fc3RhdGUpZm9yKGxldCBlPXRoaXMuX3N0YWNrLnBhdXNlZD90aGlzLl9zdGFjay5sb29wUG9zaXRpb24tMTp0aGlzLl9hY3RpdmUubGVuZ3RoLTE7ZT49MDstLWUpdGhpcy5fYWN0aXZlW2VdLmVuZCghMSk7dGhpcy5fc3RhY2sucGF1c2VkPSExLHRoaXMuX2FjdGl2ZT1uLHRoaXMuX2lkPS0xLHRoaXMuX3N0YXRlPTB9X3N0YXJ0KCl7aWYodGhpcy5fYWN0aXZlPXRoaXMuX2hhbmRsZXJzW3RoaXMuX2lkXXx8bix0aGlzLl9hY3RpdmUubGVuZ3RoKWZvcihsZXQgZT10aGlzLl9hY3RpdmUubGVuZ3RoLTE7ZT49MDtlLS0pdGhpcy5fYWN0aXZlW2VdLnN0YXJ0KCk7ZWxzZSB0aGlzLl9oYW5kbGVyRmIodGhpcy5faWQsXCJTVEFSVFwiKX1fcHV0KGUsdCxpKXtpZih0aGlzLl9hY3RpdmUubGVuZ3RoKWZvcihsZXQgcz10aGlzLl9hY3RpdmUubGVuZ3RoLTE7cz49MDtzLS0pdGhpcy5fYWN0aXZlW3NdLnB1dChlLHQsaSk7ZWxzZSB0aGlzLl9oYW5kbGVyRmIodGhpcy5faWQsXCJQVVRcIiwoMCxyLnV0ZjMyVG9TdHJpbmcpKGUsdCxpKSl9c3RhcnQoKXt0aGlzLnJlc2V0KCksdGhpcy5fc3RhdGU9MX1wdXQoZSx0LGkpe2lmKDMhPT10aGlzLl9zdGF0ZSl7aWYoMT09PXRoaXMuX3N0YXRlKWZvcig7dDxpOyl7Y29uc3QgaT1lW3QrK107aWYoNTk9PT1pKXt0aGlzLl9zdGF0ZT0yLHRoaXMuX3N0YXJ0KCk7YnJlYWt9aWYoaTw0OHx8NTc8aSlyZXR1cm4gdm9pZCh0aGlzLl9zdGF0ZT0zKTstMT09PXRoaXMuX2lkJiYodGhpcy5faWQ9MCksdGhpcy5faWQ9MTAqdGhpcy5faWQraS00OH0yPT09dGhpcy5fc3RhdGUmJmktdD4wJiZ0aGlzLl9wdXQoZSx0LGkpfX1lbmQoZSx0PSEwKXtpZigwIT09dGhpcy5fc3RhdGUpe2lmKDMhPT10aGlzLl9zdGF0ZSlpZigxPT09dGhpcy5fc3RhdGUmJnRoaXMuX3N0YXJ0KCksdGhpcy5fYWN0aXZlLmxlbmd0aCl7bGV0IGk9ITEscz10aGlzLl9hY3RpdmUubGVuZ3RoLTEscj0hMTtpZih0aGlzLl9zdGFjay5wYXVzZWQmJihzPXRoaXMuX3N0YWNrLmxvb3BQb3NpdGlvbi0xLGk9dCxyPXRoaXMuX3N0YWNrLmZhbGxUaHJvdWdoLHRoaXMuX3N0YWNrLnBhdXNlZD0hMSksIXImJiExPT09aSl7Zm9yKDtzPj0wJiYoaT10aGlzLl9hY3RpdmVbc10uZW5kKGUpLCEwIT09aSk7cy0tKWlmKGkgaW5zdGFuY2VvZiBQcm9taXNlKXJldHVybiB0aGlzLl9zdGFjay5wYXVzZWQ9ITAsdGhpcy5fc3RhY2subG9vcFBvc2l0aW9uPXMsdGhpcy5fc3RhY2suZmFsbFRocm91Z2g9ITEsaTtzLS19Zm9yKDtzPj0wO3MtLSlpZihpPXRoaXMuX2FjdGl2ZVtzXS5lbmQoITEpLGkgaW5zdGFuY2VvZiBQcm9taXNlKXJldHVybiB0aGlzLl9zdGFjay5wYXVzZWQ9ITAsdGhpcy5fc3RhY2subG9vcFBvc2l0aW9uPXMsdGhpcy5fc3RhY2suZmFsbFRocm91Z2g9ITAsaX1lbHNlIHRoaXMuX2hhbmRsZXJGYih0aGlzLl9pZCxcIkVORFwiLGUpO3RoaXMuX2FjdGl2ZT1uLHRoaXMuX2lkPS0xLHRoaXMuX3N0YXRlPTB9fX0sdC5Pc2NIYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX2hhbmRsZXI9ZSx0aGlzLl9kYXRhPVwiXCIsdGhpcy5faGl0TGltaXQ9ITF9c3RhcnQoKXt0aGlzLl9kYXRhPVwiXCIsdGhpcy5faGl0TGltaXQ9ITF9cHV0KGUsdCxpKXt0aGlzLl9oaXRMaW1pdHx8KHRoaXMuX2RhdGErPSgwLHIudXRmMzJUb1N0cmluZykoZSx0LGkpLHRoaXMuX2RhdGEubGVuZ3RoPnMuUEFZTE9BRF9MSU1JVCYmKHRoaXMuX2RhdGE9XCJcIix0aGlzLl9oaXRMaW1pdD0hMCkpfWVuZChlKXtsZXQgdD0hMTtpZih0aGlzLl9oaXRMaW1pdCl0PSExO2Vsc2UgaWYoZSYmKHQ9dGhpcy5faGFuZGxlcih0aGlzLl9kYXRhKSx0IGluc3RhbmNlb2YgUHJvbWlzZSkpcmV0dXJuIHQudGhlbigoZT0+KHRoaXMuX2RhdGE9XCJcIix0aGlzLl9oaXRMaW1pdD0hMSxlKSkpO3JldHVybiB0aGlzLl9kYXRhPVwiXCIsdGhpcy5faGl0TGltaXQ9ITEsdH19fSw4NzQyOihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5QYXJhbXM9dm9pZCAwO2NvbnN0IGk9MjE0NzQ4MzY0NztjbGFzcyBze3N0YXRpYyBmcm9tQXJyYXkoZSl7Y29uc3QgdD1uZXcgcztpZighZS5sZW5ndGgpcmV0dXJuIHQ7Zm9yKGxldCBpPUFycmF5LmlzQXJyYXkoZVswXSk/MTowO2k8ZS5sZW5ndGg7KytpKXtjb25zdCBzPWVbaV07aWYoQXJyYXkuaXNBcnJheShzKSlmb3IobGV0IGU9MDtlPHMubGVuZ3RoOysrZSl0LmFkZFN1YlBhcmFtKHNbZV0pO2Vsc2UgdC5hZGRQYXJhbShzKX1yZXR1cm4gdH1jb25zdHJ1Y3RvcihlPTMyLHQ9MzIpe2lmKHRoaXMubWF4TGVuZ3RoPWUsdGhpcy5tYXhTdWJQYXJhbXNMZW5ndGg9dCx0PjI1Nil0aHJvdyBuZXcgRXJyb3IoXCJtYXhTdWJQYXJhbXNMZW5ndGggbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDI1NlwiKTt0aGlzLnBhcmFtcz1uZXcgSW50MzJBcnJheShlKSx0aGlzLmxlbmd0aD0wLHRoaXMuX3N1YlBhcmFtcz1uZXcgSW50MzJBcnJheSh0KSx0aGlzLl9zdWJQYXJhbXNMZW5ndGg9MCx0aGlzLl9zdWJQYXJhbXNJZHg9bmV3IFVpbnQxNkFycmF5KGUpLHRoaXMuX3JlamVjdERpZ2l0cz0hMSx0aGlzLl9yZWplY3RTdWJEaWdpdHM9ITEsdGhpcy5fZGlnaXRJc1N1Yj0hMX1jbG9uZSgpe2NvbnN0IGU9bmV3IHModGhpcy5tYXhMZW5ndGgsdGhpcy5tYXhTdWJQYXJhbXNMZW5ndGgpO3JldHVybiBlLnBhcmFtcy5zZXQodGhpcy5wYXJhbXMpLGUubGVuZ3RoPXRoaXMubGVuZ3RoLGUuX3N1YlBhcmFtcy5zZXQodGhpcy5fc3ViUGFyYW1zKSxlLl9zdWJQYXJhbXNMZW5ndGg9dGhpcy5fc3ViUGFyYW1zTGVuZ3RoLGUuX3N1YlBhcmFtc0lkeC5zZXQodGhpcy5fc3ViUGFyYW1zSWR4KSxlLl9yZWplY3REaWdpdHM9dGhpcy5fcmVqZWN0RGlnaXRzLGUuX3JlamVjdFN1YkRpZ2l0cz10aGlzLl9yZWplY3RTdWJEaWdpdHMsZS5fZGlnaXRJc1N1Yj10aGlzLl9kaWdpdElzU3ViLGV9dG9BcnJheSgpe2NvbnN0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLmxlbmd0aDsrK3Qpe2UucHVzaCh0aGlzLnBhcmFtc1t0XSk7Y29uc3QgaT10aGlzLl9zdWJQYXJhbXNJZHhbdF0+Pjgscz0yNTUmdGhpcy5fc3ViUGFyYW1zSWR4W3RdO3MtaT4wJiZlLnB1c2goQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fc3ViUGFyYW1zLGkscykpfXJldHVybiBlfXJlc2V0KCl7dGhpcy5sZW5ndGg9MCx0aGlzLl9zdWJQYXJhbXNMZW5ndGg9MCx0aGlzLl9yZWplY3REaWdpdHM9ITEsdGhpcy5fcmVqZWN0U3ViRGlnaXRzPSExLHRoaXMuX2RpZ2l0SXNTdWI9ITF9YWRkUGFyYW0oZSl7aWYodGhpcy5fZGlnaXRJc1N1Yj0hMSx0aGlzLmxlbmd0aD49dGhpcy5tYXhMZW5ndGgpdGhpcy5fcmVqZWN0RGlnaXRzPSEwO2Vsc2V7aWYoZTwtMSl0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZXMgbGVzc2VyIHRoYW4gLTEgYXJlIG5vdCBhbGxvd2VkXCIpO3RoaXMuX3N1YlBhcmFtc0lkeFt0aGlzLmxlbmd0aF09dGhpcy5fc3ViUGFyYW1zTGVuZ3RoPDw4fHRoaXMuX3N1YlBhcmFtc0xlbmd0aCx0aGlzLnBhcmFtc1t0aGlzLmxlbmd0aCsrXT1lPmk/aTplfX1hZGRTdWJQYXJhbShlKXtpZih0aGlzLl9kaWdpdElzU3ViPSEwLHRoaXMubGVuZ3RoKWlmKHRoaXMuX3JlamVjdERpZ2l0c3x8dGhpcy5fc3ViUGFyYW1zTGVuZ3RoPj10aGlzLm1heFN1YlBhcmFtc0xlbmd0aCl0aGlzLl9yZWplY3RTdWJEaWdpdHM9ITA7ZWxzZXtpZihlPC0xKXRocm93IG5ldyBFcnJvcihcInZhbHVlcyBsZXNzZXIgdGhhbiAtMSBhcmUgbm90IGFsbG93ZWRcIik7dGhpcy5fc3ViUGFyYW1zW3RoaXMuX3N1YlBhcmFtc0xlbmd0aCsrXT1lPmk/aTplLHRoaXMuX3N1YlBhcmFtc0lkeFt0aGlzLmxlbmd0aC0xXSsrfX1oYXNTdWJQYXJhbXMoZSl7cmV0dXJuKDI1NSZ0aGlzLl9zdWJQYXJhbXNJZHhbZV0pLSh0aGlzLl9zdWJQYXJhbXNJZHhbZV0+PjgpPjB9Z2V0U3ViUGFyYW1zKGUpe2NvbnN0IHQ9dGhpcy5fc3ViUGFyYW1zSWR4W2VdPj44LGk9MjU1JnRoaXMuX3N1YlBhcmFtc0lkeFtlXTtyZXR1cm4gaS10PjA/dGhpcy5fc3ViUGFyYW1zLnN1YmFycmF5KHQsaSk6bnVsbH1nZXRTdWJQYXJhbXNBbGwoKXtjb25zdCBlPXt9O2ZvcihsZXQgdD0wO3Q8dGhpcy5sZW5ndGg7Kyt0KXtjb25zdCBpPXRoaXMuX3N1YlBhcmFtc0lkeFt0XT4+OCxzPTI1NSZ0aGlzLl9zdWJQYXJhbXNJZHhbdF07cy1pPjAmJihlW3RdPXRoaXMuX3N1YlBhcmFtcy5zbGljZShpLHMpKX1yZXR1cm4gZX1hZGREaWdpdChlKXtsZXQgdDtpZih0aGlzLl9yZWplY3REaWdpdHN8fCEodD10aGlzLl9kaWdpdElzU3ViP3RoaXMuX3N1YlBhcmFtc0xlbmd0aDp0aGlzLmxlbmd0aCl8fHRoaXMuX2RpZ2l0SXNTdWImJnRoaXMuX3JlamVjdFN1YkRpZ2l0cylyZXR1cm47Y29uc3Qgcz10aGlzLl9kaWdpdElzU3ViP3RoaXMuX3N1YlBhcmFtczp0aGlzLnBhcmFtcyxyPXNbdC0xXTtzW3QtMV09fnI/TWF0aC5taW4oMTAqcitlLGkpOmV9fXQuUGFyYW1zPXN9LDU3NDE6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkFkZG9uTWFuYWdlcj12b2lkIDAsdC5BZGRvbk1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLl9hZGRvbnM9W119ZGlzcG9zZSgpe2ZvcihsZXQgZT10aGlzLl9hZGRvbnMubGVuZ3RoLTE7ZT49MDtlLS0pdGhpcy5fYWRkb25zW2VdLmluc3RhbmNlLmRpc3Bvc2UoKX1sb2FkQWRkb24oZSx0KXtjb25zdCBpPXtpbnN0YW5jZTp0LGRpc3Bvc2U6dC5kaXNwb3NlLGlzRGlzcG9zZWQ6ITF9O3RoaXMuX2FkZG9ucy5wdXNoKGkpLHQuZGlzcG9zZT0oKT0+dGhpcy5fd3JhcHBlZEFkZG9uRGlzcG9zZShpKSx0LmFjdGl2YXRlKGUpfV93cmFwcGVkQWRkb25EaXNwb3NlKGUpe2lmKGUuaXNEaXNwb3NlZClyZXR1cm47bGV0IHQ9LTE7Zm9yKGxldCBpPTA7aTx0aGlzLl9hZGRvbnMubGVuZ3RoO2krKylpZih0aGlzLl9hZGRvbnNbaV09PT1lKXt0PWk7YnJlYWt9aWYoLTE9PT10KXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkaXNwb3NlIGFuIGFkZG9uIHRoYXQgaGFzIG5vdCBiZWVuIGxvYWRlZFwiKTtlLmlzRGlzcG9zZWQ9ITAsZS5kaXNwb3NlLmFwcGx5KGUuaW5zdGFuY2UpLHRoaXMuX2FkZG9ucy5zcGxpY2UodCwxKX19fSw4NzcxOihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkJ1ZmZlckFwaVZpZXc9dm9pZCAwO2NvbnN0IHM9aSgzNzg1KSxyPWkoNTExKTt0LkJ1ZmZlckFwaVZpZXc9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl9idWZmZXI9ZSx0aGlzLnR5cGU9dH1pbml0KGUpe3JldHVybiB0aGlzLl9idWZmZXI9ZSx0aGlzfWdldCBjdXJzb3JZKCl7cmV0dXJuIHRoaXMuX2J1ZmZlci55fWdldCBjdXJzb3JYKCl7cmV0dXJuIHRoaXMuX2J1ZmZlci54fWdldCB2aWV3cG9ydFkoKXtyZXR1cm4gdGhpcy5fYnVmZmVyLnlkaXNwfWdldCBiYXNlWSgpe3JldHVybiB0aGlzLl9idWZmZXIueWJhc2V9Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLl9idWZmZXIubGluZXMubGVuZ3RofWdldExpbmUoZSl7Y29uc3QgdD10aGlzLl9idWZmZXIubGluZXMuZ2V0KGUpO2lmKHQpcmV0dXJuIG5ldyBzLkJ1ZmZlckxpbmVBcGlWaWV3KHQpfWdldE51bGxDZWxsKCl7cmV0dXJuIG5ldyByLkNlbGxEYXRhfX19LDM3ODU6KGUsdCxpKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuQnVmZmVyTGluZUFwaVZpZXc9dm9pZCAwO2NvbnN0IHM9aSg1MTEpO3QuQnVmZmVyTGluZUFwaVZpZXc9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbGluZT1lfWdldCBpc1dyYXBwZWQoKXtyZXR1cm4gdGhpcy5fbGluZS5pc1dyYXBwZWR9Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLl9saW5lLmxlbmd0aH1nZXRDZWxsKGUsdCl7aWYoIShlPDB8fGU+PXRoaXMuX2xpbmUubGVuZ3RoKSlyZXR1cm4gdD8odGhpcy5fbGluZS5sb2FkQ2VsbChlLHQpLHQpOnRoaXMuX2xpbmUubG9hZENlbGwoZSxuZXcgcy5DZWxsRGF0YSl9dHJhbnNsYXRlVG9TdHJpbmcoZSx0LGkpe3JldHVybiB0aGlzLl9saW5lLnRyYW5zbGF0ZVRvU3RyaW5nKGUsdCxpKX19fSw4Mjg1OihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkJ1ZmZlck5hbWVzcGFjZUFwaT12b2lkIDA7Y29uc3Qgcz1pKDg3NzEpLHI9aSg4NDYwKSxuPWkoODQ0KTtjbGFzcyBvIGV4dGVuZHMgbi5EaXNwb3NhYmxle2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5fY29yZT1lLHRoaXMuX29uQnVmZmVyQ2hhbmdlPXRoaXMucmVnaXN0ZXIobmV3IHIuRXZlbnRFbWl0dGVyKSx0aGlzLm9uQnVmZmVyQ2hhbmdlPXRoaXMuX29uQnVmZmVyQ2hhbmdlLmV2ZW50LHRoaXMuX25vcm1hbD1uZXcgcy5CdWZmZXJBcGlWaWV3KHRoaXMuX2NvcmUuYnVmZmVycy5ub3JtYWwsXCJub3JtYWxcIiksdGhpcy5fYWx0ZXJuYXRlPW5ldyBzLkJ1ZmZlckFwaVZpZXcodGhpcy5fY29yZS5idWZmZXJzLmFsdCxcImFsdGVybmF0ZVwiKSx0aGlzLl9jb3JlLmJ1ZmZlcnMub25CdWZmZXJBY3RpdmF0ZSgoKCk9PnRoaXMuX29uQnVmZmVyQ2hhbmdlLmZpcmUodGhpcy5hY3RpdmUpKSl9Z2V0IGFjdGl2ZSgpe2lmKHRoaXMuX2NvcmUuYnVmZmVycy5hY3RpdmU9PT10aGlzLl9jb3JlLmJ1ZmZlcnMubm9ybWFsKXJldHVybiB0aGlzLm5vcm1hbDtpZih0aGlzLl9jb3JlLmJ1ZmZlcnMuYWN0aXZlPT09dGhpcy5fY29yZS5idWZmZXJzLmFsdClyZXR1cm4gdGhpcy5hbHRlcm5hdGU7dGhyb3cgbmV3IEVycm9yKFwiQWN0aXZlIGJ1ZmZlciBpcyBuZWl0aGVyIG5vcm1hbCBub3IgYWx0ZXJuYXRlXCIpfWdldCBub3JtYWwoKXtyZXR1cm4gdGhpcy5fbm9ybWFsLmluaXQodGhpcy5fY29yZS5idWZmZXJzLm5vcm1hbCl9Z2V0IGFsdGVybmF0ZSgpe3JldHVybiB0aGlzLl9hbHRlcm5hdGUuaW5pdCh0aGlzLl9jb3JlLmJ1ZmZlcnMuYWx0KX19dC5CdWZmZXJOYW1lc3BhY2VBcGk9b30sNzk3NTooZSx0KT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuUGFyc2VyQXBpPXZvaWQgMCx0LlBhcnNlckFwaT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9jb3JlPWV9cmVnaXN0ZXJDc2lIYW5kbGVyKGUsdCl7cmV0dXJuIHRoaXMuX2NvcmUucmVnaXN0ZXJDc2lIYW5kbGVyKGUsKGU9PnQoZS50b0FycmF5KCkpKSl9YWRkQ3NpSGFuZGxlcihlLHQpe3JldHVybiB0aGlzLnJlZ2lzdGVyQ3NpSGFuZGxlcihlLHQpfXJlZ2lzdGVyRGNzSGFuZGxlcihlLHQpe3JldHVybiB0aGlzLl9jb3JlLnJlZ2lzdGVyRGNzSGFuZGxlcihlLCgoZSxpKT0+dChlLGkudG9BcnJheSgpKSkpfWFkZERjc0hhbmRsZXIoZSx0KXtyZXR1cm4gdGhpcy5yZWdpc3RlckRjc0hhbmRsZXIoZSx0KX1yZWdpc3RlckVzY0hhbmRsZXIoZSx0KXtyZXR1cm4gdGhpcy5fY29yZS5yZWdpc3RlckVzY0hhbmRsZXIoZSx0KX1hZGRFc2NIYW5kbGVyKGUsdCl7cmV0dXJuIHRoaXMucmVnaXN0ZXJFc2NIYW5kbGVyKGUsdCl9cmVnaXN0ZXJPc2NIYW5kbGVyKGUsdCl7cmV0dXJuIHRoaXMuX2NvcmUucmVnaXN0ZXJPc2NIYW5kbGVyKGUsdCl9YWRkT3NjSGFuZGxlcihlLHQpe3JldHVybiB0aGlzLnJlZ2lzdGVyT3NjSGFuZGxlcihlLHQpfX19LDcwOTA6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlVuaWNvZGVBcGk9dm9pZCAwLHQuVW5pY29kZUFwaT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9jb3JlPWV9cmVnaXN0ZXIoZSl7dGhpcy5fY29yZS51bmljb2RlU2VydmljZS5yZWdpc3RlcihlKX1nZXQgdmVyc2lvbnMoKXtyZXR1cm4gdGhpcy5fY29yZS51bmljb2RlU2VydmljZS52ZXJzaW9uc31nZXQgYWN0aXZlVmVyc2lvbigpe3JldHVybiB0aGlzLl9jb3JlLnVuaWNvZGVTZXJ2aWNlLmFjdGl2ZVZlcnNpb259c2V0IGFjdGl2ZVZlcnNpb24oZSl7dGhpcy5fY29yZS51bmljb2RlU2VydmljZS5hY3RpdmVWZXJzaW9uPWV9fX0sNzQ0OmZ1bmN0aW9uKGUsdCxpKXt2YXIgcz10aGlzJiZ0aGlzLl9fZGVjb3JhdGV8fGZ1bmN0aW9uKGUsdCxpLHMpe3ZhciByLG49YXJndW1lbnRzLmxlbmd0aCxvPW48Mz90Om51bGw9PT1zP3M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGkpOnM7aWYoXCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3QmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUpbz1SZWZsZWN0LmRlY29yYXRlKGUsdCxpLHMpO2Vsc2UgZm9yKHZhciBhPWUubGVuZ3RoLTE7YT49MDthLS0pKHI9ZVthXSkmJihvPShuPDM/cihvKTpuPjM/cih0LGksbyk6cih0LGkpKXx8byk7cmV0dXJuIG4+MyYmbyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaSxvKSxvfSxyPXRoaXMmJnRoaXMuX19wYXJhbXx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oaSxzKXt0KGkscyxlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuQnVmZmVyU2VydmljZT10Lk1JTklNVU1fUk9XUz10Lk1JTklNVU1fQ09MUz12b2lkIDA7Y29uc3Qgbj1pKDg0NjApLG89aSg4NDQpLGE9aSg1Mjk1KSxoPWkoMjU4NSk7dC5NSU5JTVVNX0NPTFM9Mix0Lk1JTklNVU1fUk9XUz0xO2xldCBjPXQuQnVmZmVyU2VydmljZT1jbGFzcyBleHRlbmRzIG8uRGlzcG9zYWJsZXtnZXQgYnVmZmVyKCl7cmV0dXJuIHRoaXMuYnVmZmVycy5hY3RpdmV9Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmlzVXNlclNjcm9sbGluZz0hMSx0aGlzLl9vblJlc2l6ZT10aGlzLnJlZ2lzdGVyKG5ldyBuLkV2ZW50RW1pdHRlciksdGhpcy5vblJlc2l6ZT10aGlzLl9vblJlc2l6ZS5ldmVudCx0aGlzLl9vblNjcm9sbD10aGlzLnJlZ2lzdGVyKG5ldyBuLkV2ZW50RW1pdHRlciksdGhpcy5vblNjcm9sbD10aGlzLl9vblNjcm9sbC5ldmVudCx0aGlzLmNvbHM9TWF0aC5tYXgoZS5yYXdPcHRpb25zLmNvbHN8fDAsdC5NSU5JTVVNX0NPTFMpLHRoaXMucm93cz1NYXRoLm1heChlLnJhd09wdGlvbnMucm93c3x8MCx0Lk1JTklNVU1fUk9XUyksdGhpcy5idWZmZXJzPXRoaXMucmVnaXN0ZXIobmV3IGEuQnVmZmVyU2V0KGUsdGhpcykpfXJlc2l6ZShlLHQpe3RoaXMuY29scz1lLHRoaXMucm93cz10LHRoaXMuYnVmZmVycy5yZXNpemUoZSx0KSx0aGlzLl9vblJlc2l6ZS5maXJlKHtjb2xzOmUscm93czp0fSl9cmVzZXQoKXt0aGlzLmJ1ZmZlcnMucmVzZXQoKSx0aGlzLmlzVXNlclNjcm9sbGluZz0hMX1zY3JvbGwoZSx0PSExKXtjb25zdCBpPXRoaXMuYnVmZmVyO2xldCBzO3M9dGhpcy5fY2FjaGVkQmxhbmtMaW5lLHMmJnMubGVuZ3RoPT09dGhpcy5jb2xzJiZzLmdldEZnKDApPT09ZS5mZyYmcy5nZXRCZygwKT09PWUuYmd8fChzPWkuZ2V0QmxhbmtMaW5lKGUsdCksdGhpcy5fY2FjaGVkQmxhbmtMaW5lPXMpLHMuaXNXcmFwcGVkPXQ7Y29uc3Qgcj1pLnliYXNlK2kuc2Nyb2xsVG9wLG49aS55YmFzZStpLnNjcm9sbEJvdHRvbTtpZigwPT09aS5zY3JvbGxUb3Ape2NvbnN0IGU9aS5saW5lcy5pc0Z1bGw7bj09PWkubGluZXMubGVuZ3RoLTE/ZT9pLmxpbmVzLnJlY3ljbGUoKS5jb3B5RnJvbShzKTppLmxpbmVzLnB1c2gocy5jbG9uZSgpKTppLmxpbmVzLnNwbGljZShuKzEsMCxzLmNsb25lKCkpLGU/dGhpcy5pc1VzZXJTY3JvbGxpbmcmJihpLnlkaXNwPU1hdGgubWF4KGkueWRpc3AtMSwwKSk6KGkueWJhc2UrKyx0aGlzLmlzVXNlclNjcm9sbGluZ3x8aS55ZGlzcCsrKX1lbHNle2NvbnN0IGU9bi1yKzE7aS5saW5lcy5zaGlmdEVsZW1lbnRzKHIrMSxlLTEsLTEpLGkubGluZXMuc2V0KG4scy5jbG9uZSgpKX10aGlzLmlzVXNlclNjcm9sbGluZ3x8KGkueWRpc3A9aS55YmFzZSksdGhpcy5fb25TY3JvbGwuZmlyZShpLnlkaXNwKX1zY3JvbGxMaW5lcyhlLHQsaSl7Y29uc3Qgcz10aGlzLmJ1ZmZlcjtpZihlPDApe2lmKDA9PT1zLnlkaXNwKXJldHVybjt0aGlzLmlzVXNlclNjcm9sbGluZz0hMH1lbHNlIGUrcy55ZGlzcD49cy55YmFzZSYmKHRoaXMuaXNVc2VyU2Nyb2xsaW5nPSExKTtjb25zdCByPXMueWRpc3A7cy55ZGlzcD1NYXRoLm1heChNYXRoLm1pbihzLnlkaXNwK2Uscy55YmFzZSksMCksciE9PXMueWRpc3AmJih0fHx0aGlzLl9vblNjcm9sbC5maXJlKHMueWRpc3ApKX19O3QuQnVmZmVyU2VydmljZT1jPXMoW3IoMCxoLklPcHRpb25zU2VydmljZSldLGMpfSw3OTk0OihlLHQpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5DaGFyc2V0U2VydmljZT12b2lkIDAsdC5DaGFyc2V0U2VydmljZT1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuZ2xldmVsPTAsdGhpcy5fY2hhcnNldHM9W119cmVzZXQoKXt0aGlzLmNoYXJzZXQ9dm9pZCAwLHRoaXMuX2NoYXJzZXRzPVtdLHRoaXMuZ2xldmVsPTB9c2V0Z0xldmVsKGUpe3RoaXMuZ2xldmVsPWUsdGhpcy5jaGFyc2V0PXRoaXMuX2NoYXJzZXRzW2VdfXNldGdDaGFyc2V0KGUsdCl7dGhpcy5fY2hhcnNldHNbZV09dCx0aGlzLmdsZXZlbD09PWUmJih0aGlzLmNoYXJzZXQ9dCl9fX0sMTc1MzpmdW5jdGlvbihlLHQsaSl7dmFyIHM9dGhpcyYmdGhpcy5fX2RlY29yYXRlfHxmdW5jdGlvbihlLHQsaSxzKXt2YXIgcixuPWFyZ3VtZW50cy5sZW5ndGgsbz1uPDM/dDpudWxsPT09cz9zPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxpKTpzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZWZsZWN0LmRlY29yYXRlKW89UmVmbGVjdC5kZWNvcmF0ZShlLHQsaSxzKTtlbHNlIGZvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTA7YS0tKShyPWVbYV0pJiYobz0objwzP3Iobyk6bj4zP3IodCxpLG8pOnIodCxpKSl8fG8pO3JldHVybiBuPjMmJm8mJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGksbyksb30scj10aGlzJiZ0aGlzLl9fcGFyYW18fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkscyl7dChpLHMsZSl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkNvcmVNb3VzZVNlcnZpY2U9dm9pZCAwO2NvbnN0IG49aSgyNTg1KSxvPWkoODQ2MCksYT1pKDg0NCksaD17Tk9ORTp7ZXZlbnRzOjAscmVzdHJpY3Q6KCk9PiExfSxYMTA6e2V2ZW50czoxLHJlc3RyaWN0OmU9PjQhPT1lLmJ1dHRvbiYmMT09PWUuYWN0aW9uJiYoZS5jdHJsPSExLGUuYWx0PSExLGUuc2hpZnQ9ITEsITApfSxWVDIwMDp7ZXZlbnRzOjE5LHJlc3RyaWN0OmU9PjMyIT09ZS5hY3Rpb259LERSQUc6e2V2ZW50czoyMyxyZXN0cmljdDplPT4zMiE9PWUuYWN0aW9ufHwzIT09ZS5idXR0b259LEFOWTp7ZXZlbnRzOjMxLHJlc3RyaWN0OmU9PiEwfX07ZnVuY3Rpb24gYyhlLHQpe2xldCBpPShlLmN0cmw/MTY6MCl8KGUuc2hpZnQ/NDowKXwoZS5hbHQ/ODowKTtyZXR1cm4gND09PWUuYnV0dG9uPyhpfD02NCxpfD1lLmFjdGlvbik6KGl8PTMmZS5idXR0b24sNCZlLmJ1dHRvbiYmKGl8PTY0KSw4JmUuYnV0dG9uJiYoaXw9MTI4KSwzMj09PWUuYWN0aW9uP2l8PTMyOjAhPT1lLmFjdGlvbnx8dHx8KGl8PTMpKSxpfWNvbnN0IGw9U3RyaW5nLmZyb21DaGFyQ29kZSxkPXtERUZBVUxUOmU9Pntjb25zdCB0PVtjKGUsITEpKzMyLGUuY29sKzMyLGUucm93KzMyXTtyZXR1cm4gdFswXT4yNTV8fHRbMV0+MjU1fHx0WzJdPjI1NT9cIlwiOmBcdTAwMWJbTSR7bCh0WzBdKX0ke2wodFsxXSl9JHtsKHRbMl0pfWB9LFNHUjplPT57Y29uc3QgdD0wPT09ZS5hY3Rpb24mJjQhPT1lLmJ1dHRvbj9cIm1cIjpcIk1cIjtyZXR1cm5gXHUwMDFiWzwke2MoZSwhMCl9OyR7ZS5jb2x9OyR7ZS5yb3d9JHt0fWB9LFNHUl9QSVhFTFM6ZT0+e2NvbnN0IHQ9MD09PWUuYWN0aW9uJiY0IT09ZS5idXR0b24/XCJtXCI6XCJNXCI7cmV0dXJuYFx1MDAxYls8JHtjKGUsITApfTske2UueH07JHtlLnl9JHt0fWB9fTtsZXQgXz10LkNvcmVNb3VzZVNlcnZpY2U9Y2xhc3MgZXh0ZW5kcyBhLkRpc3Bvc2FibGV7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMuX2J1ZmZlclNlcnZpY2U9ZSx0aGlzLl9jb3JlU2VydmljZT10LHRoaXMuX3Byb3RvY29scz17fSx0aGlzLl9lbmNvZGluZ3M9e30sdGhpcy5fYWN0aXZlUHJvdG9jb2w9XCJcIix0aGlzLl9hY3RpdmVFbmNvZGluZz1cIlwiLHRoaXMuX2xhc3RFdmVudD1udWxsLHRoaXMuX29uUHJvdG9jb2xDaGFuZ2U9dGhpcy5yZWdpc3RlcihuZXcgby5FdmVudEVtaXR0ZXIpLHRoaXMub25Qcm90b2NvbENoYW5nZT10aGlzLl9vblByb3RvY29sQ2hhbmdlLmV2ZW50O2Zvcihjb25zdCBlIG9mIE9iamVjdC5rZXlzKGgpKXRoaXMuYWRkUHJvdG9jb2woZSxoW2VdKTtmb3IoY29uc3QgZSBvZiBPYmplY3Qua2V5cyhkKSl0aGlzLmFkZEVuY29kaW5nKGUsZFtlXSk7dGhpcy5yZXNldCgpfWFkZFByb3RvY29sKGUsdCl7dGhpcy5fcHJvdG9jb2xzW2VdPXR9YWRkRW5jb2RpbmcoZSx0KXt0aGlzLl9lbmNvZGluZ3NbZV09dH1nZXQgYWN0aXZlUHJvdG9jb2woKXtyZXR1cm4gdGhpcy5fYWN0aXZlUHJvdG9jb2x9Z2V0IGFyZU1vdXNlRXZlbnRzQWN0aXZlKCl7cmV0dXJuIDAhPT10aGlzLl9wcm90b2NvbHNbdGhpcy5fYWN0aXZlUHJvdG9jb2xdLmV2ZW50c31zZXQgYWN0aXZlUHJvdG9jb2woZSl7aWYoIXRoaXMuX3Byb3RvY29sc1tlXSl0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gcHJvdG9jb2wgXCIke2V9XCJgKTt0aGlzLl9hY3RpdmVQcm90b2NvbD1lLHRoaXMuX29uUHJvdG9jb2xDaGFuZ2UuZmlyZSh0aGlzLl9wcm90b2NvbHNbZV0uZXZlbnRzKX1nZXQgYWN0aXZlRW5jb2RpbmcoKXtyZXR1cm4gdGhpcy5fYWN0aXZlRW5jb2Rpbmd9c2V0IGFjdGl2ZUVuY29kaW5nKGUpe2lmKCF0aGlzLl9lbmNvZGluZ3NbZV0pdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGVuY29kaW5nIFwiJHtlfVwiYCk7dGhpcy5fYWN0aXZlRW5jb2Rpbmc9ZX1yZXNldCgpe3RoaXMuYWN0aXZlUHJvdG9jb2w9XCJOT05FXCIsdGhpcy5hY3RpdmVFbmNvZGluZz1cIkRFRkFVTFRcIix0aGlzLl9sYXN0RXZlbnQ9bnVsbH10cmlnZ2VyTW91c2VFdmVudChlKXtpZihlLmNvbDwwfHxlLmNvbD49dGhpcy5fYnVmZmVyU2VydmljZS5jb2xzfHxlLnJvdzwwfHxlLnJvdz49dGhpcy5fYnVmZmVyU2VydmljZS5yb3dzKXJldHVybiExO2lmKDQ9PT1lLmJ1dHRvbiYmMzI9PT1lLmFjdGlvbilyZXR1cm4hMTtpZigzPT09ZS5idXR0b24mJjMyIT09ZS5hY3Rpb24pcmV0dXJuITE7aWYoNCE9PWUuYnV0dG9uJiYoMj09PWUuYWN0aW9ufHwzPT09ZS5hY3Rpb24pKXJldHVybiExO2lmKGUuY29sKyssZS5yb3crKywzMj09PWUuYWN0aW9uJiZ0aGlzLl9sYXN0RXZlbnQmJnRoaXMuX2VxdWFsRXZlbnRzKHRoaXMuX2xhc3RFdmVudCxlLFwiU0dSX1BJWEVMU1wiPT09dGhpcy5fYWN0aXZlRW5jb2RpbmcpKXJldHVybiExO2lmKCF0aGlzLl9wcm90b2NvbHNbdGhpcy5fYWN0aXZlUHJvdG9jb2xdLnJlc3RyaWN0KGUpKXJldHVybiExO2NvbnN0IHQ9dGhpcy5fZW5jb2RpbmdzW3RoaXMuX2FjdGl2ZUVuY29kaW5nXShlKTtyZXR1cm4gdCYmKFwiREVGQVVMVFwiPT09dGhpcy5fYWN0aXZlRW5jb2Rpbmc/dGhpcy5fY29yZVNlcnZpY2UudHJpZ2dlckJpbmFyeUV2ZW50KHQpOnRoaXMuX2NvcmVTZXJ2aWNlLnRyaWdnZXJEYXRhRXZlbnQodCwhMCkpLHRoaXMuX2xhc3RFdmVudD1lLCEwfWV4cGxhaW5FdmVudHMoZSl7cmV0dXJue2Rvd246ISEoMSZlKSx1cDohISgyJmUpLGRyYWc6ISEoNCZlKSxtb3ZlOiEhKDgmZSksd2hlZWw6ISEoMTYmZSl9fV9lcXVhbEV2ZW50cyhlLHQsaSl7aWYoaSl7aWYoZS54IT09dC54KXJldHVybiExO2lmKGUueSE9PXQueSlyZXR1cm4hMX1lbHNle2lmKGUuY29sIT09dC5jb2wpcmV0dXJuITE7aWYoZS5yb3chPT10LnJvdylyZXR1cm4hMX1yZXR1cm4gZS5idXR0b249PT10LmJ1dHRvbiYmZS5hY3Rpb249PT10LmFjdGlvbiYmZS5jdHJsPT09dC5jdHJsJiZlLmFsdD09PXQuYWx0JiZlLnNoaWZ0PT09dC5zaGlmdH19O3QuQ29yZU1vdXNlU2VydmljZT1fPXMoW3IoMCxuLklCdWZmZXJTZXJ2aWNlKSxyKDEsbi5JQ29yZVNlcnZpY2UpXSxfKX0sNjk3NTpmdW5jdGlvbihlLHQsaSl7dmFyIHM9dGhpcyYmdGhpcy5fX2RlY29yYXRlfHxmdW5jdGlvbihlLHQsaSxzKXt2YXIgcixuPWFyZ3VtZW50cy5sZW5ndGgsbz1uPDM/dDpudWxsPT09cz9zPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxpKTpzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZWZsZWN0LmRlY29yYXRlKW89UmVmbGVjdC5kZWNvcmF0ZShlLHQsaSxzKTtlbHNlIGZvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTA7YS0tKShyPWVbYV0pJiYobz0objwzP3Iobyk6bj4zP3IodCxpLG8pOnIodCxpKSl8fG8pO3JldHVybiBuPjMmJm8mJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGksbyksb30scj10aGlzJiZ0aGlzLl9fcGFyYW18fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkscyl7dChpLHMsZSl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkNvcmVTZXJ2aWNlPXZvaWQgMDtjb25zdCBuPWkoMTQzOSksbz1pKDg0NjApLGE9aSg4NDQpLGg9aSgyNTg1KSxjPU9iamVjdC5mcmVlemUoe2luc2VydE1vZGU6ITF9KSxsPU9iamVjdC5mcmVlemUoe2FwcGxpY2F0aW9uQ3Vyc29yS2V5czohMSxhcHBsaWNhdGlvbktleXBhZDohMSxicmFja2V0ZWRQYXN0ZU1vZGU6ITEsb3JpZ2luOiExLHJldmVyc2VXcmFwYXJvdW5kOiExLHNlbmRGb2N1czohMSx3cmFwYXJvdW5kOiEwfSk7bGV0IGQ9dC5Db3JlU2VydmljZT1jbGFzcyBleHRlbmRzIGEuRGlzcG9zYWJsZXtjb25zdHJ1Y3RvcihlLHQsaSl7c3VwZXIoKSx0aGlzLl9idWZmZXJTZXJ2aWNlPWUsdGhpcy5fbG9nU2VydmljZT10LHRoaXMuX29wdGlvbnNTZXJ2aWNlPWksdGhpcy5pc0N1cnNvckluaXRpYWxpemVkPSExLHRoaXMuaXNDdXJzb3JIaWRkZW49ITEsdGhpcy5fb25EYXRhPXRoaXMucmVnaXN0ZXIobmV3IG8uRXZlbnRFbWl0dGVyKSx0aGlzLm9uRGF0YT10aGlzLl9vbkRhdGEuZXZlbnQsdGhpcy5fb25Vc2VySW5wdXQ9dGhpcy5yZWdpc3RlcihuZXcgby5FdmVudEVtaXR0ZXIpLHRoaXMub25Vc2VySW5wdXQ9dGhpcy5fb25Vc2VySW5wdXQuZXZlbnQsdGhpcy5fb25CaW5hcnk9dGhpcy5yZWdpc3RlcihuZXcgby5FdmVudEVtaXR0ZXIpLHRoaXMub25CaW5hcnk9dGhpcy5fb25CaW5hcnkuZXZlbnQsdGhpcy5fb25SZXF1ZXN0U2Nyb2xsVG9Cb3R0b209dGhpcy5yZWdpc3RlcihuZXcgby5FdmVudEVtaXR0ZXIpLHRoaXMub25SZXF1ZXN0U2Nyb2xsVG9Cb3R0b209dGhpcy5fb25SZXF1ZXN0U2Nyb2xsVG9Cb3R0b20uZXZlbnQsdGhpcy5tb2Rlcz0oMCxuLmNsb25lKShjKSx0aGlzLmRlY1ByaXZhdGVNb2Rlcz0oMCxuLmNsb25lKShsKX1yZXNldCgpe3RoaXMubW9kZXM9KDAsbi5jbG9uZSkoYyksdGhpcy5kZWNQcml2YXRlTW9kZXM9KDAsbi5jbG9uZSkobCl9dHJpZ2dlckRhdGFFdmVudChlLHQ9ITEpe2lmKHRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuZGlzYWJsZVN0ZGluKXJldHVybjtjb25zdCBpPXRoaXMuX2J1ZmZlclNlcnZpY2UuYnVmZmVyO3QmJnRoaXMuX29wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuc2Nyb2xsT25Vc2VySW5wdXQmJmkueWJhc2UhPT1pLnlkaXNwJiZ0aGlzLl9vblJlcXVlc3RTY3JvbGxUb0JvdHRvbS5maXJlKCksdCYmdGhpcy5fb25Vc2VySW5wdXQuZmlyZSgpLHRoaXMuX2xvZ1NlcnZpY2UuZGVidWcoYHNlbmRpbmcgZGF0YSBcIiR7ZX1cImAsKCgpPT5lLnNwbGl0KFwiXCIpLm1hcCgoZT0+ZS5jaGFyQ29kZUF0KDApKSkpKSx0aGlzLl9vbkRhdGEuZmlyZShlKX10cmlnZ2VyQmluYXJ5RXZlbnQoZSl7dGhpcy5fb3B0aW9uc1NlcnZpY2UucmF3T3B0aW9ucy5kaXNhYmxlU3RkaW58fCh0aGlzLl9sb2dTZXJ2aWNlLmRlYnVnKGBzZW5kaW5nIGJpbmFyeSBcIiR7ZX1cImAsKCgpPT5lLnNwbGl0KFwiXCIpLm1hcCgoZT0+ZS5jaGFyQ29kZUF0KDApKSkpKSx0aGlzLl9vbkJpbmFyeS5maXJlKGUpKX19O3QuQ29yZVNlcnZpY2U9ZD1zKFtyKDAsaC5JQnVmZmVyU2VydmljZSkscigxLGguSUxvZ1NlcnZpY2UpLHIoMixoLklPcHRpb25zU2VydmljZSldLGQpfSw5MDc0OihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkRlY29yYXRpb25TZXJ2aWNlPXZvaWQgMDtjb25zdCBzPWkoODA1NSkscj1pKDg0NjApLG49aSg4NDQpLG89aSg2MTA2KTtsZXQgYT0wLGg9MDtjbGFzcyBjIGV4dGVuZHMgbi5EaXNwb3NhYmxle2dldCBkZWNvcmF0aW9ucygpe3JldHVybiB0aGlzLl9kZWNvcmF0aW9ucy52YWx1ZXMoKX1jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5fZGVjb3JhdGlvbnM9bmV3IG8uU29ydGVkTGlzdCgoZT0+ZT8ubWFya2VyLmxpbmUpKSx0aGlzLl9vbkRlY29yYXRpb25SZWdpc3RlcmVkPXRoaXMucmVnaXN0ZXIobmV3IHIuRXZlbnRFbWl0dGVyKSx0aGlzLm9uRGVjb3JhdGlvblJlZ2lzdGVyZWQ9dGhpcy5fb25EZWNvcmF0aW9uUmVnaXN0ZXJlZC5ldmVudCx0aGlzLl9vbkRlY29yYXRpb25SZW1vdmVkPXRoaXMucmVnaXN0ZXIobmV3IHIuRXZlbnRFbWl0dGVyKSx0aGlzLm9uRGVjb3JhdGlvblJlbW92ZWQ9dGhpcy5fb25EZWNvcmF0aW9uUmVtb3ZlZC5ldmVudCx0aGlzLnJlZ2lzdGVyKCgwLG4udG9EaXNwb3NhYmxlKSgoKCk9PnRoaXMucmVzZXQoKSkpKX1yZWdpc3RlckRlY29yYXRpb24oZSl7aWYoZS5tYXJrZXIuaXNEaXNwb3NlZClyZXR1cm47Y29uc3QgdD1uZXcgbChlKTtpZih0KXtjb25zdCBlPXQubWFya2VyLm9uRGlzcG9zZSgoKCk9PnQuZGlzcG9zZSgpKSk7dC5vbkRpc3Bvc2UoKCgpPT57dCYmKHRoaXMuX2RlY29yYXRpb25zLmRlbGV0ZSh0KSYmdGhpcy5fb25EZWNvcmF0aW9uUmVtb3ZlZC5maXJlKHQpLGUuZGlzcG9zZSgpKX0pKSx0aGlzLl9kZWNvcmF0aW9ucy5pbnNlcnQodCksdGhpcy5fb25EZWNvcmF0aW9uUmVnaXN0ZXJlZC5maXJlKHQpfXJldHVybiB0fXJlc2V0KCl7Zm9yKGNvbnN0IGUgb2YgdGhpcy5fZGVjb3JhdGlvbnMudmFsdWVzKCkpZS5kaXNwb3NlKCk7dGhpcy5fZGVjb3JhdGlvbnMuY2xlYXIoKX0qZ2V0RGVjb3JhdGlvbnNBdENlbGwoZSx0LGkpe2xldCBzPTAscj0wO2Zvcihjb25zdCBuIG9mIHRoaXMuX2RlY29yYXRpb25zLmdldEtleUl0ZXJhdG9yKHQpKXM9bi5vcHRpb25zLng/PzAscj1zKyhuLm9wdGlvbnMud2lkdGg/PzEpLGU+PXMmJmU8ciYmKCFpfHwobi5vcHRpb25zLmxheWVyPz9cImJvdHRvbVwiKT09PWkpJiYoeWllbGQgbil9Zm9yRWFjaERlY29yYXRpb25BdENlbGwoZSx0LGkscyl7dGhpcy5fZGVjb3JhdGlvbnMuZm9yRWFjaEJ5S2V5KHQsKHQ9PnthPXQub3B0aW9ucy54Pz8wLGg9YSsodC5vcHRpb25zLndpZHRoPz8xKSxlPj1hJiZlPGgmJighaXx8KHQub3B0aW9ucy5sYXllcj8/XCJib3R0b21cIik9PT1pKSYmcyh0KX0pKX19dC5EZWNvcmF0aW9uU2VydmljZT1jO2NsYXNzIGwgZXh0ZW5kcyBuLkRpc3Bvc2FibGV7Z2V0IGlzRGlzcG9zZWQoKXtyZXR1cm4gdGhpcy5faXNEaXNwb3NlZH1nZXQgYmFja2dyb3VuZENvbG9yUkdCKCl7cmV0dXJuIG51bGw9PT10aGlzLl9jYWNoZWRCZyYmKHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I/dGhpcy5fY2FjaGVkQmc9cy5jc3MudG9Db2xvcih0aGlzLm9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTp0aGlzLl9jYWNoZWRCZz12b2lkIDApLHRoaXMuX2NhY2hlZEJnfWdldCBmb3JlZ3JvdW5kQ29sb3JSR0IoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2NhY2hlZEZnJiYodGhpcy5vcHRpb25zLmZvcmVncm91bmRDb2xvcj90aGlzLl9jYWNoZWRGZz1zLmNzcy50b0NvbG9yKHRoaXMub3B0aW9ucy5mb3JlZ3JvdW5kQ29sb3IpOnRoaXMuX2NhY2hlZEZnPXZvaWQgMCksdGhpcy5fY2FjaGVkRmd9Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLm9wdGlvbnM9ZSx0aGlzLm9uUmVuZGVyRW1pdHRlcj10aGlzLnJlZ2lzdGVyKG5ldyByLkV2ZW50RW1pdHRlciksdGhpcy5vblJlbmRlcj10aGlzLm9uUmVuZGVyRW1pdHRlci5ldmVudCx0aGlzLl9vbkRpc3Bvc2U9dGhpcy5yZWdpc3RlcihuZXcgci5FdmVudEVtaXR0ZXIpLHRoaXMub25EaXNwb3NlPXRoaXMuX29uRGlzcG9zZS5ldmVudCx0aGlzLl9jYWNoZWRCZz1udWxsLHRoaXMuX2NhY2hlZEZnPW51bGwsdGhpcy5tYXJrZXI9ZS5tYXJrZXIsdGhpcy5vcHRpb25zLm92ZXJ2aWV3UnVsZXJPcHRpb25zJiYhdGhpcy5vcHRpb25zLm92ZXJ2aWV3UnVsZXJPcHRpb25zLnBvc2l0aW9uJiYodGhpcy5vcHRpb25zLm92ZXJ2aWV3UnVsZXJPcHRpb25zLnBvc2l0aW9uPVwiZnVsbFwiKX1kaXNwb3NlKCl7dGhpcy5fb25EaXNwb3NlLmZpcmUoKSxzdXBlci5kaXNwb3NlKCl9fX0sNDM0ODooZSx0LGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5JbnN0YW50aWF0aW9uU2VydmljZT10LlNlcnZpY2VDb2xsZWN0aW9uPXZvaWQgMDtjb25zdCBzPWkoMjU4NSkscj1pKDgzNDMpO2NsYXNzIG57Y29uc3RydWN0b3IoLi4uZSl7dGhpcy5fZW50cmllcz1uZXcgTWFwO2Zvcihjb25zdFt0LGldb2YgZSl0aGlzLnNldCh0LGkpfXNldChlLHQpe2NvbnN0IGk9dGhpcy5fZW50cmllcy5nZXQoZSk7cmV0dXJuIHRoaXMuX2VudHJpZXMuc2V0KGUsdCksaX1mb3JFYWNoKGUpe2Zvcihjb25zdFt0LGldb2YgdGhpcy5fZW50cmllcy5lbnRyaWVzKCkpZSh0LGkpfWhhcyhlKXtyZXR1cm4gdGhpcy5fZW50cmllcy5oYXMoZSl9Z2V0KGUpe3JldHVybiB0aGlzLl9lbnRyaWVzLmdldChlKX19dC5TZXJ2aWNlQ29sbGVjdGlvbj1uLHQuSW5zdGFudGlhdGlvblNlcnZpY2U9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLl9zZXJ2aWNlcz1uZXcgbix0aGlzLl9zZXJ2aWNlcy5zZXQocy5JSW5zdGFudGlhdGlvblNlcnZpY2UsdGhpcyl9c2V0U2VydmljZShlLHQpe3RoaXMuX3NlcnZpY2VzLnNldChlLHQpfWdldFNlcnZpY2UoZSl7cmV0dXJuIHRoaXMuX3NlcnZpY2VzLmdldChlKX1jcmVhdGVJbnN0YW5jZShlLC4uLnQpe2NvbnN0IGk9KDAsci5nZXRTZXJ2aWNlRGVwZW5kZW5jaWVzKShlKS5zb3J0KCgoZSx0KT0+ZS5pbmRleC10LmluZGV4KSkscz1bXTtmb3IoY29uc3QgdCBvZiBpKXtjb25zdCBpPXRoaXMuX3NlcnZpY2VzLmdldCh0LmlkKTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYFtjcmVhdGVJbnN0YW5jZV0gJHtlLm5hbWV9IGRlcGVuZHMgb24gVU5LTk9XTiBzZXJ2aWNlICR7dC5pZH0uYCk7cy5wdXNoKGkpfWNvbnN0IG49aS5sZW5ndGg+MD9pWzBdLmluZGV4OnQubGVuZ3RoO2lmKHQubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYFtjcmVhdGVJbnN0YW5jZV0gRmlyc3Qgc2VydmljZSBkZXBlbmRlbmN5IG9mICR7ZS5uYW1lfSBhdCBwb3NpdGlvbiAke24rMX0gY29uZmxpY3RzIHdpdGggJHt0Lmxlbmd0aH0gc3RhdGljIGFyZ3VtZW50c2ApO3JldHVybiBuZXcgZSguLi5bLi4udCwuLi5zXSl9fX0sNzg2NjpmdW5jdGlvbihlLHQsaSl7dmFyIHM9dGhpcyYmdGhpcy5fX2RlY29yYXRlfHxmdW5jdGlvbihlLHQsaSxzKXt2YXIgcixuPWFyZ3VtZW50cy5sZW5ndGgsbz1uPDM/dDpudWxsPT09cz9zPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxpKTpzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBSZWZsZWN0LmRlY29yYXRlKW89UmVmbGVjdC5kZWNvcmF0ZShlLHQsaSxzKTtlbHNlIGZvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTA7YS0tKShyPWVbYV0pJiYobz0objwzP3Iobyk6bj4zP3IodCxpLG8pOnIodCxpKSl8fG8pO3JldHVybiBuPjMmJm8mJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGksbyksb30scj10aGlzJiZ0aGlzLl9fcGFyYW18fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkscyl7dChpLHMsZSl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnRyYWNlQ2FsbD10LnNldFRyYWNlTG9nZ2VyPXQuTG9nU2VydmljZT12b2lkIDA7Y29uc3Qgbj1pKDg0NCksbz1pKDI1ODUpLGE9e3RyYWNlOm8uTG9nTGV2ZWxFbnVtLlRSQUNFLGRlYnVnOm8uTG9nTGV2ZWxFbnVtLkRFQlVHLGluZm86by5Mb2dMZXZlbEVudW0uSU5GTyx3YXJuOm8uTG9nTGV2ZWxFbnVtLldBUk4sZXJyb3I6by5Mb2dMZXZlbEVudW0uRVJST1Isb2ZmOm8uTG9nTGV2ZWxFbnVtLk9GRn07bGV0IGgsYz10LkxvZ1NlcnZpY2U9Y2xhc3MgZXh0ZW5kcyBuLkRpc3Bvc2FibGV7Z2V0IGxvZ0xldmVsKCl7cmV0dXJuIHRoaXMuX2xvZ0xldmVsfWNvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5fb3B0aW9uc1NlcnZpY2U9ZSx0aGlzLl9sb2dMZXZlbD1vLkxvZ0xldmVsRW51bS5PRkYsdGhpcy5fdXBkYXRlTG9nTGV2ZWwoKSx0aGlzLnJlZ2lzdGVyKHRoaXMuX29wdGlvbnNTZXJ2aWNlLm9uU3BlY2lmaWNPcHRpb25DaGFuZ2UoXCJsb2dMZXZlbFwiLCgoKT0+dGhpcy5fdXBkYXRlTG9nTGV2ZWwoKSkpKSxoPXRoaXN9X3VwZGF0ZUxvZ0xldmVsKCl7dGhpcy5fbG9nTGV2ZWw9YVt0aGlzLl9vcHRpb25zU2VydmljZS5yYXdPcHRpb25zLmxvZ0xldmVsXX1fZXZhbExhenlPcHRpb25hbFBhcmFtcyhlKXtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKylcImZ1bmN0aW9uXCI9PXR5cGVvZiBlW3RdJiYoZVt0XT1lW3RdKCkpfV9sb2coZSx0LGkpe3RoaXMuX2V2YWxMYXp5T3B0aW9uYWxQYXJhbXMoaSksZS5jYWxsKGNvbnNvbGUsKHRoaXMuX29wdGlvbnNTZXJ2aWNlLm9wdGlvbnMubG9nZ2VyP1wiXCI6XCJ4dGVybS5qczogXCIpK3QsLi4uaSl9dHJhY2UoZSwuLi50KXt0aGlzLl9sb2dMZXZlbDw9by5Mb2dMZXZlbEVudW0uVFJBQ0UmJnRoaXMuX2xvZyh0aGlzLl9vcHRpb25zU2VydmljZS5vcHRpb25zLmxvZ2dlcj8udHJhY2UuYmluZCh0aGlzLl9vcHRpb25zU2VydmljZS5vcHRpb25zLmxvZ2dlcik/P2NvbnNvbGUubG9nLGUsdCl9ZGVidWcoZSwuLi50KXt0aGlzLl9sb2dMZXZlbDw9by5Mb2dMZXZlbEVudW0uREVCVUcmJnRoaXMuX2xvZyh0aGlzLl9vcHRpb25zU2VydmljZS5vcHRpb25zLmxvZ2dlcj8uZGVidWcuYmluZCh0aGlzLl9vcHRpb25zU2VydmljZS5vcHRpb25zLmxvZ2dlcik/P2NvbnNvbGUubG9nLGUsdCl9aW5mbyhlLC4uLnQpe3RoaXMuX2xvZ0xldmVsPD1vLkxvZ0xldmVsRW51bS5JTkZPJiZ0aGlzLl9sb2codGhpcy5fb3B0aW9uc1NlcnZpY2Uub3B0aW9ucy5sb2dnZXI/LmluZm8uYmluZCh0aGlzLl9vcHRpb25zU2VydmljZS5vcHRpb25zLmxvZ2dlcik/P2NvbnNvbGUuaW5mbyxlLHQpfXdhcm4oZSwuLi50KXt0aGlzLl9sb2dMZXZlbDw9by5Mb2dMZXZlbEVudW0uV0FSTiYmdGhpcy5fbG9nKHRoaXMuX29wdGlvbnNTZXJ2aWNlLm9wdGlvbnMubG9nZ2VyPy53YXJuLmJpbmQodGhpcy5fb3B0aW9uc1NlcnZpY2Uub3B0aW9ucy5sb2dnZXIpPz9jb25zb2xlLndhcm4sZSx0KX1lcnJvcihlLC4uLnQpe3RoaXMuX2xvZ0xldmVsPD1vLkxvZ0xldmVsRW51bS5FUlJPUiYmdGhpcy5fbG9nKHRoaXMuX29wdGlvbnNTZXJ2aWNlLm9wdGlvbnMubG9nZ2VyPy5lcnJvci5iaW5kKHRoaXMuX29wdGlvbnNTZXJ2aWNlLm9wdGlvbnMubG9nZ2VyKT8/Y29uc29sZS5lcnJvcixlLHQpfX07dC5Mb2dTZXJ2aWNlPWM9cyhbcigwLG8uSU9wdGlvbnNTZXJ2aWNlKV0sYyksdC5zZXRUcmFjZUxvZ2dlcj1mdW5jdGlvbihlKXtoPWV9LHQudHJhY2VDYWxsPWZ1bmN0aW9uKGUsdCxpKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBpLnZhbHVlKXRocm93IG5ldyBFcnJvcihcIm5vdCBzdXBwb3J0ZWRcIik7Y29uc3Qgcz1pLnZhbHVlO2kudmFsdWU9ZnVuY3Rpb24oLi4uZSl7aWYoaC5sb2dMZXZlbCE9PW8uTG9nTGV2ZWxFbnVtLlRSQUNFKXJldHVybiBzLmFwcGx5KHRoaXMsZSk7aC50cmFjZShgR2x5cGhSZW5kZXJlciMke3MubmFtZX0oJHtlLm1hcCgoZT0+SlNPTi5zdHJpbmdpZnkoZSkpKS5qb2luKFwiLCBcIil9KWApO2NvbnN0IHQ9cy5hcHBseSh0aGlzLGUpO3JldHVybiBoLnRyYWNlKGBHbHlwaFJlbmRlcmVyIyR7cy5uYW1lfSByZXR1cm5gLHQpLHR9fX0sNzMwMjooZSx0LGkpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5PcHRpb25zU2VydmljZT10LkRFRkFVTFRfT1BUSU9OUz12b2lkIDA7Y29uc3Qgcz1pKDg0NjApLHI9aSg4NDQpLG49aSg2MTE0KTt0LkRFRkFVTFRfT1BUSU9OUz17Y29sczo4MCxyb3dzOjI0LGN1cnNvckJsaW5rOiExLGN1cnNvclN0eWxlOlwiYmxvY2tcIixjdXJzb3JXaWR0aDoxLGN1cnNvckluYWN0aXZlU3R5bGU6XCJvdXRsaW5lXCIsY3VzdG9tR2x5cGhzOiEwLGRyYXdCb2xkVGV4dEluQnJpZ2h0Q29sb3JzOiEwLGRvY3VtZW50T3ZlcnJpZGU6bnVsbCxmYXN0U2Nyb2xsTW9kaWZpZXI6XCJhbHRcIixmYXN0U2Nyb2xsU2Vuc2l0aXZpdHk6NSxmb250RmFtaWx5OlwiY291cmllci1uZXcsIGNvdXJpZXIsIG1vbm9zcGFjZVwiLGZvbnRTaXplOjE1LGZvbnRXZWlnaHQ6XCJub3JtYWxcIixmb250V2VpZ2h0Qm9sZDpcImJvbGRcIixpZ25vcmVCcmFja2V0ZWRQYXN0ZU1vZGU6ITEsbGluZUhlaWdodDoxLGxldHRlclNwYWNpbmc6MCxsaW5rSGFuZGxlcjpudWxsLGxvZ0xldmVsOlwiaW5mb1wiLGxvZ2dlcjpudWxsLHNjcm9sbGJhY2s6MWUzLHNjcm9sbE9uVXNlcklucHV0OiEwLHNjcm9sbFNlbnNpdGl2aXR5OjEsc2NyZWVuUmVhZGVyTW9kZTohMSxzbW9vdGhTY3JvbGxEdXJhdGlvbjowLG1hY09wdGlvbklzTWV0YTohMSxtYWNPcHRpb25DbGlja0ZvcmNlc1NlbGVjdGlvbjohMSxtaW5pbXVtQ29udHJhc3RSYXRpbzoxLGRpc2FibGVTdGRpbjohMSxhbGxvd1Byb3Bvc2VkQXBpOiExLGFsbG93VHJhbnNwYXJlbmN5OiExLHRhYlN0b3BXaWR0aDo4LHRoZW1lOnt9LHJlc2NhbGVPdmVybGFwcGluZ0dseXBoczohMSxyaWdodENsaWNrU2VsZWN0c1dvcmQ6bi5pc01hYyx3aW5kb3dPcHRpb25zOnt9LHdpbmRvd3NNb2RlOiExLHdpbmRvd3NQdHk6e30sd29yZFNlcGFyYXRvcjpcIiAoKVtde30nLFxcXCJgXCIsYWx0Q2xpY2tNb3Zlc0N1cnNvcjohMCxjb252ZXJ0RW9sOiExLHRlcm1OYW1lOlwieHRlcm1cIixjYW5jZWxFdmVudHM6ITEsb3ZlcnZpZXdSdWxlcldpZHRoOjB9O2NvbnN0IG89W1wibm9ybWFsXCIsXCJib2xkXCIsXCIxMDBcIixcIjIwMFwiLFwiMzAwXCIsXCI0MDBcIixcIjUwMFwiLFwiNjAwXCIsXCI3MDBcIixcIjgwMFwiLFwiOTAwXCJdO2NsYXNzIGEgZXh0ZW5kcyByLkRpc3Bvc2FibGV7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLl9vbk9wdGlvbkNoYW5nZT10aGlzLnJlZ2lzdGVyKG5ldyBzLkV2ZW50RW1pdHRlciksdGhpcy5vbk9wdGlvbkNoYW5nZT10aGlzLl9vbk9wdGlvbkNoYW5nZS5ldmVudDtjb25zdCBpPXsuLi50LkRFRkFVTFRfT1BUSU9OU307Zm9yKGNvbnN0IHQgaW4gZSlpZih0IGluIGkpdHJ5e2NvbnN0IHM9ZVt0XTtpW3RdPXRoaXMuX3Nhbml0aXplQW5kVmFsaWRhdGVPcHRpb24odCxzKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKGUpfXRoaXMucmF3T3B0aW9ucz1pLHRoaXMub3B0aW9ucz17Li4uaX0sdGhpcy5fc2V0dXBPcHRpb25zKCksdGhpcy5yZWdpc3RlcigoMCxyLnRvRGlzcG9zYWJsZSkoKCgpPT57dGhpcy5yYXdPcHRpb25zLmxpbmtIYW5kbGVyPW51bGwsdGhpcy5yYXdPcHRpb25zLmRvY3VtZW50T3ZlcnJpZGU9bnVsbH0pKSl9b25TcGVjaWZpY09wdGlvbkNoYW5nZShlLHQpe3JldHVybiB0aGlzLm9uT3B0aW9uQ2hhbmdlKChpPT57aT09PWUmJnQodGhpcy5yYXdPcHRpb25zW2VdKX0pKX1vbk11bHRpcGxlT3B0aW9uQ2hhbmdlKGUsdCl7cmV0dXJuIHRoaXMub25PcHRpb25DaGFuZ2UoKGk9PnstMSE9PWUuaW5kZXhPZihpKSYmdCgpfSkpfV9zZXR1cE9wdGlvbnMoKXtjb25zdCBlPWU9PntpZighKGUgaW4gdC5ERUZBVUxUX09QVElPTlMpKXRocm93IG5ldyBFcnJvcihgTm8gb3B0aW9uIHdpdGgga2V5IFwiJHtlfVwiYCk7cmV0dXJuIHRoaXMucmF3T3B0aW9uc1tlXX0saT0oZSxpKT0+e2lmKCEoZSBpbiB0LkRFRkFVTFRfT1BUSU9OUykpdGhyb3cgbmV3IEVycm9yKGBObyBvcHRpb24gd2l0aCBrZXkgXCIke2V9XCJgKTtpPXRoaXMuX3Nhbml0aXplQW5kVmFsaWRhdGVPcHRpb24oZSxpKSx0aGlzLnJhd09wdGlvbnNbZV0hPT1pJiYodGhpcy5yYXdPcHRpb25zW2VdPWksdGhpcy5fb25PcHRpb25DaGFuZ2UuZmlyZShlKSl9O2Zvcihjb25zdCB0IGluIHRoaXMucmF3T3B0aW9ucyl7Y29uc3Qgcz17Z2V0OmUuYmluZCh0aGlzLHQpLHNldDppLmJpbmQodGhpcyx0KX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub3B0aW9ucyx0LHMpfX1fc2FuaXRpemVBbmRWYWxpZGF0ZU9wdGlvbihlLGkpe3N3aXRjaChlKXtjYXNlXCJjdXJzb3JTdHlsZVwiOmlmKGl8fChpPXQuREVGQVVMVF9PUFRJT05TW2VdKSwhZnVuY3Rpb24oZSl7cmV0dXJuXCJibG9ja1wiPT09ZXx8XCJ1bmRlcmxpbmVcIj09PWV8fFwiYmFyXCI9PT1lfShpKSl0aHJvdyBuZXcgRXJyb3IoYFwiJHtpfVwiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciAke2V9YCk7YnJlYWs7Y2FzZVwid29yZFNlcGFyYXRvclwiOml8fChpPXQuREVGQVVMVF9PUFRJT05TW2VdKTticmVhaztjYXNlXCJmb250V2VpZ2h0XCI6Y2FzZVwiZm9udFdlaWdodEJvbGRcIjppZihcIm51bWJlclwiPT10eXBlb2YgaSYmMTw9aSYmaTw9MWUzKWJyZWFrO2k9by5pbmNsdWRlcyhpKT9pOnQuREVGQVVMVF9PUFRJT05TW2VdO2JyZWFrO2Nhc2VcImN1cnNvcldpZHRoXCI6aT1NYXRoLmZsb29yKGkpO2Nhc2VcImxpbmVIZWlnaHRcIjpjYXNlXCJ0YWJTdG9wV2lkdGhcIjppZihpPDEpdGhyb3cgbmV3IEVycm9yKGAke2V9IGNhbm5vdCBiZSBsZXNzIHRoYW4gMSwgdmFsdWU6ICR7aX1gKTticmVhaztjYXNlXCJtaW5pbXVtQ29udHJhc3RSYXRpb1wiOmk9TWF0aC5tYXgoMSxNYXRoLm1pbigyMSxNYXRoLnJvdW5kKDEwKmkpLzEwKSk7YnJlYWs7Y2FzZVwic2Nyb2xsYmFja1wiOmlmKChpPU1hdGgubWluKGksNDI5NDk2NzI5NSkpPDApdGhyb3cgbmV3IEVycm9yKGAke2V9IGNhbm5vdCBiZSBsZXNzIHRoYW4gMCwgdmFsdWU6ICR7aX1gKTticmVhaztjYXNlXCJmYXN0U2Nyb2xsU2Vuc2l0aXZpdHlcIjpjYXNlXCJzY3JvbGxTZW5zaXRpdml0eVwiOmlmKGk8PTApdGhyb3cgbmV3IEVycm9yKGAke2V9IGNhbm5vdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMCwgdmFsdWU6ICR7aX1gKTticmVhaztjYXNlXCJyb3dzXCI6Y2FzZVwiY29sc1wiOmlmKCFpJiYwIT09aSl0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gbXVzdCBiZSBudW1lcmljLCB2YWx1ZTogJHtpfWApO2JyZWFrO2Nhc2VcIndpbmRvd3NQdHlcIjppPWk/P3t9fXJldHVybiBpfX10Lk9wdGlvbnNTZXJ2aWNlPWF9LDI2NjA6ZnVuY3Rpb24oZSx0LGkpe3ZhciBzPXRoaXMmJnRoaXMuX19kZWNvcmF0ZXx8ZnVuY3Rpb24oZSx0LGkscyl7dmFyIHIsbj1hcmd1bWVudHMubGVuZ3RoLG89bjwzP3Q6bnVsbD09PXM/cz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsaSk6cztpZihcIm9iamVjdFwiPT10eXBlb2YgUmVmbGVjdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSlvPVJlZmxlY3QuZGVjb3JhdGUoZSx0LGkscyk7ZWxzZSBmb3IodmFyIGE9ZS5sZW5ndGgtMTthPj0wO2EtLSkocj1lW2FdKSYmKG89KG48Mz9yKG8pOm4+Mz9yKHQsaSxvKTpyKHQsaSkpfHxvKTtyZXR1cm4gbj4zJiZvJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLG8pLG99LHI9dGhpcyYmdGhpcy5fX3BhcmFtfHxmdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihpLHMpe3QoaSxzLGUpfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Pc2NMaW5rU2VydmljZT12b2lkIDA7Y29uc3Qgbj1pKDI1ODUpO2xldCBvPXQuT3NjTGlua1NlcnZpY2U9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fYnVmZmVyU2VydmljZT1lLHRoaXMuX25leHRJZD0xLHRoaXMuX2VudHJpZXNXaXRoSWQ9bmV3IE1hcCx0aGlzLl9kYXRhQnlMaW5rSWQ9bmV3IE1hcH1yZWdpc3RlckxpbmsoZSl7Y29uc3QgdD10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlcjtpZih2b2lkIDA9PT1lLmlkKXtjb25zdCBpPXQuYWRkTWFya2VyKHQueWJhc2UrdC55KSxzPXtkYXRhOmUsaWQ6dGhpcy5fbmV4dElkKyssbGluZXM6W2ldfTtyZXR1cm4gaS5vbkRpc3Bvc2UoKCgpPT50aGlzLl9yZW1vdmVNYXJrZXJGcm9tTGluayhzLGkpKSksdGhpcy5fZGF0YUJ5TGlua0lkLnNldChzLmlkLHMpLHMuaWR9Y29uc3QgaT1lLHM9dGhpcy5fZ2V0RW50cnlJZEtleShpKSxyPXRoaXMuX2VudHJpZXNXaXRoSWQuZ2V0KHMpO2lmKHIpcmV0dXJuIHRoaXMuYWRkTGluZVRvTGluayhyLmlkLHQueWJhc2UrdC55KSxyLmlkO2NvbnN0IG49dC5hZGRNYXJrZXIodC55YmFzZSt0LnkpLG89e2lkOnRoaXMuX25leHRJZCsrLGtleTp0aGlzLl9nZXRFbnRyeUlkS2V5KGkpLGRhdGE6aSxsaW5lczpbbl19O3JldHVybiBuLm9uRGlzcG9zZSgoKCk9PnRoaXMuX3JlbW92ZU1hcmtlckZyb21MaW5rKG8sbikpKSx0aGlzLl9lbnRyaWVzV2l0aElkLnNldChvLmtleSxvKSx0aGlzLl9kYXRhQnlMaW5rSWQuc2V0KG8uaWQsbyksby5pZH1hZGRMaW5lVG9MaW5rKGUsdCl7Y29uc3QgaT10aGlzLl9kYXRhQnlMaW5rSWQuZ2V0KGUpO2lmKGkmJmkubGluZXMuZXZlcnkoKGU9PmUubGluZSE9PXQpKSl7Y29uc3QgZT10aGlzLl9idWZmZXJTZXJ2aWNlLmJ1ZmZlci5hZGRNYXJrZXIodCk7aS5saW5lcy5wdXNoKGUpLGUub25EaXNwb3NlKCgoKT0+dGhpcy5fcmVtb3ZlTWFya2VyRnJvbUxpbmsoaSxlKSkpfX1nZXRMaW5rRGF0YShlKXtyZXR1cm4gdGhpcy5fZGF0YUJ5TGlua0lkLmdldChlKT8uZGF0YX1fZ2V0RW50cnlJZEtleShlKXtyZXR1cm5gJHtlLmlkfTs7JHtlLnVyaX1gfV9yZW1vdmVNYXJrZXJGcm9tTGluayhlLHQpe2NvbnN0IGk9ZS5saW5lcy5pbmRleE9mKHQpOy0xIT09aSYmKGUubGluZXMuc3BsaWNlKGksMSksMD09PWUubGluZXMubGVuZ3RoJiYodm9pZCAwIT09ZS5kYXRhLmlkJiZ0aGlzLl9lbnRyaWVzV2l0aElkLmRlbGV0ZShlLmtleSksdGhpcy5fZGF0YUJ5TGlua0lkLmRlbGV0ZShlLmlkKSkpfX07dC5Pc2NMaW5rU2VydmljZT1vPXMoW3IoMCxuLklCdWZmZXJTZXJ2aWNlKV0sbyl9LDgzNDM6KGUsdCk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZURlY29yYXRvcj10LmdldFNlcnZpY2VEZXBlbmRlbmNpZXM9dC5zZXJ2aWNlUmVnaXN0cnk9dm9pZCAwO2NvbnN0IGk9XCJkaSR0YXJnZXRcIixzPVwiZGkkZGVwZW5kZW5jaWVzXCI7dC5zZXJ2aWNlUmVnaXN0cnk9bmV3IE1hcCx0LmdldFNlcnZpY2VEZXBlbmRlbmNpZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIGVbc118fFtdfSx0LmNyZWF0ZURlY29yYXRvcj1mdW5jdGlvbihlKXtpZih0LnNlcnZpY2VSZWdpc3RyeS5oYXMoZSkpcmV0dXJuIHQuc2VydmljZVJlZ2lzdHJ5LmdldChlKTtjb25zdCByPWZ1bmN0aW9uKGUsdCxuKXtpZigzIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJASVNlcnZpY2VOYW1lLWRlY29yYXRvciBjYW4gb25seSBiZSB1c2VkIHRvIGRlY29yYXRlIGEgcGFyYW1ldGVyXCIpOyFmdW5jdGlvbihlLHQscil7dFtpXT09PXQ/dFtzXS5wdXNoKHtpZDplLGluZGV4OnJ9KToodFtzXT1be2lkOmUsaW5kZXg6cn1dLHRbaV09dCl9KHIsZSxuKX07cmV0dXJuIHIudG9TdHJpbmc9KCk9PmUsdC5zZXJ2aWNlUmVnaXN0cnkuc2V0KGUscikscn19LDI1ODU6KGUsdCxpKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuSURlY29yYXRpb25TZXJ2aWNlPXQuSVVuaWNvZGVTZXJ2aWNlPXQuSU9zY0xpbmtTZXJ2aWNlPXQuSU9wdGlvbnNTZXJ2aWNlPXQuSUxvZ1NlcnZpY2U9dC5Mb2dMZXZlbEVudW09dC5JSW5zdGFudGlhdGlvblNlcnZpY2U9dC5JQ2hhcnNldFNlcnZpY2U9dC5JQ29yZVNlcnZpY2U9dC5JQ29yZU1vdXNlU2VydmljZT10LklCdWZmZXJTZXJ2aWNlPXZvaWQgMDtjb25zdCBzPWkoODM0Myk7dmFyIHI7dC5JQnVmZmVyU2VydmljZT0oMCxzLmNyZWF0ZURlY29yYXRvcikoXCJCdWZmZXJTZXJ2aWNlXCIpLHQuSUNvcmVNb3VzZVNlcnZpY2U9KDAscy5jcmVhdGVEZWNvcmF0b3IpKFwiQ29yZU1vdXNlU2VydmljZVwiKSx0LklDb3JlU2VydmljZT0oMCxzLmNyZWF0ZURlY29yYXRvcikoXCJDb3JlU2VydmljZVwiKSx0LklDaGFyc2V0U2VydmljZT0oMCxzLmNyZWF0ZURlY29yYXRvcikoXCJDaGFyc2V0U2VydmljZVwiKSx0LklJbnN0YW50aWF0aW9uU2VydmljZT0oMCxzLmNyZWF0ZURlY29yYXRvcikoXCJJbnN0YW50aWF0aW9uU2VydmljZVwiKSxmdW5jdGlvbihlKXtlW2UuVFJBQ0U9MF09XCJUUkFDRVwiLGVbZS5ERUJVRz0xXT1cIkRFQlVHXCIsZVtlLklORk89Ml09XCJJTkZPXCIsZVtlLldBUk49M109XCJXQVJOXCIsZVtlLkVSUk9SPTRdPVwiRVJST1JcIixlW2UuT0ZGPTVdPVwiT0ZGXCJ9KHJ8fCh0LkxvZ0xldmVsRW51bT1yPXt9KSksdC5JTG9nU2VydmljZT0oMCxzLmNyZWF0ZURlY29yYXRvcikoXCJMb2dTZXJ2aWNlXCIpLHQuSU9wdGlvbnNTZXJ2aWNlPSgwLHMuY3JlYXRlRGVjb3JhdG9yKShcIk9wdGlvbnNTZXJ2aWNlXCIpLHQuSU9zY0xpbmtTZXJ2aWNlPSgwLHMuY3JlYXRlRGVjb3JhdG9yKShcIk9zY0xpbmtTZXJ2aWNlXCIpLHQuSVVuaWNvZGVTZXJ2aWNlPSgwLHMuY3JlYXRlRGVjb3JhdG9yKShcIlVuaWNvZGVTZXJ2aWNlXCIpLHQuSURlY29yYXRpb25TZXJ2aWNlPSgwLHMuY3JlYXRlRGVjb3JhdG9yKShcIkRlY29yYXRpb25TZXJ2aWNlXCIpfSwxNDgwOihlLHQsaSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlVuaWNvZGVTZXJ2aWNlPXZvaWQgMDtjb25zdCBzPWkoODQ2MCkscj1pKDIyNSk7Y2xhc3MgbntzdGF0aWMgZXh0cmFjdFNob3VsZEpvaW4oZSl7cmV0dXJuIDAhPSgxJmUpfXN0YXRpYyBleHRyYWN0V2lkdGgoZSl7cmV0dXJuIGU+PjEmM31zdGF0aWMgZXh0cmFjdENoYXJLaW5kKGUpe3JldHVybiBlPj4zfXN0YXRpYyBjcmVhdGVQcm9wZXJ0eVZhbHVlKGUsdCxpPSExKXtyZXR1cm4oMTY3NzcyMTUmZSk8PDN8KDMmdCk8PDF8KGk/MTowKX1jb25zdHJ1Y3Rvcigpe3RoaXMuX3Byb3ZpZGVycz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX2FjdGl2ZT1cIlwiLHRoaXMuX29uQ2hhbmdlPW5ldyBzLkV2ZW50RW1pdHRlcix0aGlzLm9uQ2hhbmdlPXRoaXMuX29uQ2hhbmdlLmV2ZW50O2NvbnN0IGU9bmV3IHIuVW5pY29kZVY2O3RoaXMucmVnaXN0ZXIoZSksdGhpcy5fYWN0aXZlPWUudmVyc2lvbix0aGlzLl9hY3RpdmVQcm92aWRlcj1lfWRpc3Bvc2UoKXt0aGlzLl9vbkNoYW5nZS5kaXNwb3NlKCl9Z2V0IHZlcnNpb25zKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3Byb3ZpZGVycyl9Z2V0IGFjdGl2ZVZlcnNpb24oKXtyZXR1cm4gdGhpcy5fYWN0aXZlfXNldCBhY3RpdmVWZXJzaW9uKGUpe2lmKCF0aGlzLl9wcm92aWRlcnNbZV0pdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIFVuaWNvZGUgdmVyc2lvbiBcIiR7ZX1cImApO3RoaXMuX2FjdGl2ZT1lLHRoaXMuX2FjdGl2ZVByb3ZpZGVyPXRoaXMuX3Byb3ZpZGVyc1tlXSx0aGlzLl9vbkNoYW5nZS5maXJlKGUpfXJlZ2lzdGVyKGUpe3RoaXMuX3Byb3ZpZGVyc1tlLnZlcnNpb25dPWV9d2N3aWR0aChlKXtyZXR1cm4gdGhpcy5fYWN0aXZlUHJvdmlkZXIud2N3aWR0aChlKX1nZXRTdHJpbmdDZWxsV2lkdGgoZSl7bGV0IHQ9MCxpPTA7Y29uc3Qgcz1lLmxlbmd0aDtmb3IobGV0IHI9MDtyPHM7KytyKXtsZXQgbz1lLmNoYXJDb2RlQXQocik7aWYoNTUyOTY8PW8mJm88PTU2MzE5KXtpZigrK3I+PXMpcmV0dXJuIHQrdGhpcy53Y3dpZHRoKG8pO2NvbnN0IGk9ZS5jaGFyQ29kZUF0KHIpOzU2MzIwPD1pJiZpPD01NzM0Mz9vPTEwMjQqKG8tNTUyOTYpK2ktNTYzMjArNjU1MzY6dCs9dGhpcy53Y3dpZHRoKGkpfWNvbnN0IGE9dGhpcy5jaGFyUHJvcGVydGllcyhvLGkpO2xldCBoPW4uZXh0cmFjdFdpZHRoKGEpO24uZXh0cmFjdFNob3VsZEpvaW4oYSkmJihoLT1uLmV4dHJhY3RXaWR0aChpKSksdCs9aCxpPWF9cmV0dXJuIHR9Y2hhclByb3BlcnRpZXMoZSx0KXtyZXR1cm4gdGhpcy5fYWN0aXZlUHJvdmlkZXIuY2hhclByb3BlcnRpZXMoZSx0KX19dC5Vbmljb2RlU2VydmljZT1ufX0sdD17fTtmdW5jdGlvbiBpKHMpe3ZhciByPXRbc107aWYodm9pZCAwIT09cilyZXR1cm4gci5leHBvcnRzO3ZhciBuPXRbc109e2V4cG9ydHM6e319O3JldHVybiBlW3NdLmNhbGwobi5leHBvcnRzLG4sbi5leHBvcnRzLGkpLG4uZXhwb3J0c312YXIgcz17fTtyZXR1cm4oKCk9Pnt2YXIgZT1zO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuVGVybWluYWw9dm9pZCAwO2NvbnN0IHQ9aSg5MDQyKSxyPWkoMzIzNiksbj1pKDg0NCksbz1pKDU3NDEpLGE9aSg4Mjg1KSxoPWkoNzk3NSksYz1pKDcwOTApLGw9W1wiY29sc1wiLFwicm93c1wiXTtjbGFzcyBkIGV4dGVuZHMgbi5EaXNwb3NhYmxle2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5fY29yZT10aGlzLnJlZ2lzdGVyKG5ldyByLlRlcm1pbmFsKGUpKSx0aGlzLl9hZGRvbk1hbmFnZXI9dGhpcy5yZWdpc3RlcihuZXcgby5BZGRvbk1hbmFnZXIpLHRoaXMuX3B1YmxpY09wdGlvbnM9ey4uLnRoaXMuX2NvcmUub3B0aW9uc307Y29uc3QgdD1lPT50aGlzLl9jb3JlLm9wdGlvbnNbZV0saT0oZSx0KT0+e3RoaXMuX2NoZWNrUmVhZG9ubHlPcHRpb25zKGUpLHRoaXMuX2NvcmUub3B0aW9uc1tlXT10fTtmb3IoY29uc3QgZSBpbiB0aGlzLl9jb3JlLm9wdGlvbnMpe2NvbnN0IHM9e2dldDp0LmJpbmQodGhpcyxlKSxzZXQ6aS5iaW5kKHRoaXMsZSl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLl9wdWJsaWNPcHRpb25zLGUscyl9fV9jaGVja1JlYWRvbmx5T3B0aW9ucyhlKXtpZihsLmluY2x1ZGVzKGUpKXRocm93IG5ldyBFcnJvcihgT3B0aW9uIFwiJHtlfVwiIGNhbiBvbmx5IGJlIHNldCBpbiB0aGUgY29uc3RydWN0b3JgKX1fY2hlY2tQcm9wb3NlZEFwaSgpe2lmKCF0aGlzLl9jb3JlLm9wdGlvbnNTZXJ2aWNlLnJhd09wdGlvbnMuYWxsb3dQcm9wb3NlZEFwaSl0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBzZXQgdGhlIGFsbG93UHJvcG9zZWRBcGkgb3B0aW9uIHRvIHRydWUgdG8gdXNlIHByb3Bvc2VkIEFQSVwiKX1nZXQgb25CZWxsKCl7cmV0dXJuIHRoaXMuX2NvcmUub25CZWxsfWdldCBvbkJpbmFyeSgpe3JldHVybiB0aGlzLl9jb3JlLm9uQmluYXJ5fWdldCBvbkN1cnNvck1vdmUoKXtyZXR1cm4gdGhpcy5fY29yZS5vbkN1cnNvck1vdmV9Z2V0IG9uRGF0YSgpe3JldHVybiB0aGlzLl9jb3JlLm9uRGF0YX1nZXQgb25LZXkoKXtyZXR1cm4gdGhpcy5fY29yZS5vbktleX1nZXQgb25MaW5lRmVlZCgpe3JldHVybiB0aGlzLl9jb3JlLm9uTGluZUZlZWR9Z2V0IG9uUmVuZGVyKCl7cmV0dXJuIHRoaXMuX2NvcmUub25SZW5kZXJ9Z2V0IG9uUmVzaXplKCl7cmV0dXJuIHRoaXMuX2NvcmUub25SZXNpemV9Z2V0IG9uU2Nyb2xsKCl7cmV0dXJuIHRoaXMuX2NvcmUub25TY3JvbGx9Z2V0IG9uU2VsZWN0aW9uQ2hhbmdlKCl7cmV0dXJuIHRoaXMuX2NvcmUub25TZWxlY3Rpb25DaGFuZ2V9Z2V0IG9uVGl0bGVDaGFuZ2UoKXtyZXR1cm4gdGhpcy5fY29yZS5vblRpdGxlQ2hhbmdlfWdldCBvbldyaXRlUGFyc2VkKCl7cmV0dXJuIHRoaXMuX2NvcmUub25Xcml0ZVBhcnNlZH1nZXQgZWxlbWVudCgpe3JldHVybiB0aGlzLl9jb3JlLmVsZW1lbnR9Z2V0IHBhcnNlcigpe3JldHVybiB0aGlzLl9wYXJzZXJ8fCh0aGlzLl9wYXJzZXI9bmV3IGguUGFyc2VyQXBpKHRoaXMuX2NvcmUpKSx0aGlzLl9wYXJzZXJ9Z2V0IHVuaWNvZGUoKXtyZXR1cm4gdGhpcy5fY2hlY2tQcm9wb3NlZEFwaSgpLG5ldyBjLlVuaWNvZGVBcGkodGhpcy5fY29yZSl9Z2V0IHRleHRhcmVhKCl7cmV0dXJuIHRoaXMuX2NvcmUudGV4dGFyZWF9Z2V0IHJvd3MoKXtyZXR1cm4gdGhpcy5fY29yZS5yb3dzfWdldCBjb2xzKCl7cmV0dXJuIHRoaXMuX2NvcmUuY29sc31nZXQgYnVmZmVyKCl7cmV0dXJuIHRoaXMuX2J1ZmZlcnx8KHRoaXMuX2J1ZmZlcj10aGlzLnJlZ2lzdGVyKG5ldyBhLkJ1ZmZlck5hbWVzcGFjZUFwaSh0aGlzLl9jb3JlKSkpLHRoaXMuX2J1ZmZlcn1nZXQgbWFya2Vycygpe3JldHVybiB0aGlzLl9jaGVja1Byb3Bvc2VkQXBpKCksdGhpcy5fY29yZS5tYXJrZXJzfWdldCBtb2Rlcygpe2NvbnN0IGU9dGhpcy5fY29yZS5jb3JlU2VydmljZS5kZWNQcml2YXRlTW9kZXM7bGV0IHQ9XCJub25lXCI7c3dpdGNoKHRoaXMuX2NvcmUuY29yZU1vdXNlU2VydmljZS5hY3RpdmVQcm90b2NvbCl7Y2FzZVwiWDEwXCI6dD1cIngxMFwiO2JyZWFrO2Nhc2VcIlZUMjAwXCI6dD1cInZ0MjAwXCI7YnJlYWs7Y2FzZVwiRFJBR1wiOnQ9XCJkcmFnXCI7YnJlYWs7Y2FzZVwiQU5ZXCI6dD1cImFueVwifXJldHVybnthcHBsaWNhdGlvbkN1cnNvcktleXNNb2RlOmUuYXBwbGljYXRpb25DdXJzb3JLZXlzLGFwcGxpY2F0aW9uS2V5cGFkTW9kZTplLmFwcGxpY2F0aW9uS2V5cGFkLGJyYWNrZXRlZFBhc3RlTW9kZTplLmJyYWNrZXRlZFBhc3RlTW9kZSxpbnNlcnRNb2RlOnRoaXMuX2NvcmUuY29yZVNlcnZpY2UubW9kZXMuaW5zZXJ0TW9kZSxtb3VzZVRyYWNraW5nTW9kZTp0LG9yaWdpbk1vZGU6ZS5vcmlnaW4scmV2ZXJzZVdyYXBhcm91bmRNb2RlOmUucmV2ZXJzZVdyYXBhcm91bmQsc2VuZEZvY3VzTW9kZTplLnNlbmRGb2N1cyx3cmFwYXJvdW5kTW9kZTplLndyYXBhcm91bmR9fWdldCBvcHRpb25zKCl7cmV0dXJuIHRoaXMuX3B1YmxpY09wdGlvbnN9c2V0IG9wdGlvbnMoZSl7Zm9yKGNvbnN0IHQgaW4gZSl0aGlzLl9wdWJsaWNPcHRpb25zW3RdPWVbdF19Ymx1cigpe3RoaXMuX2NvcmUuYmx1cigpfWZvY3VzKCl7dGhpcy5fY29yZS5mb2N1cygpfWlucHV0KGUsdD0hMCl7dGhpcy5fY29yZS5pbnB1dChlLHQpfXJlc2l6ZShlLHQpe3RoaXMuX3ZlcmlmeUludGVnZXJzKGUsdCksdGhpcy5fY29yZS5yZXNpemUoZSx0KX1vcGVuKGUpe3RoaXMuX2NvcmUub3BlbihlKX1hdHRhY2hDdXN0b21LZXlFdmVudEhhbmRsZXIoZSl7dGhpcy5fY29yZS5hdHRhY2hDdXN0b21LZXlFdmVudEhhbmRsZXIoZSl9YXR0YWNoQ3VzdG9tV2hlZWxFdmVudEhhbmRsZXIoZSl7dGhpcy5fY29yZS5hdHRhY2hDdXN0b21XaGVlbEV2ZW50SGFuZGxlcihlKX1yZWdpc3RlckxpbmtQcm92aWRlcihlKXtyZXR1cm4gdGhpcy5fY29yZS5yZWdpc3RlckxpbmtQcm92aWRlcihlKX1yZWdpc3RlckNoYXJhY3RlckpvaW5lcihlKXtyZXR1cm4gdGhpcy5fY2hlY2tQcm9wb3NlZEFwaSgpLHRoaXMuX2NvcmUucmVnaXN0ZXJDaGFyYWN0ZXJKb2luZXIoZSl9ZGVyZWdpc3RlckNoYXJhY3RlckpvaW5lcihlKXt0aGlzLl9jaGVja1Byb3Bvc2VkQXBpKCksdGhpcy5fY29yZS5kZXJlZ2lzdGVyQ2hhcmFjdGVySm9pbmVyKGUpfXJlZ2lzdGVyTWFya2VyKGU9MCl7cmV0dXJuIHRoaXMuX3ZlcmlmeUludGVnZXJzKGUpLHRoaXMuX2NvcmUucmVnaXN0ZXJNYXJrZXIoZSl9cmVnaXN0ZXJEZWNvcmF0aW9uKGUpe3JldHVybiB0aGlzLl9jaGVja1Byb3Bvc2VkQXBpKCksdGhpcy5fdmVyaWZ5UG9zaXRpdmVJbnRlZ2VycyhlLng/PzAsZS53aWR0aD8/MCxlLmhlaWdodD8/MCksdGhpcy5fY29yZS5yZWdpc3RlckRlY29yYXRpb24oZSl9aGFzU2VsZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvcmUuaGFzU2VsZWN0aW9uKCl9c2VsZWN0KGUsdCxpKXt0aGlzLl92ZXJpZnlJbnRlZ2VycyhlLHQsaSksdGhpcy5fY29yZS5zZWxlY3QoZSx0LGkpfWdldFNlbGVjdGlvbigpe3JldHVybiB0aGlzLl9jb3JlLmdldFNlbGVjdGlvbigpfWdldFNlbGVjdGlvblBvc2l0aW9uKCl7cmV0dXJuIHRoaXMuX2NvcmUuZ2V0U2VsZWN0aW9uUG9zaXRpb24oKX1jbGVhclNlbGVjdGlvbigpe3RoaXMuX2NvcmUuY2xlYXJTZWxlY3Rpb24oKX1zZWxlY3RBbGwoKXt0aGlzLl9jb3JlLnNlbGVjdEFsbCgpfXNlbGVjdExpbmVzKGUsdCl7dGhpcy5fdmVyaWZ5SW50ZWdlcnMoZSx0KSx0aGlzLl9jb3JlLnNlbGVjdExpbmVzKGUsdCl9ZGlzcG9zZSgpe3N1cGVyLmRpc3Bvc2UoKX1zY3JvbGxMaW5lcyhlKXt0aGlzLl92ZXJpZnlJbnRlZ2VycyhlKSx0aGlzLl9jb3JlLnNjcm9sbExpbmVzKGUpfXNjcm9sbFBhZ2VzKGUpe3RoaXMuX3ZlcmlmeUludGVnZXJzKGUpLHRoaXMuX2NvcmUuc2Nyb2xsUGFnZXMoZSl9c2Nyb2xsVG9Ub3AoKXt0aGlzLl9jb3JlLnNjcm9sbFRvVG9wKCl9c2Nyb2xsVG9Cb3R0b20oKXt0aGlzLl9jb3JlLnNjcm9sbFRvQm90dG9tKCl9c2Nyb2xsVG9MaW5lKGUpe3RoaXMuX3ZlcmlmeUludGVnZXJzKGUpLHRoaXMuX2NvcmUuc2Nyb2xsVG9MaW5lKGUpfWNsZWFyKCl7dGhpcy5fY29yZS5jbGVhcigpfXdyaXRlKGUsdCl7dGhpcy5fY29yZS53cml0ZShlLHQpfXdyaXRlbG4oZSx0KXt0aGlzLl9jb3JlLndyaXRlKGUpLHRoaXMuX2NvcmUud3JpdGUoXCJcXHJcXG5cIix0KX1wYXN0ZShlKXt0aGlzLl9jb3JlLnBhc3RlKGUpfXJlZnJlc2goZSx0KXt0aGlzLl92ZXJpZnlJbnRlZ2VycyhlLHQpLHRoaXMuX2NvcmUucmVmcmVzaChlLHQpfXJlc2V0KCl7dGhpcy5fY29yZS5yZXNldCgpfWNsZWFyVGV4dHVyZUF0bGFzKCl7dGhpcy5fY29yZS5jbGVhclRleHR1cmVBdGxhcygpfWxvYWRBZGRvbihlKXt0aGlzLl9hZGRvbk1hbmFnZXIubG9hZEFkZG9uKHRoaXMsZSl9c3RhdGljIGdldCBzdHJpbmdzKCl7cmV0dXJuIHR9X3ZlcmlmeUludGVnZXJzKC4uLmUpe2Zvcihjb25zdCB0IG9mIGUpaWYodD09PTEvMHx8aXNOYU4odCl8fHQlMSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEFQSSBvbmx5IGFjY2VwdHMgaW50ZWdlcnNcIil9X3ZlcmlmeVBvc2l0aXZlSW50ZWdlcnMoLi4uZSl7Zm9yKGNvbnN0IHQgb2YgZSlpZih0JiYodD09PTEvMHx8aXNOYU4odCl8fHQlMSE9MHx8dDwwKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEFQSSBvbmx5IGFjY2VwdHMgcG9zaXRpdmUgaW50ZWdlcnNcIil9fWUuVGVybWluYWw9ZH0pKCksc30pKCkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXh0ZXJtLmpzLm1hcCIsImltcG9ydCB0eXBlIHsgVGVybWluYWwsIElUZXJtaW5hbEFkZG9uIH0gZnJvbSAnQHh0ZXJtL3h0ZXJtJ1xuaW1wb3J0IHR5cGUgeyBBZGRvbkRlZmluaXRpb24gfSBmcm9tICcuLi90eXBlcydcblxuZXhwb3J0IGNsYXNzIEFkZG9uTWFuYWdlciB7XG4gIHByaXZhdGUgbG9hZGVkQWRkb25zID0gbmV3IE1hcDxzdHJpbmcsIElUZXJtaW5hbEFkZG9uPigpXG5cbiAgcHJpdmF0ZSBhZGRvbkRpc3Bvc2FibGVzID0gbmV3IE1hcDxzdHJpbmcsICgpID0+IHZvaWQ+KClcblxuICAvKipcbiAgICogTG9hZCBhZGRvbnMgaW50byB0aGUgdGVybWluYWxcbiAgICogU3VwcG9ydHMgYm90aCBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgYW5kIGluc3RhbmNlc1xuICAgKi9cbiAgbG9hZEFkZG9ucyh0ZXJtaW5hbDogVGVybWluYWwsIGFkZG9uczogQWRkb25EZWZpbml0aW9uW10pOiB2b2lkIHtcbiAgICBhZGRvbnMuZm9yRWFjaCgoYWRkb25EZWYsIGluZGV4KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhZGRvbiA9IHRoaXMuY3JlYXRlQWRkb25JbnN0YW5jZShhZGRvbkRlZilcbiAgICAgICAgY29uc3QgYWRkb25LZXkgPSB0aGlzLmdldEFkZG9uS2V5KGFkZG9uLCBpbmRleClcblxuICAgICAgICB0ZXJtaW5hbC5sb2FkQWRkb24oYWRkb24pXG4gICAgICAgIHRoaXMubG9hZGVkQWRkb25zLnNldChhZGRvbktleSwgYWRkb24pXG5cbiAgICAgICAgLy8gU3RvcmUgY2xlYW51cCBmdW5jdGlvbiBpZiB0aGUgYWRkb24gcHJvdmlkZXMgb25lXG4gICAgICAgIGlmICgnZGlzcG9zZScgaW4gYWRkb24gJiYgdHlwZW9mIGFkZG9uLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmFkZG9uRGlzcG9zYWJsZXMuc2V0KGFkZG9uS2V5LCAoKSA9PiBhZGRvbi5kaXNwb3NlKCkpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIGFkZG9uIGF0IGluZGV4ICR7aW5kZXh9OmAsIGVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbG9hZGVkIGFkZG9uIGJ5IGl0cyBjb25zdHJ1Y3RvciBuYW1lIG9yIGluZGV4XG4gICAqL1xuICBnZXRBZGRvbjxUIGV4dGVuZHMgSVRlcm1pbmFsQWRkb24+KFxuICAgIGFkZG9uQ29uc3RydWN0b3I6IG5ldyAoLi4uYXJnczogdW5rbm93bltdKSA9PiBUXG4gICk6IFQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGFkZG9uTmFtZSA9IGFkZG9uQ29uc3RydWN0b3IubmFtZVxuICAgIGZvciAoY29uc3QgW2tleSwgYWRkb25dIG9mIHRoaXMubG9hZGVkQWRkb25zKSB7XG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoYWRkb25OYW1lKSB8fCBhZGRvbi5jb25zdHJ1Y3Rvci5uYW1lID09PSBhZGRvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZG9uIGFzIFRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3BlY2lmaWMgYWRkb24gdHlwZSBpcyBsb2FkZWRcbiAgICovXG4gIGhhc0FkZG9uKFxuICAgIGFkZG9uQ29uc3RydWN0b3I6IG5ldyAoLi4uYXJnczogdW5rbm93bltdKSA9PiBJVGVybWluYWxBZGRvblxuICApOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBZGRvbihhZGRvbkNvbnN0cnVjdG9yKSAhPT0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBsb2FkZWQgYWRkb25zXG4gICAqL1xuICBnZXRBbGxBZGRvbnMoKTogSVRlcm1pbmFsQWRkb25bXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5sb2FkZWRBZGRvbnMudmFsdWVzKCkpXG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgYWxsIGxvYWRlZCBhZGRvbnNcbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgLy8gRGlzcG9zZSBhbGwgYWRkb25zIHRoYXQgc3VwcG9ydCBkaXNwb3NhbFxuICAgIHRoaXMuYWRkb25EaXNwb3NhYmxlcy5mb3JFYWNoKChkaXNwb3NlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNwb3NlKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRpc3Bvc2luZyBhZGRvbjonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5sb2FkZWRBZGRvbnMuY2xlYXIoKVxuICAgIHRoaXMuYWRkb25EaXNwb3NhYmxlcy5jbGVhcigpXG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUFkZG9uSW5zdGFuY2UoYWRkb25EZWY6IEFkZG9uRGVmaW5pdGlvbik6IElUZXJtaW5hbEFkZG9uIHtcbiAgICBpZiAodHlwZW9mIGFkZG9uRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBDb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgICAgcmV0dXJuIG5ldyAoYWRkb25EZWYgYXMgbmV3ICgpID0+IElUZXJtaW5hbEFkZG9uKSgpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWRkb25EZWYgPT09ICdvYmplY3QnICYmICdhZGRvbicgaW4gYWRkb25EZWYpIHtcbiAgICAgIC8vIE9iamVjdCB3aXRoIGFkZG9uIGFuZCBvcHRpb25hbCBhcmdzXG4gICAgICBjb25zdCB7IGFkZG9uLCBhcmdzID0gW10gfSA9IGFkZG9uRGVmXG4gICAgICBpZiAodHlwZW9mIGFkZG9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgKGFkZG9uIGFzIG5ldyAoLi4uYXJnczogdW5rbm93bltdKSA9PiBJVGVybWluYWxBZGRvbikoXG4gICAgICAgICAgLi4uYXJnc1xuICAgICAgICApXG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkb25cbiAgICB9XG4gICAgLy8gQWxyZWFkeSBhbiBpbnN0YW5jZVxuICAgIHJldHVybiBhZGRvbkRlZiBhcyBJVGVybWluYWxBZGRvblxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBZGRvbktleShhZGRvbjogSVRlcm1pbmFsQWRkb24sIGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IG5hbWUgPSBhZGRvbi5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdVbmtub3duQWRkb24nXG4gICAgcmV0dXJuIGAke25hbWV9LSR7aW5kZXh9YFxuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFRlcm1pbmFsLCBJRGlzcG9zYWJsZSB9IGZyb20gJ0B4dGVybS94dGVybSdcbmltcG9ydCB0eXBlIHsgWFRlcm1FdmVudEhhbmRsZXJzIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmV4cG9ydCBjbGFzcyBFdmVudE1hbmFnZXIge1xuICBwcml2YXRlIGRpc3Bvc2FibGVzOiBJRGlzcG9zYWJsZVtdID0gW11cblxuICAvKipcbiAgICogU2V0IHVwIGFsbCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIHRlcm1pbmFsXG4gICAqIFVzZXMgYSBzaW5nbGUgY29uc29saWRhdGVkIGFwcHJvYWNoIGluc3RlYWQgb2YgbXVsdGlwbGUgY3JlYXRlRWZmZWN0IGNhbGxzXG4gICAqL1xuICBzZXR1cEV2ZW50TGlzdGVuZXJzKHRlcm1pbmFsOiBUZXJtaW5hbCwgaGFuZGxlcnM6IFhUZXJtRXZlbnRIYW5kbGVycyk6IHZvaWQge1xuICAgIC8vIEJlbGwgZXZlbnRcbiAgICBpZiAoaGFuZGxlcnMub25CZWxsKSB7XG4gICAgICB0aGlzLmFkZERpc3Bvc2FibGUoXG4gICAgICAgIHRlcm1pbmFsLm9uQmVsbCgoKSA9PiB7XG4gICAgICAgICAgaGFuZGxlcnMub25CZWxsPy4oKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIEJpbmFyeSBldmVudFxuICAgIGlmIChoYW5kbGVycy5vbkJpbmFyeSkge1xuICAgICAgdGhpcy5hZGREaXNwb3NhYmxlKFxuICAgICAgICB0ZXJtaW5hbC5vbkJpbmFyeSgoZGF0YSkgPT4ge1xuICAgICAgICAgIGhhbmRsZXJzLm9uQmluYXJ5Py4oZGF0YSlcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBDdXJzb3IgbW92ZSBldmVudFxuICAgIGlmIChoYW5kbGVycy5vbkN1cnNvck1vdmUpIHtcbiAgICAgIHRoaXMuYWRkRGlzcG9zYWJsZShcbiAgICAgICAgdGVybWluYWwub25DdXJzb3JNb3ZlKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBidWZmZXIgPSB0ZXJtaW5hbC5idWZmZXIuYWN0aXZlXG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7IHg6IGJ1ZmZlci5jdXJzb3JYLCB5OiBidWZmZXIuY3Vyc29yWSB9XG4gICAgICAgICAgaGFuZGxlcnMub25DdXJzb3JNb3ZlPy4ocG9zaXRpb24pXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gRGF0YSBldmVudCAobW9zdCBpbXBvcnRhbnQgZm9yIHRlcm1pbmFsIGlucHV0KVxuICAgIGlmIChoYW5kbGVycy5vbkRhdGEpIHtcbiAgICAgIHRoaXMuYWRkRGlzcG9zYWJsZShcbiAgICAgICAgdGVybWluYWwub25EYXRhKChkYXRhKSA9PiB7XG4gICAgICAgICAgaGFuZGxlcnMub25EYXRhPy4oZGF0YSlcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBLZXkgZXZlbnRcbiAgICBpZiAoaGFuZGxlcnMub25LZXkpIHtcbiAgICAgIHRoaXMuYWRkRGlzcG9zYWJsZShcbiAgICAgICAgdGVybWluYWwub25LZXkoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaGFuZGxlcnMub25LZXk/LihldmVudClcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBMaW5lIGZlZWQgZXZlbnRcbiAgICBpZiAoaGFuZGxlcnMub25MaW5lRmVlZCkge1xuICAgICAgdGhpcy5hZGREaXNwb3NhYmxlKFxuICAgICAgICB0ZXJtaW5hbC5vbkxpbmVGZWVkKCgpID0+IHtcbiAgICAgICAgICBoYW5kbGVycy5vbkxpbmVGZWVkPy4oKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFJlbmRlciBldmVudFxuICAgIGlmIChoYW5kbGVycy5vblJlbmRlcikge1xuICAgICAgdGhpcy5hZGREaXNwb3NhYmxlKFxuICAgICAgICB0ZXJtaW5hbC5vblJlbmRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICBoYW5kbGVycy5vblJlbmRlcj8uKGV2ZW50KVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFJlc2l6ZSBldmVudCAoaW1wb3J0YW50IGZvciByZXNwb25zaXZlIHRlcm1pbmFscylcbiAgICBpZiAoaGFuZGxlcnMub25SZXNpemUpIHtcbiAgICAgIHRoaXMuYWRkRGlzcG9zYWJsZShcbiAgICAgICAgdGVybWluYWwub25SZXNpemUoKHNpemUpID0+IHtcbiAgICAgICAgICBoYW5kbGVycy5vblJlc2l6ZT8uKHNpemUpXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gU2Nyb2xsIGV2ZW50XG4gICAgaWYgKGhhbmRsZXJzLm9uU2Nyb2xsKSB7XG4gICAgICB0aGlzLmFkZERpc3Bvc2FibGUoXG4gICAgICAgIHRlcm1pbmFsLm9uU2Nyb2xsKCh5UG9zKSA9PiB7XG4gICAgICAgICAgaGFuZGxlcnMub25TY3JvbGw/Lih5UG9zKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFNlbGVjdGlvbiBjaGFuZ2UgZXZlbnRcbiAgICBpZiAoaGFuZGxlcnMub25TZWxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuYWRkRGlzcG9zYWJsZShcbiAgICAgICAgdGVybWluYWwub25TZWxlY3Rpb25DaGFuZ2UoKCkgPT4ge1xuICAgICAgICAgIGhhbmRsZXJzLm9uU2VsZWN0aW9uQ2hhbmdlPy4oKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFRpdGxlIGNoYW5nZSBldmVudFxuICAgIGlmIChoYW5kbGVycy5vblRpdGxlQ2hhbmdlKSB7XG4gICAgICB0aGlzLmFkZERpc3Bvc2FibGUoXG4gICAgICAgIHRlcm1pbmFsLm9uVGl0bGVDaGFuZ2UoKHRpdGxlKSA9PiB7XG4gICAgICAgICAgaGFuZGxlcnMub25UaXRsZUNoYW5nZT8uKHRpdGxlKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIFdyaXRlIHBhcnNlZCBldmVudFxuICAgIGlmIChoYW5kbGVycy5vbldyaXRlUGFyc2VkKSB7XG4gICAgICB0aGlzLmFkZERpc3Bvc2FibGUoXG4gICAgICAgIHRlcm1pbmFsLm9uV3JpdGVQYXJzZWQoKCkgPT4ge1xuICAgICAgICAgIGhhbmRsZXJzLm9uV3JpdGVQYXJzZWQ/LigpXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBldmVudCBoYW5kbGVycyB3aGVuIHByb3BzIGNoYW5nZVxuICAgKiBPbmx5IHVwZGF0ZXMgY2hhbmdlZCBoYW5kbGVycyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBkaXNwb3NhbHNcbiAgICovXG4gIHVwZGF0ZUV2ZW50SGFuZGxlcnMoXG4gICAgdGVybWluYWw6IFRlcm1pbmFsLFxuICAgIG5ld0hhbmRsZXJzOiBYVGVybUV2ZW50SGFuZGxlcnMsXG4gICAgX3ByZXZIYW5kbGVycz86IFhUZXJtRXZlbnRIYW5kbGVyc1xuICApOiB2b2lkIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgd2UnbGwgZGlzcG9zZSBhbGwgYW5kIHJlLXNldHVwXG4gICAgLy8gSW4gYSBtb3JlIG9wdGltaXplZCB2ZXJzaW9uLCB3ZSBjb3VsZCBkaWZmIHRoZSBoYW5kbGVyc1xuICAgIHRoaXMuZGlzcG9zZSgpXG4gICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKHRlcm1pbmFsLCBuZXdIYW5kbGVycylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBkaXNwb3NhYmxlIHRvIG91ciBjbGVhbnVwIGxpc3RcbiAgICovXG4gIHByaXZhdGUgYWRkRGlzcG9zYWJsZShkaXNwb3NhYmxlOiBJRGlzcG9zYWJsZSk6IHZvaWQge1xuICAgIHRoaXMuZGlzcG9zYWJsZXMucHVzaChkaXNwb3NhYmxlKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5kaXNwb3NhYmxlcy5mb3JFYWNoKChkaXNwb3NhYmxlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNwb3NhYmxlLmRpc3Bvc2UoKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGlzcG9zaW5nIGV2ZW50IGxpc3RlbmVyOicsIGVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5kaXNwb3NhYmxlcyA9IFtdXG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZVNpZ25hbCwgY3JlYXRlRWZmZWN0LCBvbkNsZWFudXAsIG9uTW91bnQgfSBmcm9tICdzb2xpZC1qcyc7XG5pbXBvcnQgeyBUZXJtaW5hbCB9IGZyb20gJ0B4dGVybS94dGVybSc7XG5pbXBvcnQgdHlwZSB7IFhUZXJtUHJvcHMsIFRlcm1pbmFsUmVmLCBYVGVybUV2ZW50SGFuZGxlcnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBBZGRvbk1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9hZGRvbi1tYW5hZ2VyJztcbmltcG9ydCB7IEV2ZW50TWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL2V2ZW50LW1hbmFnZXInO1xuXG4vLyBJbXBvcnQgZGVmYXVsdCB4dGVybS5qcyBzdHlsZXMgY29uZGl0aW9uYWxseVxubGV0IHN0eWxlc0xvYWRlZCA9IGZhbHNlO1xuY29uc3QgbG9hZERlZmF1bHRTdHlsZXMgPSAoKSA9PiB7XG4gIGlmICghc3R5bGVzTG9hZGVkKSB7XG4gICAgaW1wb3J0KCdAeHRlcm0veHRlcm0vY3NzL3h0ZXJtLmNzcycpO1xuICAgIHN0eWxlc0xvYWRlZCA9IHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogQSBwcm9kdWN0aW9uLXJlYWR5IFNvbGlkSlMgd3JhcHBlciBmb3IgeHRlcm0uanNcbiAqIFxuICogRmVhdHVyZXM6XG4gKiAtIFByb3BlciBtZW1vcnkgbWFuYWdlbWVudCBhbmQgY2xlYW51cFxuICogLSBDb25zb2xpZGF0ZWQgZXZlbnQgaGFuZGxpbmcgKG5vIG1lbW9yeSBsZWFrcylcbiAqIC0gRnVsbCBhZGRvbiBzdXBwb3J0IHdpdGggdHlwZSBzYWZldHlcbiAqIC0gSW1wZXJhdGl2ZSBBUEkgdmlhIHJlZnNcbiAqIC0gT3B0aW1pemVkIHJlYWN0aXZlIHBhdHRlcm5zXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIDxYVGVybVxuICogICBvcHRpb25zPXt7IGZvbnRTaXplOiAxNCwgY3Vyc29yQmxpbms6IHRydWUgfX1cbiAqICAgb25EYXRhPXsoZGF0YSkgPT4gc2VuZFRvU1NIKGRhdGEpfVxuICogICBvbk1vdW50PXsodGVybWluYWwsIHJlZikgPT4ge1xuICogICAgIHJlZi53cml0ZSgnV2VsY29tZSB0byBYVGVybSFcXG4nKTtcbiAqICAgfX1cbiAqICAgYWRkb25zPXtbRml0QWRkb24sIFNlYXJjaEFkZG9uXX1cbiAqIC8+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFhUZXJtKHByb3BzOiBYVGVybVByb3BzKSB7XG4gIGNvbnN0IFt0ZXJtaW5hbCwgc2V0VGVybWluYWxdID0gY3JlYXRlU2lnbmFsPFRlcm1pbmFsPigpO1xuICBjb25zdCBbY29udGFpbmVyUmVmLCBzZXRDb250YWluZXJSZWZdID0gY3JlYXRlU2lnbmFsPEhUTUxEaXZFbGVtZW50PigpO1xuICBcbiAgbGV0IGFkZG9uTWFuYWdlcjogQWRkb25NYW5hZ2VyO1xuICBsZXQgZXZlbnRNYW5hZ2VyOiBFdmVudE1hbmFnZXI7XG4gIGxldCBtb3VudENsZWFudXA6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcblxuICAvLyBDcmVhdGUgdGVybWluYWwgcmVmZXJlbmNlIGZvciBpbXBlcmF0aXZlIGFjY2Vzc1xuICBjb25zdCBjcmVhdGVUZXJtaW5hbFJlZiA9ICh0ZXJtOiBUZXJtaW5hbCk6IFRlcm1pbmFsUmVmID0+ICh7XG4gICAgZ2V0IHRlcm1pbmFsKCkgeyByZXR1cm4gdGVybTsgfSxcbiAgICB3cml0ZTogKGRhdGE6IHN0cmluZykgPT4gdGVybS53cml0ZShkYXRhKSxcbiAgICB3cml0ZWxuOiAoZGF0YTogc3RyaW5nKSA9PiB0ZXJtLndyaXRlbG4oZGF0YSksXG4gICAgY2xlYXI6ICgpID0+IHRlcm0uY2xlYXIoKSxcbiAgICByZXNldDogKCkgPT4gdGVybS5yZXNldCgpLFxuICAgIGZvY3VzOiAoKSA9PiB0ZXJtLmZvY3VzKCksXG4gICAgYmx1cjogKCkgPT4gdGVybS5ibHVyKCksXG4gICAgc2Nyb2xsVG9Ub3A6ICgpID0+IHRlcm0uc2Nyb2xsVG9Ub3AoKSxcbiAgICBzY3JvbGxUb0JvdHRvbTogKCkgPT4gdGVybS5zY3JvbGxUb0JvdHRvbSgpLFxuICAgIHNjcm9sbFRvTGluZTogKGxpbmU6IG51bWJlcikgPT4gdGVybS5zY3JvbGxUb0xpbmUobGluZSksXG4gICAgc2VsZWN0OiAoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyLCBsZW5ndGg6IG51bWJlcikgPT4gdGVybS5zZWxlY3QoY29sLCByb3csIGxlbmd0aCksXG4gICAgc2VsZWN0QWxsOiAoKSA9PiB0ZXJtLnNlbGVjdEFsbCgpLFxuICAgIHNlbGVjdExpbmVzOiAoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpID0+IHRlcm0uc2VsZWN0TGluZXMoc3RhcnQsIGVuZCksXG4gICAgY2xlYXJTZWxlY3Rpb246ICgpID0+IHRlcm0uY2xlYXJTZWxlY3Rpb24oKSxcbiAgICBnZXRTZWxlY3Rpb246ICgpID0+IHRlcm0uZ2V0U2VsZWN0aW9uKCksXG4gICAgaGFzU2VsZWN0aW9uOiAoKSA9PiB0ZXJtLmhhc1NlbGVjdGlvbigpLFxuICAgIHJlc2l6ZTogKGNvbHM6IG51bWJlciwgcm93czogbnVtYmVyKSA9PiB0ZXJtLnJlc2l6ZShjb2xzLCByb3dzKSxcbiAgICAvLyBBZGRvbi1zcGVjaWZpYyBtZXRob2RzIChhdmFpbGFibGUgb25seSBpZiBhZGRvbnMgYXJlIGxvYWRlZClcbiAgICBmaXQ6ICgpID0+IHtcbiAgICAgIC8vIFRyeSB0byBnZXQgRml0QWRkb24gZnJvbSBvdXIgYWRkb24gbWFuYWdlclxuICAgICAgY29uc3QgYWRkb25zID0gYWRkb25NYW5hZ2VyPy5nZXRBbGxBZGRvbnMoKSB8fCBbXTtcbiAgICAgIGNvbnN0IGZpdEFkZG9uID0gYWRkb25zLmZpbmQoYWRkb24gPT4gXG4gICAgICAgIGFkZG9uICYmIGFkZG9uLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdGaXRBZGRvbicgJiYgdHlwZW9mIChhZGRvbiBhcyBhbnkpLmZpdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKGZpdEFkZG9uKSB7XG4gICAgICAgIChmaXRBZGRvbiBhcyBhbnkpLmZpdCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZmluZE5leHQ6ICh0ZXJtOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IHNlYXJjaEFkZG9uID0gYWRkb25NYW5hZ2VyPy5nZXRBZGRvbihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKGdsb2JhbFRoaXMgYXMgYW55KS5TZWFyY2hBZGRvbiB8fCBjbGFzcyBTZWFyY2hBZGRvbiB7IGZpbmROZXh0KCkgeyByZXR1cm4gZmFsc2U7IH0gfVxuICAgICAgKTtcbiAgICAgIGlmIChzZWFyY2hBZGRvbiAmJiAnZmluZE5leHQnIGluIHNlYXJjaEFkZG9uKSB7XG4gICAgICAgIHJldHVybiAoc2VhcmNoQWRkb24gYXMgeyBmaW5kTmV4dCh0ZXJtOiBzdHJpbmcpOiBib29sZWFuIH0pLmZpbmROZXh0KHRlcm0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZmluZFByZXZpb3VzOiAodGVybTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBzZWFyY2hBZGRvbiA9IGFkZG9uTWFuYWdlcj8uZ2V0QWRkb24oXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChnbG9iYWxUaGlzIGFzIGFueSkuU2VhcmNoQWRkb24gfHwgY2xhc3MgU2VhcmNoQWRkb24geyBmaW5kUHJldmlvdXMoKSB7IHJldHVybiBmYWxzZTsgfSB9XG4gICAgICApO1xuICAgICAgaWYgKHNlYXJjaEFkZG9uICYmICdmaW5kUHJldmlvdXMnIGluIHNlYXJjaEFkZG9uKSB7XG4gICAgICAgIHJldHVybiAoc2VhcmNoQWRkb24gYXMgeyBmaW5kUHJldmlvdXModGVybTogc3RyaW5nKTogYm9vbGVhbiB9KS5maW5kUHJldmlvdXModGVybSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbml0aWFsaXplIHRlcm1pbmFsIHdoZW4gY29udGFpbmVyIGlzIHJlYWR5XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmKCk7XG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybjtcblxuICAgIC8vIExvYWQgZGVmYXVsdCBzdHlsZXMgaWYgcmVxdWVzdGVkXG4gICAgaWYgKHByb3BzLmxvYWREZWZhdWx0U3R5bGVzICE9PSBmYWxzZSkge1xuICAgICAgbG9hZERlZmF1bHRTdHlsZXMoKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGVybWluYWwgaW5zdGFuY2VcbiAgICBjb25zdCB0ZXJtID0gbmV3IFRlcm1pbmFsKHByb3BzLm9wdGlvbnMpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgbWFuYWdlcnNcbiAgICBhZGRvbk1hbmFnZXIgPSBuZXcgQWRkb25NYW5hZ2VyKCk7XG4gICAgZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcigpO1xuXG4gICAgLy8gTG9hZCBhZGRvbnMgYmVmb3JlIG9wZW5pbmcgdGVybWluYWxcbiAgICBpZiAocHJvcHMuYWRkb25zICYmIHByb3BzLmFkZG9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBhZGRvbk1hbmFnZXIubG9hZEFkZG9ucyh0ZXJtLCBwcm9wcy5hZGRvbnMpO1xuICAgIH1cblxuICAgIC8vIE9wZW4gdGVybWluYWwgaW4gY29udGFpbmVyXG4gICAgdGVybS5vcGVuKGNvbnRhaW5lcik7XG4gICAgXG4gICAgLy8gU2V0IHVwIGV2ZW50IGxpc3RlbmVycyAtIGZpbHRlciBvdXQgdW5kZWZpbmVkIGhhbmRsZXJzXG4gICAgY29uc3QgZXZlbnRIYW5kbGVyczogWFRlcm1FdmVudEhhbmRsZXJzID0ge307XG4gICAgaWYgKHByb3BzLm9uQmVsbCkgZXZlbnRIYW5kbGVycy5vbkJlbGwgPSBwcm9wcy5vbkJlbGw7XG4gICAgaWYgKHByb3BzLm9uQmluYXJ5KSBldmVudEhhbmRsZXJzLm9uQmluYXJ5ID0gcHJvcHMub25CaW5hcnk7XG4gICAgaWYgKHByb3BzLm9uQ3Vyc29yTW92ZSkgZXZlbnRIYW5kbGVycy5vbkN1cnNvck1vdmUgPSBwcm9wcy5vbkN1cnNvck1vdmU7XG4gICAgaWYgKHByb3BzLm9uRGF0YSkgZXZlbnRIYW5kbGVycy5vbkRhdGEgPSBwcm9wcy5vbkRhdGE7XG4gICAgaWYgKHByb3BzLm9uS2V5KSBldmVudEhhbmRsZXJzLm9uS2V5ID0gcHJvcHMub25LZXk7XG4gICAgaWYgKHByb3BzLm9uTGluZUZlZWQpIGV2ZW50SGFuZGxlcnMub25MaW5lRmVlZCA9IHByb3BzLm9uTGluZUZlZWQ7XG4gICAgaWYgKHByb3BzLm9uUmVuZGVyKSBldmVudEhhbmRsZXJzLm9uUmVuZGVyID0gcHJvcHMub25SZW5kZXI7XG4gICAgaWYgKHByb3BzLm9uUmVzaXplKSBldmVudEhhbmRsZXJzLm9uUmVzaXplID0gcHJvcHMub25SZXNpemU7XG4gICAgaWYgKHByb3BzLm9uU2Nyb2xsKSBldmVudEhhbmRsZXJzLm9uU2Nyb2xsID0gcHJvcHMub25TY3JvbGw7XG4gICAgaWYgKHByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKSBldmVudEhhbmRsZXJzLm9uU2VsZWN0aW9uQ2hhbmdlID0gcHJvcHMub25TZWxlY3Rpb25DaGFuZ2U7XG4gICAgaWYgKHByb3BzLm9uVGl0bGVDaGFuZ2UpIGV2ZW50SGFuZGxlcnMub25UaXRsZUNoYW5nZSA9IHByb3BzLm9uVGl0bGVDaGFuZ2U7XG4gICAgaWYgKHByb3BzLm9uV3JpdGVQYXJzZWQpIGV2ZW50SGFuZGxlcnMub25Xcml0ZVBhcnNlZCA9IHByb3BzLm9uV3JpdGVQYXJzZWQ7XG4gICAgZXZlbnRNYW5hZ2VyLnNldHVwRXZlbnRMaXN0ZW5lcnModGVybSwgZXZlbnRIYW5kbGVycyk7XG5cbiAgICAvLyBDcmVhdGUgdGVybWluYWwgcmVmZXJlbmNlXG4gICAgY29uc3QgdGVybWluYWxSZWYgPSBjcmVhdGVUZXJtaW5hbFJlZih0ZXJtKTtcbiAgICBcbiAgICAvLyBDYWxsIG1vdW50IGNhbGxiYWNrXG4gICAgaWYgKHByb3BzLm9uTW91bnQpIHtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSBwcm9wcy5vbk1vdW50KHRlcm0sIHRlcm1pbmFsUmVmKTtcbiAgICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb3VudENsZWFudXAgPSBjbGVhbnVwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb3ZpZGUgcmVmIHRvIHBhcmVudCBpZiByZXF1ZXN0ZWRcbiAgICBpZiAocHJvcHMucmVmKSB7XG4gICAgICBwcm9wcy5yZWYodGVybWluYWxSZWYpO1xuICAgIH1cblxuICAgIC8vIEF1dG8tZm9jdXMgaWYgcmVxdWVzdGVkXG4gICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgLy8gVXNlIHNldFRpbWVvdXQgdG8gZW5zdXJlIHRlcm1pbmFsIGlzIGZ1bGx5IGluaXRpYWxpemVkXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRlcm0uZm9jdXMoKSwgMCk7XG4gICAgfVxuXG4gICAgc2V0VGVybWluYWwodGVybSk7XG4gIH0pO1xuXG4gIC8vIFVwZGF0ZSBldmVudCBoYW5kbGVycyB3aGVuIHByb3BzIGNoYW5nZVxuICBjcmVhdGVFZmZlY3QoKHByZXZIYW5kbGVycykgPT4ge1xuICAgIGNvbnN0IHRlcm0gPSB0ZXJtaW5hbCgpO1xuICAgIGlmICghdGVybSB8fCAhZXZlbnRNYW5hZ2VyKSByZXR1cm47XG5cbiAgICBjb25zdCBjdXJyZW50SGFuZGxlcnM6IFhUZXJtRXZlbnRIYW5kbGVycyA9IHt9O1xuICAgIGlmIChwcm9wcy5vbkJlbGwpIGN1cnJlbnRIYW5kbGVycy5vbkJlbGwgPSBwcm9wcy5vbkJlbGw7XG4gICAgaWYgKHByb3BzLm9uQmluYXJ5KSBjdXJyZW50SGFuZGxlcnMub25CaW5hcnkgPSBwcm9wcy5vbkJpbmFyeTtcbiAgICBpZiAocHJvcHMub25DdXJzb3JNb3ZlKSBjdXJyZW50SGFuZGxlcnMub25DdXJzb3JNb3ZlID0gcHJvcHMub25DdXJzb3JNb3ZlO1xuICAgIGlmIChwcm9wcy5vbkRhdGEpIGN1cnJlbnRIYW5kbGVycy5vbkRhdGEgPSBwcm9wcy5vbkRhdGE7XG4gICAgaWYgKHByb3BzLm9uS2V5KSBjdXJyZW50SGFuZGxlcnMub25LZXkgPSBwcm9wcy5vbktleTtcbiAgICBpZiAocHJvcHMub25MaW5lRmVlZCkgY3VycmVudEhhbmRsZXJzLm9uTGluZUZlZWQgPSBwcm9wcy5vbkxpbmVGZWVkO1xuICAgIGlmIChwcm9wcy5vblJlbmRlcikgY3VycmVudEhhbmRsZXJzLm9uUmVuZGVyID0gcHJvcHMub25SZW5kZXI7XG4gICAgaWYgKHByb3BzLm9uUmVzaXplKSBjdXJyZW50SGFuZGxlcnMub25SZXNpemUgPSBwcm9wcy5vblJlc2l6ZTtcbiAgICBpZiAocHJvcHMub25TY3JvbGwpIGN1cnJlbnRIYW5kbGVycy5vblNjcm9sbCA9IHByb3BzLm9uU2Nyb2xsO1xuICAgIGlmIChwcm9wcy5vblNlbGVjdGlvbkNoYW5nZSkgY3VycmVudEhhbmRsZXJzLm9uU2VsZWN0aW9uQ2hhbmdlID0gcHJvcHMub25TZWxlY3Rpb25DaGFuZ2U7XG4gICAgaWYgKHByb3BzLm9uVGl0bGVDaGFuZ2UpIGN1cnJlbnRIYW5kbGVycy5vblRpdGxlQ2hhbmdlID0gcHJvcHMub25UaXRsZUNoYW5nZTtcbiAgICBpZiAocHJvcHMub25Xcml0ZVBhcnNlZCkgY3VycmVudEhhbmRsZXJzLm9uV3JpdGVQYXJzZWQgPSBwcm9wcy5vbldyaXRlUGFyc2VkO1xuXG4gICAgLy8gT25seSB1cGRhdGUgaWYgaGFuZGxlcnMgYWN0dWFsbHkgY2hhbmdlZFxuICAgIGlmIChKU09OLnN0cmluZ2lmeShjdXJyZW50SGFuZGxlcnMpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2SGFuZGxlcnMpKSB7XG4gICAgICBldmVudE1hbmFnZXIudXBkYXRlRXZlbnRIYW5kbGVycyh0ZXJtLCBjdXJyZW50SGFuZGxlcnMsIHByZXZIYW5kbGVycyBhcyBYVGVybUV2ZW50SGFuZGxlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50SGFuZGxlcnM7XG4gIH0pO1xuXG4gIC8vIENsZWFudXAgb24gdW5tb3VudFxuICBvbkNsZWFudXAoKCkgPT4ge1xuICAgIGNvbnN0IHRlcm0gPSB0ZXJtaW5hbCgpO1xuICAgIFxuICAgIC8vIENhbGwgdW5tb3VudCBjYWxsYmFja1xuICAgIGlmIChwcm9wcy5vblVubW91bnQgJiYgdGVybSkge1xuICAgICAgcHJvcHMub25Vbm1vdW50KHRlcm0pO1xuICAgIH1cblxuICAgIC8vIENhbGwgbW91bnQgY2xlYW51cFxuICAgIGlmIChtb3VudENsZWFudXApIHtcbiAgICAgIG1vdW50Q2xlYW51cCgpO1xuICAgICAgbW91bnRDbGVhbnVwID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIENsZWFudXAgbWFuYWdlcnNcbiAgICBpZiAoZXZlbnRNYW5hZ2VyKSB7XG4gICAgICBldmVudE1hbmFnZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoYWRkb25NYW5hZ2VyKSB7XG4gICAgICBhZGRvbk1hbmFnZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIERpc3Bvc2UgdGVybWluYWxcbiAgICBpZiAodGVybSkge1xuICAgICAgdGVybS5kaXNwb3NlKCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHJlZj17c2V0Q29udGFpbmVyUmVmfVxuICAgICAgY2xhc3M9e3Byb3BzLmNsYXNzIHx8ICd4dGVybS1jb250YWluZXInfVxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIC4uLnByb3BzLnN0eWxlXG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59IiwiY29uc3QgUEFDS0VUX1RZUEVTID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gbm8gTWFwID0gbm8gcG9seWZpbGxcblBBQ0tFVF9UWVBFU1tcIm9wZW5cIl0gPSBcIjBcIjtcblBBQ0tFVF9UWVBFU1tcImNsb3NlXCJdID0gXCIxXCI7XG5QQUNLRVRfVFlQRVNbXCJwaW5nXCJdID0gXCIyXCI7XG5QQUNLRVRfVFlQRVNbXCJwb25nXCJdID0gXCIzXCI7XG5QQUNLRVRfVFlQRVNbXCJtZXNzYWdlXCJdID0gXCI0XCI7XG5QQUNLRVRfVFlQRVNbXCJ1cGdyYWRlXCJdID0gXCI1XCI7XG5QQUNLRVRfVFlQRVNbXCJub29wXCJdID0gXCI2XCI7XG5jb25zdCBQQUNLRVRfVFlQRVNfUkVWRVJTRSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5PYmplY3Qua2V5cyhQQUNLRVRfVFlQRVMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIFBBQ0tFVF9UWVBFU19SRVZFUlNFW1BBQ0tFVF9UWVBFU1trZXldXSA9IGtleTtcbn0pO1xuY29uc3QgRVJST1JfUEFDS0VUID0geyB0eXBlOiBcImVycm9yXCIsIGRhdGE6IFwicGFyc2VyIGVycm9yXCIgfTtcbmV4cG9ydCB7IFBBQ0tFVF9UWVBFUywgUEFDS0VUX1RZUEVTX1JFVkVSU0UsIEVSUk9SX1BBQ0tFVCB9O1xuIiwiaW1wb3J0IHsgUEFDS0VUX1RZUEVTIH0gZnJvbSBcIi4vY29tbW9ucy5qc1wiO1xuY29uc3Qgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gXCJbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl1cIik7XG5jb25zdCB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIjtcbi8vIEFycmF5QnVmZmVyLmlzVmlldyBtZXRob2QgaXMgbm90IGRlZmluZWQgaW4gSUUxMFxuY29uc3QgaXNWaWV3ID0gKG9iaikgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxuICAgICAgICA6IG9iaiAmJiBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuY29uc3QgZW5jb2RlUGFja2V0ID0gKHsgdHlwZSwgZGF0YSB9LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spID0+IHtcbiAgICBpZiAod2l0aE5hdGl2ZUJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlQmxvYkFzQmFzZTY0KGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiZcbiAgICAgICAgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcoZGF0YSkpKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUJsb2JBc0Jhc2U2NChuZXcgQmxvYihbZGF0YV0pLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcGxhaW4gc3RyaW5nXG4gICAgcmV0dXJuIGNhbGxiYWNrKFBBQ0tFVF9UWVBFU1t0eXBlXSArIChkYXRhIHx8IFwiXCIpKTtcbn07XG5jb25zdCBlbmNvZGVCbG9iQXNCYXNlNjQgPSAoZGF0YSwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZpbGVSZWFkZXIucmVzdWx0LnNwbGl0KFwiLFwiKVsxXTtcbiAgICAgICAgY2FsbGJhY2soXCJiXCIgKyAoY29udGVudCB8fCBcIlwiKSk7XG4gICAgfTtcbiAgICByZXR1cm4gZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGRhdGEpO1xufTtcbmZ1bmN0aW9uIHRvQXJyYXkoZGF0YSkge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgIH1cbn1cbmxldCBURVhUX0VOQ09ERVI7XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUGFja2V0VG9CaW5hcnkocGFja2V0LCBjYWxsYmFjaykge1xuICAgIGlmICh3aXRoTmF0aXZlQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHBhY2tldC5kYXRhLmFycmF5QnVmZmVyKCkudGhlbih0b0FycmF5KS50aGVuKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmXG4gICAgICAgIChwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGlzVmlldyhwYWNrZXQuZGF0YSkpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0b0FycmF5KHBhY2tldC5kYXRhKSk7XG4gICAgfVxuICAgIGVuY29kZVBhY2tldChwYWNrZXQsIGZhbHNlLCAoZW5jb2RlZCkgPT4ge1xuICAgICAgICBpZiAoIVRFWFRfRU5DT0RFUikge1xuICAgICAgICAgICAgVEVYVF9FTkNPREVSID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soVEVYVF9FTkNPREVSLmVuY29kZShlbmNvZGVkKSk7XG4gICAgfSk7XG59XG5leHBvcnQgeyBlbmNvZGVQYWNrZXQgfTtcbiIsIi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tldGlvL2Jhc2U2NC1hcnJheWJ1ZmZlclxuY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4vLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG5jb25zdCBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBbXSA6IG5ldyBVaW50OEFycmF5KDI1Nik7XG5mb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbn1cbmV4cG9ydCBjb25zdCBlbmNvZGUgPSAoYXJyYXlidWZmZXIpID0+IHtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gJyc7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG4gICAgaWYgKGxlbiAlIDMgPT09IDIpIHtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyAnPSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyAnPT0nO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTY0O1xufTtcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAoYmFzZTY0KSA9PiB7XG4gICAgbGV0IGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LCBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCwgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09ICc9Jykge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09ICc9Jykge1xuICAgICAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSwgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGVuY29kZWQxID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgZW5jb2RlZDIgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDIpXTtcbiAgICAgICAgZW5jb2RlZDQgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbn07XG4iLCJpbXBvcnQgeyBFUlJPUl9QQUNLRVQsIFBBQ0tFVF9UWVBFU19SRVZFUlNFLCB9IGZyb20gXCIuL2NvbW1vbnMuanNcIjtcbmltcG9ydCB7IGRlY29kZSB9IGZyb20gXCIuL2NvbnRyaWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzXCI7XG5jb25zdCB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIjtcbmV4cG9ydCBjb25zdCBkZWNvZGVQYWNrZXQgPSAoZW5jb2RlZFBhY2tldCwgYmluYXJ5VHlwZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgZW5jb2RlZFBhY2tldCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICBkYXRhOiBtYXBCaW5hcnkoZW5jb2RlZFBhY2tldCwgYmluYXJ5VHlwZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBlbmNvZGVkUGFja2V0LmNoYXJBdCgwKTtcbiAgICBpZiAodHlwZSA9PT0gXCJiXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgZGF0YTogZGVjb2RlQmFzZTY0UGFja2V0KGVuY29kZWRQYWNrZXQuc3Vic3RyaW5nKDEpLCBiaW5hcnlUeXBlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGFja2V0VHlwZSA9IFBBQ0tFVF9UWVBFU19SRVZFUlNFW3R5cGVdO1xuICAgIGlmICghcGFja2V0VHlwZSkge1xuICAgICAgICByZXR1cm4gRVJST1JfUEFDS0VUO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZFBhY2tldC5sZW5ndGggPiAxXG4gICAgICAgID8ge1xuICAgICAgICAgICAgdHlwZTogUEFDS0VUX1RZUEVTX1JFVkVSU0VbdHlwZV0sXG4gICAgICAgICAgICBkYXRhOiBlbmNvZGVkUGFja2V0LnN1YnN0cmluZygxKSxcbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHR5cGU6IFBBQ0tFVF9UWVBFU19SRVZFUlNFW3R5cGVdLFxuICAgICAgICB9O1xufTtcbmNvbnN0IGRlY29kZUJhc2U2NFBhY2tldCA9IChkYXRhLCBiaW5hcnlUeXBlKSA9PiB7XG4gICAgaWYgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlcikge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlKGRhdGEpO1xuICAgICAgICByZXR1cm4gbWFwQmluYXJ5KGRlY29kZWQsIGJpbmFyeVR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgYmFzZTY0OiB0cnVlLCBkYXRhIH07IC8vIGZhbGxiYWNrIGZvciBvbGQgYnJvd3NlcnNcbiAgICB9XG59O1xuY29uc3QgbWFwQmluYXJ5ID0gKGRhdGEsIGJpbmFyeVR5cGUpID0+IHtcbiAgICBzd2l0Y2ggKGJpbmFyeVR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgIC8vIGZyb20gV2ViU29ja2V0ICsgYmluYXJ5VHlwZSBcImJsb2JcIlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBIVFRQIGxvbmctcG9sbGluZyBvciBXZWJUcmFuc3BvcnRcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoW2RhdGFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBIVFRQIGxvbmctcG9sbGluZyAoYmFzZTY0KSBvciBXZWJTb2NrZXQgKyBiaW5hcnlUeXBlIFwiYXJyYXlidWZmZXJcIlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZnJvbSBXZWJUcmFuc3BvcnQgKFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgIH1cbn07XG4iLCJpbXBvcnQgeyBlbmNvZGVQYWNrZXQsIGVuY29kZVBhY2tldFRvQmluYXJ5IH0gZnJvbSBcIi4vZW5jb2RlUGFja2V0LmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVQYWNrZXQgfSBmcm9tIFwiLi9kZWNvZGVQYWNrZXQuanNcIjtcbmltcG9ydCB7IEVSUk9SX1BBQ0tFVCwgfSBmcm9tIFwiLi9jb21tb25zLmpzXCI7XG5jb25zdCBTRVBBUkFUT1IgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMwKTsgLy8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlbGltaXRlciNBU0NJSV9kZWxpbWl0ZWRfdGV4dFxuY29uc3QgZW5jb2RlUGF5bG9hZCA9IChwYWNrZXRzLCBjYWxsYmFjaykgPT4ge1xuICAgIC8vIHNvbWUgcGFja2V0cyBtYXkgYmUgYWRkZWQgdG8gdGhlIGFycmF5IHdoaWxlIGVuY29kaW5nLCBzbyB0aGUgaW5pdGlhbCBsZW5ndGggbXVzdCBiZSBzYXZlZFxuICAgIGNvbnN0IGxlbmd0aCA9IHBhY2tldHMubGVuZ3RoO1xuICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBwYWNrZXRzLmZvckVhY2goKHBhY2tldCwgaSkgPT4ge1xuICAgICAgICAvLyBmb3JjZSBiYXNlNjQgZW5jb2RpbmcgZm9yIGJpbmFyeSBwYWNrZXRzXG4gICAgICAgIGVuY29kZVBhY2tldChwYWNrZXQsIGZhbHNlLCAoZW5jb2RlZFBhY2tldCkgPT4ge1xuICAgICAgICAgICAgZW5jb2RlZFBhY2tldHNbaV0gPSBlbmNvZGVkUGFja2V0O1xuICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVuY29kZWRQYWNrZXRzLmpvaW4oU0VQQVJBVE9SKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmNvbnN0IGRlY29kZVBheWxvYWQgPSAoZW5jb2RlZFBheWxvYWQsIGJpbmFyeVR5cGUpID0+IHtcbiAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IGVuY29kZWRQYXlsb2FkLnNwbGl0KFNFUEFSQVRPUik7XG4gICAgY29uc3QgcGFja2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZFBhY2tldCA9IGRlY29kZVBhY2tldChlbmNvZGVkUGFja2V0c1tpXSwgYmluYXJ5VHlwZSk7XG4gICAgICAgIHBhY2tldHMucHVzaChkZWNvZGVkUGFja2V0KTtcbiAgICAgICAgaWYgKGRlY29kZWRQYWNrZXQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFja2V0cztcbn07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFja2V0RW5jb2RlclN0cmVhbSgpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybShwYWNrZXQsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGVuY29kZVBhY2tldFRvQmluYXJ5KHBhY2tldCwgKGVuY29kZWRQYWNrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkTGVuZ3RoID0gZW5jb2RlZFBhY2tldC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlcjtcbiAgICAgICAgICAgICAgICAvLyBpbnNwaXJlZCBieSB0aGUgV2ViU29ja2V0IGZvcm1hdDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldHNfQVBJL1dyaXRpbmdfV2ViU29ja2V0X3NlcnZlcnMjZGVjb2RpbmdfcGF5bG9hZF9sZW5ndGhcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZExlbmd0aCA8IDEyNikge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGFWaWV3KGhlYWRlci5idWZmZXIpLnNldFVpbnQ4KDAsIHBheWxvYWRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoMyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgoMCwgMTI2KTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MTYoMSwgcGF5bG9hZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgVWludDhBcnJheSg5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhoZWFkZXIuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OCgwLCAxMjcpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LnNldEJpZ1VpbnQ2NCgxLCBCaWdJbnQocGF5bG9hZExlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBiaXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgcGxhaW4gdGV4dCAoMCkgb3IgYmluYXJ5ICgxKVxuICAgICAgICAgICAgICAgIGlmIChwYWNrZXQuZGF0YSAmJiB0eXBlb2YgcGFja2V0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyWzBdIHw9IDB4ODA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShoZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkUGFja2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxubGV0IFRFWFRfREVDT0RFUjtcbmZ1bmN0aW9uIHRvdGFsTGVuZ3RoKGNodW5rcykge1xuICAgIHJldHVybiBjaHVua3MucmVkdWNlKChhY2MsIGNodW5rKSA9PiBhY2MgKyBjaHVuay5sZW5ndGgsIDApO1xufVxuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgc2l6ZSkge1xuICAgIGlmIChjaHVua3NbMF0ubGVuZ3RoID09PSBzaXplKSB7XG4gICAgICAgIHJldHVybiBjaHVua3Muc2hpZnQoKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IGNodW5rc1swXVtqKytdO1xuICAgICAgICBpZiAoaiA9PT0gY2h1bmtzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2h1bmtzLmxlbmd0aCAmJiBqIDwgY2h1bmtzWzBdLmxlbmd0aCkge1xuICAgICAgICBjaHVua3NbMF0gPSBjaHVua3NbMF0uc2xpY2Uoaik7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFja2V0RGVjb2RlclN0cmVhbShtYXhQYXlsb2FkLCBiaW5hcnlUeXBlKSB7XG4gICAgaWYgKCFURVhUX0RFQ09ERVIpIHtcbiAgICAgICAgVEVYVF9ERUNPREVSID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGxldCBzdGF0ZSA9IDAgLyogU3RhdGUuUkVBRF9IRUFERVIgKi87XG4gICAgbGV0IGV4cGVjdGVkTGVuZ3RoID0gLTE7XG4gICAgbGV0IGlzQmluYXJ5ID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAwIC8qIFN0YXRlLlJFQURfSEVBREVSICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbExlbmd0aChjaHVua3MpIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gY29uY2F0Q2h1bmtzKGNodW5rcywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlzQmluYXJ5ID0gKGhlYWRlclswXSAmIDB4ODApID09PSAweDgwO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZExlbmd0aCA9IGhlYWRlclswXSAmIDB4N2Y7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZExlbmd0aCA8IDEyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzIC8qIFN0YXRlLlJFQURfUEFZTE9BRCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChleHBlY3RlZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDEgLyogU3RhdGUuUkVBRF9FWFRFTkRFRF9MRU5HVEhfMTYgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDIgLyogU3RhdGUuUkVBRF9FWFRFTkRFRF9MRU5HVEhfNjQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09IDEgLyogU3RhdGUuUkVBRF9FWFRFTkRFRF9MRU5HVEhfMTYgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsTGVuZ3RoKGNodW5rcykgPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJBcnJheSA9IGNvbmNhdENodW5rcyhjaHVua3MsIDIpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZExlbmd0aCA9IG5ldyBEYXRhVmlldyhoZWFkZXJBcnJheS5idWZmZXIsIGhlYWRlckFycmF5LmJ5dGVPZmZzZXQsIGhlYWRlckFycmF5Lmxlbmd0aCkuZ2V0VWludDE2KDApO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDMgLyogU3RhdGUuUkVBRF9QQVlMT0FEICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gMiAvKiBTdGF0ZS5SRUFEX0VYVEVOREVEX0xFTkdUSF82NCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxMZW5ndGgoY2h1bmtzKSA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckFycmF5ID0gY29uY2F0Q2h1bmtzKGNodW5rcywgOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyQXJyYXkuYnVmZmVyLCBoZWFkZXJBcnJheS5ieXRlT2Zmc2V0LCBoZWFkZXJBcnJheS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gdmlldy5nZXRVaW50MzIoMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbWF4aW11bSBzYWZlIGludGVnZXIgaW4gSmF2YVNjcmlwdCBpcyAyXjUzIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKEVSUk9SX1BBQ0tFVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZExlbmd0aCA9IG4gKiBNYXRoLnBvdygyLCAzMikgKyB2aWV3LmdldFVpbnQzMig0KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzIC8qIFN0YXRlLlJFQURfUEFZTE9BRCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbExlbmd0aChjaHVua3MpIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjb25jYXRDaHVua3MoY2h1bmtzLCBleHBlY3RlZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkZWNvZGVQYWNrZXQoaXNCaW5hcnkgPyBkYXRhIDogVEVYVF9ERUNPREVSLmRlY29kZShkYXRhKSwgYmluYXJ5VHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDAgLyogU3RhdGUuUkVBRF9IRUFERVIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZExlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExlbmd0aCA+IG1heFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKEVSUk9SX1BBQ0tFVCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBwcm90b2NvbCA9IDQ7XG5leHBvcnQgeyBlbmNvZGVQYWNrZXQsIGVuY29kZVBheWxvYWQsIGRlY29kZVBhY2tldCwgZGVjb2RlUGF5bG9hZCwgfTtcbiIsIi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICBmdW5jdGlvbiBvbigpIHtcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xuICAvLyBvbmUgaXMgc3Vic2NyaWJlZCBmb3IgdG8gYXZvaWQgbWVtb3J5IGxlYWsuXG4gIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICB9XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBhbGlhcyB1c2VkIGZvciByZXNlcnZlZCBldmVudHMgKHByb3RlY3RlZCBtZXRob2QpXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0UmVzZXJ2ZWQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcbiIsImV4cG9ydCBjb25zdCBuZXh0VGljayA9ICgoKSA9PiB7XG4gICAgY29uc3QgaXNQcm9taXNlQXZhaWxhYmxlID0gdHlwZW9mIFByb21pc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgUHJvbWlzZS5yZXNvbHZlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgaWYgKGlzUHJvbWlzZUF2YWlsYWJsZSkge1xuICAgICAgICByZXR1cm4gKGNiKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGNiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoY2IsIHNldFRpbWVvdXRGbikgPT4gc2V0VGltZW91dEZuKGNiLCAwKTtcbiAgICB9XG59KSgpO1xuZXhwb3J0IGNvbnN0IGdsb2JhbFRoaXNTaGltID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG4gICAgfVxufSkoKTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0QmluYXJ5VHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb29raWVKYXIoKSB7IH1cbiIsImltcG9ydCB7IGdsb2JhbFRoaXNTaGltIGFzIGdsb2JhbFRoaXMgfSBmcm9tIFwiLi9nbG9iYWxzLm5vZGUuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwgLi4uYXR0cikge1xuICAgIHJldHVybiBhdHRyLnJlZHVjZSgoYWNjLCBrKSA9PiB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIGFjY1trXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbi8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHJlYWwgdGltZW91dCBmdW5jdGlvbnMgc28gdGhleSBjYW4gYmUgdXNlZCB3aGVuIG92ZXJyaWRkZW5cbmNvbnN0IE5BVElWRV9TRVRfVElNRU9VVCA9IGdsb2JhbFRoaXMuc2V0VGltZW91dDtcbmNvbnN0IE5BVElWRV9DTEVBUl9USU1FT1VUID0gZ2xvYmFsVGhpcy5jbGVhclRpbWVvdXQ7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbFRpbWVyRnVuY3Rpb25zKG9iaiwgb3B0cykge1xuICAgIGlmIChvcHRzLnVzZU5hdGl2ZVRpbWVycykge1xuICAgICAgICBvYmouc2V0VGltZW91dEZuID0gTkFUSVZFX1NFVF9USU1FT1VULmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgICAgIG9iai5jbGVhclRpbWVvdXRGbiA9IE5BVElWRV9DTEVBUl9USU1FT1VULmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYmouc2V0VGltZW91dEZuID0gZ2xvYmFsVGhpcy5zZXRUaW1lb3V0LmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgICAgIG9iai5jbGVhclRpbWVvdXRGbiA9IGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0LmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgfVxufVxuLy8gYmFzZTY0IGVuY29kZWQgYnVmZmVycyBhcmUgYWJvdXQgMzMlIGJpZ2dlciAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0KVxuY29uc3QgQkFTRTY0X09WRVJIRUFEID0gMS4zMztcbi8vIHdlIGNvdWxkIGFsc28gaGF2ZSB1c2VkIGBuZXcgQmxvYihbb2JqXSkuc2l6ZWAsIGJ1dCBpdCBpc24ndCBzdXBwb3J0ZWQgaW4gSUU5XG5leHBvcnQgZnVuY3Rpb24gYnl0ZUxlbmd0aChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdXRmOExlbmd0aChvYmopO1xuICAgIH1cbiAgICAvLyBhcnJheWJ1ZmZlciBvciBibG9iXG4gICAgcmV0dXJuIE1hdGguY2VpbCgob2JqLmJ5dGVMZW5ndGggfHwgb2JqLnNpemUpICogQkFTRTY0X09WRVJIRUFEKTtcbn1cbmZ1bmN0aW9uIHV0ZjhMZW5ndGgoc3RyKSB7XG4gICAgbGV0IGMgPSAwLCBsZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgbGVuZ3RoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGxlbmd0aCArPSA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSA4LWNoYXJhY3RlcnMgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU3RyaW5nKCkge1xuICAgIHJldHVybiAoRGF0ZS5ub3coKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDMpICtcbiAgICAgICAgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDUpKTtcbn1cbiIsIi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dhbGtuL3F1ZXJ5c3RyaW5nXG4vKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKG9iaikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyYnO1xuICAgICAgICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUocXMpIHtcbiAgICBsZXQgcXJ5ID0ge307XG4gICAgbGV0IHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBsZXQgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gcXJ5O1xufVxuIiwiaW1wb3J0IHsgZGVjb2RlUGFja2V0IH0gZnJvbSBcImVuZ2luZS5pby1wYXJzZXJcIjtcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tIFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiO1xuaW1wb3J0IHsgaW5zdGFsbFRpbWVyRnVuY3Rpb25zIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSBcIi4vY29udHJpYi9wYXJzZXFzLmpzXCI7XG5leHBvcnQgY2xhc3MgVHJhbnNwb3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVhc29uLCBkZXNjcmlwdGlvbiwgY29udGV4dCkge1xuICAgICAgICBzdXBlcihyZWFzb24pO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiVHJhbnNwb3J0RXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBpbnN0YWxsVGltZXJGdW5jdGlvbnModGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICAgICAgICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICAgICAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gIW9wdHMuZm9yY2VCYXNlNjQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSBjb250ZXh0IC0gdGhlIGVycm9yIGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkVycm9yKHJlYXNvbiwgZGVzY3JpcHRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgbmV3IFRyYW5zcG9ydEVycm9yKHJlYXNvbiwgZGVzY3JpcHRpb24sIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICAgIHRoaXMuZG9PcGVuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuaW5nXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAgICAgKi9cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGhhcHBlbiBpZiB0aGUgdHJhbnNwb3J0IHdhcyBzaWxlbnRseSBjbG9zZWQgaW4gdGhlIGJlZm9yZXVubG9hZCBldmVudCBoYW5kbGVyXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gb3BlblxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uT3BlbigpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuXCI7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJvcGVuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgY29uc3QgcGFja2V0ID0gZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICAgICAgICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25QYWNrZXQocGFja2V0KSB7XG4gICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcInBhY2tldFwiLCBwYWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkNsb3NlKGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiY2xvc2VcIiwgZGV0YWlscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlcyB0aGUgdHJhbnNwb3J0LCBpbiBvcmRlciBub3QgdG8gbG9zZSBwYWNrZXRzIGR1cmluZyBhbiB1cGdyYWRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9uUGF1c2VcbiAgICAgKi9cbiAgICBwYXVzZShvblBhdXNlKSB7IH1cbiAgICBjcmVhdGVVcmkoc2NoZW1hLCBxdWVyeSA9IHt9KSB7XG4gICAgICAgIHJldHVybiAoc2NoZW1hICtcbiAgICAgICAgICAgIFwiOi8vXCIgK1xuICAgICAgICAgICAgdGhpcy5faG9zdG5hbWUoKSArXG4gICAgICAgICAgICB0aGlzLl9wb3J0KCkgK1xuICAgICAgICAgICAgdGhpcy5vcHRzLnBhdGggK1xuICAgICAgICAgICAgdGhpcy5fcXVlcnkocXVlcnkpKTtcbiAgICB9XG4gICAgX2hvc3RuYW1lKCkge1xuICAgICAgICBjb25zdCBob3N0bmFtZSA9IHRoaXMub3B0cy5ob3N0bmFtZTtcbiAgICAgICAgcmV0dXJuIGhvc3RuYW1lLmluZGV4T2YoXCI6XCIpID09PSAtMSA/IGhvc3RuYW1lIDogXCJbXCIgKyBob3N0bmFtZSArIFwiXVwiO1xuICAgIH1cbiAgICBfcG9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5wb3J0ICYmXG4gICAgICAgICAgICAoKHRoaXMub3B0cy5zZWN1cmUgJiYgTnVtYmVyKHRoaXMub3B0cy5wb3J0ICE9PSA0NDMpKSB8fFxuICAgICAgICAgICAgICAgICghdGhpcy5vcHRzLnNlY3VyZSAmJiBOdW1iZXIodGhpcy5vcHRzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCI6XCIgKyB0aGlzLm9wdHMucG9ydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9xdWVyeShxdWVyeSkge1xuICAgICAgICBjb25zdCBlbmNvZGVkUXVlcnkgPSBlbmNvZGUocXVlcnkpO1xuICAgICAgICByZXR1cm4gZW5jb2RlZFF1ZXJ5Lmxlbmd0aCA/IFwiP1wiICsgZW5jb2RlZFF1ZXJ5IDogXCJcIjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUcmFuc3BvcnQgfSBmcm9tIFwiLi4vdHJhbnNwb3J0LmpzXCI7XG5pbXBvcnQgeyByYW5kb21TdHJpbmcgfSBmcm9tIFwiLi4vdXRpbC5qc1wiO1xuaW1wb3J0IHsgZW5jb2RlUGF5bG9hZCwgZGVjb2RlUGF5bG9hZCB9IGZyb20gXCJlbmdpbmUuaW8tcGFyc2VyXCI7XG5leHBvcnQgY2xhc3MgUG9sbGluZyBleHRlbmRzIFRyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3BvbGxpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcInBvbGxpbmdcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICAgICAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGRvT3BlbigpIHtcbiAgICAgICAgdGhpcy5fcG9sbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgcG9sbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUGF1c2UgLSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIHBhdXNlKG9uUGF1c2UpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJwYXVzaW5nXCI7XG4gICAgICAgIGNvbnN0IHBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJwYXVzZWRcIjtcbiAgICAgICAgICAgIG9uUGF1c2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3BvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9sbGluZykge1xuICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwicG9sbENvbXBsZXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdG90YWwrKztcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJkcmFpblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wb2xsKCkge1xuICAgICAgICB0aGlzLl9wb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kb1BvbGwoKTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwb2xsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICAgICAgICAgIGlmIChcIm9wZW5pbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHBhY2tldC50eXBlID09PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgICAgIHRoaXMub25PcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICBpZiAoXCJjbG9zZVwiID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSh7IGRlc2NyaXB0aW9uOiBcInRyYW5zcG9ydCBjbG9zZWQgYnkgdGhlIHNlcnZlclwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRoaXMub25QYWNrZXQocGFja2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGVjb2RlIHBheWxvYWRcbiAgICAgICAgZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgICAgICAgaWYgKFwiY2xvc2VkXCIgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcbiAgICAgICAgICAgIHRoaXMuX3BvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicG9sbENvbXBsZXRlXCIpO1xuICAgICAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkb0Nsb3NlKCkge1xuICAgICAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoW3sgdHlwZTogXCJjbG9zZVwiIH1dKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgICAgICAgICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICAgICAgICAgIHRoaXMub25jZShcIm9wZW5cIiwgY2xvc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHMgLSBkYXRhIHBhY2tldHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgd3JpdGUocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIGVuY29kZVBheWxvYWQocGFja2V0cywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9Xcml0ZShkYXRhLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXJpKCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLm9wdHMuc2VjdXJlID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgICAgICAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgICAgICAgaWYgKGZhbHNlICE9PSB0aGlzLm9wdHMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICAgICAgICAgIHF1ZXJ5W3RoaXMub3B0cy50aW1lc3RhbXBQYXJhbV0gPSByYW5kb21TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgICAgICAgICAgcXVlcnkuYjY0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVVcmkoc2NoZW1hLCBxdWVyeSk7XG4gICAgfVxufVxuIiwiLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY29tcG9uZW50L2hhcy1jb3JzXG5sZXQgdmFsdWUgPSBmYWxzZTtcbnRyeSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xufVxuY2F0Y2ggKGVycikge1xuICAgIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcbn1cbmV4cG9ydCBjb25zdCBoYXNDT1JTID0gdmFsdWU7XG4iLCJpbXBvcnQgeyBQb2xsaW5nIH0gZnJvbSBcIi4vcG9sbGluZy5qc1wiO1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gXCJAc29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyXCI7XG5pbXBvcnQgeyBpbnN0YWxsVGltZXJGdW5jdGlvbnMsIHBpY2sgfSBmcm9tIFwiLi4vdXRpbC5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpc1NoaW0gYXMgZ2xvYmFsVGhpcyB9IGZyb20gXCIuLi9nbG9iYWxzLm5vZGUuanNcIjtcbmltcG9ydCB7IGhhc0NPUlMgfSBmcm9tIFwiLi4vY29udHJpYi9oYXMtY29ycy5qc1wiO1xuZnVuY3Rpb24gZW1wdHkoKSB7IH1cbmV4cG9ydCBjbGFzcyBCYXNlWEhSIGV4dGVuZHMgUG9sbGluZyB7XG4gICAgLyoqXG4gICAgICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc3QgaXNTU0wgPSBcImh0dHBzOlwiID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgICAgIGxldCBwb3J0ID0gbG9jYXRpb24ucG9ydDtcbiAgICAgICAgICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICAgICAgICAgIGlmICghcG9ydCkge1xuICAgICAgICAgICAgICAgIHBvcnQgPSBpc1NTTCA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnhkID1cbiAgICAgICAgICAgICAgICAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgIG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICBwb3J0ICE9PSBvcHRzLnBvcnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb1dyaXRlKGRhdGEsIGZuKSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5vbihcInN1Y2Nlc3NcIiwgZm4pO1xuICAgICAgICByZXEub24oXCJlcnJvclwiLCAoeGhyU3RhdHVzLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJ4aHIgcG9zdCBlcnJvclwiLCB4aHJTdGF0dXMsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZG9Qb2xsKCkge1xuICAgICAgICBjb25zdCByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgICAgICAgcmVxLm9uKFwiZGF0YVwiLCB0aGlzLm9uRGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgKHhoclN0YXR1cywgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwieGhyIHBvbGwgZXJyb3JcIiwgeGhyU3RhdHVzLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucG9sbFhociA9IHJlcTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVxdWVzdCBleHRlbmRzIEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjcmVhdGVSZXF1ZXN0LCB1cmksIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVSZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdDtcbiAgICAgICAgaW5zdGFsbFRpbWVyRnVuY3Rpb25zKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLl9vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gb3B0cy5tZXRob2QgfHwgXCJHRVRcIjtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICAgICAgICB0aGlzLl9jcmVhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHBpY2sodGhpcy5fb3B0cywgXCJhZ2VudFwiLCBcInBmeFwiLCBcImtleVwiLCBcInBhc3NwaHJhc2VcIiwgXCJjZXJ0XCIsIFwiY2FcIiwgXCJjaXBoZXJzXCIsIFwicmVqZWN0VW5hdXRob3JpemVkXCIsIFwiYXV0b1VucmVmXCIpO1xuICAgICAgICBvcHRzLnhkb21haW4gPSAhIXRoaXMuX29wdHMueGQ7XG4gICAgICAgIGNvbnN0IHhociA9ICh0aGlzLl94aHIgPSB0aGlzLmNyZWF0ZVJlcXVlc3Qob3B0cykpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgeGhyLm9wZW4odGhpcy5fbWV0aG9kLCB0aGlzLl91cmksIHRydWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0cy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5fb3B0cy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIHRoaXMuX29wdHMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIGlmIChcIlBPU1RcIiA9PT0gdGhpcy5fbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCIqLypcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9vcHRzLmNvb2tpZUphcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZENvb2tpZXMoeGhyKTtcbiAgICAgICAgICAgIC8vIGllNiBjaGVja1xuICAgICAgICAgICAgaWYgKFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyKSB7XG4gICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMuX29wdHMud2l0aENyZWRlbnRpYWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdHMucmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB4aHIudGltZW91dCA9IHRoaXMuX29wdHMucmVxdWVzdFRpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5fb3B0cy5jb29raWVKYXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJzZUNvb2tpZXMoXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwic2V0LWNvb2tpZVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IodHlwZW9mIHhoci5zdGF0dXMgPT09IFwibnVtYmVyXCIgPyB4aHIuc3RhdHVzIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIuc2VuZCh0aGlzLl9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoZSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgICAgICAgICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLl9pbmRleF0gPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGVycm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25FcnJvcihlcnIpIHtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIsIHRoaXMuX3hocik7XG4gICAgICAgIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBob3VzZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFudXAoZnJvbUVycm9yKSB7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgdGhpcy5feGhyIHx8IG51bGwgPT09IHRoaXMuX3hocikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3hoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgICAgICAgaWYgKGZyb21FcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl94aHIuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLl9pbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5feGhyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gbG9hZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uTG9hZCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX3hoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInN1Y2Nlc3NcIik7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIH1cbn1cblJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG5SZXF1ZXN0LnJlcXVlc3RzID0ge307XG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHR5cGVvZiBhdHRhY2hFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCB0ZXJtaW5hdGlvbkV2ZW50ID0gXCJvbnBhZ2VoaWRlXCIgaW4gZ2xvYmFsVGhpcyA/IFwicGFnZWhpZGVcIiA6IFwidW5sb2FkXCI7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIodGVybWluYXRpb25FdmVudCwgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG4gICAgZm9yIChsZXQgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBoYXNYSFIyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB4aHIgPSBuZXdSZXF1ZXN0KHtcbiAgICAgICAgeGRvbWFpbjogZmFsc2UsXG4gICAgfSk7XG4gICAgcmV0dXJuIHhociAmJiB4aHIucmVzcG9uc2VUeXBlICE9PSBudWxsO1xufSkoKTtcbi8qKlxuICogSFRUUCBsb25nLXBvbGxpbmcgYmFzZWQgb24gdGhlIGJ1aWx0LWluIGBYTUxIdHRwUmVxdWVzdGAgb2JqZWN0LlxuICpcbiAqIFVzYWdlOiBicm93c2VyXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3RcbiAqL1xuZXhwb3J0IGNsYXNzIFhIUiBleHRlbmRzIEJhc2VYSFIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIGNvbnN0IGZvcmNlQmFzZTY0ID0gb3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0O1xuICAgICAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gaGFzWEhSMiAmJiAhZm9yY2VCYXNlNjQ7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0cyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgeyB4ZDogdGhpcy54ZCB9LCB0aGlzLm9wdHMpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QobmV3UmVxdWVzdCwgdGhpcy51cmkoKSwgb3B0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3UmVxdWVzdChvcHRzKSB7XG4gICAgY29uc3QgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcbiAgICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgICB0cnkge1xuICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICBpZiAoIXhkb21haW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ2xvYmFsVGhpc1tbXCJBY3RpdmVcIl0uY29uY2F0KFwiT2JqZWN0XCIpLmpvaW4oXCJYXCIpXShcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBUcmFuc3BvcnQgfSBmcm9tIFwiLi4vdHJhbnNwb3J0LmpzXCI7XG5pbXBvcnQgeyBwaWNrLCByYW5kb21TdHJpbmcgfSBmcm9tIFwiLi4vdXRpbC5qc1wiO1xuaW1wb3J0IHsgZW5jb2RlUGFja2V0IH0gZnJvbSBcImVuZ2luZS5pby1wYXJzZXJcIjtcbmltcG9ydCB7IGdsb2JhbFRoaXNTaGltIGFzIGdsb2JhbFRoaXMsIG5leHRUaWNrIH0gZnJvbSBcIi4uL2dsb2JhbHMubm9kZS5qc1wiO1xuLy8gZGV0ZWN0IFJlYWN0TmF0aXZlIGVudmlyb25tZW50XG5jb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09IFwicmVhY3RuYXRpdmVcIjtcbmV4cG9ydCBjbGFzcyBCYXNlV1MgZXh0ZW5kcyBUcmFuc3BvcnQge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJzb2NrZXRcIjtcbiAgICB9XG4gICAgZG9PcGVuKCkge1xuICAgICAgICBjb25zdCB1cmkgPSB0aGlzLnVyaSgpO1xuICAgICAgICBjb25zdCBwcm90b2NvbHMgPSB0aGlzLm9wdHMucHJvdG9jb2xzO1xuICAgICAgICAvLyBSZWFjdCBOYXRpdmUgb25seSBzdXBwb3J0cyB0aGUgJ2hlYWRlcnMnIG9wdGlvbiwgYW5kIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIGFueXRoaW5nIGVsc2UgaXMgcGFzc2VkXG4gICAgICAgIGNvbnN0IG9wdHMgPSBpc1JlYWN0TmF0aXZlXG4gICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICA6IHBpY2sodGhpcy5vcHRzLCBcImFnZW50XCIsIFwicGVyTWVzc2FnZURlZmxhdGVcIiwgXCJwZnhcIiwgXCJrZXlcIiwgXCJwYXNzcGhyYXNlXCIsIFwiY2VydFwiLCBcImNhXCIsIFwiY2lwaGVyc1wiLCBcInJlamVjdFVuYXV0aG9yaXplZFwiLCBcImxvY2FsQWRkcmVzc1wiLCBcInByb3RvY29sVmVyc2lvblwiLCBcIm9yaWdpblwiLCBcIm1heFBheWxvYWRcIiwgXCJmYW1pbHlcIiwgXCJjaGVja1NlcnZlcklkZW50aXR5XCIpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gdGhpcy5vcHRzLmV4dHJhSGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53cyA9IHRoaXMuY3JlYXRlU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9IHRoaXMuc29ja2V0LmJpbmFyeVR5cGU7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmF1dG9VbnJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMud3MuX3NvY2tldC51bnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gKGNsb3NlRXZlbnQpID0+IHRoaXMub25DbG9zZSh7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiBjbG9zZWRcIixcbiAgICAgICAgICAgIGNvbnRleHQ6IGNsb3NlRXZlbnQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IChldikgPT4gdGhpcy5vbkRhdGEoZXYuZGF0YSk7XG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IChlKSA9PiB0aGlzLm9uRXJyb3IoXCJ3ZWJzb2NrZXQgZXJyb3JcIiwgZSk7XG4gICAgfVxuICAgIHdyaXRlKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAgICAgICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gcGFja2V0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RQYWNrZXQgPSBpID09PSBwYWNrZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBlbmNvZGVQYWNrZXQocGFja2V0LCB0aGlzLnN1cHBvcnRzQmluYXJ5LCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Xcml0ZShwYWNrZXQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWtlIGRyYWluXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRyYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNldFRpbWVvdXRGbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9DbG9zZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSAoKSA9PiB7IH07XG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLndzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cmkoKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMub3B0cy5zZWN1cmUgPyBcIndzc1wiIDogXCJ3c1wiO1xuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gICAgICAgIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gICAgICAgIGlmICh0aGlzLm9wdHMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICAgICAgICAgIHF1ZXJ5W3RoaXMub3B0cy50aW1lc3RhbXBQYXJhbV0gPSByYW5kb21TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgICAgICBxdWVyeS5iNjQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVVyaShzY2hlbWEsIHF1ZXJ5KTtcbiAgICB9XG59XG5jb25zdCBXZWJTb2NrZXRDdG9yID0gZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfHwgZ2xvYmFsVGhpcy5Nb3pXZWJTb2NrZXQ7XG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgYmFzZWQgb24gdGhlIGJ1aWx0LWluIGBXZWJTb2NrZXRgIG9iamVjdC5cbiAqXG4gKiBVc2FnZTogYnJvd3NlciwgTm9kZS5qcyAoc2luY2UgdjIxKSwgRGVubywgQnVuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViU29ja2V0XG4gKiBAc2VlIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWFwaV93ZWJzb2NrZXRcbiAqIEBzZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9nbG9iYWxzLmh0bWwjd2Vic29ja2V0XG4gKi9cbmV4cG9ydCBjbGFzcyBXUyBleHRlbmRzIEJhc2VXUyB7XG4gICAgY3JlYXRlU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiAhaXNSZWFjdE5hdGl2ZVxuICAgICAgICAgICAgPyBwcm90b2NvbHNcbiAgICAgICAgICAgICAgICA/IG5ldyBXZWJTb2NrZXRDdG9yKHVyaSwgcHJvdG9jb2xzKVxuICAgICAgICAgICAgICAgIDogbmV3IFdlYlNvY2tldEN0b3IodXJpKVxuICAgICAgICAgICAgOiBuZXcgV2ViU29ja2V0Q3Rvcih1cmksIHByb3RvY29scywgb3B0cyk7XG4gICAgfVxuICAgIGRvV3JpdGUoX3BhY2tldCwgZGF0YSkge1xuICAgICAgICB0aGlzLndzLnNlbmQoZGF0YSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVHJhbnNwb3J0IH0gZnJvbSBcIi4uL3RyYW5zcG9ydC5qc1wiO1xuaW1wb3J0IHsgbmV4dFRpY2sgfSBmcm9tIFwiLi4vZ2xvYmFscy5ub2RlLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVQYWNrZXREZWNvZGVyU3RyZWFtLCBjcmVhdGVQYWNrZXRFbmNvZGVyU3RyZWFtLCB9IGZyb20gXCJlbmdpbmUuaW8tcGFyc2VyXCI7XG4vKipcbiAqIFdlYlRyYW5zcG9ydCB0cmFuc3BvcnQgYmFzZWQgb24gdGhlIGJ1aWx0LWluIGBXZWJUcmFuc3BvcnRgIG9iamVjdC5cbiAqXG4gKiBVc2FnZTogYnJvd3NlciwgTm9kZS5qcyAod2l0aCB0aGUgYEBmYWlscy1jb21wb25lbnRzL3dlYnRyYW5zcG9ydGAgcGFja2FnZSlcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJUcmFuc3BvcnRcbiAqIEBzZWUgaHR0cHM6Ly9jYW5pdXNlLmNvbS93ZWJ0cmFuc3BvcnRcbiAqL1xuZXhwb3J0IGNsYXNzIFdUIGV4dGVuZHMgVHJhbnNwb3J0IHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwid2VidHJhbnNwb3J0XCI7XG4gICAgfVxuICAgIGRvT3BlbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IG5ldyBXZWJUcmFuc3BvcnQodGhpcy5jcmVhdGVVcmkoXCJodHRwc1wiKSwgdGhpcy5vcHRzLnRyYW5zcG9ydE9wdGlvbnNbdGhpcy5uYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2VkXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJ3ZWJ0cmFuc3BvcnQgZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG5vdGU6IHdlIGNvdWxkIGhhdmUgdXNlZCBhc3luYy9hd2FpdCwgYnV0IHRoYXQgd291bGQgcmVxdWlyZSBzb21lIGFkZGl0aW9uYWwgcG9seWZpbGxzXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5yZWFkeS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydC5jcmVhdGVCaWRpcmVjdGlvbmFsU3RyZWFtKCkudGhlbigoc3RyZWFtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb2RlclN0cmVhbSA9IGNyZWF0ZVBhY2tldERlY29kZXJTdHJlYW0oTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5yZWFkYWJsZS5waXBlVGhyb3VnaChkZWNvZGVyU3RyZWFtKS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyU3RyZWFtID0gY3JlYXRlUGFja2V0RW5jb2RlclN0cmVhbSgpO1xuICAgICAgICAgICAgICAgIGVuY29kZXJTdHJlYW0ucmVhZGFibGUucGlwZVRvKHN0cmVhbS53cml0YWJsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVyID0gZW5jb2RlclN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZWFkKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblBhY2tldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrZXQgPSB7IHR5cGU6IFwib3BlblwiIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkuc2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhY2tldC5kYXRhID0gYHtcInNpZFwiOlwiJHt0aGlzLnF1ZXJ5LnNpZH1cIn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZXIud3JpdGUocGFja2V0KS50aGVuKCgpID0+IHRoaXMub25PcGVuKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3cml0ZShwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgbGFzdFBhY2tldCA9IGkgPT09IHBhY2tldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZShwYWNrZXQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zZXRUaW1lb3V0Rm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvQ2xvc2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5fdHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBYSFIgfSBmcm9tIFwiLi9wb2xsaW5nLXhoci5ub2RlLmpzXCI7XG5pbXBvcnQgeyBXUyB9IGZyb20gXCIuL3dlYnNvY2tldC5ub2RlLmpzXCI7XG5pbXBvcnQgeyBXVCB9IGZyb20gXCIuL3dlYnRyYW5zcG9ydC5qc1wiO1xuZXhwb3J0IGNvbnN0IHRyYW5zcG9ydHMgPSB7XG4gICAgd2Vic29ja2V0OiBXUyxcbiAgICB3ZWJ0cmFuc3BvcnQ6IFdULFxuICAgIHBvbGxpbmc6IFhIUixcbn07XG4iLCIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nYWxrbi9wYXJzZXVyaVxuLyoqXG4gKiBQYXJzZXMgYSBVUklcbiAqXG4gKiBOb3RlOiB3ZSBjb3VsZCBhbHNvIGhhdmUgdXNlZCB0aGUgYnVpbHQtaW4gVVJMIG9iamVjdCwgYnV0IGl0IGlzbid0IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLlxuICpcbiAqIFNlZTpcbiAqIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTFxuICogLSBodHRwczovL2Nhbml1c2UuY29tL3VybFxuICogLSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMzk4NiNhcHBlbmRpeC1CXG4gKlxuICogSGlzdG9yeSBvZiB0aGUgcGFyc2UoKSBtZXRob2Q6XG4gKiAtIGZpcnN0IGNvbW1pdDogaHR0cHM6Ly9naXRodWIuY29tL3NvY2tldGlvL3NvY2tldC5pby1jbGllbnQvY29tbWl0LzRlZTFkNWQ5NGIzOTA2YTljMDUyYjQ1OWYxYTgxOGIxNWYzOGY5MWNcbiAqIC0gZXhwb3J0IGludG8gaXRzIG93biBtb2R1bGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9lbmdpbmUuaW8tY2xpZW50L2NvbW1pdC9kZTJjNTYxZTQ1NjRlZmViNzhmMWJkYjFiYTM5ZWY4MWIyODIyY2IzXG4gKiAtIHJlaW1wb3J0OiBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLWNsaWVudC9jb21taXQvZGYzMjI3N2MzZjZkNjIyZWVjNWVkMDlmNDkzY2FlM2YzMzkxZDI0MlxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5jb25zdCByZSA9IC9eKD86KD8hW146QFxcLz8jXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QFxcLz8jXSopKD86OihbXjpAXFwvPyNdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuY29uc3QgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoID4gODAwMCkge1xuICAgICAgICB0aHJvdyBcIlVSSSB0b28gbG9uZ1wiO1xuICAgIH1cbiAgICBjb25zdCBzcmMgPSBzdHIsIGIgPSBzdHIuaW5kZXhPZignWycpLCBlID0gc3RyLmluZGV4T2YoJ10nKTtcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBtID0gcmUuZXhlYyhzdHIgfHwgJycpLCB1cmkgPSB7fSwgaSA9IDE0O1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfVxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuICAgIHVyaS5wYXRoTmFtZXMgPSBwYXRoTmFtZXModXJpLCB1cmlbJ3BhdGgnXSk7XG4gICAgdXJpLnF1ZXJ5S2V5ID0gcXVlcnlLZXkodXJpLCB1cmlbJ3F1ZXJ5J10pO1xuICAgIHJldHVybiB1cmk7XG59XG5mdW5jdGlvbiBwYXRoTmFtZXMob2JqLCBwYXRoKSB7XG4gICAgY29uc3QgcmVneCA9IC9cXC97Miw5fS9nLCBuYW1lcyA9IHBhdGgucmVwbGFjZShyZWd4LCBcIi9cIikuc3BsaXQoXCIvXCIpO1xuICAgIGlmIChwYXRoLnNsaWNlKDAsIDEpID09ICcvJyB8fCBwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBuYW1lcy5zcGxpY2UoMCwgMSk7XG4gICAgfVxuICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PSAnLycpIHtcbiAgICAgICAgbmFtZXMuc3BsaWNlKG5hbWVzLmxlbmd0aCAtIDEsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXM7XG59XG5mdW5jdGlvbiBxdWVyeUtleSh1cmksIHF1ZXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIHF1ZXJ5LnJlcGxhY2UoLyg/Ol58JikoW14mPV0qKT0/KFteJl0qKS9nLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuICAgICAgICBpZiAoJDEpIHtcbiAgICAgICAgICAgIGRhdGFbJDFdID0gJDI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbiIsImltcG9ydCB7IHRyYW5zcG9ydHMgYXMgREVGQVVMVF9UUkFOU1BPUlRTIH0gZnJvbSBcIi4vdHJhbnNwb3J0cy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgaW5zdGFsbFRpbWVyRnVuY3Rpb25zLCBieXRlTGVuZ3RoIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSBcIi4vY29udHJpYi9wYXJzZXFzLmpzXCI7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gXCIuL2NvbnRyaWIvcGFyc2V1cmkuanNcIjtcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tIFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiO1xuaW1wb3J0IHsgcHJvdG9jb2wgfSBmcm9tIFwiZW5naW5lLmlvLXBhcnNlclwiO1xuaW1wb3J0IHsgY3JlYXRlQ29va2llSmFyLCBkZWZhdWx0QmluYXJ5VHlwZSwgbmV4dFRpY2ssIH0gZnJvbSBcIi4vZ2xvYmFscy5ub2RlLmpzXCI7XG5jb25zdCB3aXRoRXZlbnRMaXN0ZW5lcnMgPSB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIHJlbW92ZUV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IE9GRkxJTkVfRVZFTlRfTElTVEVORVJTID0gW107XG5pZiAod2l0aEV2ZW50TGlzdGVuZXJzKSB7XG4gICAgLy8gd2l0aGluIGEgU2VydmljZVdvcmtlciwgYW55IGV2ZW50IGhhbmRsZXIgZm9yIHRoZSAnb2ZmbGluZScgZXZlbnQgbXVzdCBiZSBhZGRlZCBvbiB0aGUgaW5pdGlhbCBldmFsdWF0aW9uIG9mIHRoZVxuICAgIC8vIHNjcmlwdCwgc28gd2UgY3JlYXRlIG9uZSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgaGVyZSB3aGljaCB3aWxsIGZvcndhcmQgdGhlIGV2ZW50IHRvIHRoZSBzb2NrZXQgaW5zdGFuY2VzXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgKCkgPT4ge1xuICAgICAgICBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSk7XG4gICAgfSwgZmFsc2UpO1xufVxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGEgV2ViU29ja2V0LWxpa2UgaW50ZXJmYWNlIHRvIGNvbm5lY3QgdG8gYW4gRW5naW5lLklPIHNlcnZlci4gVGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBlc3RhYmxpc2hlZFxuICogd2l0aCBvbmUgb2YgdGhlIGF2YWlsYWJsZSBsb3ctbGV2ZWwgdHJhbnNwb3J0cywgbGlrZSBIVFRQIGxvbmctcG9sbGluZywgV2ViU29ja2V0IG9yIFdlYlRyYW5zcG9ydC5cbiAqXG4gKiBUaGlzIGNsYXNzIGNvbWVzIHdpdGhvdXQgdXBncmFkZSBtZWNoYW5pc20sIHdoaWNoIG1lYW5zIHRoYXQgaXQgd2lsbCBrZWVwIHRoZSBmaXJzdCBsb3ctbGV2ZWwgdHJhbnNwb3J0IHRoYXRcbiAqIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBJbiBvcmRlciB0byBhbGxvdyB0cmVlLXNoYWtpbmcsIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzIGluY2x1ZGVkLCB0aGF0J3Mgd2h5IHRoZSBgdHJhbnNwb3J0c2Agb3B0aW9uIGlzIG1hbmRhdG9yeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgU29ja2V0V2l0aG91dFVwZ3JhZGUsIFdlYlNvY2tldCB9IGZyb20gXCJlbmdpbmUuaW8tY2xpZW50XCI7XG4gKlxuICogY29uc3Qgc29ja2V0ID0gbmV3IFNvY2tldFdpdGhvdXRVcGdyYWRlKHtcbiAqICAgdHJhbnNwb3J0czogW1dlYlNvY2tldF1cbiAqIH0pO1xuICpcbiAqIHNvY2tldC5vbihcIm9wZW5cIiwgKCkgPT4ge1xuICogICBzb2NrZXQuc2VuZChcImhlbGxvXCIpO1xuICogfSk7XG4gKlxuICogQHNlZSBTb2NrZXRXaXRoVXBncmFkZVxuICogQHNlZSBTb2NrZXRcbiAqL1xuZXhwb3J0IGNsYXNzIFNvY2tldFdpdGhvdXRVcGdyYWRlIGV4dGVuZHMgRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgLSB1cmkgb3Igb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJpbmFyeVR5cGUgPSBkZWZhdWx0QmluYXJ5VHlwZTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLl9wcmV2QnVmZmVyTGVuID0gMDtcbiAgICAgICAgdGhpcy5fcGluZ0ludGVydmFsID0gLTE7XG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuX21heFBheWxvYWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBleHBpcmF0aW9uIHRpbWVzdGFtcCBvZiB0aGUge0BsaW5rIF9waW5nVGltZW91dFRpbWVyfSBvYmplY3QgaXMgdHJhY2tlZCwgaW4gY2FzZSB0aGUgdGltZXIgaXMgdGhyb3R0bGVkIGFuZCB0aGVcbiAgICAgICAgICogY2FsbGJhY2sgaXMgbm90IGZpcmVkIG9uIHRpbWUuIFRoaXMgY2FuIGhhcHBlbiBmb3IgZXhhbXBsZSB3aGVuIGEgbGFwdG9wIGlzIHN1c3BlbmRlZCBvciB3aGVuIGEgcGhvbmUgaXMgbG9ja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXRUaW1lID0gSW5maW5pdHk7XG4gICAgICAgIGlmICh1cmkgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVyaSkge1xuICAgICAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgICAgIHVyaSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVyaSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVXJpID0gcGFyc2UodXJpKTtcbiAgICAgICAgICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZWRVcmkuaG9zdDtcbiAgICAgICAgICAgIG9wdHMuc2VjdXJlID1cbiAgICAgICAgICAgICAgICBwYXJzZWRVcmkucHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCBwYXJzZWRVcmkucHJvdG9jb2wgPT09IFwid3NzXCI7XG4gICAgICAgICAgICBvcHRzLnBvcnQgPSBwYXJzZWRVcmkucG9ydDtcbiAgICAgICAgICAgIGlmIChwYXJzZWRVcmkucXVlcnkpXG4gICAgICAgICAgICAgICAgb3B0cy5xdWVyeSA9IHBhcnNlZFVyaS5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICAgICAgICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZShvcHRzLmhvc3QpLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFsbFRpbWVyRnVuY3Rpb25zKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLnNlY3VyZSA9XG4gICAgICAgICAgICBudWxsICE9IG9wdHMuc2VjdXJlXG4gICAgICAgICAgICAgICAgPyBvcHRzLnNlY3VyZVxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIFwiaHR0cHM6XCIgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgICAgICAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgICAgICAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9XG4gICAgICAgICAgICBvcHRzLmhvc3RuYW1lIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogXCJsb2NhbGhvc3RcIik7XG4gICAgICAgIHRoaXMucG9ydCA9XG4gICAgICAgICAgICBvcHRzLnBvcnQgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5zZWN1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCI0NDNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjgwXCIpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0c0J5TmFtZSA9IHt9O1xuICAgICAgICBvcHRzLnRyYW5zcG9ydHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0TmFtZSA9IHQucHJvdG90eXBlLm5hbWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zcG9ydHNCeU5hbWVbdHJhbnNwb3J0TmFtZV0gPSB0O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBwYXRoOiBcIi9lbmdpbmUuaW9cIixcbiAgICAgICAgICAgIGFnZW50OiBmYWxzZSxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgICAgICB1cGdyYWRlOiB0cnVlLFxuICAgICAgICAgICAgdGltZXN0YW1wUGFyYW06IFwidFwiLFxuICAgICAgICAgICAgcmVtZW1iZXJVcGdyYWRlOiBmYWxzZSxcbiAgICAgICAgICAgIGFkZFRyYWlsaW5nU2xhc2g6IHRydWUsXG4gICAgICAgICAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHRydWUsXG4gICAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZToge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAyNCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc3BvcnRPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIGNsb3NlT25CZWZvcmV1bmxvYWQ6IGZhbHNlLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgdGhpcy5vcHRzLnBhdGggPVxuICAgICAgICAgICAgdGhpcy5vcHRzLnBhdGgucmVwbGFjZSgvXFwvJC8sIFwiXCIpICtcbiAgICAgICAgICAgICAgICAodGhpcy5vcHRzLmFkZFRyYWlsaW5nU2xhc2ggPyBcIi9cIiA6IFwiXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5xdWVyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5vcHRzLnF1ZXJ5ID0gZGVjb2RlKHRoaXMub3B0cy5xdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpdGhFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jbG9zZU9uQmVmb3JldW5sb2FkKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBjbG9zZXMgdGhlIGNvbm5lY3Rpb24gd2hlbiB0aGUgXCJiZWZvcmV1bmxvYWRcIiBldmVudCBpcyBlbWl0dGVkIGJ1dCBub3QgQ2hyb21lLiBUaGlzIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlcyBldmVyeSBicm93c2VyIGJlaGF2ZXMgdGhlIHNhbWUgKG5vIFwiZGlzY29ubmVjdFwiIGV2ZW50IGF0IHRoZSBTb2NrZXQuSU8gbGV2ZWwgd2hlbiB0aGUgcGFnZSBpc1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlZC9yZWxvYWRlZClcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbGVudGx5IGNsb3NlIHRoZSB0cmFuc3BvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCB0aGlzLl9iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ob3N0bmFtZSAhPT0gXCJsb2NhbGhvc3RcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZmxpbmVFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNsb3NlKFwidHJhbnNwb3J0IGNsb3NlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIm5ldHdvcmsgY29ubmVjdGlvbiBsb3N0XCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT0ZGTElORV9FVkVOVF9MSVNURU5FUlMucHVzaCh0aGlzLl9vZmZsaW5lRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvb2tpZUphciA9IGNyZWF0ZUNvb2tpZUphcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRyYW5zcG9ydCBuYW1lXG4gICAgICogQHJldHVybiB7VHJhbnNwb3J0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlVHJhbnNwb3J0KG5hbWUpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMucXVlcnkpO1xuICAgICAgICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgICAgICAgcXVlcnkuRUlPID0gcHJvdG9jb2w7XG4gICAgICAgIC8vIHRyYW5zcG9ydCBuYW1lXG4gICAgICAgIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG4gICAgICAgIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICAgICAgICBpZiAodGhpcy5pZClcbiAgICAgICAgICAgIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMsIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgc29ja2V0OiB0aGlzLFxuICAgICAgICAgICAgaG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG4gICAgICAgICAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgICAgICAgICAgcG9ydDogdGhpcy5wb3J0LFxuICAgICAgICB9LCB0aGlzLm9wdHMudHJhbnNwb3J0T3B0aW9uc1tuYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5fdHJhbnNwb3J0c0J5TmFtZVtuYW1lXShvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydE5hbWUgPSB0aGlzLm9wdHMucmVtZW1iZXJVcGdyYWRlICYmXG4gICAgICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKFwid2Vic29ja2V0XCIpICE9PSAtMVxuICAgICAgICAgICAgPyBcIndlYnNvY2tldFwiXG4gICAgICAgICAgICA6IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB0cmFuc3BvcnQub3BlbigpO1xuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gICAgICAgIHRyYW5zcG9ydFxuICAgICAgICAgICAgLm9uKFwiZHJhaW5cIiwgdGhpcy5fb25EcmFpbi5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLm9uKFwicGFja2V0XCIsIHRoaXMuX29uUGFja2V0LmJpbmQodGhpcykpXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCB0aGlzLl9vbkVycm9yLmJpbmQodGhpcykpXG4gICAgICAgICAgICAub24oXCJjbG9zZVwiLCAocmVhc29uKSA9PiB0aGlzLl9vbkNsb3NlKFwidHJhbnNwb3J0IGNsb3NlXCIsIHJlYXNvbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPVxuICAgICAgICAgICAgXCJ3ZWJzb2NrZXRcIiA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJvcGVuXCIpO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgICAgICAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImhlYXJ0YmVhdFwiKTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKEpTT04ucGFyc2UocGFja2V0LmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VuZFBhY2tldChcInBvbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwb25nXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJzZXJ2ZXIgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRhdGFcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcIm1lc3NhZ2VcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gaGFuZHNoYWtlIG9ialxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25IYW5kc2hha2UoZGF0YSkge1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImhhbmRzaGFrZVwiLCBkYXRhKTtcbiAgICAgICAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgICAgICAgdGhpcy5fcGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgICAgICAgdGhpcy5fbWF4UGF5bG9hZCA9IGRhdGEubWF4UGF5bG9hZDtcbiAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICAgICAgICBpZiAoXCJjbG9zZWRcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYW5kIHJlc2V0cyBwaW5nIHRpbWVvdXQgdGltZXIgYmFzZWQgb24gc2VydmVyIHBpbmdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXRQaW5nVGltZW91dCgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXRGbih0aGlzLl9waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgY29uc3QgZGVsYXkgPSB0aGlzLl9waW5nSW50ZXJ2YWwgKyB0aGlzLl9waW5nVGltZW91dDtcbiAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXRUaW1lID0gRGF0ZS5ub3coKSArIGRlbGF5O1xuICAgICAgICB0aGlzLl9waW5nVGltZW91dFRpbWVyID0gdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25DbG9zZShcInBpbmcgdGltZW91dFwiKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmF1dG9VbnJlZikge1xuICAgICAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXRUaW1lci51bnJlZigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkRyYWluKCkge1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLl9wcmV2QnVmZmVyTGVuKTtcbiAgICAgICAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAgICAgICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgICAgICAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgICAgICAgdGhpcy5fcHJldkJ1ZmZlckxlbiA9IDA7XG4gICAgICAgIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkcmFpblwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgaWYgKFwiY2xvc2VkXCIgIT09IHRoaXMucmVhZHlTdGF0ZSAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAgICAgICAgICF0aGlzLnVwZ3JhZGluZyAmJlxuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldHMgPSB0aGlzLl9nZXRXcml0YWJsZVBhY2tldHMoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQocGFja2V0cyk7XG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgICAgICAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICAgICAgICAgIHRoaXMuX3ByZXZCdWZmZXJMZW4gPSBwYWNrZXRzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZmx1c2hcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoZSBlbmNvZGVkIHNpemUgb2YgdGhlIHdyaXRlQnVmZmVyIGlzIGJlbG93IHRoZSBtYXhQYXlsb2FkIHZhbHVlIHNlbnQgYnkgdGhlIHNlcnZlciAob25seSBmb3IgSFRUUFxuICAgICAqIGxvbmctcG9sbGluZylcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFdyaXRhYmxlUGFja2V0cygpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkQ2hlY2tQYXlsb2FkU2l6ZSA9IHRoaXMuX21heFBheWxvYWQgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0Lm5hbWUgPT09IFwicG9sbGluZ1wiICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA+IDE7XG4gICAgICAgIGlmICghc2hvdWxkQ2hlY2tQYXlsb2FkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBheWxvYWRTaXplID0gMTsgLy8gZmlyc3QgcGFja2V0IHR5cGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy53cml0ZUJ1ZmZlcltpXS5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHBheWxvYWRTaXplID4gdGhpcy5fbWF4UGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF5bG9hZFNpemUgKz0gMjsgLy8gc2VwYXJhdG9yICsgcGFja2V0IHR5cGVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUJ1ZmZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGhlYXJ0YmVhdCB0aW1lciBoYXMgZXhwaXJlZCBidXQgdGhlIHNvY2tldCBoYXMgbm90IHlldCBiZWVuIG5vdGlmaWVkLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgaXMgcHJpdmF0ZSBmb3Igbm93IGJlY2F1c2UgaXQgZG9lcyBub3QgcmVhbGx5IGZpdCB0aGUgV2ViU29ja2V0IEFQSSwgYnV0IGlmIHdlIHB1dCBpdCBpbiB0aGVcbiAgICAgKiBgd3JpdGUoKWAgbWV0aG9kIHRoZW4gdGhlIG1lc3NhZ2Ugd291bGQgbm90IGJlIGJ1ZmZlcmVkIGJ5IHRoZSBTb2NrZXQuSU8gY2xpZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIC8qIHByaXZhdGUgKi8gX2hhc1BpbmdFeHBpcmVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BpbmdUaW1lb3V0VGltZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gRGF0ZS5ub3coKSA+IHRoaXMuX3BpbmdUaW1lb3V0VGltZTtcbiAgICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0VGltZSA9IDA7XG4gICAgICAgICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25DbG9zZShcInBpbmcgdGltZW91dFwiKTtcbiAgICAgICAgICAgIH0sIHRoaXMuc2V0VGltZW91dEZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzRXhwaXJlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB3cml0ZShtc2csIG9wdGlvbnMsIGZuKSB7XG4gICAgICAgIHRoaXMuX3NlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIG1zZywgb3B0aW9ucywgZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlLiBBbGlhcyBvZiB7QGxpbmsgU29ja2V0I3dyaXRlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgc2VuZChtc2csIG9wdGlvbnMsIGZuKSB7XG4gICAgICAgIHRoaXMuX3NlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIG1zZywgb3B0aW9ucywgZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZTogcGFja2V0IHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZW5kUGFja2V0KHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBmbiA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjbG9zaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0Q3JlYXRlXCIsIHBhY2tldCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJmbHVzaFwiLCBmbik7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2xvc2UoXCJmb3JjZWQgY2xvc2VcIik7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwQW5kQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9mZihcInVwZ3JhZGVcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwidXBncmFkZUVycm9yXCIsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB3YWl0Rm9yVXBncmFkZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJ1cGdyYWRlXCIsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJ1cGdyYWRlRXJyb3JcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgXCJvcGVuXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zaW5nXCI7XG4gICAgICAgICAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJkcmFpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25FcnJvcihlcnIpIHtcbiAgICAgICAgU29ja2V0V2l0aG91dFVwZ3JhZGUucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdHMudHJ5QWxsVHJhbnNwb3J0cyAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wZW4oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGVycik7XG4gICAgICAgIHRoaXMuX29uQ2xvc2UoXCJ0cmFuc3BvcnQgZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25DbG9zZShyZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChcIm9wZW5pbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAgICAgICBcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAgICAgICBcImNsb3NpbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBjbGVhciB0aW1lcnNcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0Rm4odGhpcy5fcGluZ1RpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycyhcImNsb3NlXCIpO1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBpZiAod2l0aEV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JlZm9yZXVubG9hZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCB0aGlzLl9iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vZmZsaW5lRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gT0ZGTElORV9FVkVOVF9MSVNURU5FUlMuaW5kZXhPZih0aGlzLl9vZmZsaW5lRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT0ZGTElORV9FVkVOVF9MSVNURU5FUlMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICAgICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgICAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgICAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNsb3NlXCIsIHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG4gICAgICAgICAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZCdWZmZXJMZW4gPSAwO1xuICAgICAgICB9XG4gICAgfVxufVxuU29ja2V0V2l0aG91dFVwZ3JhZGUucHJvdG9jb2wgPSBwcm90b2NvbDtcbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBhIFdlYlNvY2tldC1saWtlIGludGVyZmFjZSB0byBjb25uZWN0IHRvIGFuIEVuZ2luZS5JTyBzZXJ2ZXIuIFRoZSBjb25uZWN0aW9uIHdpbGwgYmUgZXN0YWJsaXNoZWRcbiAqIHdpdGggb25lIG9mIHRoZSBhdmFpbGFibGUgbG93LWxldmVsIHRyYW5zcG9ydHMsIGxpa2UgSFRUUCBsb25nLXBvbGxpbmcsIFdlYlNvY2tldCBvciBXZWJUcmFuc3BvcnQuXG4gKlxuICogVGhpcyBjbGFzcyBjb21lcyB3aXRoIGFuIHVwZ3JhZGUgbWVjaGFuaXNtLCB3aGljaCBtZWFucyB0aGF0IG9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgd2l0aCB0aGUgZmlyc3RcbiAqIGxvdy1sZXZlbCB0cmFuc3BvcnQsIGl0IHdpbGwgdHJ5IHRvIHVwZ3JhZGUgdG8gYSBiZXR0ZXIgdHJhbnNwb3J0LlxuICpcbiAqIEluIG9yZGVyIHRvIGFsbG93IHRyZWUtc2hha2luZywgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHMgaW5jbHVkZWQsIHRoYXQncyB3aHkgdGhlIGB0cmFuc3BvcnRzYCBvcHRpb24gaXMgbWFuZGF0b3J5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBTb2NrZXRXaXRoVXBncmFkZSwgV2ViU29ja2V0IH0gZnJvbSBcImVuZ2luZS5pby1jbGllbnRcIjtcbiAqXG4gKiBjb25zdCBzb2NrZXQgPSBuZXcgU29ja2V0V2l0aFVwZ3JhZGUoe1xuICogICB0cmFuc3BvcnRzOiBbV2ViU29ja2V0XVxuICogfSk7XG4gKlxuICogc29ja2V0Lm9uKFwib3BlblwiLCAoKSA9PiB7XG4gKiAgIHNvY2tldC5zZW5kKFwiaGVsbG9cIik7XG4gKiB9KTtcbiAqXG4gKiBAc2VlIFNvY2tldFdpdGhvdXRVcGdyYWRlXG4gKiBAc2VlIFNvY2tldFxuICovXG5leHBvcnQgY2xhc3MgU29ja2V0V2l0aFVwZ3JhZGUgZXh0ZW5kcyBTb2NrZXRXaXRob3V0VXBncmFkZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3VwZ3JhZGVzID0gW107XG4gICAgfVxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgc3VwZXIub25PcGVuKCk7XG4gICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMub3B0cy51cGdyYWRlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3VwZ3JhZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvYmUodGhpcy5fdXBncmFkZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdHJhbnNwb3J0IG5hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9iZShuYW1lKSB7XG4gICAgICAgIGxldCB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lKTtcbiAgICAgICAgbGV0IGZhaWxlZCA9IGZhbHNlO1xuICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb25UcmFuc3BvcnRPcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZhaWxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiBcInBpbmdcIiwgZGF0YTogXCJwcm9iZVwiIH1dKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbmNlKFwicGFja2V0XCIsIChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKFwicG9uZ1wiID09PSBtc2cudHlwZSAmJiBcInByb2JlXCIgPT09IG1zZy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJ1cGdyYWRpbmdcIiwgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFuc3BvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIFNvY2tldFdpdGhvdXRVcGdyYWRlLnByaW9yV2Vic29ja2V0U3VjY2VzcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBcIndlYnNvY2tldFwiID09PSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucGF1c2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZhaWxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJjbG9zZWRcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiBcInVwZ3JhZGVcIiB9XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGVcIiwgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcInByb2JlIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJ1cGdyYWRlRXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgICAgICAgICAgaWYgKGZhaWxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICAgICAgICBjb25zdCBvbmVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJwcm9iZSBlcnJvcjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwidXBncmFkZUVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpIHtcbiAgICAgICAgICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICAgICAgICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgICAgICAgICAgb25lcnJvcihcInNvY2tldCBjbG9zZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgICAgICAgZnVuY3Rpb24gb251cGdyYWRlKHRvKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT09IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwib3BlblwiLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25lcnJvcik7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwiY2xvc2VcIiwgb25jbG9zZSk7XG4gICAgICAgICAgICB0aGlzLm9mZihcInVwZ3JhZGluZ1wiLCBvbnVwZ3JhZGUpO1xuICAgICAgICB9O1xuICAgICAgICB0cmFuc3BvcnQub25jZShcIm9wZW5cIiwgb25UcmFuc3BvcnRPcGVuKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJlcnJvclwiLCBvbmVycm9yKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgdGhpcy5vbmNlKFwiY2xvc2VcIiwgb25jbG9zZSk7XG4gICAgICAgIHRoaXMub25jZShcInVwZ3JhZGluZ1wiLCBvbnVwZ3JhZGUpO1xuICAgICAgICBpZiAodGhpcy5fdXBncmFkZXMuaW5kZXhPZihcIndlYnRyYW5zcG9ydFwiKSAhPT0gLTEgJiZcbiAgICAgICAgICAgIG5hbWUgIT09IFwid2VidHJhbnNwb3J0XCIpIHtcbiAgICAgICAgICAgIC8vIGZhdm9yIFdlYlRyYW5zcG9ydFxuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5vcGVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vcGVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25IYW5kc2hha2UoZGF0YSkge1xuICAgICAgICB0aGlzLl91cGdyYWRlcyA9IHRoaXMuX2ZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICAgICAgICBzdXBlci5vbkhhbmRzaGFrZShkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB1cGdyYWRlcyAtIHNlcnZlciB1cGdyYWRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbHRlclVwZ3JhZGVzKHVwZ3JhZGVzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cGdyYWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKH50aGlzLnRyYW5zcG9ydHMuaW5kZXhPZih1cGdyYWRlc1tpXSkpXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSBXZWJTb2NrZXQtbGlrZSBpbnRlcmZhY2UgdG8gY29ubmVjdCB0byBhbiBFbmdpbmUuSU8gc2VydmVyLiBUaGUgY29ubmVjdGlvbiB3aWxsIGJlIGVzdGFibGlzaGVkXG4gKiB3aXRoIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGxvdy1sZXZlbCB0cmFuc3BvcnRzLCBsaWtlIEhUVFAgbG9uZy1wb2xsaW5nLCBXZWJTb2NrZXQgb3IgV2ViVHJhbnNwb3J0LlxuICpcbiAqIFRoaXMgY2xhc3MgY29tZXMgd2l0aCBhbiB1cGdyYWRlIG1lY2hhbmlzbSwgd2hpY2ggbWVhbnMgdGhhdCBvbmNlIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIHdpdGggdGhlIGZpcnN0XG4gKiBsb3ctbGV2ZWwgdHJhbnNwb3J0LCBpdCB3aWxsIHRyeSB0byB1cGdyYWRlIHRvIGEgYmV0dGVyIHRyYW5zcG9ydC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgU29ja2V0IH0gZnJvbSBcImVuZ2luZS5pby1jbGllbnRcIjtcbiAqXG4gKiBjb25zdCBzb2NrZXQgPSBuZXcgU29ja2V0KCk7XG4gKlxuICogc29ja2V0Lm9uKFwib3BlblwiLCAoKSA9PiB7XG4gKiAgIHNvY2tldC5zZW5kKFwiaGVsbG9cIik7XG4gKiB9KTtcbiAqXG4gKiBAc2VlIFNvY2tldFdpdGhvdXRVcGdyYWRlXG4gKiBAc2VlIFNvY2tldFdpdGhVcGdyYWRlXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2NrZXQgZXh0ZW5kcyBTb2NrZXRXaXRoVXBncmFkZSB7XG4gICAgY29uc3RydWN0b3IodXJpLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgbyA9IHR5cGVvZiB1cmkgPT09IFwib2JqZWN0XCIgPyB1cmkgOiBvcHRzO1xuICAgICAgICBpZiAoIW8udHJhbnNwb3J0cyB8fFxuICAgICAgICAgICAgKG8udHJhbnNwb3J0cyAmJiB0eXBlb2Ygby50cmFuc3BvcnRzWzBdID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgby50cmFuc3BvcnRzID0gKG8udHJhbnNwb3J0cyB8fCBbXCJwb2xsaW5nXCIsIFwid2Vic29ja2V0XCIsIFwid2VidHJhbnNwb3J0XCJdKVxuICAgICAgICAgICAgICAgIC5tYXAoKHRyYW5zcG9ydE5hbWUpID0+IERFRkFVTFRfVFJBTlNQT1JUU1t0cmFuc3BvcnROYW1lXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh0KSA9PiAhIXQpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHVyaSwgbyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwiZW5naW5lLmlvLWNsaWVudFwiO1xuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB1cmkgLSB1cmxcbiAqIEBwYXJhbSBwYXRoIC0gdGhlIHJlcXVlc3QgcGF0aCBvZiB0aGUgY29ubmVjdGlvblxuICogQHBhcmFtIGxvYyAtIEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXJsKHVyaSwgcGF0aCA9IFwiXCIsIGxvYykge1xuICAgIGxldCBvYmogPSB1cmk7XG4gICAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgICBsb2MgPSBsb2MgfHwgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBsb2NhdGlvbik7XG4gICAgaWYgKG51bGwgPT0gdXJpKVxuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2MuaG9zdDtcbiAgICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoXCIvXCIgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIGlmIChcIi9cIiA9PT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGxvYykge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIFwiLy9cIiArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVyaSA9IFwiaHR0cHM6Ly9cIiArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJzZVxuICAgICAgICBvYmogPSBwYXJzZSh1cmkpO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgICBpZiAoIW9iai5wb3J0KSB7XG4gICAgICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgICAgICAgb2JqLnBvcnQgPSBcIjgwXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICBvYmoucG9ydCA9IFwiNDQzXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCBcIi9cIjtcbiAgICBjb25zdCBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZihcIjpcIikgIT09IC0xO1xuICAgIGNvbnN0IGhvc3QgPSBpcHY2ID8gXCJbXCIgKyBvYmouaG9zdCArIFwiXVwiIDogb2JqLmhvc3Q7XG4gICAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICAgIG9iai5pZCA9IG9iai5wcm90b2NvbCArIFwiOi8vXCIgKyBob3N0ICsgXCI6XCIgKyBvYmoucG9ydCArIHBhdGg7XG4gICAgLy8gZGVmaW5lIGhyZWZcbiAgICBvYmouaHJlZiA9XG4gICAgICAgIG9iai5wcm90b2NvbCArXG4gICAgICAgICAgICBcIjovL1wiICtcbiAgICAgICAgICAgIGhvc3QgK1xuICAgICAgICAgICAgKGxvYyAmJiBsb2MucG9ydCA9PT0gb2JqLnBvcnQgPyBcIlwiIDogXCI6XCIgKyBvYmoucG9ydCk7XG4gICAgcmV0dXJuIG9iajtcbn1cbiIsImNvbnN0IHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNWaWV3ID0gKG9iaikgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxuICAgICAgICA6IG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn07XG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAodHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gXCJbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl1cIik7XG5jb25zdCB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gXCJbb2JqZWN0IEZpbGVDb25zdHJ1Y3Rvcl1cIik7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBCdWZmZXIsIGFuIEFycmF5QnVmZmVyLCBhIEJsb2Igb3IgYSBGaWxlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0JpbmFyeShvYmopIHtcbiAgICByZXR1cm4gKCh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiYgKG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGlzVmlldyhvYmopKSkgfHxcbiAgICAgICAgKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzQmluYXJ5KG9iaiwgdG9KU09OKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0JpbmFyeShvYmopKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqLnRvSlNPTiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgaXNCaW5hcnkgfSBmcm9tIFwiLi9pcy1iaW5hcnkuanNcIjtcbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgfCBCbG9iIHwgRmlsZSBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0KSB7XG4gICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgIGNvbnN0IHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgICBjb25zdCBwYWNrID0gcGFja2V0O1xuICAgIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICAgIHJldHVybiB7IHBhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVycyB9O1xufVxuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgICBpZiAoIWRhdGEpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIGlmIChpc0JpbmFyeShkYXRhKSkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNvbnN0cnVjdFBhY2tldChwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSwgYnVmZmVycyk7XG4gICAgZGVsZXRlIHBhY2tldC5hdHRhY2htZW50czsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICAgIHJldHVybiBwYWNrZXQ7XG59XG5mdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICAgIGlmICghZGF0YSlcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgaXNJbmRleFZhbGlkID0gdHlwZW9mIGRhdGEubnVtID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICBkYXRhLm51bSA+PSAwICYmXG4gICAgICAgICAgICBkYXRhLm51bSA8IGJ1ZmZlcnMubGVuZ3RoO1xuICAgICAgICBpZiAoaXNJbmRleFZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBhdHRhY2htZW50c1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbiIsImltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tIFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiO1xuaW1wb3J0IHsgZGVjb25zdHJ1Y3RQYWNrZXQsIHJlY29uc3RydWN0UGFja2V0IH0gZnJvbSBcIi4vYmluYXJ5LmpzXCI7XG5pbXBvcnQgeyBpc0JpbmFyeSwgaGFzQmluYXJ5IH0gZnJvbSBcIi4vaXMtYmluYXJ5LmpzXCI7XG4vKipcbiAqIFRoZXNlIHN0cmluZ3MgbXVzdCBub3QgYmUgdXNlZCBhcyBldmVudCBuYW1lcywgYXMgdGhleSBoYXZlIGEgc3BlY2lhbCBtZWFuaW5nLlxuICovXG5jb25zdCBSRVNFUlZFRF9FVkVOVFMgPSBbXG4gICAgXCJjb25uZWN0XCIsXG4gICAgXCJjb25uZWN0X2Vycm9yXCIsXG4gICAgXCJkaXNjb25uZWN0XCIsXG4gICAgXCJkaXNjb25uZWN0aW5nXCIsXG4gICAgXCJuZXdMaXN0ZW5lclwiLFxuICAgIFwicmVtb3ZlTGlzdGVuZXJcIiwgLy8gdXNlZCBieSB0aGUgTm9kZS5qcyBFdmVudEVtaXR0ZXJcbl07XG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcHJvdG9jb2wgPSA1O1xuZXhwb3J0IHZhciBQYWNrZXRUeXBlO1xuKGZ1bmN0aW9uIChQYWNrZXRUeXBlKSB7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQ09OTkVDVFwiXSA9IDBdID0gXCJDT05ORUNUXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiRElTQ09OTkVDVFwiXSA9IDFdID0gXCJESVNDT05ORUNUXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiRVZFTlRcIl0gPSAyXSA9IFwiRVZFTlRcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJBQ0tcIl0gPSAzXSA9IFwiQUNLXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQ09OTkVDVF9FUlJPUlwiXSA9IDRdID0gXCJDT05ORUNUX0VSUk9SXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQklOQVJZX0VWRU5UXCJdID0gNV0gPSBcIkJJTkFSWV9FVkVOVFwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkJJTkFSWV9BQ0tcIl0gPSA2XSA9IFwiQklOQVJZX0FDS1wiO1xufSkoUGFja2V0VHlwZSB8fCAoUGFja2V0VHlwZSA9IHt9KSk7XG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEVuY29kZXIge1xuICAgIC8qKlxuICAgICAqIEVuY29kZXIgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlcGxhY2VyIC0gY3VzdG9tIHJlcGxhY2VyIHRvIHBhc3MgZG93biB0byBKU09OLnBhcnNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVwbGFjZXIpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAgICAgKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gICAgICovXG4gICAgZW5jb2RlKG9iaikge1xuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFBhY2tldFR5cGUuRVZFTlQgfHwgb2JqLnR5cGUgPT09IFBhY2tldFR5cGUuQUNLKSB7XG4gICAgICAgICAgICBpZiAoaGFzQmluYXJ5KG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVBc0JpbmFyeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG9iai50eXBlID09PSBQYWNrZXRUeXBlLkVWRU5UXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFBhY2tldFR5cGUuQklOQVJZX0FDSyxcbiAgICAgICAgICAgICAgICAgICAgbnNwOiBvYmoubnNwLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBvYmouZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG9iai5pZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RoaXMuZW5jb2RlQXNTdHJpbmcob2JqKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICAgICAqL1xuICAgIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICAgICAgICAvLyBmaXJzdCBpcyB0eXBlXG4gICAgICAgIGxldCBzdHIgPSBcIlwiICsgb2JqLnR5cGU7XG4gICAgICAgIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UIHx8XG4gICAgICAgICAgICBvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfQUNLKSB7XG4gICAgICAgICAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzICsgXCItXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAgICAgICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgICAgICAgaWYgKG9iai5uc3AgJiYgXCIvXCIgIT09IG9iai5uc3ApIHtcbiAgICAgICAgICAgIHN0ciArPSBvYmoubnNwICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gICAgICAgIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgICAgICAgICAgc3RyICs9IG9iai5pZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBqc29uIGRhdGFcbiAgICAgICAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICAgICAgICAgIHN0ciArPSBKU09OLnN0cmluZ2lmeShvYmouZGF0YSwgdGhpcy5yZXBsYWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gICAgICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICAgICAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICAgICAqL1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaikge1xuICAgICAgICBjb25zdCBkZWNvbnN0cnVjdGlvbiA9IGRlY29uc3RydWN0UGFja2V0KG9iaik7XG4gICAgICAgIGNvbnN0IHBhY2sgPSB0aGlzLmVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuICAgICAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgICAgIHJldHVybiBidWZmZXJzOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgICB9XG59XG4vLyBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUxMTI4MS9jaGVjay1pZi1hLXZhbHVlLWlzLWFuLW9iamVjdC1pbi1qYXZhc2NyaXB0XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWNvZGVyIGV4dGVuZHMgRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogRGVjb2RlciBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmV2aXZlciAtIGN1c3RvbSByZXZpdmVyIHRvIHBhc3MgZG93biB0byBKU09OLnN0cmluZ2lmeVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJldml2ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXZpdmVyID0gcmV2aXZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBlbmNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICAgICAqL1xuICAgIGFkZChvYmopIHtcbiAgICAgICAgbGV0IHBhY2tldDtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnb3QgcGxhaW50ZXh0IGRhdGEgd2hlbiByZWNvbnN0cnVjdGluZyBhIHBhY2tldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhY2tldCA9IHRoaXMuZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgICAgICAgICBjb25zdCBpc0JpbmFyeUV2ZW50ID0gcGFja2V0LnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UO1xuICAgICAgICAgICAgaWYgKGlzQmluYXJ5RXZlbnQgfHwgcGFja2V0LnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0FDSykge1xuICAgICAgICAgICAgICAgIHBhY2tldC50eXBlID0gaXNCaW5hcnlFdmVudCA/IFBhY2tldFR5cGUuRVZFTlQgOiBQYWNrZXRUeXBlLkFDSztcbiAgICAgICAgICAgICAgICAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgICAgICAgICAgICBpZiAocGFja2V0LmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImRlY29kZWRcIiwgcGFja2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICAgICAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiZGVjb2RlZFwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmluYXJ5KG9iaikgfHwgb2JqLmJhc2U2NCkge1xuICAgICAgICAgICAgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgICAgICAgICAgIGlmIChwYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImRlY29kZWRcIiwgcGFja2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiICsgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKi9cbiAgICBkZWNvZGVTdHJpbmcoc3RyKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgLy8gbG9vayB1cCB0eXBlXG4gICAgICAgIGNvbnN0IHAgPSB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIoc3RyLmNoYXJBdCgwKSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChQYWNrZXRUeXBlW3AudHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBwYWNrZXQgdHlwZSBcIiArIHAudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICAgICAgICBpZiAocC50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVCB8fFxuICAgICAgICAgICAgcC50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0spIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9PSBcIi1cIiAmJiBpICE9IHN0ci5sZW5ndGgpIHsgfVxuICAgICAgICAgICAgY29uc3QgYnVmID0gc3RyLnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgICAgICAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBhdHRhY2htZW50c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICAgICAgICBpZiAoXCIvXCIgPT09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKCsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChcIixcIiA9PT0gYylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5uc3AgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAubnNwID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vayB1cCBpZFxuICAgICAgICBjb25zdCBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gICAgICAgIGlmIChcIlwiICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKCsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5pZCA9IE51bWJlcihzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gICAgICAgIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLnRyeVBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgICAgICAgICAgaWYgKERlY29kZXIuaXNQYXlsb2FkVmFsaWQocC50eXBlLCBwYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHAuZGF0YSA9IHBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBheWxvYWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHRyeVBhcnNlKHN0cikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLCB0aGlzLnJldml2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGlzUGF5bG9hZFZhbGlkKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQ09OTkVDVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QocGF5bG9hZCk7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuRElTQ09OTkVDVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwYXlsb2FkID09PSBcInN0cmluZ1wiIHx8IGlzT2JqZWN0KHBheWxvYWQpO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkVWRU5UOlxuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkocGF5bG9hZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBwYXlsb2FkWzBdID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHBheWxvYWRbMF0gPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRVNFUlZFRF9FVkVOVFMuaW5kZXhPZihwYXlsb2FkWzBdKSA9PT0gLTEpKSk7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQUNLOlxuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBCaW5hcnlSZWNvbnN0cnVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgICAgICAgdGhpcy5wYWNrZXQgPSBwYWNrZXQ7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuICAgICAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG4gICAgICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAgICAgKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAgICAgKi9cbiAgICB0YWtlQmluYXJ5RGF0YShiaW5EYXRhKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgIC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gcmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBmaW5pc2hlZFJlY29uc3RydWN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuICAgIG9iai5vbihldiwgZm4pO1xuICAgIHJldHVybiBmdW5jdGlvbiBzdWJEZXN0cm95KCkge1xuICAgICAgICBvYmoub2ZmKGV2LCBmbik7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IFBhY2tldFR5cGUgfSBmcm9tIFwic29ja2V0LmlvLXBhcnNlclwiO1xuaW1wb3J0IHsgb24gfSBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHsgRW1pdHRlciwgfSBmcm9tIFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiO1xuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqL1xuY29uc3QgUkVTRVJWRURfRVZFTlRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgY29ubmVjdDogMSxcbiAgICBjb25uZWN0X2Vycm9yOiAxLFxuICAgIGRpc2Nvbm5lY3Q6IDEsXG4gICAgZGlzY29ubmVjdGluZzogMSxcbiAgICAvLyBFdmVudEVtaXR0ZXIgcmVzZXJ2ZWQgZXZlbnRzOiBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19ldmVudF9uZXdsaXN0ZW5lclxuICAgIG5ld0xpc3RlbmVyOiAxLFxuICAgIHJlbW92ZUxpc3RlbmVyOiAxLFxufSk7XG4vKipcbiAqIEEgU29ja2V0IGlzIHRoZSBmdW5kYW1lbnRhbCBjbGFzcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc2VydmVyLlxuICpcbiAqIEEgU29ja2V0IGJlbG9uZ3MgdG8gYSBjZXJ0YWluIE5hbWVzcGFjZSAoYnkgZGVmYXVsdCAvKSBhbmQgdXNlcyBhbiB1bmRlcmx5aW5nIHtAbGluayBNYW5hZ2VyfSB0byBjb21tdW5pY2F0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAqXG4gKiBzb2NrZXQub24oXCJjb25uZWN0XCIsICgpID0+IHtcbiAqICAgY29uc29sZS5sb2coXCJjb25uZWN0ZWRcIik7XG4gKiB9KTtcbiAqXG4gKiAvLyBzZW5kIGFuIGV2ZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIHNvY2tldC5lbWl0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICpcbiAqIHNvY2tldC5vbihcImZvb2JhclwiLCAoKSA9PiB7XG4gKiAgIC8vIGFuIGV2ZW50IHdhcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAqIH0pO1xuICpcbiAqIC8vIHVwb24gZGlzY29ubmVjdGlvblxuICogc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGBkaXNjb25uZWN0ZWQgZHVlIHRvICR7cmVhc29ufWApO1xuICogfSk7XG4gKi9cbmV4cG9ydCBjbGFzcyBTb2NrZXQgZXh0ZW5kcyBFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbywgbnNwLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzb2NrZXQgaXMgY3VycmVudGx5IGNvbm5lY3RlZCB0byB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBzb2NrZXQgPSBpbygpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBzb2NrZXQub24oXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuY29ubmVjdGVkKTsgLy8gdHJ1ZVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm5lY3RlZCk7IC8vIGZhbHNlXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgd2FzIHJlY292ZXJlZCBhZnRlciBhIHRlbXBvcmFyeSBkaXNjb25uZWN0aW9uLiBJbiB0aGF0IGNhc2UsIGFueSBtaXNzZWQgcGFja2V0cyB3aWxsXG4gICAgICAgICAqIGJlIHRyYW5zbWl0dGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY292ZXJlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIGZvciBwYWNrZXRzIHJlY2VpdmVkIGJlZm9yZSB0aGUgQ09OTkVDVCBwYWNrZXRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnVmZmVyIGZvciBwYWNrZXRzIHRoYXQgd2lsbCBiZSBzZW50IG9uY2UgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHF1ZXVlIG9mIHBhY2tldHMgdG8gYmUgc2VudCB3aXRoIHJldHJ5IGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogUGFja2V0cyBhcmUgc2VudCBvbmUgYnkgb25lLCBlYWNoIHdhaXRpbmcgZm9yIHRoZSBzZXJ2ZXIgYWNrbm93bGVkZ2VtZW50LCBpbiBvcmRlciB0byBndWFyYW50ZWUgdGhlIGRlbGl2ZXJ5IG9yZGVyLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2VxdWVuY2UgdG8gZ2VuZXJhdGUgdGhlIElEIG9mIHRoZSB7QGxpbmsgUXVldWVkUGFja2V0fS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3F1ZXVlU2VxID0gMDtcbiAgICAgICAgdGhpcy5pZHMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgY29udGFpbmluZyBhY2tub3dsZWRnZW1lbnQgaGFuZGxlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgd2l0aEVycm9yYCBhdHRyaWJ1dGUgaXMgdXNlZCB0byBkaWZmZXJlbnRpYXRlIGhhbmRsZXJzIHRoYXQgYWNjZXB0IGFuIGVycm9yIGFzIGZpcnN0IGFyZ3VtZW50OlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGBzb2NrZXQuZW1pdChcInRlc3RcIiwgKGVyciwgdmFsdWUpID0+IHsgLi4uIH0pYCB3aXRoIGBhY2tUaW1lb3V0YCBvcHRpb25cbiAgICAgICAgICogLSBgc29ja2V0LnRpbWVvdXQoNTAwMCkuZW1pdChcInRlc3RcIiwgKGVyciwgdmFsdWUpID0+IHsgLi4uIH0pYFxuICAgICAgICAgKiAtIGBjb25zdCB2YWx1ZSA9IGF3YWl0IHNvY2tldC5lbWl0V2l0aEFjayhcInRlc3RcIilgXG4gICAgICAgICAqXG4gICAgICAgICAqIEZyb20gdGhvc2UgdGhhdCBkb24ndDpcbiAgICAgICAgICpcbiAgICAgICAgICogLSBgc29ja2V0LmVtaXQoXCJ0ZXN0XCIsICh2YWx1ZSkgPT4geyAuLi4gfSk7YFxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiB0aGUgZmlyc3QgY2FzZSwgdGhlIGhhbmRsZXJzIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gZXJyb3Igd2hlbjpcbiAgICAgICAgICpcbiAgICAgICAgICogLSB0aGUgdGltZW91dCBpcyByZWFjaGVkXG4gICAgICAgICAqIC0gdGhlIHNvY2tldCBnZXRzIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiB0aGUgc2Vjb25kIGNhc2UsIHRoZSBoYW5kbGVycyB3aWxsIGJlIHNpbXBseSBkaXNjYXJkZWQgdXBvbiBkaXNjb25uZWN0aW9uLCBzaW5jZSB0aGUgY2xpZW50IHdpbGwgbmV2ZXIgcmVjZWl2ZVxuICAgICAgICAgKiBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY2tzID0ge307XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5pbyA9IGlvO1xuICAgICAgICB0aGlzLm5zcCA9IG5zcDtcbiAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hdXRoKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGggPSBvcHRzLmF1dGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5pby5fYXV0b0Nvbm5lY3QpXG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBkaXNjb25uZWN0ZWRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgICAgKlxuICAgICAqIHNvY2tldC5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmRpc2Nvbm5lY3RlZCk7IC8vIGZhbHNlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5kaXNjb25uZWN0ZWQpOyAvLyB0cnVlXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0IGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbm5lY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN1YkV2ZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3VicylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaW8gPSB0aGlzLmlvO1xuICAgICAgICB0aGlzLnN1YnMgPSBbXG4gICAgICAgICAgICBvbihpbywgXCJvcGVuXCIsIHRoaXMub25vcGVuLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgb24oaW8sIFwicGFja2V0XCIsIHRoaXMub25wYWNrZXQuYmluZCh0aGlzKSksXG4gICAgICAgICAgICBvbihpbywgXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKSksXG4gICAgICAgICAgICBvbihpbywgXCJjbG9zZVwiLCB0aGlzLm9uY2xvc2UuYmluZCh0aGlzKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIFNvY2tldCB3aWxsIHRyeSB0byByZWNvbm5lY3Qgd2hlbiBpdHMgTWFuYWdlciBjb25uZWN0cyBvciByZWNvbm5lY3RzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzb2NrZXQgPSBpbygpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coc29ja2V0LmFjdGl2ZSk7IC8vIHRydWVcbiAgICAgKlxuICAgICAqIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwgKHJlYXNvbikgPT4ge1xuICAgICAqICAgaWYgKHJlYXNvbiA9PT0gXCJpbyBzZXJ2ZXIgZGlzY29ubmVjdFwiKSB7XG4gICAgICogICAgIC8vIHRoZSBkaXNjb25uZWN0aW9uIHdhcyBpbml0aWF0ZWQgYnkgdGhlIHNlcnZlciwgeW91IG5lZWQgdG8gbWFudWFsbHkgcmVjb25uZWN0XG4gICAgICogICAgIGNvbnNvbGUubG9nKHNvY2tldC5hY3RpdmUpOyAvLyBmYWxzZVxuICAgICAqICAgfVxuICAgICAqICAgLy8gZWxzZSB0aGUgc29ja2V0IHdpbGwgYXV0b21hdGljYWxseSB0cnkgdG8gcmVjb25uZWN0XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuYWN0aXZlKTsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc3VicztcbiAgICB9XG4gICAgLyoqXG4gICAgICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHNvY2tldCA9IGlvKHtcbiAgICAgKiAgIGF1dG9Db25uZWN0OiBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5zdWJFdmVudHMoKTtcbiAgICAgICAgaWYgKCF0aGlzLmlvW1wiX3JlY29ubmVjdGluZ1wiXSlcbiAgICAgICAgICAgIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuICAgICAgICBpZiAoXCJvcGVuXCIgPT09IHRoaXMuaW8uX3JlYWR5U3RhdGUpXG4gICAgICAgICAgICB0aGlzLm9ub3BlbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBjb25uZWN0KCl9LlxuICAgICAqL1xuICAgIG9wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtaW1pY3MgdGhlIFdlYlNvY2tldC5zZW5kKCkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViU29ja2V0L3NlbmRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0LnNlbmQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIC8vIHRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAqIHNvY2tldC5lbWl0KFwibWVzc2FnZVwiLCBcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgc2VuZCguLi5hcmdzKSB7XG4gICAgICAgIGFyZ3MudW5zaGlmdChcIm1lc3NhZ2VcIik7XG4gICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGBlbWl0YC5cbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0LmVtaXQoXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqXG4gICAgICogLy8gYWxsIHNlcmlhbGl6YWJsZSBkYXRhc3RydWN0dXJlcyBhcmUgc3VwcG9ydGVkIChubyBuZWVkIHRvIGNhbGwgSlNPTi5zdHJpbmdpZnkpXG4gICAgICogc29ja2V0LmVtaXQoXCJoZWxsb1wiLCAxLCBcIjJcIiwgeyAzOiBbXCI0XCJdLCA1OiBVaW50OEFycmF5LmZyb20oWzZdKSB9KTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gdGhlIHNlcnZlclxuICAgICAqIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiLCAodmFsKSA9PiB7XG4gICAgICogICAvLyAuLi5cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChSRVNFUlZFRF9FVkVOVFMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGV2LnRvU3RyaW5nKCkgKyAnXCIgaXMgYSByZXNlcnZlZCBldmVudCBuYW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy51bnNoaWZ0KGV2KTtcbiAgICAgICAgaWYgKHRoaXMuX29wdHMucmV0cmllcyAmJiAhdGhpcy5mbGFncy5mcm9tUXVldWUgJiYgIXRoaXMuZmxhZ3Mudm9sYXRpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUXVldWUoYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiBQYWNrZXRUeXBlLkVWRU5ULFxuICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgfTtcbiAgICAgICAgcGFja2V0Lm9wdGlvbnMgPSB7fTtcbiAgICAgICAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSB0aGlzLmZsYWdzLmNvbXByZXNzICE9PSBmYWxzZTtcbiAgICAgICAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5pZHMrKztcbiAgICAgICAgICAgIGNvbnN0IGFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlckFja0NhbGxiYWNrKGlkLCBhY2spO1xuICAgICAgICAgICAgcGFja2V0LmlkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNUcmFuc3BvcnRXcml0YWJsZSA9IChfYiA9IChfYSA9IHRoaXMuaW8uZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud3JpdGFibGU7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gdGhpcy5jb25uZWN0ZWQgJiYgISgoX2MgPSB0aGlzLmlvLmVuZ2luZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLl9oYXNQaW5nRXhwaXJlZCgpKTtcbiAgICAgICAgY29uc3QgZGlzY2FyZFBhY2tldCA9IHRoaXMuZmxhZ3Mudm9sYXRpbGUgJiYgIWlzVHJhbnNwb3J0V3JpdGFibGU7XG4gICAgICAgIGlmIChkaXNjYXJkUGFja2V0KSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoX2EgPSB0aGlzLmZsYWdzLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX29wdHMuYWNrVGltZW91dDtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hY2tzW2lkXSA9IGFjaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy5pby5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWNrc1tpZF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbmRCdWZmZXJbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlci5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNrLmNhbGwodGhpcywgbmV3IEVycm9yKFwib3BlcmF0aW9uIGhhcyB0aW1lZCBvdXRcIikpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgZm4gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5pby5jbGVhclRpbWVvdXRGbih0aW1lcik7XG4gICAgICAgICAgICBhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGZuLndpdGhFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMuYWNrc1tpZF0gPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYW5kIHdhaXRzIGZvciBhbiBhY2tub3dsZWRnZW1lbnRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gd2l0aG91dCB0aW1lb3V0XG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzb2NrZXQuZW1pdFdpdGhBY2soXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqXG4gICAgICogLy8gd2l0aCBhIHNwZWNpZmljIHRpbWVvdXRcbiAgICAgKiB0cnkge1xuICAgICAqICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzb2NrZXQudGltZW91dCgxMDAwKS5lbWl0V2l0aEFjayhcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICogfSBjYXRjaCAoZXJyKSB7XG4gICAgICogICAvLyB0aGUgc2VydmVyIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc2VydmVyIGFja25vd2xlZGdlcyB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBlbWl0V2l0aEFjayhldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm4gPSAoYXJnMSwgYXJnMikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmcxID8gcmVqZWN0KGFyZzEpIDogcmVzb2x2ZShhcmcyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmbi53aXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgYXJncy5wdXNoKGZuKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHBhY2tldCB0byB0aGUgcXVldWUuXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRUb1F1ZXVlKGFyZ3MpIHtcbiAgICAgICAgbGV0IGFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy5fcXVldWVTZXErKyxcbiAgICAgICAgICAgIHRyeUNvdW50OiAwLFxuICAgICAgICAgICAgcGVuZGluZzogZmFsc2UsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgZmxhZ3M6IE9iamVjdC5hc3NpZ24oeyBmcm9tUXVldWU6IHRydWUgfSwgdGhpcy5mbGFncyksXG4gICAgICAgIH07XG4gICAgICAgIGFyZ3MucHVzaCgoZXJyLCAuLi5yZXNwb25zZUFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmIChwYWNrZXQgIT09IHRoaXMuX3F1ZXVlWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhY2tldCBoYXMgYWxyZWFkeSBiZWVuIGFja25vd2xlZGdlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc0Vycm9yID0gZXJyICE9PSBudWxsO1xuICAgICAgICAgICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhY2tldC50cnlDb3VudCA+IHRoaXMuX29wdHMucmV0cmllcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjaykge1xuICAgICAgICAgICAgICAgICAgICBhY2sobnVsbCwgLi4ucmVzcG9uc2VBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWNrZXQucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RyYWluUXVldWUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFja2V0KTtcbiAgICAgICAgdGhpcy5fZHJhaW5RdWV1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHF1ZXVlLCBhbmQgd2FpdCBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gZm9yY2UgLSB3aGV0aGVyIHRvIHJlc2VuZCBhIHBhY2tldCB0aGF0IGhhcyBub3QgYmVlbiBhY2tub3dsZWRnZWQgeWV0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kcmFpblF1ZXVlKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCB8fCB0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWNrZXQgPSB0aGlzLl9xdWV1ZVswXTtcbiAgICAgICAgaWYgKHBhY2tldC5wZW5kaW5nICYmICFmb3JjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBhY2tldC5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgcGFja2V0LnRyeUNvdW50Kys7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBwYWNrZXQuZmxhZ3M7XG4gICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBwYWNrZXQuYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcGFja2V0KHBhY2tldCkge1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gICAgICAgIHRoaXMuaW8uX3BhY2tldChwYWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbm9wZW4oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5hdXRoID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5hdXRoKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZENvbm5lY3RQYWNrZXQoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb25uZWN0UGFja2V0KHRoaXMuYXV0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBDT05ORUNUIHBhY2tldCB0byBpbml0aWF0ZSB0aGUgU29ja2V0LklPIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbmRDb25uZWN0UGFja2V0KGRhdGEpIHtcbiAgICAgICAgdGhpcy5wYWNrZXQoe1xuICAgICAgICAgICAgdHlwZTogUGFja2V0VHlwZS5DT05ORUNULFxuICAgICAgICAgICAgZGF0YTogdGhpcy5fcGlkXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHsgcGlkOiB0aGlzLl9waWQsIG9mZnNldDogdGhpcy5fbGFzdE9mZnNldCB9LCBkYXRhKVxuICAgICAgICAgICAgICAgIDogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGVuZ2luZSBvciBtYW5hZ2VyIGBlcnJvcmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmVycm9yKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3RfZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWFzb25cbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBkZWxldGUgdGhpcy5pZDtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkaXNjb25uZWN0XCIsIHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICB0aGlzLl9jbGVhckFja3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBhY2tub3dsZWRnZW1lbnQgaGFuZGxlcnMgdXBvbiBkaXNjb25uZWN0aW9uLCBzaW5jZSB0aGUgY2xpZW50IHdpbGwgbmV2ZXIgcmVjZWl2ZSBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbVxuICAgICAqIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhckFja3MoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNrcykuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQnVmZmVyZWQgPSB0aGlzLnNlbmRCdWZmZXIuc29tZSgocGFja2V0KSA9PiBTdHJpbmcocGFja2V0LmlkKSA9PT0gaWQpO1xuICAgICAgICAgICAgaWYgKCFpc0J1ZmZlcmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90ZTogaGFuZGxlcnMgdGhhdCBkbyBub3QgYWNjZXB0IGFuIGVycm9yIGFzIGZpcnN0IGFyZ3VtZW50IGFyZSBpZ25vcmVkIGhlcmVcbiAgICAgICAgICAgICAgICBjb25zdCBhY2sgPSB0aGlzLmFja3NbaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFja3NbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChhY2sud2l0aEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjay5jYWxsKHRoaXMsIG5ldyBFcnJvcihcInNvY2tldCBoYXMgYmVlbiBkaXNjb25uZWN0ZWRcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbnBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgY29uc3Qgc2FtZU5hbWVzcGFjZSA9IHBhY2tldC5uc3AgPT09IHRoaXMubnNwO1xuICAgICAgICBpZiAoIXNhbWVOYW1lc3BhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5DT05ORUNUOlxuICAgICAgICAgICAgICAgIGlmIChwYWNrZXQuZGF0YSAmJiBwYWNrZXQuZGF0YS5zaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNvbm5lY3QocGFja2V0LmRhdGEuc2lkLCBwYWNrZXQuZGF0YS5waWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0X2Vycm9yXCIsIG5ldyBFcnJvcihcIkl0IHNlZW1zIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWNoIGEgU29ja2V0LklPIHNlcnZlciBpbiB2Mi54IHdpdGggYSB2My54IGNsaWVudCwgYnV0IHRoZXkgYXJlIG5vdCBjb21wYXRpYmxlIChtb3JlIGluZm9ybWF0aW9uIGhlcmU6IGh0dHBzOi8vc29ja2V0LmlvL2RvY3MvdjMvbWlncmF0aW5nLWZyb20tMi14LXRvLTMtMC8pXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuRVZFTlQ6XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQklOQVJZX0VWRU5UOlxuICAgICAgICAgICAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkFDSzpcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5CSU5BUllfQUNLOlxuICAgICAgICAgICAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5ESVNDT05ORUNUOlxuICAgICAgICAgICAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUjpcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IocGFja2V0LmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGVyci5kYXRhID0gcGFja2V0LmRhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3RfZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZXZlbnQocGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgICAgICAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKE9iamVjdC5mcmVlemUoYXJncykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRFdmVudChhcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbnlMaXN0ZW5lcnMgJiYgdGhpcy5fYW55TGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGlmICh0aGlzLl9waWQgJiYgYXJncy5sZW5ndGggJiYgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5fbGFzdE9mZnNldCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhY2soaWQpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBzZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgICAgICAgICBpZiAoc2VudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYucGFja2V0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQYWNrZXRUeXBlLkFDSyxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWRnZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmFjayhwYWNrZXQpIHtcbiAgICAgICAgY29uc3QgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gICAgICAgIGlmICh0eXBlb2YgYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgRklYTUUgYWNrIGlzIGluY29ycmVjdGx5IGluZmVycmVkIGFzICduZXZlcidcbiAgICAgICAgaWYgKGFjay53aXRoRXJyb3IpIHtcbiAgICAgICAgICAgIHBhY2tldC5kYXRhLnVuc2hpZnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25jb25uZWN0KGlkLCBwaWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnJlY292ZXJlZCA9IHBpZCAmJiB0aGlzLl9waWQgPT09IHBpZDtcbiAgICAgICAgdGhpcy5fcGlkID0gcGlkOyAvLyBkZWZpbmVkIG9ubHkgaWYgY29ubmVjdGlvbiBzdGF0ZSByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0XCIpO1xuICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBlbWl0QnVmZmVyZWQoKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5mb3JFYWNoKChhcmdzKSA9PiB0aGlzLmVtaXRFdmVudChhcmdzKSk7XG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgocGFja2V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm9uY2xvc2UoXCJpbyBzZXJ2ZXIgZGlzY29ubmVjdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAgICAgKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICAgICAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzKSB7XG4gICAgICAgICAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICAgICAgICAgIHRoaXMuc3Vicy5mb3JFYWNoKChzdWJEZXN0cm95KSA9PiBzdWJEZXN0cm95KCkpO1xuICAgICAgICAgICAgdGhpcy5zdWJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW9bXCJfZGVzdHJveVwiXSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS4gSW4gdGhhdCBjYXNlLCB0aGUgc29ja2V0IHdpbGwgbm90IHRyeSB0byByZWNvbm5lY3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGlzIHRoZSBsYXN0IGFjdGl2ZSBTb2NrZXQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBNYW5hZ2VyfSwgdGhlIGxvdy1sZXZlbCBjb25uZWN0aW9uIHdpbGwgYmUgY2xvc2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzb2NrZXQgPSBpbygpO1xuICAgICAqXG4gICAgICogc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAocmVhc29uKSA9PiB7XG4gICAgICogICAvLyBjb25zb2xlLmxvZyhyZWFzb24pOyBwcmludHMgXCJpbyBjbGllbnQgZGlzY29ubmVjdFwiXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IFBhY2tldFR5cGUuRElTQ09OTkVDVCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvLyBmaXJlIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5vbmNsb3NlKFwiaW8gY2xpZW50IGRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgZGlzY29ubmVjdCgpfS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5jb21wcmVzcyhmYWxzZSkuZW1pdChcImhlbGxvXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBtZXNzYWdlIHdpbGwgYmUgZHJvcHBlZCB3aGVuIHRoaXMgc29ja2V0IGlzIG5vdFxuICAgICAqIHJlYWR5IHRvIHNlbmQgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC52b2xhdGlsZS5lbWl0KFwiaGVsbG9cIik7IC8vIHRoZSBzZXJ2ZXIgbWF5IG9yIG1heSBub3QgcmVjZWl2ZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybnMgc2VsZlxuICAgICAqL1xuICAgIGdldCB2b2xhdGlsZSgpIHtcbiAgICAgICAgdGhpcy5mbGFncy52b2xhdGlsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgICogZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgd2l0aG91dCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgc2VydmVyOlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQudGltZW91dCg1MDAwKS5lbWl0KFwibXktZXZlbnRcIiwgKGVycikgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyB0aGUgc2VydmVyIGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHJldHVybnMgc2VsZlxuICAgICAqL1xuICAgIHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICB0aGlzLmZsYWdzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZVxuICAgICAqIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQub25BbnkoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgZ290ICR7ZXZlbnR9YCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbkFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay4gVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0LnByZXBlbmRBbnkoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgZ290IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcmVwZW5kQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGNhdGNoQWxsTGlzdGVuZXIgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBnb3QgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBzb2NrZXQub25BbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAvLyByZW1vdmUgYSBzcGVjaWZpYyBsaXN0ZW5lclxuICAgICAqIHNvY2tldC5vZmZBbnkoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAvLyBvciByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAqIHNvY2tldC5vZmZBbnkoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9mZkFueShsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMuX2FueUxpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0aGF0IGFyZSBsaXN0ZW5pbmcgZm9yIGFueSBldmVudCB0aGF0IGlzIHNwZWNpZmllZC4gVGhpcyBhcnJheSBjYW4gYmUgbWFuaXB1bGF0ZWQsXG4gICAgICogZS5nLiB0byByZW1vdmUgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIGxpc3RlbmVyc0FueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZVxuICAgICAqIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogTm90ZTogYWNrbm93bGVkZ2VtZW50cyBzZW50IHRvIHRoZSBzZXJ2ZXIgYXJlIG5vdCBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0Lm9uQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25BbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay4gVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKlxuICAgICAqIE5vdGU6IGFja25vd2xlZGdlbWVudHMgc2VudCB0byB0aGUgc2VydmVyIGFyZSBub3QgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5wcmVwZW5kQW55T3V0Z29pbmcoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgcHJlcGVuZEFueU91dGdvaW5nKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGNhdGNoQWxsTGlzdGVuZXIgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBzZW50IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogc29ja2V0Lm9uQW55T3V0Z29pbmcoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAvLyByZW1vdmUgYSBzcGVjaWZpYyBsaXN0ZW5lclxuICAgICAqIHNvY2tldC5vZmZBbnlPdXRnb2luZyhjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqIC8vIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG4gICAgICogc29ja2V0Lm9mZkFueU91dGdvaW5nKCk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gW2xpc3RlbmVyXSAtIHRoZSBjYXRjaC1hbGwgbGlzdGVuZXIgKG9wdGlvbmFsKVxuICAgICAqL1xuICAgIG9mZkFueU91dGdvaW5nKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50IHRoYXQgaXMgc3BlY2lmaWVkLiBUaGlzIGFycmF5IGNhbiBiZSBtYW5pcHVsYXRlZCxcbiAgICAgKiBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgbGlzdGVuZXJzQW55T3V0Z29pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoZSBsaXN0ZW5lcnMgZm9yIGVhY2ggcGFja2V0IHNlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyAmJiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gICAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gICAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24gKG1pbikge1xuICAgIHRoaXMubXMgPSBtaW47XG59O1xuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbiAobWF4KSB7XG4gICAgdGhpcy5tYXggPSBtYXg7XG59O1xuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uIChqaXR0ZXIpIHtcbiAgICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG4iLCJpbXBvcnQgeyBTb2NrZXQgYXMgRW5naW5lLCBpbnN0YWxsVGltZXJGdW5jdGlvbnMsIG5leHRUaWNrLCB9IGZyb20gXCJlbmdpbmUuaW8tY2xpZW50XCI7XG5pbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwiLi9zb2NrZXQuanNcIjtcbmltcG9ydCAqIGFzIHBhcnNlciBmcm9tIFwic29ja2V0LmlvLXBhcnNlclwiO1xuaW1wb3J0IHsgb24gfSBmcm9tIFwiLi9vbi5qc1wiO1xuaW1wb3J0IHsgQmFja29mZiB9IGZyb20gXCIuL2NvbnRyaWIvYmFja28yLmpzXCI7XG5pbXBvcnQgeyBFbWl0dGVyLCB9IGZyb20gXCJAc29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyXCI7XG5leHBvcnQgY2xhc3MgTWFuYWdlciBleHRlbmRzIEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubnNwcyA9IHt9O1xuICAgICAgICB0aGlzLnN1YnMgPSBbXTtcbiAgICAgICAgaWYgKHVyaSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXJpKSB7XG4gICAgICAgICAgICBvcHRzID0gdXJpO1xuICAgICAgICAgICAgdXJpID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgXCIvc29ja2V0LmlvXCI7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIGluc3RhbGxUaW1lckZ1bmN0aW9ucyh0aGlzLCBvcHRzKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gICAgICAgIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigoX2EgPSBvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAuNSk7XG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICAgICAgICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgICAgICAgICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgICAgICAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgdGhpcy51cmkgPSB1cmk7XG4gICAgICAgIGNvbnN0IF9wYXJzZXIgPSBvcHRzLnBhcnNlciB8fCBwYXJzZXI7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG5ldyBfcGFyc2VyLkVuY29kZXIoKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IF9wYXJzZXIuRGVjb2RlcigpO1xuICAgICAgICB0aGlzLl9hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fYXV0b0Nvbm5lY3QpXG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gICAgcmVjb25uZWN0aW9uKHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzKHYpIHtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVjb25uZWN0aW9uRGVsYXkodikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgICAgICAgKF9hID0gdGhpcy5iYWNrb2ZmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0TWluKHYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmFuZG9taXphdGlvbkZhY3Rvcih2KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICAgICAgICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgICAgICAgKF9hID0gdGhpcy5iYWNrb2ZmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Sml0dGVyKHYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVjb25uZWN0aW9uRGVsYXlNYXgodikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgICAgICAgKF9hID0gdGhpcy5iYWNrb2ZmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0TWF4KHYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGltZW91dCh2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICAgICAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtYXliZVJlY29ubmVjdE9uT3BlbigpIHtcbiAgICAgICAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICAgICAgICBpZiAoIXRoaXMuX3JlY29ubmVjdGluZyAmJlxuICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0aW9uICYmXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIG9wdGlvbmFsLCBjYWxsYmFja1xuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBvcGVuKGZuKSB7XG4gICAgICAgIGlmICh+dGhpcy5fcmVhZHlTdGF0ZS5pbmRleE9mKFwib3BlblwiKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLmVuZ2luZSA9IG5ldyBFbmdpbmUodGhpcy51cmksIHRoaXMub3B0cyk7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFwib3BlbmluZ1wiO1xuICAgICAgICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgLy8gZW1pdCBgb3BlbmBcbiAgICAgICAgY29uc3Qgb3BlblN1YkRlc3Ryb3kgPSBvbihzb2NrZXQsIFwib3BlblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9ub3BlbigpO1xuICAgICAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBlbWl0IGBlcnJvcmBcbiAgICAgICAgY29uc3QgZXJyb3JTdWIgPSBvbihzb2NrZXQsIFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgICAgICAgICAvLyBzZXQgdGltZXJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9wZW5TdWJEZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IoXCJ0aW1lb3V0XCIpKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5hdXRvVW5yZWYpIHtcbiAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0Rm4odGltZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzLnB1c2gob3BlblN1YkRlc3Ryb3kpO1xuICAgICAgICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Igb3BlbigpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY29ubmVjdChmbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuKGZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9ub3BlbigpIHtcbiAgICAgICAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIC8vIG1hcmsgYXMgb3BlblxuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJvcGVuXCI7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwib3BlblwiKTtcbiAgICAgICAgLy8gYWRkIG5ldyBzdWJzXG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICAgICAgICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsIFwicGluZ1wiLCB0aGlzLm9ucGluZy5iaW5kKHRoaXMpKSwgb24oc29ja2V0LCBcImRhdGFcIiwgdGhpcy5vbmRhdGEuYmluZCh0aGlzKSksIG9uKHNvY2tldCwgXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKSksIG9uKHNvY2tldCwgXCJjbG9zZVwiLCB0aGlzLm9uY2xvc2UuYmluZCh0aGlzKSksIFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG9uKHRoaXMuZGVjb2RlciwgXCJkZWNvZGVkXCIsIHRoaXMub25kZWNvZGVkLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbnBpbmcoKSB7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGluZ1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kYXRhKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25jbG9zZShcInBhcnNlIGVycm9yXCIsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRlY29kZWQocGFja2V0KSB7XG4gICAgICAgIC8vIHRoZSBuZXh0VGljayBjYWxsIHByZXZlbnRzIGFuIGV4Y2VwdGlvbiBpbiBhIHVzZXItcHJvdmlkZWQgZXZlbnQgbGlzdGVuZXIgZnJvbSB0cmlnZ2VyaW5nIGEgZGlzY29ubmVjdGlvbiBkdWUgdG8gYSBcInBhcnNlIGVycm9yXCJcbiAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICAgICAgfSwgdGhpcy5zZXRUaW1lb3V0Rm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZXJyb3IoZXJyKSB7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NvY2tldH1cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc29ja2V0KG5zcCwgb3B0cykge1xuICAgICAgICBsZXQgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gICAgICAgIGlmICghc29ja2V0KSB7XG4gICAgICAgICAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCwgb3B0cyk7XG4gICAgICAgICAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9hdXRvQ29ubmVjdCAmJiAhc29ja2V0LmFjdGl2ZSkge1xuICAgICAgICAgICAgc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb2NrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZXN0cm95KHNvY2tldCkge1xuICAgICAgICBjb25zdCBuc3BzID0gT2JqZWN0LmtleXModGhpcy5uc3BzKTtcbiAgICAgICAgZm9yIChjb25zdCBuc3Agb2YgbnNwcykge1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gICAgICAgICAgICBpZiAoc29ja2V0LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFja2V0KHBhY2tldCkge1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5zdWJzLmZvckVhY2goKHN1YkRlc3Ryb3kpID0+IHN1YkRlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMuc3Vicy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbG9zZSgpIHtcbiAgICAgICAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25jbG9zZShcImZvcmNlZCBjbG9zZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIGNsb3NlKClcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuOlxuICAgICAqXG4gICAgICogLSB0aGUgbG93LWxldmVsIGVuZ2luZSBpcyBjbG9zZWRcbiAgICAgKiAtIHRoZSBwYXJzZXIgZW5jb3VudGVyZWQgYSBiYWRseSBmb3JtYXR0ZWQgcGFja2V0XG4gICAgICogLSBhbGwgc29ja2V0cyBhcmUgZGlzY29ubmVjdGVkXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICAoX2EgPSB0aGlzLmVuZ2luZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjbG9zZVwiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJyZWNvbm5lY3RfZmFpbGVkXCIpO1xuICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInJlY29ubmVjdF9hdHRlbXB0XCIsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNlbGYub3BlbigoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicmVjb25uZWN0X2Vycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3Vicy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dEZuKHRpbWVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbnJlY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInJlY29ubmVjdFwiLCBhdHRlbXB0KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyB1cmwgfSBmcm9tIFwiLi91cmwuanNcIjtcbmltcG9ydCB7IE1hbmFnZXIgfSBmcm9tIFwiLi9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwiLi9zb2NrZXQuanNcIjtcbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cbmNvbnN0IGNhY2hlID0ge307XG5mdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiB1cmkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgdXJpID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBjb25zdCBwYXJzZWQgPSB1cmwodXJpLCBvcHRzLnBhdGggfHwgXCIvc29ja2V0LmlvXCIpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gICAgY29uc3QgaWQgPSBwYXJzZWQuaWQ7XG4gICAgY29uc3QgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICAgIGNvbnN0IHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF1bXCJuc3BzXCJdO1xuICAgIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8XG4gICAgICAgIG9wdHNbXCJmb3JjZSBuZXcgY29ubmVjdGlvblwiXSB8fFxuICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHxcbiAgICAgICAgc2FtZU5hbWVzcGFjZTtcbiAgICBsZXQgaW87XG4gICAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgaW8gPSBuZXcgTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIGNhY2hlW2lkXSA9IG5ldyBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaW8gPSBjYWNoZVtpZF07XG4gICAgfVxuICAgIGlmIChwYXJzZWQucXVlcnkgJiYgIW9wdHMucXVlcnkpIHtcbiAgICAgICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeUtleTtcbiAgICB9XG4gICAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG4vLyBzbyB0aGF0IFwibG9va3VwXCIgY2FuIGJlIHVzZWQgYm90aCBhcyBhIGZ1bmN0aW9uIChlLmcuIGBpbyguLi4pYCkgYW5kIGFzIGFcbi8vIG5hbWVzcGFjZSAoZS5nLiBgaW8uY29ubmVjdCguLi4pYCksIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5PYmplY3QuYXNzaWduKGxvb2t1cCwge1xuICAgIE1hbmFnZXIsXG4gICAgU29ja2V0LFxuICAgIGlvOiBsb29rdXAsXG4gICAgY29ubmVjdDogbG9va3VwLFxufSk7XG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgeyBwcm90b2NvbCB9IGZyb20gXCJzb2NrZXQuaW8tcGFyc2VyXCI7XG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgeyBNYW5hZ2VyLCBTb2NrZXQsIGxvb2t1cCBhcyBpbywgbG9va3VwIGFzIGNvbm5lY3QsIGxvb2t1cCBhcyBkZWZhdWx0LCB9O1xuZXhwb3J0IHsgRmV0Y2gsIE5vZGVYSFIsIFhIUiwgTm9kZVdlYlNvY2tldCwgV2ViU29ja2V0LCBXZWJUcmFuc3BvcnQsIH0gZnJvbSBcImVuZ2luZS5pby1jbGllbnRcIjtcbiIsIi8vIFNvbGlkSlMgU29ja2V0IFNlcnZpY2UgZm9yIFdlYlNTSDIgQ2xpZW50XG5pbXBvcnQgeyBjcmVhdGVTaWduYWwsIGNyZWF0ZUVmZmVjdCB9IGZyb20gJ3NvbGlkLWpzJ1xuaW1wb3J0IHR5cGUgeyBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuaW1wb3J0IHsgaW8gfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuaW1wb3J0IGNyZWF0ZURlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IG1hc2tPYmplY3QgZnJvbSAnanNtYXNrZXInXG5cbi8vIEltcG9ydCBzdGF0ZSBtYW5hZ2VtZW50XG5pbXBvcnQge1xuICBzdGF0ZSxcbiAgc2V0U3RhdGUsXG4gIHNldEVycm9yTWVzc2FnZSxcbiAgLy8gc2V0SXNMb2dpbkRpYWxvZ09wZW4sXG4gIHNldElzRXJyb3JEaWFsb2dPcGVuLFxuICBzZXRTZXNzaW9uRm9vdGVyLFxuICBzZXRIZWFkZXJDb250ZW50LFxuICBzZXRQcm9tcHREYXRhXG59IGZyb20gJy4uL3N0YXRlLXNvbGlkLmpzJ1xuXG4vLyBJbXBvcnQgdXRpbGl0aWVzXG5pbXBvcnQgeyBnZXRDcmVkZW50aWFscyB9IGZyb20gJy4uL3V0aWxzLmpzJ1xuXG4vLyBJbXBvcnQgdHlwZXNcbmltcG9ydCB0eXBlIHtcbiAgQ2xpZW50QXV0aGVudGljYXRlUGF5bG9hZCxcbiAgQ2xpZW50UmVzaXplUGF5bG9hZCxcbiAgQ2xpZW50VG9TZXJ2ZXJFdmVudHMsXG4gIFNlcnZlclRvQ2xpZW50RXZlbnRzLFxuICBQZXJtaXNzaW9uc1BheWxvYWRcbn0gZnJvbSAnLi4vLi4vdHlwZXMvZXZlbnRzLmQnXG5pbXBvcnQgdHlwZSB7IFdlYlNTSDJDb25maWcgfSBmcm9tICcuLi8uLi90eXBlcy9jb25maWcuZCdcbi8vIGltcG9ydCB0eXBlIHsgRWxlbWVudElkIH0gZnJvbSAnLi4vLi4vdHlwZXMvZG9tLmQnXG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ3dlYnNzaDItY2xpZW50OnNvY2tldC1zZXJ2aWNlJylcblxuLy8gU29ja2V0IGluc3RhbmNlIGFuZCByZWFjdGl2ZSBzdGF0ZVxuZXhwb3J0IGNvbnN0IFtzb2NrZXQsIHNldFNvY2tldF0gPSBjcmVhdGVTaWduYWw8U29ja2V0PFxuICBTZXJ2ZXJUb0NsaWVudEV2ZW50cyxcbiAgQ2xpZW50VG9TZXJ2ZXJFdmVudHNcbj4gfCBudWxsPihudWxsKVxuZXhwb3J0IGNvbnN0IFtpc0Nvbm5lY3RlZCwgc2V0SXNDb25uZWN0ZWRdID0gY3JlYXRlU2lnbmFsKGZhbHNlKVxuZXhwb3J0IGNvbnN0IFtjb25uZWN0aW9uU3RhdHVzLCBzZXRDb25uZWN0aW9uU3RhdHVzXSA9XG4gIGNyZWF0ZVNpZ25hbDxzdHJpbmc+KCdEaXNjb25uZWN0ZWQnKVxuZXhwb3J0IGNvbnN0IFtjb25uZWN0aW9uU3RhdHVzQ29sb3IsIHNldENvbm5lY3Rpb25TdGF0dXNDb2xvcl0gPVxuICBjcmVhdGVTaWduYWw8c3RyaW5nPigncmVkJylcblxuLy8gQ29uZmlndXJhdGlvbiBhbmQgY2FsbGJhY2tzXG5sZXQgY29uZmlnOiBXZWJTU0gyQ29uZmlnIHwgbnVsbCA9IG51bGxcbmxldCB3cml0ZVRvVGVybWluYWw6ICgoZGF0YTogc3RyaW5nKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsXG5sZXQgb25Db25uZWN0Q2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsXG5sZXQgb25EaXNjb25uZWN0Q2FsbGJhY2s6ICgocmVhc29uOiBzdHJpbmcsIGV4dHJhPzogdW5rbm93bikgPT4gdm9pZCkgfCBudWxsID1cbiAgbnVsbFxubGV0IG9uRGF0YUNhbGxiYWNrOiAoKGNodW5rOiBzdHJpbmcpID0+IHZvaWQpIHwgbnVsbCA9IG51bGxcbmxldCBmb2N1c1Rlcm1pbmFsQ2FsbGJhY2s6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsXG5sZXQgc3RvcmVkRm9ybURhdGE6IFBhcnRpYWw8Q2xpZW50QXV0aGVudGljYXRlUGF5bG9hZD4gfCBudWxsID0gbnVsbFxuXG4vLyBUZXJtaW5hbCBkaW1lbnNpb25zIHNpZ25hbCBmb3IgcmVhY3RpdmUgcmVzaXppbmdcbmV4cG9ydCBjb25zdCBbdGVybWluYWxEaW1lbnNpb25zLCBzZXRUZXJtaW5hbERpbWVuc2lvbnNdID0gY3JlYXRlU2lnbmFsPHtcbiAgY29sczogbnVtYmVyXG4gIHJvd3M6IG51bWJlclxufT4oeyBjb2xzOiA4MCwgcm93czogMjQgfSlcblxuLy8gU29ja2V0IFNlcnZpY2UgQ2xhc3NcbmV4cG9ydCBjbGFzcyBTb2NrZXRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBjbGVhbnVwRnVuY3Rpb25zOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdXG5cbiAgLy8gUmVhY3RpdmUgZWZmZWN0cyB3aWxsIGJlIHNldCB1cCB3aGVuIHRoZSBzZXJ2aWNlIGlzIGluaXRpYWxpemVkIHdpdGhpbiBhIGNvbXBvbmVudFxuXG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBmcm9tIHdpdGhpbiBhIFNvbGlkSlMgY29tcG9uZW50XG4gIHNldHVwUmVhY3RpdmVFZmZlY3RzKCkge1xuICAgIC8vIEF1dG8tZW1pdCByZXNpemUgd2hlbiB0ZXJtaW5hbCBkaW1lbnNpb25zIGNoYW5nZVxuICAgIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBkaW1zID0gdGVybWluYWxEaW1lbnNpb25zKClcbiAgICAgIGNvbnN0IGN1cnJlbnRTb2NrZXQgPSBzb2NrZXQoKVxuICAgICAgaWYgKGN1cnJlbnRTb2NrZXQgJiYgaXNDb25uZWN0ZWQoKSAmJiBkaW1zLmNvbHMgPiAwICYmIGRpbXMucm93cyA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0UmVzaXplKGRpbXMpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFVwZGF0ZSBVSSBlbGVtZW50cyByZWFjdGl2ZWx5XG4gICAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGNvbm5lY3Rpb25TdGF0dXMoKVxuICAgICAgY29uc3QgY29sb3IgPSBjb25uZWN0aW9uU3RhdHVzQ29sb3IoKVxuICAgICAgdGhpcy51cGRhdGVTdGF0dXNFbGVtZW50KHN0YXR1cywgY29sb3IpXG4gICAgfSlcblxuICAgIC8vIFN0b3JlIGNsZWFudXAgZnVuY3Rpb25zIGlmIG5lZWRlZFxuICAgIC8vIE5vdGU6IFNvbGlkSlMgYXV0b21hdGljYWxseSBoYW5kbGVzIGNsZWFudXAgd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzXG4gIH1cblxuICAvLyBJbml0aWFsaXplIHNvY2tldCB3aXRoIGNvbmZpZ3VyYXRpb25cbiAgaW5pdFNvY2tldChcbiAgICBjb25maWdPYmo6IFdlYlNTSDJDb25maWcsXG4gICAgY29ubmVjdENhbGxiYWNrOiAoKSA9PiB2b2lkLFxuICAgIGRpc2Nvbm5lY3RDYWxsYmFjazogKHJlYXNvbjogc3RyaW5nLCBleHRyYT86IHVua25vd24pID0+IHZvaWQsXG4gICAgZGF0YUNhbGxiYWNrOiAoY2h1bms6IHN0cmluZykgPT4gdm9pZCxcbiAgICB3cml0ZUZ1bmN0aW9uOiAoZGF0YTogc3RyaW5nKSA9PiB2b2lkLFxuICAgIGZvY3VzQ2FsbGJhY2s6ICgpID0+IHZvaWRcbiAgKTogdm9pZCB7XG4gICAgY29uZmlnID0gY29uZmlnT2JqXG4gICAgb25Db25uZWN0Q2FsbGJhY2sgPSBjb25uZWN0Q2FsbGJhY2tcbiAgICBvbkRpc2Nvbm5lY3RDYWxsYmFjayA9IGRpc2Nvbm5lY3RDYWxsYmFja1xuICAgIG9uRGF0YUNhbGxiYWNrID0gZGF0YUNhbGxiYWNrXG4gICAgd3JpdGVUb1Rlcm1pbmFsID0gd3JpdGVGdW5jdGlvblxuICAgIGZvY3VzVGVybWluYWxDYWxsYmFjayA9IGZvY3VzQ2FsbGJhY2tcbiAgICBkZWJ1ZygnU29ja2V0IHNlcnZpY2UgaW5pdGlhbGl6ZWQnKVxuICB9XG5cbiAgLy8gU2V0IGZvcm0gZGF0YSBmb3IgYXV0aGVudGljYXRpb25cbiAgc2V0Rm9ybURhdGEoZm9ybURhdGE6IFBhcnRpYWw8Q2xpZW50QXV0aGVudGljYXRlUGF5bG9hZD4pOiB2b2lkIHtcbiAgICBzdG9yZWRGb3JtRGF0YSA9IGZvcm1EYXRhXG4gICAgZGVidWcoJ0Zvcm0gZGF0YSBzdG9yZWQnLCB7IHBvcnQ6IGZvcm1EYXRhLnBvcnQgfSlcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgc29ja2V0IGNvbm5lY3Rpb25cbiAgaW5pdGlhbGl6ZVNvY2tldENvbm5lY3Rpb24oKTogU29ja2V0PFxuICAgIFNlcnZlclRvQ2xpZW50RXZlbnRzLFxuICAgIENsaWVudFRvU2VydmVyRXZlbnRzXG4gID4ge1xuICAgIGRlYnVnKCdJbml0aWFsaXppbmcgc29ja2V0IGNvbm5lY3Rpb24nKVxuICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uKClcblxuICAgIGNvbnN0IG5ld1NvY2tldCA9IGlvKHRoaXMuZ2V0V2ViU29ja2V0VXJsKCksIHtcbiAgICAgIHBhdGg6IHRoaXMuZ2V0U29ja2V0SU9QYXRoKCksXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gICAgICByZWNvbm5lY3Rpb246IGZhbHNlLFxuICAgICAgdGltZW91dDogMjAwMDAsXG4gICAgICB0cmFuc3BvcnRzOiBbJ3dlYnNvY2tldCcsICdwb2xsaW5nJ11cbiAgICB9KSBhcyBTb2NrZXQ8U2VydmVyVG9DbGllbnRFdmVudHMsIENsaWVudFRvU2VydmVyRXZlbnRzPlxuXG4gICAgc2V0U29ja2V0KG5ld1NvY2tldClcbiAgICB0aGlzLnNldHVwU29ja2V0TGlzdGVuZXJzKG5ld1NvY2tldClcbiAgICByZXR1cm4gbmV3U29ja2V0XG4gIH1cblxuICAvLyBDbG9zZSBjb25uZWN0aW9uXG4gIGNsb3NlQ29ubmVjdGlvbigpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50U29ja2V0ID0gc29ja2V0KClcbiAgICBpZiAoY3VycmVudFNvY2tldCkge1xuICAgICAgZGVidWcoJ0Nsb3NpbmcgY29ubmVjdGlvbicpXG4gICAgICBjdXJyZW50U29ja2V0LmNsb3NlKClcbiAgICAgIHNldFNvY2tldChudWxsKVxuICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgLy8gRW1pdCBkYXRhIHRvIHNlcnZlclxuICBlbWl0RGF0YShkYXRhOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50U29ja2V0ID0gc29ja2V0KClcbiAgICBpZiAoY3VycmVudFNvY2tldCkge1xuICAgICAgY3VycmVudFNvY2tldC5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB9XG4gIH1cblxuICAvLyBFbWl0IHJlc2l6ZSBldmVudFxuICBlbWl0UmVzaXplKGRpbWVuc2lvbnM6IENsaWVudFJlc2l6ZVBheWxvYWQpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50U29ja2V0ID0gc29ja2V0KClcbiAgICBpZiAoY3VycmVudFNvY2tldCkge1xuICAgICAgY3VycmVudFNvY2tldC5lbWl0KCdyZXNpemUnLCBkaW1lbnNpb25zKVxuICAgICAgZGVidWcoJ1Jlc2l6ZSBlbWl0dGVkJywgZGltZW5zaW9ucylcbiAgICB9XG4gIH1cblxuICAvLyBSZWF1dGhlbnRpY2F0ZVxuICByZWF1dGgoKTogdm9pZCB7XG4gICAgaWYgKHN0YXRlLmFsbG93UmVhdXRoKSB7XG4gICAgICBjb25zdCBjdXJyZW50U29ja2V0ID0gc29ja2V0KClcbiAgICAgIGlmIChjdXJyZW50U29ja2V0KSB7XG4gICAgICAgIGRlYnVnKCdSZWF1dGhlbnRpY2F0aW5nJylcbiAgICAgICAgY3VycmVudFNvY2tldC5lbWl0KCdjb250cm9sJywgJ3JlYXV0aCcpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignUmVhdXRoZW50aWNhdGlvbiBub3QgcGVybWl0dGVkJylcbiAgICAgIHNldEVycm9yTWVzc2FnZSgnUmVhdXRoZW50aWNhdGlvbiBub3QgcGVybWl0dGVkJylcbiAgICAgIHNldElzRXJyb3JEaWFsb2dPcGVuKHRydWUpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVwbGF5IGNyZWRlbnRpYWxzXG4gIHJlcGxheUNyZWRlbnRpYWxzKCk6IHZvaWQge1xuICAgIGlmIChzdGF0ZS5hbGxvd1JlcGxheSkge1xuICAgICAgY29uc3QgY3VycmVudFNvY2tldCA9IHNvY2tldCgpXG4gICAgICBpZiAoY3VycmVudFNvY2tldCkge1xuICAgICAgICBkZWJ1ZygnUmVwbGF5aW5nIGNyZWRlbnRpYWxzJylcbiAgICAgICAgY3VycmVudFNvY2tldC5lbWl0KCdjb250cm9sJywgJ3JlcGxheUNyZWRlbnRpYWxzJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdDcmVkZW50aWFsIHJlcGxheSBub3QgcGVybWl0dGVkJylcbiAgICAgIHNldEVycm9yTWVzc2FnZSgnQ3JlZGVudGlhbCByZXBsYXkgbm90IHBlcm1pdHRlZCcpXG4gICAgICBzZXRJc0Vycm9yRGlhbG9nT3Blbih0cnVlKVxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBrZXlib2FyZC1pbnRlcmFjdGl2ZSBwcm9tcHQgcmVzcG9uc2VzXG4gIHN1Ym1pdFByb21wdFJlc3BvbnNlcyhyZXNwb25zZXM6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFNvY2tldCA9IHNvY2tldCgpXG4gICAgaWYgKGN1cnJlbnRTb2NrZXQpIHtcbiAgICAgIGRlYnVnKCdTdWJtaXR0aW5nIHByb21wdCByZXNwb25zZXMnLCByZXNwb25zZXMubGVuZ3RoKVxuICAgICAgY3VycmVudFNvY2tldC5lbWl0KCdkYXRhJywgcmVzcG9uc2VzLmpvaW4oJ1xcbicpKVxuICAgICAgc2V0UHJvbXB0RGF0YShudWxsKVxuICAgIH1cbiAgfVxuXG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuICBwcml2YXRlIGdldFNvY2tldElPUGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBjb25maWc/LnNvY2tldD8ucGF0aCB8fCAnL3NzaC9zb2NrZXQuaW8nXG4gIH1cblxuICBwcml2YXRlIGdldFdlYlNvY2tldFVybCgpOiBzdHJpbmcge1xuICAgIGlmIChjb25maWc/LnNvY2tldD8udXJsKSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGNvbmZpZy5zb2NrZXQudXJsKVxuICAgICAgdXJsLnByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICd3c3M6JyA6ICd3czonXG4gICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKClcbiAgICB9XG4gICAgY29uc3QgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonID8gJ3dzczonIDogJ3dzOidcbiAgICBjb25zdCBob3N0ID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lXG4gICAgY29uc3QgcG9ydCA9IHdpbmRvdy5sb2NhdGlvbi5wb3J0IHx8IChwcm90b2NvbCA9PT0gJ3dzczonID8gJzQ0MycgOiAnODAnKVxuICAgIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdH06JHtwb3J0fWBcbiAgfVxuXG4gIHByaXZhdGUgYXV0aGVudGljYXRlKFxuICAgIGZvcm1EYXRhOiBQYXJ0aWFsPENsaWVudEF1dGhlbnRpY2F0ZVBheWxvYWQ+IHwgbnVsbCA9IG51bGxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgZGltcyA9IHRlcm1pbmFsRGltZW5zaW9ucygpXG4gICAgY29uc3QgZWZmZWN0aXZlRm9ybURhdGEgPSBmb3JtRGF0YSB8fCBzdG9yZWRGb3JtRGF0YVxuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gZ2V0Q3JlZGVudGlhbHMoXG4gICAgICBlZmZlY3RpdmVGb3JtRGF0YSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IG51bGwsXG4gICAgICBkaW1zXG4gICAgKVxuXG4gICAgaWYgKGVmZmVjdGl2ZUZvcm1EYXRhPy5wcml2YXRlS2V5KSB7XG4gICAgICBjcmVkZW50aWFscy5wcml2YXRlS2V5ID0gZWZmZWN0aXZlRm9ybURhdGEucHJpdmF0ZUtleVxuICAgICAgaWYgKGVmZmVjdGl2ZUZvcm1EYXRhLnBhc3NwaHJhc2UpIHtcbiAgICAgICAgY3JlZGVudGlhbHMucGFzc3BocmFzZSA9IGVmZmVjdGl2ZUZvcm1EYXRhLnBhc3NwaHJhc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRTdGF0ZSgndGVybScsIGNyZWRlbnRpYWxzLnRlcm0gPz8gbnVsbClcbiAgICBjb25zdCBtYXNrZWRDb250ZW50ID0gbWFza09iamVjdChjcmVkZW50aWFscylcbiAgICBkZWJ1ZygnQXV0aGVudGljYXRpbmcnLCBtYXNrZWRDb250ZW50KVxuXG4gICAgY29uc3QgY3VycmVudFNvY2tldCA9IHNvY2tldCgpXG4gICAgaWYgKGNyZWRlbnRpYWxzLmhvc3QgJiYgY3JlZGVudGlhbHMudXNlcm5hbWUgJiYgY3VycmVudFNvY2tldCkge1xuICAgICAgY3VycmVudFNvY2tldC5lbWl0KCdhdXRoZW50aWNhdGUnLCBjcmVkZW50aWFscylcbiAgICAgIHNldENvbm5lY3Rpb25TdGF0dXMoJ0F1dGhlbnRpY2F0aW5nLi4uJylcbiAgICAgIHNldENvbm5lY3Rpb25TdGF0dXNDb2xvcignb3JhbmdlJylcbiAgICB9IGVsc2UgaWYgKG9uRGlzY29ubmVjdENhbGxiYWNrKSB7XG4gICAgICBvbkRpc2Nvbm5lY3RDYWxsYmFjaygnYXV0aF9yZXF1aXJlZCcpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRUZXJtaW5hbCgpOiB2b2lkIHtcbiAgICBjb25zdCBkaW1zID0gdGVybWluYWxEaW1lbnNpb25zKClcbiAgICBjb25zdCB0ZXJtID0gc3RhdGUudGVybSA/PyAneHRlcm0tY29sb3InXG4gICAgY29uc3QgdGVybWluYWwgPSB7IGNvbHM6IGRpbXMuY29scyA/PyAwLCByb3dzOiBkaW1zLnJvd3MgPz8gMCwgdGVybSB9XG4gICAgZGVidWcoJ0dldHRpbmcgdGVybWluYWwnLCB0ZXJtaW5hbClcbiAgICBjb25zdCBjdXJyZW50U29ja2V0ID0gc29ja2V0KClcbiAgICBpZiAoY3VycmVudFNvY2tldCkgY3VycmVudFNvY2tldC5lbWl0KCd0ZXJtaW5hbCcsIHRlcm1pbmFsKVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVTdGF0dXNFbGVtZW50KHN0YXR1czogc3RyaW5nLCBjb2xvcjogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gVXNlIHJlYWN0aXZlIHN0YXRlIGluc3RlYWQgb2YgZGlyZWN0IERPTSBtYW5pcHVsYXRpb25cbiAgICBzZXRDb25uZWN0aW9uU3RhdHVzKHN0YXR1cylcbiAgICBzZXRDb25uZWN0aW9uU3RhdHVzQ29sb3IoY29sb3IpXG4gIH1cblxuICAvLyBTb2NrZXQgZXZlbnQgaGFuZGxlcnNcbiAgcHJpdmF0ZSBzZXR1cFNvY2tldExpc3RlbmVycyhcbiAgICBzb2NrZXRJbnN0YW5jZTogU29ja2V0PFNlcnZlclRvQ2xpZW50RXZlbnRzLCBDbGllbnRUb1NlcnZlckV2ZW50cz5cbiAgKTogdm9pZCB7XG4gICAgZGVidWcoJ1NldHRpbmcgdXAgc29ja2V0IGxpc3RlbmVycycpXG5cbiAgICAvLyBBdXRoZW50aWNhdGlvbiBldmVudHNcbiAgICBzb2NrZXRJbnN0YW5jZS5vbignYXV0aGVudGljYXRpb24nLCAoZGF0YSkgPT4ge1xuICAgICAgZGVidWcoJ0F1dGhlbnRpY2F0aW9uIGV2ZW50JywgZGF0YSlcbiAgICAgIHN3aXRjaCAoZGF0YS5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSAncmVxdWVzdF9hdXRoJzpcbiAgICAgICAgICB0aGlzLmF1dGhlbnRpY2F0ZSgpXG4gICAgICAgICAgc2V0Q29ubmVjdGlvblN0YXR1cygnUmVxdWVzdGluZyBhdXRoZW50aWNhdGlvbi4uLicpXG4gICAgICAgICAgc2V0Q29ubmVjdGlvblN0YXR1c0NvbG9yKCdvcmFuZ2UnKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2F1dGhfcmVzdWx0JzpcbiAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhSZXN1bHQoe1xuICAgICAgICAgICAgc3VjY2VzczogQm9vbGVhbihkYXRhLnN1Y2Nlc3MpLFxuICAgICAgICAgICAgLi4uKGRhdGEubWVzc2FnZSAmJiB7IG1lc3NhZ2U6IGRhdGEubWVzc2FnZSB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAna2V5Ym9hcmQtaW50ZXJhY3RpdmUnOlxuICAgICAgICAgIGlmICgncHJvbXB0cycgaW4gZGF0YSAmJiBkYXRhLnByb21wdHMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlS2V5Ym9hcmRJbnRlcmFjdGl2ZSh7XG4gICAgICAgICAgICAgIHByb21wdHM6IGRhdGEucHJvbXB0cyBhcyBBcnJheTx7IHByb21wdDogc3RyaW5nOyBlY2hvOiBib29sZWFuIH0+LFxuICAgICAgICAgICAgICAuLi4oJ25hbWUnIGluIGRhdGEgJiYgZGF0YS5uYW1lXG4gICAgICAgICAgICAgICAgPyB7IG5hbWU6IGRhdGEubmFtZSBhcyBzdHJpbmcgfVxuICAgICAgICAgICAgICAgIDoge30pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdyZWF1dGgnOlxuICAgICAgICAgIGlmIChvbkRpc2Nvbm5lY3RDYWxsYmFjaylcbiAgICAgICAgICAgIG9uRGlzY29ubmVjdENhbGxiYWNrKCdyZWF1dGhfcmVxdWlyZWQnLCBzb2NrZXRJbnN0YW5jZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdkaW1lbnNpb25zJzpcbiAgICAgICAgICB0aGlzLmVtaXRSZXNpemUodGVybWluYWxEaW1lbnNpb25zKCkpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkZWJ1ZyhgVW5oYW5kbGVkIGF1dGhlbnRpY2F0aW9uIGFjdGlvbjogJHtkYXRhLmFjdGlvbn1gKVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFBlcm1pc3Npb25zIGV2ZW50XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ3Blcm1pc3Npb25zJywgKHBheWxvYWQ6IFBlcm1pc3Npb25zUGF5bG9hZCkgPT4ge1xuICAgICAgZGVidWcoJ1Blcm1pc3Npb25zJywgcGF5bG9hZClcbiAgICAgIE9iamVjdC5lbnRyaWVzKHBheWxvYWQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ2FsbG93UmVhdXRoJzoge1xuICAgICAgICAgICAgc2V0U3RhdGUoJ2FsbG93UmVhdXRoJywgQm9vbGVhbih2YWx1ZSkpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdhbGxvd1JlY29ubmVjdCc6IHtcbiAgICAgICAgICAgIHNldFN0YXRlKCdhbGxvd1JlY29ubmVjdCcsIEJvb2xlYW4odmFsdWUpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnYWxsb3dSZXBsYXknOiB7XG4gICAgICAgICAgICBzZXRTdGF0ZSgnYWxsb3dSZXBsYXknLCBCb29sZWFuKHZhbHVlKSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGRlYnVnKGBVbmhhbmRsZWQgcGVybWlzc2lvbiBrZXk6ICR7a2V5fWApXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgLy8gVGVybWluYWwgZXZlbnRzXG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2dldFRlcm1pbmFsJywgKCkgPT4gdGhpcy5nZXRUZXJtaW5hbCgpKVxuICAgIHNvY2tldEluc3RhbmNlLm9uKCdkYXRhJywgKGNodW5rOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICh3cml0ZVRvVGVybWluYWwpIHdyaXRlVG9UZXJtaW5hbChjaHVuaylcbiAgICAgIGlmIChvbkRhdGFDYWxsYmFjaykgb25EYXRhQ2FsbGJhY2soY2h1bmspXG4gICAgfSlcblxuICAgIC8vIEVycm9yIGV2ZW50c1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdzc2hlcnJvcicsIChtc2c6IHN0cmluZykgPT4ge1xuICAgICAgZGVidWcoJ1NTSCBFcnJvcicsIG1zZylcbiAgICAgIGlmIChvbkRpc2Nvbm5lY3RDYWxsYmFjaykgb25EaXNjb25uZWN0Q2FsbGJhY2soJ3NzaF9lcnJvcicsIG1zZylcbiAgICB9KVxuXG4gICAgLy8gQ29ubmVjdGlvbiBldmVudHNcbiAgICBzb2NrZXRJbnN0YW5jZS5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGRlYnVnKCdDb25uZWN0ZWQgdG8gc2VydmVyJylcbiAgICAgIHNldFN0YXRlKCdpc0Nvbm5lY3RpbmcnLCBmYWxzZSlcbiAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpXG4gICAgICBzZXRDb25uZWN0aW9uU3RhdHVzKCdDb25uZWN0ZWQnKVxuICAgICAgc2V0Q29ubmVjdGlvblN0YXR1c0NvbG9yKCdncmVlbicpXG4gICAgICBpZiAob25Db25uZWN0Q2FsbGJhY2spIG9uQ29ubmVjdENhbGxiYWNrKClcbiAgICB9KVxuXG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgIGRlYnVnKCdDb25uZWN0aW9uIGVycm9yJywgZXJyb3IpXG4gICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSlcbiAgICAgIGlmIChvbkRpc2Nvbm5lY3RDYWxsYmFjaykgb25EaXNjb25uZWN0Q2FsbGJhY2soJ2Nvbm5lY3RfZXJyb3InLCBlcnJvcilcbiAgICB9KVxuXG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Rpc2Nvbm5lY3QnLCAocmVhc29uKSA9PiB7XG4gICAgICBkZWJ1ZygnRGlzY29ubmVjdGVkJywgcmVhc29uKVxuICAgICAgc2V0U3RhdGUoJ2lzQ29ubmVjdGluZycsIGZhbHNlKVxuICAgICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpXG4gICAgICBzZXRDb25uZWN0aW9uU3RhdHVzKGBXRUJTT0NLRVQgU0VSVkVSIERJU0NPTk5FQ1RFRDogJHtyZWFzb259YClcbiAgICAgIHNldENvbm5lY3Rpb25TdGF0dXNDb2xvcigncmVkJylcbiAgICAgIGlmIChvbkRpc2Nvbm5lY3RDYWxsYmFjaykgb25EaXNjb25uZWN0Q2FsbGJhY2socmVhc29uKVxuICAgIH0pXG5cbiAgICAvLyBVSSB1cGRhdGUgZXZlbnRzXG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ3VwZGF0ZVVJJywgKGRhdGEpID0+IHtcbiAgICAgIGRlYnVnKCdVSSBVcGRhdGUnLCBkYXRhKVxuICAgICAgY29uc3QgeyBlbGVtZW50LCB2YWx1ZSB9ID0gZGF0YVxuICAgICAgaWYgKCFlbGVtZW50IHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICd1cGRhdGVVSTogUmVjZWl2ZWQgaW52YWxpZCBkYXRhIGZyb20gdXBkYXRlVUkgZXZlbnQ6JyxcbiAgICAgICAgICBkYXRhXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBVSSB1cGRhdGVzIGJ5IHVwZGF0aW5nIHRoZSBhcHByb3ByaWF0ZSBTb2xpZEpTIHNpZ25hbHNcbiAgICAgIHN3aXRjaCAoZWxlbWVudCkge1xuICAgICAgICBjYXNlICdmb290ZXInOiB7XG4gICAgICAgICAgY29uc3QgZm9vdGVyVmFsdWUgPVxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAndGV4dCcgaW4gdmFsdWVcbiAgICAgICAgICAgICAgPyAodmFsdWUgYXMgeyB0ZXh0OiBzdHJpbmcgfSkudGV4dFxuICAgICAgICAgICAgICA6IFN0cmluZyh2YWx1ZSlcbiAgICAgICAgICBzZXRTZXNzaW9uRm9vdGVyKGZvb3RlclZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3RhdHVzJzpcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1c0VsZW1lbnQoU3RyaW5nKHZhbHVlKSwgJ2dyZWVuJylcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgICAgIC8vIFVzZSByZWFjdGl2ZSBoZWFkZXIgc3RhdGVcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyRGF0YSA9IHZhbHVlIGFzIHsgdGV4dDogc3RyaW5nOyBiYWNrZ3JvdW5kPzogc3RyaW5nIH1cbiAgICAgICAgICAgIHNldEhlYWRlckNvbnRlbnQoe1xuICAgICAgICAgICAgICB0ZXh0OiBoZWFkZXJEYXRhLnRleHQsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IGhlYWRlckRhdGEuYmFja2dyb3VuZCB8fCAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRIZWFkZXJDb250ZW50KHtcbiAgICAgICAgICAgICAgdGV4dDogU3RyaW5nKHZhbHVlKSxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50J1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBVbmtub3duIGVsZW1lbnRzIC0gbG9nIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICBkZWJ1ZyhgVW5rbm93biBlbGVtZW50IHVwZGF0ZTogJHtlbGVtZW50fWAsIHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQXV0aFJlc3VsdChyZXN1bHQ6IHtcbiAgICBzdWNjZXNzOiBib29sZWFuXG4gICAgbWVzc2FnZT86IHN0cmluZ1xuICB9KTogdm9pZCB7XG4gICAgZGVidWcoJ0F1dGggcmVzdWx0JywgcmVzdWx0KVxuICAgIHNldFN0YXRlKCdpc0Nvbm5lY3RpbmcnLCBmYWxzZSlcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHNldENvbm5lY3Rpb25TdGF0dXMoJ0Nvbm5lY3RlZCcpXG4gICAgICBzZXRDb25uZWN0aW9uU3RhdHVzQ29sb3IoJ2dyZWVuJylcbiAgICAgIGlmIChmb2N1c1Rlcm1pbmFsQ2FsbGJhY2spIGZvY3VzVGVybWluYWxDYWxsYmFjaygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldENvbm5lY3Rpb25TdGF0dXMoYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHtyZXN1bHQubWVzc2FnZSA/PyAnJ31gKVxuICAgICAgc2V0Q29ubmVjdGlvblN0YXR1c0NvbG9yKCdyZWQnKVxuICAgICAgaWYgKG9uRGlzY29ubmVjdENhbGxiYWNrKVxuICAgICAgICBvbkRpc2Nvbm5lY3RDYWxsYmFjaygnYXV0aF9mYWlsZWQnLCByZXN1bHQubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUtleWJvYXJkSW50ZXJhY3RpdmUoZGF0YToge1xuICAgIHByb21wdHM6IEFycmF5PHsgcHJvbXB0OiBzdHJpbmc7IGVjaG86IGJvb2xlYW4gfT5cbiAgICBuYW1lPzogc3RyaW5nXG4gIH0pOiB2b2lkIHtcbiAgICBkZWJ1ZygnS2V5Ym9hcmQgaW50ZXJhY3RpdmUgYXV0aGVudGljYXRpb24nLCBkYXRhKVxuICAgIC8vIFVzZSB0aGUgcmVhY3RpdmUgcHJvbXB0IG1vZGFsXG4gICAgc2V0UHJvbXB0RGF0YSh7XG4gICAgICB0aXRsZTogZGF0YS5uYW1lIHx8ICdBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcsXG4gICAgICBwcm9tcHRzOiBkYXRhLnByb21wdHNcbiAgICB9KVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBzb2NrZXRTZXJ2aWNlID0gbmV3IFNvY2tldFNlcnZpY2UoKVxuXG4vLyBFeHBvcnQgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbXBhdGliaWxpdHlcbmV4cG9ydCBjb25zdCBzZXRGb3JtRGF0YSA9IChmb3JtRGF0YTogUGFydGlhbDxDbGllbnRBdXRoZW50aWNhdGVQYXlsb2FkPikgPT5cbiAgc29ja2V0U2VydmljZS5zZXRGb3JtRGF0YShmb3JtRGF0YSlcbmV4cG9ydCBjb25zdCBjbG9zZUNvbm5lY3Rpb24gPSAoKSA9PiBzb2NrZXRTZXJ2aWNlLmNsb3NlQ29ubmVjdGlvbigpXG5leHBvcnQgY29uc3QgZW1pdERhdGEgPSAoZGF0YTogc3RyaW5nKSA9PiBzb2NrZXRTZXJ2aWNlLmVtaXREYXRhKGRhdGEpXG5leHBvcnQgY29uc3QgZW1pdFJlc2l6ZSA9IChkaW1lbnNpb25zOiBDbGllbnRSZXNpemVQYXlsb2FkKSA9PlxuICBzb2NrZXRTZXJ2aWNlLmVtaXRSZXNpemUoZGltZW5zaW9ucylcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplU29ja2V0Q29ubmVjdGlvbiA9ICgpID0+XG4gIHNvY2tldFNlcnZpY2UuaW5pdGlhbGl6ZVNvY2tldENvbm5lY3Rpb24oKVxuZXhwb3J0IGNvbnN0IGluaXRTb2NrZXQgPSAoXG4gIGNvbmZpZ09iajogV2ViU1NIMkNvbmZpZyxcbiAgY29ubmVjdENhbGxiYWNrOiAoKSA9PiB2b2lkLFxuICBkaXNjb25uZWN0Q2FsbGJhY2s6IChyZWFzb246IHN0cmluZywgZXh0cmE/OiB1bmtub3duKSA9PiB2b2lkLFxuICBkYXRhQ2FsbGJhY2s6IChjaHVuazogc3RyaW5nKSA9PiB2b2lkLFxuICB3cml0ZUZ1bmN0aW9uOiAoZGF0YTogc3RyaW5nKSA9PiB2b2lkLFxuICBmb2N1c0NhbGxiYWNrOiAoKSA9PiB2b2lkXG4pID0+XG4gIHNvY2tldFNlcnZpY2UuaW5pdFNvY2tldChcbiAgICBjb25maWdPYmosXG4gICAgY29ubmVjdENhbGxiYWNrLFxuICAgIGRpc2Nvbm5lY3RDYWxsYmFjayxcbiAgICBkYXRhQ2FsbGJhY2ssXG4gICAgd3JpdGVGdW5jdGlvbixcbiAgICBmb2N1c0NhbGxiYWNrXG4gIClcbmV4cG9ydCBjb25zdCByZWF1dGggPSAoKSA9PiBzb2NrZXRTZXJ2aWNlLnJlYXV0aCgpXG5leHBvcnQgY29uc3QgcmVwbGF5Q3JlZGVudGlhbHMgPSAoKSA9PiBzb2NrZXRTZXJ2aWNlLnJlcGxheUNyZWRlbnRpYWxzKClcbmV4cG9ydCBjb25zdCBzdWJtaXRQcm9tcHRSZXNwb25zZXMgPSAocmVzcG9uc2VzOiBzdHJpbmdbXSkgPT5cbiAgc29ja2V0U2VydmljZS5zdWJtaXRQcm9tcHRSZXNwb25zZXMocmVzcG9uc2VzKVxuIiwiLy8gY2xpZW50XG4vLyBjbGllbnQvc3JjL2pzL3NldHRpbmdzLnRzXG5cbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tICdkZWJ1ZydcblxuY29uc3QgZGVidWcgPSBjcmVhdGVEZWJ1Zygnd2Vic3NoMi1jbGllbnQ6c2V0dGluZ3MnKVxuXG5jb25zdCBTVE9SQUdFX0tFWSA9ICd3ZWJzc2gyLnNldHRpbmdzLmdsb2JhbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVTZXR0aW5ncygpOiB2b2lkIHtcbiAgaWYgKCFsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSkpIHtcbiAgICBzYXZlVGVybWluYWxTZXR0aW5ncyh7fSlcbiAgICBkZWJ1ZygnaW5pdGlhbGl6ZVNldHRpbmdzOiBJbml0aWFsaXplZCBlbXB0eSBzZXR0aW5ncyBpbiBsb2NhbFN0b3JhZ2UnKVxuICB9XG4gIGRlYnVnKCdpbml0aWFsaXplU2V0dGluZ3MnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVkU2V0dGluZ3MoKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSlcbiAgaWYgKHJhdykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHJhdykgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgIGRlYnVnKCdnZXRTdG9yZWRTZXR0aW5ncycsIHBhcnNlZClcbiAgICAgIHJldHVybiBwYXJzZWRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignZ2V0U3RvcmVkU2V0dGluZ3M6IEVycm9yIHBhcnNpbmcgc3RvcmVkIHNldHRpbmdzOicsIGVycm9yKVxuICAgIH1cbiAgfVxuICByZXR1cm4ge31cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVUZXJtaW5hbFNldHRpbmdzKHNldHRpbmdzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHZvaWQge1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpXG4gICAgZGVidWcoJ3NhdmVUZXJtaW5hbFNldHRpbmdzJywgc2V0dGluZ3MpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignc2F2ZVRlcm1pbmFsU2V0dGluZ3MnLCBlcnJvcilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0TG9jYWxUZXJtaW5hbFNldHRpbmdzID0gZ2V0U3RvcmVkU2V0dGluZ3NcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3RvcmVkU2V0dGluZ3MoKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICBkZWJ1ZygnYXBwbHlTdG9yZWRTZXR0aW5ncyBjYWxsZWQnKVxuICByZXR1cm4gZ2V0U3RvcmVkU2V0dGluZ3MoKVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVTaWduYWwsIGNyZWF0ZUVmZmVjdCwgb25Nb3VudCwgb25DbGVhbnVwIH0gZnJvbSAnc29saWQtanMnXG5pbXBvcnQgeyBGaXRBZGRvbiB9IGZyb20gJ0B4dGVybS9hZGRvbi1maXQnXG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSAnZGVidWcnXG5cbi8vIEltcG9ydCB0aGUgY3VzdG9tIHNvbGlkLXh0ZXJtIHdyYXBwZXJcbmltcG9ydCB7IFhUZXJtIH0gZnJvbSAnLi4veHRlcm0tc29saWQvY29tcG9uZW50cy9YVGVybSdcbmltcG9ydCB0eXBlIHsgVGVybWluYWxSZWYsIFhUZXJtUHJvcHMgfSBmcm9tICcuLi94dGVybS1zb2xpZC90eXBlcydcbmltcG9ydCB0eXBlIHsgVGVybWluYWwsIElUZXJtaW5hbE9wdGlvbnMgfSBmcm9tICdAeHRlcm0veHRlcm0nXG5cbi8vIEltcG9ydCBleGlzdGluZyBmdW5jdGlvbmFsaXR5XG5pbXBvcnQgeyB2YWxpZGF0ZU51bWJlciwgZGVmYXVsdFNldHRpbmdzIH0gZnJvbSAnLi4vdXRpbHMuanMnXG5pbXBvcnQgeyBlbWl0RGF0YSwgZW1pdFJlc2l6ZSB9IGZyb20gJy4uL3NlcnZpY2VzL3NvY2tldC1zZXJ2aWNlLmpzJ1xuaW1wb3J0IHsgZ2V0U3RvcmVkU2V0dGluZ3MgfSBmcm9tICcuLi9zZXR0aW5ncy5qcydcbmltcG9ydCB0eXBlIHsgV2ViU1NIMkNvbmZpZywgVGVybWluYWxTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3R5cGVzL2NvbmZpZy5kJ1xuXG5jb25zdCBkZWJ1ZyA9IGNyZWF0ZURlYnVnKCd3ZWJzc2gyLWNsaWVudDp0ZXJtaW5hbC1jb21wb25lbnQnKVxuXG5pbnRlcmZhY2UgVGVybWluYWxDb21wb25lbnRQcm9wcyB7XG4gIGNvbmZpZzogV2ViU1NIMkNvbmZpZ1xuICBvblRlcm1pbmFsUmVhZHk/OiAodGVybWluYWxSZWY6IFRlcm1pbmFsUmVmKSA9PiB2b2lkXG4gIGNsYXNzPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjb25zdCBUZXJtaW5hbENvbXBvbmVudDogQ29tcG9uZW50PFRlcm1pbmFsQ29tcG9uZW50UHJvcHM+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFt0ZXJtaW5hbFJlZiwgc2V0VGVybWluYWxSZWZdID0gY3JlYXRlU2lnbmFsPFRlcm1pbmFsUmVmPigpXG4gIGxldCBmaXRBZGRvbkluc3RhbmNlOiBGaXRBZGRvbiB8IG51bGwgPSBudWxsXG4gIFxuICAvLyBHZXQgdGVybWluYWwgc2V0dGluZ3MgYmFzZWQgb24gY29uZmlnXG4gIGNvbnN0IGdldFRlcm1pbmFsT3B0aW9ucyA9ICgpOiBQYXJ0aWFsPElUZXJtaW5hbE9wdGlvbnM+ID0+IHtcbiAgICBkZWJ1ZygnZ2V0VGVybWluYWxPcHRpb25zJylcbiAgICBjb25zdCBzdG9yZWRTZXR0aW5ncyA9IGdldFN0b3JlZFNldHRpbmdzKCkgYXMgUGFydGlhbDxUZXJtaW5hbFNldHRpbmdzPlxuICAgIGNvbnN0IHRlcm1pbmFsQ29uZmlnID0gKHByb3BzLmNvbmZpZz8udGVybWluYWwgPz8ge30pIGFzIFBhcnRpYWw8VGVybWluYWxTZXR0aW5ncz5cblxuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnM6IFBhcnRpYWw8SVRlcm1pbmFsT3B0aW9ucz4gPSB7XG4gICAgICBjdXJzb3JCbGluazogKHN0b3JlZFNldHRpbmdzLmN1cnNvckJsaW5rID8/XG4gICAgICAgIHRlcm1pbmFsQ29uZmlnLmN1cnNvckJsaW5rID8/XG4gICAgICAgIGRlZmF1bHRTZXR0aW5ncy5jdXJzb3JCbGluaykgYXMgYm9vbGVhbixcbiAgICAgIHNjcm9sbGJhY2s6IHZhbGlkYXRlTnVtYmVyKFxuICAgICAgICAoc3RvcmVkU2V0dGluZ3Muc2Nyb2xsYmFjayA/PyB0ZXJtaW5hbENvbmZpZy5zY3JvbGxiYWNrKSBhcyBudW1iZXIsXG4gICAgICAgIDEsXG4gICAgICAgIDIwMDAwMCxcbiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnNjcm9sbGJhY2tcbiAgICAgICksXG4gICAgICB0YWJTdG9wV2lkdGg6IHZhbGlkYXRlTnVtYmVyKFxuICAgICAgICAoc3RvcmVkU2V0dGluZ3MudGFiU3RvcFdpZHRoID8/IHRlcm1pbmFsQ29uZmlnLnRhYlN0b3BXaWR0aCkgYXMgbnVtYmVyLFxuICAgICAgICAxLFxuICAgICAgICAxMDAsXG4gICAgICAgIGRlZmF1bHRTZXR0aW5ncy50YWJTdG9wV2lkdGhcbiAgICAgICksXG4gICAgICBmb250U2l6ZTogdmFsaWRhdGVOdW1iZXIoXG4gICAgICAgIChzdG9yZWRTZXR0aW5ncy5mb250U2l6ZSA/PyB0ZXJtaW5hbENvbmZpZy5mb250U2l6ZSkgYXMgbnVtYmVyLFxuICAgICAgICAxLFxuICAgICAgICA3MixcbiAgICAgICAgZGVmYXVsdFNldHRpbmdzLmZvbnRTaXplXG4gICAgICApLFxuICAgICAgZm9udEZhbWlseTogU3RyaW5nKFxuICAgICAgICBzdG9yZWRTZXR0aW5ncy5mb250RmFtaWx5ID8/XG4gICAgICAgICAgdGVybWluYWxDb25maWcuZm9udEZhbWlseSA/P1xuICAgICAgICAgIGRlZmF1bHRTZXR0aW5ncy5mb250RmFtaWx5XG4gICAgICApLFxuICAgICAgbGV0dGVyU3BhY2luZzogKHN0b3JlZFNldHRpbmdzLmxldHRlclNwYWNpbmcgPz9cbiAgICAgICAgdGVybWluYWxDb25maWcubGV0dGVyU3BhY2luZyA/P1xuICAgICAgICBkZWZhdWx0U2V0dGluZ3MubGV0dGVyU3BhY2luZykgYXMgbnVtYmVyLFxuICAgICAgbGluZUhlaWdodDogKHN0b3JlZFNldHRpbmdzLmxpbmVIZWlnaHQgPz9cbiAgICAgICAgdGVybWluYWxDb25maWcubGluZUhlaWdodCA/P1xuICAgICAgICBkZWZhdWx0U2V0dGluZ3MubGluZUhlaWdodCkgYXMgbnVtYmVyXG4gICAgfVxuXG4gICAgZGVidWcoJ2dldFRlcm1pbmFsT3B0aW9ucycsIG1lcmdlZE9wdGlvbnMpXG4gICAgcmV0dXJuIG1lcmdlZE9wdGlvbnNcbiAgfVxuXG4gIC8vIEhhbmRsZSBkYXRhIGZyb20gdGVybWluYWwgKHNlbnQgdG8gc2VydmVyKVxuICBjb25zdCBoYW5kbGVUZXJtaW5hbERhdGEgPSAoZGF0YTogc3RyaW5nKSA9PiB7XG4gICAgZW1pdERhdGEoZGF0YSlcbiAgfVxuXG4gIC8vIEhhbmRsZSB0aXRsZSBjaGFuZ2VzXG4gIGNvbnN0IGhhbmRsZVRpdGxlQ2hhbmdlID0gKHRpdGxlOiBzdHJpbmcpID0+IHtcbiAgICBkb2N1bWVudC50aXRsZSA9IHRpdGxlXG4gIH1cblxuICAvLyBIYW5kbGUgdGVybWluYWwgbW91bnRcbiAgY29uc3QgaGFuZGxlVGVybWluYWxNb3VudCA9ICh0ZXJtaW5hbDogVGVybWluYWwsIHJlZjogVGVybWluYWxSZWYpID0+IHtcbiAgICBkZWJ1ZygnVGVybWluYWwgbW91bnRlZCcpXG4gICAgc2V0VGVybWluYWxSZWYocmVmKVxuICAgIFxuICAgIC8vIENyZWF0ZSBhbmQgbG9hZCBGaXRBZGRvbiBkaXJlY3RseSBmb3IgcmVsaWFibGUgYWNjZXNzXG4gICAgZml0QWRkb25JbnN0YW5jZSA9IG5ldyBGaXRBZGRvbigpXG4gICAgdGVybWluYWwubG9hZEFkZG9uKGZpdEFkZG9uSW5zdGFuY2UpXG4gICAgXG4gICAgLy8gRml0IHRlcm1pbmFsIGFmdGVyIG1vdW50IHdpdGggbXVsdGlwbGUgYXR0ZW1wdHMgZm9yIHByb3BlciBzaXppbmdcbiAgICBjb25zdCBmaXRUZXJtaW5hbCA9ICgpID0+IHtcbiAgICAgIGlmIChmaXRBZGRvbkluc3RhbmNlICYmIHJlZi50ZXJtaW5hbCkge1xuICAgICAgICBmaXRBZGRvbkluc3RhbmNlLmZpdCgpXG4gICAgICAgIGNvbnN0IGRpbXMgPSB7IGNvbHM6IHJlZi50ZXJtaW5hbC5jb2xzLCByb3dzOiByZWYudGVybWluYWwucm93cyB9XG4gICAgICAgIGRlYnVnKCdUZXJtaW5hbCBmaXR0ZWQsIGRpbWVuc2lvbnM6JywgZGltcy5jb2xzLCAneCcsIGRpbXMucm93cylcbiAgICAgICAgXG4gICAgICAgIC8vIE5vdGlmeSBwYXJlbnQgY29tcG9uZW50IGFib3V0IGRpbWVuc2lvbiBjaGFuZ2VzXG4gICAgICAgIGlmIChwcm9wcy5vblRlcm1pbmFsUmVhZHkpIHtcbiAgICAgICAgICBwcm9wcy5vblRlcm1pbmFsUmVhZHkocmVmKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxzbyB1cGRhdGUgdGhlIHRlcm1pbmFsIG1hbmFnZXIgd2l0aCB0aGUgRml0QWRkb25cbiAgICB0ZXJtaW5hbE1hbmFnZXIuc2V0VGVybWluYWxSZWYocmVmLCBmaXRBZGRvbkluc3RhbmNlKVxuICAgIFxuICAgIC8vIEluaXRpYWwgZml0IC0gc2luZ2xlIGNhbGwgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgZml0VGVybWluYWwoKVxuICAgIFxuICAgIC8vIFNldCB1cCByZXNpemUgb2JzZXJ2ZXIgZm9yIHJlc3BvbnNpdmUgZml0dGluZ1xuICAgIGxldCByZXNpemVPYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXIgfCB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiByZWYudGVybWluYWwpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHJlZi50ZXJtaW5hbC5lbGVtZW50Py5wYXJlbnRFbGVtZW50XG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICBmaXRUZXJtaW5hbCgpXG4gICAgICAgIH0pXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB1cCB3aW5kb3cgcmVzaXplIGxpc3RlbmVyIGFzIGJhY2t1cFxuICAgIGNvbnN0IGhhbmRsZVdpbmRvd1Jlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGZpdFRlcm1pbmFsKClcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVdpbmRvd1Jlc2l6ZSlcbiAgICBcbiAgICAvLyBDbGVhbnVwIGZ1bmN0aW9uXG4gICAgb25DbGVhbnVwKCgpID0+IHtcbiAgICAgIGlmIChyZXNpemVPYnNlcnZlcikge1xuICAgICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVXaW5kb3dSZXNpemUpXG4gICAgICBkZWJ1ZygnVGVybWluYWwgcmVzaXplIGhhbmRsZXJzIGNsZWFuZWQgdXAnKVxuICAgIH0pXG5cbiAgICAvLyBJbml0aWFsIG5vdGlmaWNhdGlvblxuICAgIGlmIChwcm9wcy5vblRlcm1pbmFsUmVhZHkpIHtcbiAgICAgIHByb3BzLm9uVGVybWluYWxSZWFkeShyZWYpXG4gICAgfVxuICB9XG5cbiAgLy8gVGVybWluYWwgc2V0dGluZ3NcbiAgY29uc3QgdGVybWluYWxPcHRpb25zID0gZ2V0VGVybWluYWxPcHRpb25zKClcblxuICBjb25zdCB4dGVybVByb3BzOiBYVGVybVByb3BzID0ge1xuICAgIG9wdGlvbnM6IHRlcm1pbmFsT3B0aW9ucyxcbiAgICBhZGRvbnM6IFtdLCAvLyBXZSBsb2FkIEZpdEFkZG9uIGRpcmVjdGx5IGluIGhhbmRsZVRlcm1pbmFsTW91bnRcbiAgICBvbkRhdGE6IGhhbmRsZVRlcm1pbmFsRGF0YSxcbiAgICBvblRpdGxlQ2hhbmdlOiBoYW5kbGVUaXRsZUNoYW5nZSxcbiAgICBvbk1vdW50OiBoYW5kbGVUZXJtaW5hbE1vdW50LFxuICAgIGNsYXNzOiBwcm9wcy5jbGFzcyB8fCAndGVybWluYWwtY29udGFpbmVyJyxcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgfSxcbiAgICBhdXRvRm9jdXM6IHRydWVcbiAgfVxuXG4gIHJldHVybiA8WFRlcm0gey4uLnh0ZXJtUHJvcHN9IC8+XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIGV4dGVybmFsIGFjY2VzcyAobWFpbnRhaW5pbmcgY29tcGF0aWJpbGl0eSlcbmV4cG9ydCBjbGFzcyBTb2xpZFRlcm1pbmFsTWFuYWdlciB7XG4gIHByaXZhdGUgdGVybWluYWxSZWY6IFRlcm1pbmFsUmVmIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBmaXRBZGRvbjogRml0QWRkb24gfCBudWxsID0gbnVsbFxuXG4gIHNldFRlcm1pbmFsUmVmKHJlZjogVGVybWluYWxSZWYsIGZpdEFkZG9uPzogRml0QWRkb24pIHtcbiAgICB0aGlzLnRlcm1pbmFsUmVmID0gcmVmXG4gICAgaWYgKGZpdEFkZG9uKSB7XG4gICAgICB0aGlzLmZpdEFkZG9uID0gZml0QWRkb25cbiAgICB9XG4gIH1cblxuICB3cml0ZVRvVGVybWluYWwoZGF0YTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudGVybWluYWxSZWYpIHtcbiAgICAgIHRoaXMudGVybWluYWxSZWYud3JpdGUoZGF0YSlcbiAgICB9XG4gIH1cblxuICByZXNldFRlcm1pbmFsKCk6IHZvaWQge1xuICAgIGRlYnVnKCdyZXNldFRlcm1pbmFsJylcbiAgICBpZiAodGhpcy50ZXJtaW5hbFJlZikge1xuICAgICAgdGhpcy50ZXJtaW5hbFJlZi5yZXNldCgpXG4gICAgfVxuICB9XG5cbiAgcmVzaXplVGVybWluYWwoKTogeyBjb2xzOiBudW1iZXI7IHJvd3M6IG51bWJlciB9IHwgbnVsbCB7XG4gICAgaWYgKHRoaXMudGVybWluYWxSZWYgJiYgdGhpcy50ZXJtaW5hbFJlZi50ZXJtaW5hbCAmJiB0aGlzLmZpdEFkZG9uKSB7XG4gICAgICB0aGlzLmZpdEFkZG9uLmZpdCgpXG4gICAgICBjb25zdCBkaW1lbnNpb25zID0geyBcbiAgICAgICAgY29sczogdGhpcy50ZXJtaW5hbFJlZi50ZXJtaW5hbC5jb2xzLCBcbiAgICAgICAgcm93czogdGhpcy50ZXJtaW5hbFJlZi50ZXJtaW5hbC5yb3dzIFxuICAgICAgfVxuICAgICAgZGVidWcoJ3Jlc2l6ZVRlcm1pbmFsJywgZGltZW5zaW9ucylcbiAgICAgIFxuICAgICAgLy8gRW1pdCByZXNpemUgdG8gc29ja2V0IHNlcnZpY2VcbiAgICAgIGVtaXRSZXNpemUoZGltZW5zaW9ucylcbiAgICAgIFxuICAgICAgcmV0dXJuIGRpbWVuc2lvbnNcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZvY3VzVGVybWluYWwoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudGVybWluYWxSZWYpIHtcbiAgICAgIHRoaXMudGVybWluYWxSZWYuZm9jdXMoKVxuICAgIH1cbiAgfVxuXG4gIGdldFRlcm1pbmFsRGltZW5zaW9ucygpOiB7IGNvbHM6IG51bWJlcjsgcm93czogbnVtYmVyIH0ge1xuICAgIGlmICh0aGlzLnRlcm1pbmFsUmVmICYmIHRoaXMudGVybWluYWxSZWYudGVybWluYWwpIHtcbiAgICAgIGNvbnN0IHsgY29scywgcm93cyB9ID0gdGhpcy50ZXJtaW5hbFJlZi50ZXJtaW5hbFxuICAgICAgZGVidWcoJ2dldFRlcm1pbmFsRGltZW5zaW9ucycsIHsgY29scywgcm93cyB9KVxuICAgICAgcmV0dXJuIHsgY29scywgcm93cyB9XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ2dldFRlcm1pbmFsRGltZW5zaW9uczogVGVybWluYWwgbm90IGluaXRpYWxpemVkJylcbiAgICByZXR1cm4geyBjb2xzOiAwLCByb3dzOiAwIH1cbiAgfVxuXG4gIHVwZGF0ZVRlcm1pbmFsU2V0dGluZ3MobmV3T3B0aW9uczogUGFydGlhbDxJVGVybWluYWxPcHRpb25zPik6IHZvaWQge1xuICAgIGlmICh0aGlzLnRlcm1pbmFsUmVmICYmIHRoaXMudGVybWluYWxSZWYudGVybWluYWwpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy50ZXJtaW5hbFJlZi50ZXJtaW5hbC5vcHRpb25zLCBuZXdPcHRpb25zKVxuICAgICAgdGhpcy50ZXJtaW5hbFJlZi5maXQoKVxuICAgICAgZGVidWcoJ3VwZGF0ZVRlcm1pbmFsU2V0dGluZ3MnLCBuZXdPcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIGFwcGx5VGVybWluYWxTZXR0aW5ncyhvcHRpb25zOiBQYXJ0aWFsPElUZXJtaW5hbE9wdGlvbnM+KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnRlcm1pbmFsUmVmIHx8ICF0aGlzLnRlcm1pbmFsUmVmLnRlcm1pbmFsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdhcHBseVRlcm1pbmFsU2V0dGluZ3M6IFRlcm1pbmFsIG5vdCBpbml0aWFsaXplZCcpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZGVidWcoJ2FwcGx5VGVybWluYWxTZXR0aW5ncycsIG9wdGlvbnMpXG5cbiAgICBjb25zdCB0ZXJtaW5hbFNldHRpbmdzOiBQYXJ0aWFsPElUZXJtaW5hbE9wdGlvbnM+ID0ge1xuICAgICAgY3Vyc29yQmxpbms6IChvcHRpb25zLmN1cnNvckJsaW5rID8/XG4gICAgICAgIGRlZmF1bHRTZXR0aW5ncy5jdXJzb3JCbGluaykgYXMgYm9vbGVhbixcbiAgICAgIHNjcm9sbGJhY2s6IHZhbGlkYXRlTnVtYmVyKFxuICAgICAgICBvcHRpb25zLnNjcm9sbGJhY2sgYXMgbnVtYmVyLFxuICAgICAgICAxLFxuICAgICAgICAyMDAwMDAsXG4gICAgICAgIGRlZmF1bHRTZXR0aW5ncy5zY3JvbGxiYWNrXG4gICAgICApLFxuICAgICAgdGFiU3RvcFdpZHRoOiB2YWxpZGF0ZU51bWJlcihcbiAgICAgICAgb3B0aW9ucy50YWJTdG9wV2lkdGggYXMgbnVtYmVyLFxuICAgICAgICAxLFxuICAgICAgICAxMDAsXG4gICAgICAgIGRlZmF1bHRTZXR0aW5ncy50YWJTdG9wV2lkdGhcbiAgICAgICksXG4gICAgICBmb250U2l6ZTogdmFsaWRhdGVOdW1iZXIoXG4gICAgICAgIG9wdGlvbnMuZm9udFNpemUgYXMgbnVtYmVyLFxuICAgICAgICAxLFxuICAgICAgICA3MixcbiAgICAgICAgZGVmYXVsdFNldHRpbmdzLmZvbnRTaXplXG4gICAgICApLFxuICAgICAgZm9udEZhbWlseTogU3RyaW5nKG9wdGlvbnMuZm9udEZhbWlseSA/PyBkZWZhdWx0U2V0dGluZ3MuZm9udEZhbWlseSksXG4gICAgICBsZXR0ZXJTcGFjaW5nOiAob3B0aW9ucy5sZXR0ZXJTcGFjaW5nID8/XG4gICAgICAgIGRlZmF1bHRTZXR0aW5ncy5sZXR0ZXJTcGFjaW5nKSBhcyBudW1iZXIsXG4gICAgICBsaW5lSGVpZ2h0OiAob3B0aW9ucy5saW5lSGVpZ2h0ID8/IGRlZmF1bHRTZXR0aW5ncy5saW5lSGVpZ2h0KSBhcyBudW1iZXJcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMudGVybWluYWxSZWYudGVybWluYWwub3B0aW9ucywgdGVybWluYWxTZXR0aW5ncylcbiAgICB0aGlzLnRlcm1pbmFsUmVmLmZpdCgpXG4gIH1cblxuICBnZXRUZXJtaW5hbEluc3RhbmNlKCk6IFRlcm1pbmFsIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMudGVybWluYWxSZWY/LnRlcm1pbmFsIHx8IG51bGxcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlIGZvciBjb21wYXRpYmlsaXR5XG5leHBvcnQgY29uc3QgdGVybWluYWxNYW5hZ2VyID0gbmV3IFNvbGlkVGVybWluYWxNYW5hZ2VyKCkiLCJpbXBvcnQgeyBDb21wb25lbnQsIEpTWCwgU2hvdywgRm9yLCBjcmVhdGVTaWduYWwsIGNyZWF0ZUVmZmVjdCwgb25Nb3VudCwgb25DbGVhbnVwIH0gZnJvbSAnc29saWQtanMnXG5pbXBvcnQgeyBQb3J0YWwgfSBmcm9tICdzb2xpZC1qcy93ZWInXG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSAnZGVidWcnXG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ3dlYnNzaDItY2xpZW50Om1vZGFsJylcblxuaW50ZXJmYWNlIE1vZGFsUHJvcHMge1xuICBpc09wZW46IGJvb2xlYW5cbiAgb25DbG9zZTogKCkgPT4gdm9pZFxuICBjaGlsZHJlbjogSlNYLkVsZW1lbnRcbiAgY2xhc3M/OiBzdHJpbmdcbiAgc2hvd0Nsb3NlQnV0dG9uPzogYm9vbGVhblxuICBjbG9zZU9uQmFja2Ryb3BDbGljaz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNvbnN0IE1vZGFsOiBDb21wb25lbnQ8TW9kYWxQcm9wcz4gPSAocHJvcHMpID0+IHtcbiAgbGV0IGRpYWxvZ1JlZjogSFRNTERpYWxvZ0VsZW1lbnQgfCB1bmRlZmluZWRcbiAgXG4gIC8vIEhhbmRsZSBtb2RhbCBzdGF0ZSBjaGFuZ2VzXG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgZGVidWcoJ01vZGFsIGNyZWF0ZUVmZmVjdCB0cmlnZ2VyZWQ6JywgeyBpc09wZW46IHByb3BzLmlzT3BlbiwgaGFzRGlhbG9nOiAhIWRpYWxvZ1JlZiB9KVxuICAgIFxuICAgIC8vIFdhaXQgZm9yIHRoZSBkaWFsb2cgZWxlbWVudCB0byBiZSByZWFkeVxuICAgIGlmIChwcm9wcy5pc09wZW4pIHtcbiAgICAgIGNvbnN0IG9wZW5EaWFsb2cgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkaWFsb2dSZWYpIHtcbiAgICAgICAgICBkZWJ1ZygnT3BlbmluZyBtb2RhbCBkaWFsb2cnKVxuICAgICAgICAgIGRpYWxvZ1JlZi5zaG93TW9kYWwoKVxuICAgICAgICAgIC8vIEZvY3VzIHRyYXAgLSBmb2N1cyBvbiBmaXJzdCBmb2N1c2FibGUgZWxlbWVudFxuICAgICAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZGlhbG9nUmVmLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnYnV0dG9uLCBbaHJlZl0sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGZpcnN0RWxlbWVudCA9IGZvY3VzYWJsZUVsZW1lbnRzWzBdIGFzIEhUTUxFbGVtZW50XG4gICAgICAgICAgaWYgKGZpcnN0RWxlbWVudCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBmaXJzdEVsZW1lbnQuZm9jdXMoKSwgNTApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJldHJ5IGlmIGRpYWxvZyBpc24ndCByZWFkeSB5ZXRcbiAgICAgICAgICBzZXRUaW1lb3V0KG9wZW5EaWFsb2csIDEwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSBkaWFsb2cgaXMgbW91bnRlZFxuICAgICAgc2V0VGltZW91dChvcGVuRGlhbG9nLCAwKVxuICAgIH0gZWxzZSBpZiAoZGlhbG9nUmVmKSB7XG4gICAgICBkZWJ1ZygnQ2xvc2luZyBtb2RhbCBkaWFsb2cnKVxuICAgICAgZGlhbG9nUmVmLmNsb3NlKClcbiAgICB9XG4gIH0pXG5cbiAgLy8gSGFuZGxlIGtleWJvYXJkIGV2ZW50c1xuICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICBpZiAoZS5rZXkgPT09ICdFc2NhcGUnICYmIHByb3BzLmlzT3Blbikge1xuICAgICAgcHJvcHMub25DbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGJhY2tkcm9wIGNsaWNrc1xuICBjb25zdCBoYW5kbGVEaWFsb2dDbGljayA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGRpYWxvZ1JlZj8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBpZiAoXG4gICAgICByZWN0ICYmXG4gICAgICBwcm9wcy5jbG9zZU9uQmFja2Ryb3BDbGljayAhPT0gZmFsc2UgJiZcbiAgICAgIChlLmNsaWVudFggPCByZWN0LmxlZnQgfHxcbiAgICAgICAgZS5jbGllbnRYID4gcmVjdC5yaWdodCB8fFxuICAgICAgICBlLmNsaWVudFkgPCByZWN0LnRvcCB8fFxuICAgICAgICBlLmNsaWVudFkgPiByZWN0LmJvdHRvbSlcbiAgICApIHtcbiAgICAgIHByb3BzLm9uQ2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKVxuICB9KVxuXG4gIG9uQ2xlYW51cCgoKSA9PiB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pXG4gIH0pXG5cbiAgcmV0dXJuIChcbiAgICA8UG9ydGFsPlxuICAgICAgPFNob3cgd2hlbj17cHJvcHMuaXNPcGVufT5cbiAgICAgICAgPGRpYWxvZ1xuICAgICAgICAgIHJlZj17ZGlhbG9nUmVmfVxuICAgICAgICAgIGNsYXNzPXtgbW9kYWwgJHtwcm9wcy5jbGFzcyB8fCAnJ31gfVxuICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZURpYWxvZ0NsaWNrfVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIiBvbkNsaWNrPXsoZSkgPT4gZS5zdG9wUHJvcGFnYXRpb24oKX0+XG4gICAgICAgICAgICA8U2hvdyB3aGVuPXtwcm9wcy5zaG93Q2xvc2VCdXR0b24gIT09IGZhbHNlfT5cbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiY2xvc2UtYnV0dG9uIGFic29sdXRlIHRvcC0yIHJpZ2h0LTIgdGV4dC1uZXV0cmFsLTQwMCBob3Zlcjp0ZXh0LW5ldXRyYWwtNjAwIHRleHQteGwgbGVhZGluZy1ub25lIHAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItMFwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17cHJvcHMub25DbG9zZX1cbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiQ2xvc2VcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgJnRpbWVzO1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvU2hvdz5cbiAgICAgICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaWFsb2c+XG4gICAgICA8L1Nob3c+XG4gICAgPC9Qb3J0YWw+XG4gIClcbn1cblxuLy8gRXJyb3IgTW9kYWwgQ29tcG9uZW50XG5pbnRlcmZhY2UgRXJyb3JNb2RhbFByb3BzIHtcbiAgaXNPcGVuOiBib29sZWFuXG4gIG9uQ2xvc2U6ICgpID0+IHZvaWRcbiAgbWVzc2FnZTogc3RyaW5nXG59XG5cbmV4cG9ydCBjb25zdCBFcnJvck1vZGFsOiBDb21wb25lbnQ8RXJyb3JNb2RhbFByb3BzPiA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxNb2RhbCBcbiAgICAgIGlzT3Blbj17cHJvcHMuaXNPcGVufSBcbiAgICAgIG9uQ2xvc2U9e3Byb3BzLm9uQ2xvc2V9XG4gICAgICBjbGFzcz1cImVycm9yLW1vZGFsXCJcbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwicmVsYXRpdmUgZXJyb3ItbW9kYWwgYmctcmVkLTUwIGJvcmRlciBib3JkZXItcmVkLTQwMCByb3VuZGVkLW1kIHNoYWRvdy1tZCBwLTUgdy04MCBzbTp3LTk2XCI+XG4gICAgICAgIDxoMiBjbGFzcz1cInRleHQtcmVkLTcwMCB0ZXh0LWxnIGZvbnQtc2VtaWJvbGQgbWItM1wiPkVycm9yPC9oMj5cbiAgICAgICAgPHAgY2xhc3M9XCJ0ZXh0LXJlZC02MDAgbWItNFwiPntwcm9wcy5tZXNzYWdlfTwvcD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZsZXgganVzdGlmeS1lbmRcIj5cbiAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzcz1cImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLW1kIGJvcmRlciBib3JkZXItdHJhbnNwYXJlbnQgcHgtMyBweS0yIHRleHQtc20gZm9udC1tZWRpdW0gYmctcmVkLTYwMCB0ZXh0LXdoaXRlIGhvdmVyOmJnLXJlZC03MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLW9mZnNldC0yIGZvY3VzOnJpbmctcmVkLTUwMFwiXG4gICAgICAgICAgICBvbkNsaWNrPXtwcm9wcy5vbkNsb3NlfVxuICAgICAgICAgICAgYXV0b2ZvY3VzXG4gICAgICAgICAgPlxuICAgICAgICAgICAgQ2xvc2VcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L01vZGFsPlxuICApXG59XG5cbi8vIFByb21wdCBNb2RhbCBDb21wb25lbnQgKGZvciBrZXlib2FyZC1pbnRlcmFjdGl2ZSBhdXRoZW50aWNhdGlvbilcbmludGVyZmFjZSBQcm9tcHRNb2RhbFByb3BzIHtcbiAgaXNPcGVuOiBib29sZWFuXG4gIG9uQ2xvc2U6ICgpID0+IHZvaWRcbiAgdGl0bGU6IHN0cmluZ1xuICBwcm9tcHRzOiBBcnJheTx7IHByb21wdDogc3RyaW5nOyBlY2hvOiBib29sZWFuIH0+XG4gIG9uU3VibWl0OiAocmVzcG9uc2VzOiBzdHJpbmdbXSkgPT4gdm9pZFxufVxuXG5leHBvcnQgY29uc3QgUHJvbXB0TW9kYWw6IENvbXBvbmVudDxQcm9tcHRNb2RhbFByb3BzPiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBbcmVzcG9uc2VzLCBzZXRSZXNwb25zZXNdID0gY3JlYXRlU2lnbmFsPHN0cmluZ1tdPihbXSlcblxuICAvLyBJbml0aWFsaXplIHJlc3BvbnNlcyBhcnJheSB3aGVuIHByb21wdHMgY2hhbmdlXG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByb3BzLnByb21wdHMpIHtcbiAgICAgIHNldFJlc3BvbnNlcyhuZXcgQXJyYXkocHJvcHMucHJvbXB0cy5sZW5ndGgpLmZpbGwoJycpKVxuICAgIH1cbiAgfSlcblxuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChpbmRleDogbnVtYmVyLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgbmV3UmVzcG9uc2VzID0gWy4uLnJlc3BvbnNlcygpXVxuICAgIG5ld1Jlc3BvbnNlc1tpbmRleF0gPSB2YWx1ZVxuICAgIHNldFJlc3BvbnNlcyhuZXdSZXNwb25zZXMpXG4gIH1cblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSAoZTogRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBwcm9wcy5vblN1Ym1pdChyZXNwb25zZXMoKSlcbiAgICBwcm9wcy5vbkNsb3NlKClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPE1vZGFsIFxuICAgICAgaXNPcGVuPXtwcm9wcy5pc09wZW59IFxuICAgICAgb25DbG9zZT17cHJvcHMub25DbG9zZX1cbiAgICAgIGNsYXNzPVwicHJvbXB0LW1vZGFsXCJcbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwicmVsYXRpdmUgcHJvbXB0LW1vZGFsIGJnLXdoaXRlIHRleHQtc2xhdGUtODAwIGJvcmRlciBib3JkZXItbmV1dHJhbC0zMDAgcm91bmRlZC1tZCBzaGFkb3ctbWQgcC01IHctODAgc206dy05NlwiPlxuICAgICAgICA8aDIgY2xhc3M9XCJ0ZXh0LWxnIGZvbnQtc2VtaWJvbGQgdGV4dC1zbGF0ZS05MDAgbWItNFwiPntwcm9wcy50aXRsZX08L2gyPlxuICAgICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0fT5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWItNCBzcGFjZS15LTNcIj5cbiAgICAgICAgICAgIDxGb3IgZWFjaD17cHJvcHMucHJvbXB0c30+XG4gICAgICAgICAgICAgIHsocHJvbXB0LCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImJsb2NrIHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1zbGF0ZS03MDAgbWItMVwiPlxuICAgICAgICAgICAgICAgICAge3Byb21wdC5wcm9tcHR9XG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgIHR5cGU9e3Byb21wdC5lY2hvID8gJ3RleHQnIDogJ3Bhc3N3b3JkJ31cbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYmxvY2sgdy1mdWxsIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci1zbGF0ZS0zMDAgYmctd2hpdGUgdGV4dC1zbGF0ZS05MDAgcGxhY2Vob2xkZXItc2xhdGUtNDAwIHB4LTMgcHktMiBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYmx1ZS01MDAgZm9jdXM6Ym9yZGVyLWJsdWUtNTAwXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtyZXNwb25zZXMoKVtpbmRleCgpXSB8fCAnJ31cbiAgICAgICAgICAgICAgICAgIG9uSW5wdXQ9eyhlKSA9PiBoYW5kbGVJbnB1dENoYW5nZShpbmRleCgpLCBlLmN1cnJlbnRUYXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgICAgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvRm9yPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGdhcC0yIGp1c3RpZnktZW5kXCI+XG4gICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHB4LTMgcHktMiB0ZXh0LXNtIGZvbnQtbWVkaXVtIGJnLXNsYXRlLTcwMCB0ZXh0LXdoaXRlIGhvdmVyOmJnLXNsYXRlLTgwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctb2Zmc2V0LTIgZm9jdXM6cmluZy1zbGF0ZS01MDBcIlxuICAgICAgICAgICAgICBvbkNsaWNrPXtwcm9wcy5vbkNsb3NlfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBDYW5jZWxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICAgIGNsYXNzPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci10cmFuc3BhcmVudCBweC0zIHB5LTIgdGV4dC1zbSBmb250LW1lZGl1bSBiZy1ibHVlLTYwMCB0ZXh0LXdoaXRlIGhvdmVyOmJnLWJsdWUtNzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1vZmZzZXQtMiBmb2N1czpyaW5nLWJsdWUtNTAwXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgU3VibWl0XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9mb3JtPlxuICAgICAgPC9kaXY+XG4gICAgPC9Nb2RhbD5cbiAgKVxufSIsImV4cG9ydCBkZWZhdWx0IFwiPCEtLSBAbGljZW5zZSBsdWNpZGUtc3RhdGljIHYwLjU0Mi4wIC0gSVNDIC0tPlxcbjxzdmdcXG4gIGNsYXNzPVxcXCJsdWNpZGUgbHVjaWRlLW1lbnVcXFwiXFxuICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICB3aWR0aD1cXFwiMjRcXFwiXFxuICBoZWlnaHQ9XFxcIjI0XFxcIlxcbiAgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIlxcbiAgZmlsbD1cXFwibm9uZVxcXCJcXG4gIHN0cm9rZT1cXFwiY3VycmVudENvbG9yXFxcIlxcbiAgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIlxcbiAgc3Ryb2tlLWxpbmVjYXA9XFxcInJvdW5kXFxcIlxcbiAgc3Ryb2tlLWxpbmVqb2luPVxcXCJyb3VuZFxcXCJcXG4+XFxuICA8cGF0aCBkPVxcXCJNNCAxMmgxNlxcXCIgLz5cXG4gIDxwYXRoIGQ9XFxcIk00IDE4aDE2XFxcIiAvPlxcbiAgPHBhdGggZD1cXFwiTTQgNmgxNlxcXCIgLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPCEtLSBAbGljZW5zZSBsdWNpZGUtc3RhdGljIHYwLjU0Mi4wIC0gSVNDIC0tPlxcbjxzdmdcXG4gIGNsYXNzPVxcXCJsdWNpZGUgbHVjaWRlLWNsaXBib2FyZFxcXCJcXG4gIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCJcXG4gIHdpZHRoPVxcXCIyNFxcXCJcXG4gIGhlaWdodD1cXFwiMjRcXFwiXFxuICB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiXFxuICBmaWxsPVxcXCJub25lXFxcIlxcbiAgc3Ryb2tlPVxcXCJjdXJyZW50Q29sb3JcXFwiXFxuICBzdHJva2Utd2lkdGg9XFxcIjJcXFwiXFxuICBzdHJva2UtbGluZWNhcD1cXFwicm91bmRcXFwiXFxuICBzdHJva2UtbGluZWpvaW49XFxcInJvdW5kXFxcIlxcbj5cXG4gIDxyZWN0IHdpZHRoPVxcXCI4XFxcIiBoZWlnaHQ9XFxcIjRcXFwiIHg9XFxcIjhcXFwiIHk9XFxcIjJcXFwiIHJ4PVxcXCIxXFxcIiByeT1cXFwiMVxcXCIgLz5cXG4gIDxwYXRoIGQ9XFxcIk0xNiA0aDJhMiAyIDAgMCAxIDIgMnYxNGEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2YTIgMiAwIDAgMSAyLTJoMlxcXCIgLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPCEtLSBAbGljZW5zZSBsdWNpZGUtc3RhdGljIHYwLjU0Mi4wIC0gSVNDIC0tPlxcbjxzdmdcXG4gIGNsYXNzPVxcXCJsdWNpZGUgbHVjaWRlLXNldHRpbmdzXFxcIlxcbiAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgd2lkdGg9XFxcIjI0XFxcIlxcbiAgaGVpZ2h0PVxcXCIyNFxcXCJcXG4gIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCJcXG4gIGZpbGw9XFxcIm5vbmVcXFwiXFxuICBzdHJva2U9XFxcImN1cnJlbnRDb2xvclxcXCJcXG4gIHN0cm9rZS13aWR0aD1cXFwiMlxcXCJcXG4gIHN0cm9rZS1saW5lY2FwPVxcXCJyb3VuZFxcXCJcXG4gIHN0cm9rZS1saW5lam9pbj1cXFwicm91bmRcXFwiXFxuPlxcbiAgPHBhdGggZD1cXFwiTTkuNjcxIDQuMTM2YTIuMzQgMi4zNCAwIDAgMSA0LjY1OSAwIDIuMzQgMi4zNCAwIDAgMCAzLjMxOSAxLjkxNSAyLjM0IDIuMzQgMCAwIDEgMi4zMyA0LjAzMyAyLjM0IDIuMzQgMCAwIDAgMCAzLjgzMSAyLjM0IDIuMzQgMCAwIDEtMi4zMyA0LjAzMyAyLjM0IDIuMzQgMCAwIDAtMy4zMTkgMS45MTUgMi4zNCAyLjM0IDAgMCAxLTQuNjU5IDAgMi4zNCAyLjM0IDAgMCAwLTMuMzItMS45MTUgMi4zNCAyLjM0IDAgMCAxLTIuMzMtNC4wMzMgMi4zNCAyLjM0IDAgMCAwIDAtMy44MzFBMi4zNCAyLjM0IDAgMCAxIDYuMzUgNi4wNTFhMi4zNCAyLjM0IDAgMCAwIDMuMzE5LTEuOTE1XFxcIiAvPlxcbiAgPGNpcmNsZSBjeD1cXFwiMTJcXFwiIGN5PVxcXCIxMlxcXCIgcj1cXFwiM1xcXCIgLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPCEtLSBAbGljZW5zZSBsdWNpZGUtc3RhdGljIHYwLjU0Mi4wIC0gSVNDIC0tPlxcbjxzdmdcXG4gIGNsYXNzPVxcXCJsdWNpZGUgbHVjaWRlLWRvd25sb2FkXFxcIlxcbiAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgd2lkdGg9XFxcIjI0XFxcIlxcbiAgaGVpZ2h0PVxcXCIyNFxcXCJcXG4gIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCJcXG4gIGZpbGw9XFxcIm5vbmVcXFwiXFxuICBzdHJva2U9XFxcImN1cnJlbnRDb2xvclxcXCJcXG4gIHN0cm9rZS13aWR0aD1cXFwiMlxcXCJcXG4gIHN0cm9rZS1saW5lY2FwPVxcXCJyb3VuZFxcXCJcXG4gIHN0cm9rZS1saW5lam9pbj1cXFwicm91bmRcXFwiXFxuPlxcbiAgPHBhdGggZD1cXFwiTTEyIDE1VjNcXFwiIC8+XFxuICA8cGF0aCBkPVxcXCJNMjEgMTV2NGEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnYtNFxcXCIgLz5cXG4gIDxwYXRoIGQ9XFxcIm03IDEwIDUgNSA1LTVcXFwiIC8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjwhLS0gQGxpY2Vuc2UgbHVjaWRlLXN0YXRpYyB2MC41NDIuMCAtIElTQyAtLT5cXG48c3ZnXFxuICBjbGFzcz1cXFwibHVjaWRlIGx1Y2lkZS1rZXlcXFwiXFxuICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICB3aWR0aD1cXFwiMjRcXFwiXFxuICBoZWlnaHQ9XFxcIjI0XFxcIlxcbiAgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIlxcbiAgZmlsbD1cXFwibm9uZVxcXCJcXG4gIHN0cm9rZT1cXFwiY3VycmVudENvbG9yXFxcIlxcbiAgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIlxcbiAgc3Ryb2tlLWxpbmVjYXA9XFxcInJvdW5kXFxcIlxcbiAgc3Ryb2tlLWxpbmVqb2luPVxcXCJyb3VuZFxcXCJcXG4+XFxuICA8cGF0aCBkPVxcXCJtMTUuNSA3LjUgMi4zIDIuM2ExIDEgMCAwIDAgMS40IDBsMi4xLTIuMWExIDEgMCAwIDAgMC0xLjRMMTkgNFxcXCIgLz5cXG4gIDxwYXRoIGQ9XFxcIm0yMSAyLTkuNiA5LjZcXFwiIC8+XFxuICA8Y2lyY2xlIGN4PVxcXCI3LjVcXFwiIGN5PVxcXCIxNS41XFxcIiByPVxcXCI1LjVcXFwiIC8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjwhLS0gQGxpY2Vuc2UgbHVjaWRlLXN0YXRpYyB2MC41NDIuMCAtIElTQyAtLT5cXG48c3ZnXFxuICBjbGFzcz1cXFwibHVjaWRlIGx1Y2lkZS10cmFzaC0yXFxcIlxcbiAgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIlxcbiAgd2lkdGg9XFxcIjI0XFxcIlxcbiAgaGVpZ2h0PVxcXCIyNFxcXCJcXG4gIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCJcXG4gIGZpbGw9XFxcIm5vbmVcXFwiXFxuICBzdHJva2U9XFxcImN1cnJlbnRDb2xvclxcXCJcXG4gIHN0cm9rZS13aWR0aD1cXFwiMlxcXCJcXG4gIHN0cm9rZS1saW5lY2FwPVxcXCJyb3VuZFxcXCJcXG4gIHN0cm9rZS1saW5lam9pbj1cXFwicm91bmRcXFwiXFxuPlxcbiAgPHBhdGggZD1cXFwiTTEwIDExdjZcXFwiIC8+XFxuICA8cGF0aCBkPVxcXCJNMTQgMTF2NlxcXCIgLz5cXG4gIDxwYXRoIGQ9XFxcIk0xOSA2djE0YTIgMiAwIDAgMS0yIDJIN2EyIDIgMCAwIDEtMi0yVjZcXFwiIC8+XFxuICA8cGF0aCBkPVxcXCJNMyA2aDE4XFxcIiAvPlxcbiAgPHBhdGggZD1cXFwiTTggNlY0YTIgMiAwIDAgMSAyLTJoNGEyIDIgMCAwIDEgMiAydjJcXFwiIC8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjwhLS0gQGxpY2Vuc2UgbHVjaWRlLXN0YXRpYyB2MC41NDIuMCAtIElTQyAtLT5cXG48c3ZnXFxuICBjbGFzcz1cXFwibHVjaWRlIGx1Y2lkZS11cGxvYWRcXFwiXFxuICB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXFxuICB3aWR0aD1cXFwiMjRcXFwiXFxuICBoZWlnaHQ9XFxcIjI0XFxcIlxcbiAgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIlxcbiAgZmlsbD1cXFwibm9uZVxcXCJcXG4gIHN0cm9rZT1cXFwiY3VycmVudENvbG9yXFxcIlxcbiAgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIlxcbiAgc3Ryb2tlLWxpbmVjYXA9XFxcInJvdW5kXFxcIlxcbiAgc3Ryb2tlLWxpbmVqb2luPVxcXCJyb3VuZFxcXCJcXG4+XFxuICA8cGF0aCBkPVxcXCJNMTIgM3YxMlxcXCIgLz5cXG4gIDxwYXRoIGQ9XFxcIm0xNyA4LTUtNS01IDVcXFwiIC8+XFxuICA8cGF0aCBkPVxcXCJNMjEgMTV2NGEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnYtNFxcXCIgLz5cXG48L3N2Zz5cXG5cIiIsIi8vIGNsaWVudC9zcmMvanMvaWNvbnMudHNcbi8vIFplcm8tcnVudGltZSBpY29uIGhlbHBlciB1c2luZyBsdWNpZGUtc3RhdGljIGlubGluZSBTVkdzXG5cbmltcG9ydCBNZW51IGZyb20gJ2x1Y2lkZS1zdGF0aWMvaWNvbnMvbWVudS5zdmc/cmF3J1xuaW1wb3J0IENsaXBib2FyZCBmcm9tICdsdWNpZGUtc3RhdGljL2ljb25zL2NsaXBib2FyZC5zdmc/cmF3J1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJ2x1Y2lkZS1zdGF0aWMvaWNvbnMvc2V0dGluZ3Muc3ZnP3JhdydcbmltcG9ydCBEb3dubG9hZCBmcm9tICdsdWNpZGUtc3RhdGljL2ljb25zL2Rvd25sb2FkLnN2Zz9yYXcnXG5pbXBvcnQgS2V5IGZyb20gJ2x1Y2lkZS1zdGF0aWMvaWNvbnMva2V5LnN2Zz9yYXcnXG5pbXBvcnQgVHJhc2gyIGZyb20gJ2x1Y2lkZS1zdGF0aWMvaWNvbnMvdHJhc2gtMi5zdmc/cmF3J1xuaW1wb3J0IFVwbG9hZCBmcm9tICdsdWNpZGUtc3RhdGljL2ljb25zL3VwbG9hZC5zdmc/cmF3J1xuXG5leHBvcnQgY29uc3QgSUNPTlM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gIG1lbnU6IE1lbnUsXG4gIGNsaXBib2FyZDogQ2xpcGJvYXJkLFxuICBzZXR0aW5nczogU2V0dGluZ3MsXG4gIGRvd25sb2FkOiBEb3dubG9hZCxcbiAga2V5OiBLZXksXG4gICd0cmFzaC1jYW4nOiBUcmFzaDIsXG4gIHRyYXNoOiBUcmFzaDIsXG4gIHVwbG9hZDogVXBsb2FkXG59XG5cbi8vIERPTSBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIHJlbW92ZWQgLSB1c2UgSWNvbiBjb21wb25lbnQgaW5zdGVhZFxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBzcGxpdFByb3BzIH0gZnJvbSAnc29saWQtanMnXG5pbXBvcnQgeyBJQ09OUyB9IGZyb20gJy4uL2ljb25zLmpzJ1xuXG5pbnRlcmZhY2UgSWNvblByb3BzIHtcbiAgbmFtZTogc3RyaW5nXG4gIGNsYXNzPzogc3RyaW5nXG4gIFtrZXk6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgY29uc3QgSWNvbjogQ29tcG9uZW50PEljb25Qcm9wcz4gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW2xvY2FsLCBvdGhlcnNdID0gc3BsaXRQcm9wcyhwcm9wcywgWyduYW1lJywgJ2NsYXNzJ10pXG4gIFxuICBjb25zdCBzdmdSYXcgPSBJQ09OU1tsb2NhbC5uYW1lXSB8fCAnJ1xuICBcbiAgaWYgKCFzdmdSYXcpIHtcbiAgICBjb25zb2xlLndhcm4oYEljb24gXCIke2xvY2FsLm5hbWV9XCIgbm90IGZvdW5kIGluIElDT05TYClcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIFxuICAvLyBQYXJzZSB0aGUgU1ZHIHRvIGV4dHJhY3QgYXR0cmlidXRlcyBhbmQgY29udGVudFxuICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKClcbiAgY29uc3QgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmdSYXcsICdpbWFnZS9zdmcreG1sJylcbiAgY29uc3Qgc3ZnRWwgPSBkb2MucXVlcnlTZWxlY3Rvcignc3ZnJylcbiAgXG4gIGlmICghc3ZnRWwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIFxuICAvLyBTcGxpdCBjbGFzc2VzOiBhcHBseSBzaXppbmcvYW5pbWF0aW9uIHRvIFNWRywgY29udGFpbmVyL2xheW91dCB0byB3cmFwcGVyXG4gIGNvbnN0IHRva2VucyA9IChsb2NhbC5jbGFzcyB8fCAnJykuc3BsaXQoL1xccysvKS5maWx0ZXIoQm9vbGVhbilcbiAgY29uc3Qgc3ZnQ2xhc3M6IHN0cmluZ1tdID0gW11cbiAgY29uc3Qgd3JhcHBlckNsYXNzOiBzdHJpbmdbXSA9IFsnaWNvbiddXG4gIFxuICB0b2tlbnMuZm9yRWFjaCgodCkgPT4ge1xuICAgIGlmIChcbiAgICAgIHQuc3RhcnRzV2l0aCgndy0nKSB8fFxuICAgICAgdC5zdGFydHNXaXRoKCdoLScpIHx8XG4gICAgICB0LnN0YXJ0c1dpdGgoJ2FuaW1hdGUtJykgfHxcbiAgICAgIHQuc3RhcnRzV2l0aCgnb3JpZ2luLScpIHx8XG4gICAgICB0LnN0YXJ0c1dpdGgoJ2lubGluZS0nKVxuICAgICkge1xuICAgICAgc3ZnQ2xhc3MucHVzaCh0KVxuICAgIH0gZWxzZSB7XG4gICAgICB3cmFwcGVyQ2xhc3MucHVzaCh0KVxuICAgIH1cbiAgfSlcbiAgXG4gIC8vIEdldCBleGlzdGluZyBTVkcgYXR0cmlidXRlc1xuICBjb25zdCBleGlzdGluZ1N2Z0NsYXNzID0gc3ZnRWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnXG4gIGNvbnN0IGZpbmFsU3ZnQ2xhc3MgPSBgJHtleGlzdGluZ1N2Z0NsYXNzfSAke3N2Z0NsYXNzLmpvaW4oJyAnKX1gLnRyaW0oKVxuICBcbiAgLy8gQ3JlYXRlIHRoZSBTVkcgd2l0aCB1cGRhdGVkIGNsYXNzXG4gIGNvbnN0IHN2Z1dpdGhDbGFzcyA9IHN2Z1Jhdy5yZXBsYWNlKFxuICAgIC88c3ZnKFtePl0qKWNsYXNzPVwiKFteXCJdKilcIihbXj5dKikvLFxuICAgIGA8c3ZnJDFjbGFzcz1cIiR7ZmluYWxTdmdDbGFzc31cIiQzYFxuICApLnJlcGxhY2UoXG4gICAgLzxzdmcoW14+XSopKD8hY2xhc3M9KShbXj5dKikvLFxuICAgIGA8c3ZnJDFjbGFzcz1cIiR7ZmluYWxTdmdDbGFzc31cIiQyYFxuICApXG4gIFxuICByZXR1cm4gKFxuICAgIDxzcGFuIGNsYXNzPXt3cmFwcGVyQ2xhc3Muam9pbignICcpfSB7Li4ub3RoZXJzfSBpbm5lckhUTUw9e3N2Z1dpdGhDbGFzc30gLz5cbiAgKVxufSIsImltcG9ydCB7IGNyZWF0ZVNpZ25hbCwgY3JlYXRlTWVtbywgQWNjZXNzb3IgfSBmcm9tICdzb2xpZC1qcydcbmltcG9ydCB7IHZhbGlkYXRlUHJpdmF0ZUtleSwgdmFsaWRhdGVQcml2YXRlS2V5RGVlcCB9IGZyb20gJy4uL3V0aWxzLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFByaXZhdGVLZXlWYWxpZGF0aW9uU3RhdGUge1xuICBpc1ZhbGlkOiBib29sZWFuXG4gIGZvcm1hdDogJ09QRU5TU0gnIHwgJ1BLQ1M4JyB8ICdQS0NTMS1SU0EnIHwgJ0VDJyB8ICdEU0EnIHwgJ3Vua25vd24nXG4gIGVycm9yPzogc3RyaW5nXG4gIHN1Z2dlc3Rpb24/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVByaXZhdGVLZXlWYWxpZGF0aW9uKGtleTogQWNjZXNzb3I8c3RyaW5nPikge1xuICBjb25zdCBbdmFsaWRhdGlvblN0YXRlLCBzZXRWYWxpZGF0aW9uU3RhdGVdID0gY3JlYXRlU2lnbmFsPFByaXZhdGVLZXlWYWxpZGF0aW9uU3RhdGU+KHtcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICBmb3JtYXQ6ICd1bmtub3duJ1xuICB9KVxuXG4gIGNvbnN0IHZhbGlkYXRlID0gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qga2V5VmFsdWUgPSBrZXkoKVxuICAgIFxuICAgIC8vIEVtcHR5IGtleSBpcyB2YWxpZCAobm90IHJlcXVpcmVkKVxuICAgIGlmICgha2V5VmFsdWUgfHwga2V5VmFsdWUudHJpbSgpID09PSAnJykge1xuICAgICAgc2V0VmFsaWRhdGlvblN0YXRlKHsgaXNWYWxpZDogdHJ1ZSwgZm9ybWF0OiAndW5rbm93bicgfSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBtaXN0YWtlc1xuICAgIGlmIChrZXlWYWx1ZS5pbmNsdWRlcygnc3NoLXJzYScpIHx8IGtleVZhbHVlLmluY2x1ZGVzKCdzc2gtZWQyNTUxOScpIHx8IGtleVZhbHVlLmluY2x1ZGVzKCdlY2RzYS1zaGEyJykpIHtcbiAgICAgIHNldFZhbGlkYXRpb25TdGF0ZSh7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBmb3JtYXQ6ICd1bmtub3duJyxcbiAgICAgICAgZXJyb3I6ICdUaGlzIGFwcGVhcnMgdG8gYmUgYSBwdWJsaWMga2V5JyxcbiAgICAgICAgc3VnZ2VzdGlvbjogJ1BsZWFzZSB1c2UgeW91ciBwcml2YXRlIGtleSBmaWxlIGluc3RlYWQgKHVzdWFsbHkgaWRfcnNhLCBub3QgaWRfcnNhLnB1YiknXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gQmFzaWMgdmFsaWRhdGlvblxuICAgIGlmICghdmFsaWRhdGVQcml2YXRlS2V5KGtleVZhbHVlKSkge1xuICAgICAgbGV0IGVycm9yID0gJ0ludmFsaWQgcHJpdmF0ZSBrZXkgZm9ybWF0J1xuICAgICAgbGV0IHN1Z2dlc3Rpb24gPSAnJ1xuXG4gICAgICBpZiAoa2V5VmFsdWUuaW5jbHVkZXMoJ0JFR0lOJykgJiYgIWtleVZhbHVlLmluY2x1ZGVzKCdQUklWQVRFJykpIHtcbiAgICAgICAgZXJyb3IgPSAnVGhpcyBpcyBub3QgYSBwcml2YXRlIGtleSdcbiAgICAgICAgc3VnZ2VzdGlvbiA9ICdMb29rIGZvciBhIGZpbGUgd2l0aG91dCAucHViIGV4dGVuc2lvbidcbiAgICAgIH0gZWxzZSBpZiAoIWtleVZhbHVlLmluY2x1ZGVzKCdCRUdJTicpKSB7XG4gICAgICAgIGVycm9yID0gJ01pc3NpbmcgUEVNIGhlYWRlcnMnXG4gICAgICAgIHN1Z2dlc3Rpb24gPSAnS2V5IHNob3VsZCBzdGFydCB3aXRoIC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLSdcbiAgICAgIH1cblxuICAgICAgc2V0VmFsaWRhdGlvblN0YXRlKHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogJ3Vua25vd24nLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgc3VnZ2VzdGlvblxuICAgICAgfSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIERlZXAgdmFsaWRhdGlvblxuICAgIGNvbnN0IGRlZXBSZXN1bHQgPSB2YWxpZGF0ZVByaXZhdGVLZXlEZWVwKGtleVZhbHVlKVxuICAgIGlmICghZGVlcFJlc3VsdCkge1xuICAgICAgc2V0VmFsaWRhdGlvblN0YXRlKHtcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogJ3Vua25vd24nLFxuICAgICAgICBlcnJvcjogJ0tleSBzdHJ1Y3R1cmUgaXMgaW52YWxpZCcsXG4gICAgICAgIHN1Z2dlc3Rpb246ICdUaGUga2V5IGFwcGVhcnMgY29ycnVwdGVkIG9yIGlzIGluIGFuIHVuc3VwcG9ydGVkIGZvcm1hdCdcbiAgICAgIH0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBWYWxpZCBrZXlcbiAgICBzZXRWYWxpZGF0aW9uU3RhdGUoe1xuICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgIGZvcm1hdDogZGVlcFJlc3VsdC5mb3JtYXRcbiAgICB9KVxuICAgIHJldHVybiB0cnVlXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICB2YWxpZGF0aW9uU3RhdGUsXG4gICAgdmFsaWRhdGUsXG4gICAgaXNWYWxpZDogKCkgPT4gdmFsaWRhdGlvblN0YXRlKCkuaXNWYWxpZCxcbiAgICBmb3JtYXQ6ICgpID0+IHZhbGlkYXRpb25TdGF0ZSgpLmZvcm1hdCxcbiAgICBlcnJvcjogKCkgPT4gdmFsaWRhdGlvblN0YXRlKCkuZXJyb3IsXG4gICAgc3VnZ2VzdGlvbjogKCkgPT4gdmFsaWRhdGlvblN0YXRlKCkuc3VnZ2VzdGlvblxuICB9XG59IiwiLy8gRm9ybSB2YWxpZGF0aW9uIHV0aWxpdGllcyBmb3IgU29saWRKUyBjb21wb25lbnRzXG5pbXBvcnQgdHlwZSB7IEFjY2Vzc29yIH0gZnJvbSAnc29saWQtanMnXG5pbXBvcnQgeyBjcmVhdGVTaWduYWwgfSBmcm9tICdzb2xpZC1qcydcbmltcG9ydCB7IHZhbGlkYXRlUHJpdmF0ZUtleSwgdmFsaWRhdGVQcml2YXRlS2V5RGVlcCB9IGZyb20gJy4uL3V0aWxzLmpzJ1xuXG4vLyBWYWxpZGF0aW9uIHJ1bGUgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvblJ1bGU8VCA9IHVua25vd24+IHtcbiAgbWVzc2FnZTogc3RyaW5nXG4gIHZhbGlkYXRlOiAodmFsdWU6IFQpID0+IGJvb2xlYW5cbn1cblxuLy8gRmllbGQgdmFsaWRhdGlvbiBzdGF0ZVxuZXhwb3J0IGludGVyZmFjZSBGaWVsZFZhbGlkYXRpb24ge1xuICBpc1ZhbGlkOiBib29sZWFuXG4gIGVycm9yPzogc3RyaW5nXG59XG5cbi8vIENyZWF0ZSBhIGZpZWxkIHZhbGlkYXRvclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpZWxkVmFsaWRhdG9yPFQ+KFxuICB2YWx1ZTogQWNjZXNzb3I8VD4sXG4gIHJ1bGVzOiBWYWxpZGF0aW9uUnVsZTxUPltdID0gW11cbikge1xuICBjb25zdCBbdmFsaWRhdGlvbiwgc2V0VmFsaWRhdGlvbl0gPSBjcmVhdGVTaWduYWw8RmllbGRWYWxpZGF0aW9uPih7XG4gICAgaXNWYWxpZDogdHJ1ZVxuICB9KVxuXG4gIGNvbnN0IHZhbGlkYXRlID0gKCk6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHZhbHVlKClcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xuICAgICAgaWYgKCFydWxlLnZhbGlkYXRlKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgc2V0VmFsaWRhdGlvbih7XG4gICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IHJ1bGUubWVzc2FnZVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRWYWxpZGF0aW9uKHsgaXNWYWxpZDogdHJ1ZSB9KVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbGlkYXRpb24sXG4gICAgdmFsaWRhdGUsXG4gICAgcmVzZXQ6ICgpID0+IHNldFZhbGlkYXRpb24oeyBpc1ZhbGlkOiB0cnVlIH0pXG4gIH1cbn1cblxuLy8gQ29tbW9uIHZhbGlkYXRpb24gcnVsZXNcbmV4cG9ydCBjb25zdCBWYWxpZGF0aW9uUnVsZXMgPSB7XG4gIHJlcXVpcmVkOiA8VD4obWVzc2FnZSA9ICdUaGlzIGZpZWxkIGlzIHJlcXVpcmVkJyk6IFZhbGlkYXRpb25SdWxlPFQ+ID0+ICh7XG4gICAgbWVzc2FnZSxcbiAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpLmxlbmd0aCA+IDBcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJ1xuICAgIH1cbiAgfSksXG5cbiAgbWluTGVuZ3RoOiAobWluOiBudW1iZXIsIG1lc3NhZ2U/OiBzdHJpbmcpOiBWYWxpZGF0aW9uUnVsZTxzdHJpbmc+ID0+ICh7XG4gICAgbWVzc2FnZTogbWVzc2FnZSB8fCBgTXVzdCBiZSBhdCBsZWFzdCAke21pbn0gY2hhcmFjdGVyc2AsXG4gICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4gdmFsdWUubGVuZ3RoID49IG1pblxuICB9KSxcblxuICBtYXhMZW5ndGg6IChtYXg6IG51bWJlciwgbWVzc2FnZT86IHN0cmluZyk6IFZhbGlkYXRpb25SdWxlPHN0cmluZz4gPT4gKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IGBNdXN0IGJlIG5vIG1vcmUgdGhhbiAke21heH0gY2hhcmFjdGVyc2AsXG4gICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4gdmFsdWUubGVuZ3RoIDw9IG1heFxuICB9KSxcblxuICBwYXR0ZXJuOiAoXG4gICAgcmVnZXg6IFJlZ0V4cCxcbiAgICBtZXNzYWdlID0gJ0ludmFsaWQgZm9ybWF0J1xuICApOiBWYWxpZGF0aW9uUnVsZTxzdHJpbmc+ID0+ICh7XG4gICAgbWVzc2FnZSxcbiAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiByZWdleC50ZXN0KHZhbHVlKVxuICB9KSxcblxuICBlbWFpbDogKG1lc3NhZ2UgPSAnSW52YWxpZCBlbWFpbCBhZGRyZXNzJyk6IFZhbGlkYXRpb25SdWxlPHN0cmluZz4gPT4gKHtcbiAgICBtZXNzYWdlLFxuICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvLnRlc3QodmFsdWUpXG4gIH0pLFxuXG4gIHBvcnQ6IChcbiAgICBtZXNzYWdlID0gJ1BvcnQgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDY1NTM1J1xuICApOiBWYWxpZGF0aW9uUnVsZTxudW1iZXI+ID0+ICh7XG4gICAgbWVzc2FnZSxcbiAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBudW0gPSBOdW1iZXIodmFsdWUpXG4gICAgICByZXR1cm4gbnVtID49IDEgJiYgbnVtIDw9IDY1NTM1XG4gICAgfVxuICB9KSxcblxuICBob3N0bmFtZTogKFxuICAgIG1lc3NhZ2UgPSAnSW52YWxpZCBob3N0bmFtZSBvciBJUCBhZGRyZXNzJ1xuICApOiBWYWxpZGF0aW9uUnVsZTxzdHJpbmc+ID0+ICh7XG4gICAgbWVzc2FnZSxcbiAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAvLyBCYXNpYyBob3N0bmFtZS9JUCB2YWxpZGF0aW9uXG4gICAgICBpZiAoIXZhbHVlLnRyaW0oKSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIC8vIENoZWNrIGZvciB2YWxpZCBob3N0bmFtZSBmb3JtYXRcbiAgICAgIGNvbnN0IGhvc3RuYW1lUmVnZXggPVxuICAgICAgICAvXihbYS16QS1aMC05XXxbYS16QS1aMC05XVthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKShcXC4oW2EtekEtWjAtOV18W2EtekEtWjAtOV1bYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSkpKiQvXG5cbiAgICAgIC8vIENoZWNrIGZvciB2YWxpZCBJUHY0IGZvcm1hdFxuICAgICAgY29uc3QgaXB2NFJlZ2V4ID1cbiAgICAgICAgL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPykkL1xuXG4gICAgICAvLyBDaGVjayBmb3IgdmFsaWQgSVB2NiBmb3JtYXQgKGJhc2ljIGNoZWNrKVxuICAgICAgY29uc3QgaXB2NlJlZ2V4ID0gL14oPzpbMC05YS1mQS1GXXsxLDR9Oil7N31bMC05YS1mQS1GXXsxLDR9JHxeOjoxJHxeOjokL1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBob3N0bmFtZVJlZ2V4LnRlc3QodmFsdWUpIHx8XG4gICAgICAgIGlwdjRSZWdleC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICBpcHY2UmVnZXgudGVzdCh2YWx1ZSlcbiAgICAgIClcbiAgICB9XG4gIH0pLFxuXG4gIGN1c3RvbTogPFQ+KFxuICAgIHZhbGlkYXRlOiAodmFsdWU6IFQpID0+IGJvb2xlYW4sXG4gICAgbWVzc2FnZSA9ICdJbnZhbGlkIHZhbHVlJ1xuICApOiBWYWxpZGF0aW9uUnVsZTxUPiA9PiAoe1xuICAgIG1lc3NhZ2UsXG4gICAgdmFsaWRhdGVcbiAgfSksXG5cbiAgcHJpdmF0ZUtleTogKFxuICAgIG1lc3NhZ2UgPSAnSW52YWxpZCBwcml2YXRlIGtleSBmb3JtYXQnXG4gICk6IFZhbGlkYXRpb25SdWxlPHN0cmluZz4gPT4gKHtcbiAgICBtZXNzYWdlLFxuICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUudHJpbSgpID09PSAnJykgcmV0dXJuIHRydWUgLy8gRW1wdHkgaXMgYWxsb3dlZFxuICAgICAgcmV0dXJuIHZhbGlkYXRlUHJpdmF0ZUtleSh2YWx1ZSlcbiAgICB9XG4gIH0pLFxuXG4gIHByaXZhdGVLZXlEZWVwOiAoXG4gICAgbWVzc2FnZSA9ICdQcml2YXRlIGtleSBhcHBlYXJzIG1hbGZvcm1lZCBvciB1bnN1cHBvcnRlZCdcbiAgKTogVmFsaWRhdGlvblJ1bGU8c3RyaW5nPiA9PiAoe1xuICAgIG1lc3NhZ2UsXG4gICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS50cmltKCkgPT09ICcnKSByZXR1cm4gdHJ1ZSAvLyBFbXB0eSBpcyBhbGxvd2VkXG4gICAgICByZXR1cm4gdmFsaWRhdGVQcml2YXRlS2V5KHZhbHVlKSAmJiB2YWxpZGF0ZVByaXZhdGVLZXlEZWVwKHZhbHVlKSAhPT0gbnVsbFxuICAgIH1cbiAgfSksXG5cbiAgcHJpdmF0ZUtleVdpdGhEZXRhaWxzOiAoKTogVmFsaWRhdGlvblJ1bGU8c3RyaW5nPiA9PiAoe1xuICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHByaXZhdGUga2V5JyxcbiAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLnRyaW0oKSA9PT0gJycpIHJldHVybiB0cnVlIC8vIEVtcHR5IGlzIGFsbG93ZWRcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHB1YmxpYyBrZXkgbWlzdGFrZVxuICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdzc2gtcnNhJykgfHwgdmFsdWUuaW5jbHVkZXMoJ3NzaC1lZDI1NTE5JykgfHwgdmFsdWUuaW5jbHVkZXMoJ2VjZHNhLXNoYTInKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHZhbGlkYXRlUHJpdmF0ZUtleSh2YWx1ZSkgJiYgdmFsaWRhdGVQcml2YXRlS2V5RGVlcCh2YWx1ZSkgIT09IG51bGxcbiAgICB9XG4gIH0pXG59XG5cbi8vIEZvcm0gdmFsaWRhdG9yIGZvciBtdWx0aXBsZSBmaWVsZHNcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JtVmFsaWRhdG9yKFxuICBmaWVsZHM6IFJlY29yZDxzdHJpbmcsIHsgdmFsaWRhdGU6ICgpID0+IGJvb2xlYW4gfT5cbikge1xuICBjb25zdCBbaXNGb3JtVmFsaWQsIHNldElzRm9ybVZhbGlkXSA9IGNyZWF0ZVNpZ25hbCh0cnVlKVxuXG4gIGNvbnN0IHZhbGlkYXRlRm9ybSA9ICgpOiBib29sZWFuID0+IHtcbiAgICBsZXQgdmFsaWQgPSB0cnVlXG5cbiAgICBPYmplY3QudmFsdWVzKGZpZWxkcykuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgIGlmICghZmllbGQudmFsaWRhdGUoKSkge1xuICAgICAgICB2YWxpZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHNldElzRm9ybVZhbGlkKHZhbGlkKVxuICAgIHJldHVybiB2YWxpZFxuICB9XG5cbiAgY29uc3QgcmVzZXRGb3JtID0gKCkgPT4ge1xuICAgIE9iamVjdC52YWx1ZXMoZmllbGRzKS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgaWYgKCdyZXNldCcgaW4gZmllbGQpIHtcbiAgICAgICAgOyhmaWVsZCBhcyB7IHJlc2V0OiAoKSA9PiB2b2lkIH0pLnJlc2V0KClcbiAgICAgIH1cbiAgICB9KVxuICAgIHNldElzRm9ybVZhbGlkKHRydWUpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzRm9ybVZhbGlkLFxuICAgIHZhbGlkYXRlRm9ybSxcbiAgICByZXNldEZvcm1cbiAgfVxufVxuXG4vLyBBc3luYyB2YWxpZGF0b3IgZm9yIHNlcnZlci1zaWRlIHZhbGlkYXRpb25cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBc3luY1ZhbGlkYXRvcjxUPihcbiAgdmFsdWU6IEFjY2Vzc29yPFQ+LFxuICBhc3luY1ZhbGlkYXRlOiAodmFsdWU6IFQpID0+IFByb21pc2U8eyBpc1ZhbGlkOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PixcbiAgZGVib3VuY2VNcyA9IDUwMFxuKSB7XG4gIGNvbnN0IFt2YWxpZGF0aW9uLCBzZXRWYWxpZGF0aW9uXSA9IGNyZWF0ZVNpZ25hbDxGaWVsZFZhbGlkYXRpb24+KHtcbiAgICBpc1ZhbGlkOiB0cnVlXG4gIH0pXG4gIGNvbnN0IFtpc1ZhbGlkYXRpbmcsIHNldElzVmFsaWRhdGluZ10gPSBjcmVhdGVTaWduYWwoZmFsc2UpXG5cbiAgbGV0IHRpbWVvdXRJZDogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgY29uc3QgdmFsaWRhdGUgPSAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBzZXRJc1ZhbGlkYXRpbmcodHJ1ZSlcblxuICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgICAgfVxuXG4gICAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdmFsdWUoKVxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFzeW5jVmFsaWRhdGUoY3VycmVudFZhbHVlKVxuXG4gICAgICAgICAgc2V0VmFsaWRhdGlvbihyZXN1bHQpXG4gICAgICAgICAgc2V0SXNWYWxpZGF0aW5nKGZhbHNlKVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0LmlzVmFsaWQpXG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHNldFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ1ZhbGlkYXRpb24gZXJyb3Igb2NjdXJyZWQnXG4gICAgICAgICAgfSlcbiAgICAgICAgICBzZXRJc1ZhbGlkYXRpbmcoZmFsc2UpXG4gICAgICAgICAgcmVzb2x2ZShmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfSwgZGVib3VuY2VNcylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWxpZGF0aW9uLFxuICAgIGlzVmFsaWRhdGluZyxcbiAgICB2YWxpZGF0ZSxcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuICAgICAgfVxuICAgICAgc2V0VmFsaWRhdGlvbih7IGlzVmFsaWQ6IHRydWUgfSlcbiAgICAgIHNldElzVmFsaWRhdGluZyhmYWxzZSlcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlU2lnbmFsLCBjcmVhdGVFZmZlY3QsIG9uTW91bnQgfSBmcm9tICdzb2xpZC1qcydcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCB7IE1vZGFsIH0gZnJvbSAnLi9Nb2RhbCdcbmltcG9ydCB7IEljb24gfSBmcm9tICcuL0ljb24nXG5pbXBvcnQgeyB2YWxpZGF0ZVByaXZhdGVLZXksIHZhbGlkYXRlUHJpdmF0ZUtleURlZXAgfSBmcm9tICcuLi91dGlscy5qcydcbmltcG9ydCB7IHVzZVByaXZhdGVLZXlWYWxpZGF0aW9uIH0gZnJvbSAnLi4vaG9va3MvdXNlUHJpdmF0ZUtleVZhbGlkYXRpb24nXG5pbXBvcnQgeyBjcmVhdGVGaWVsZFZhbGlkYXRvciwgVmFsaWRhdGlvblJ1bGVzIH0gZnJvbSAnLi4vdXRpbHMvdmFsaWRhdGlvbidcbmltcG9ydCB0eXBlIHsgQ2xpZW50QXV0aGVudGljYXRlUGF5bG9hZCB9IGZyb20gJy4uLy4uL3R5cGVzL2V2ZW50cy5kJ1xuXG5jb25zdCBkZWJ1ZyA9IGNyZWF0ZURlYnVnKCd3ZWJzc2gyLWNsaWVudDpsb2dpbi1tb2RhbCcpXG5cbmludGVyZmFjZSBMb2dpbk1vZGFsUHJvcHMge1xuICBpc09wZW46IGJvb2xlYW5cbiAgb25DbG9zZTogKCkgPT4gdm9pZFxuICBvblN1Ym1pdDogKGZvcm1EYXRhOiBQYXJ0aWFsPENsaWVudEF1dGhlbnRpY2F0ZVBheWxvYWQ+KSA9PiB2b2lkXG4gIG9uT3B0aW9uc0NsaWNrPzogKCkgPT4gdm9pZFxuICBpbml0aWFsVmFsdWVzPzogUGFydGlhbDxDbGllbnRBdXRoZW50aWNhdGVQYXlsb2FkPiB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgY29uc3QgTG9naW5Nb2RhbDogQ29tcG9uZW50PExvZ2luTW9kYWxQcm9wcz4gPSAocHJvcHMpID0+IHtcbiAgZGVidWcoJ0xvZ2luTW9kYWwgcmVuZGVyJywgeyBpc09wZW46IHByb3BzLmlzT3BlbiB9KVxuICBcbiAgLy8gRGVidWcgdGhlIHByb3BzIHJlYWN0aXZpdHlcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBkZWJ1ZygnTG9naW5Nb2RhbCBpc09wZW4gY2hhbmdlZDonLCBwcm9wcy5pc09wZW4pXG4gIH0pXG4gIGNvbnN0IFtmb3JtRGF0YSwgc2V0Rm9ybURhdGFdID0gY3JlYXRlU2lnbmFsPFBhcnRpYWw8Q2xpZW50QXV0aGVudGljYXRlUGF5bG9hZD4+KHtcbiAgICBob3N0OiAnJyxcbiAgICBwb3J0OiAyMixcbiAgICB1c2VybmFtZTogJycsXG4gICAgcGFzc3dvcmQ6ICcnLFxuICAgIHByaXZhdGVLZXk6ICcnLFxuICAgIHBhc3NwaHJhc2U6ICcnXG4gIH0pXG4gIFxuICBjb25zdCBbc2hvd1ByaXZhdGVLZXlTZWN0aW9uLCBzZXRTaG93UHJpdmF0ZUtleVNlY3Rpb25dID0gY3JlYXRlU2lnbmFsKGZhbHNlKVxuICBjb25zdCBbY2Fwc0xvY2tBY3RpdmUsIHNldENhcHNMb2NrQWN0aXZlXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSlcbiAgXG4gIC8vIFJlYWN0aXZlIHByaXZhdGUga2V5IHZhbGlkYXRpb25cbiAgY29uc3QgcHJpdmF0ZUtleVZhbGlkYXRpb24gPSB1c2VQcml2YXRlS2V5VmFsaWRhdGlvbigoKSA9PiBmb3JtRGF0YSgpLnByaXZhdGVLZXkgfHwgJycpXG4gIFxuICAvLyBGaWVsZCB2YWxpZGF0b3JzIGZvciBvdGhlciBmaWVsZHNcbiAgY29uc3QgaG9zdFZhbGlkYXRvciA9IGNyZWF0ZUZpZWxkVmFsaWRhdG9yKFxuICAgICgpID0+IGZvcm1EYXRhKCkuaG9zdCB8fCAnJyxcbiAgICBbVmFsaWRhdGlvblJ1bGVzLnJlcXVpcmVkKCksIFZhbGlkYXRpb25SdWxlcy5ob3N0bmFtZSgpXVxuICApXG4gIFxuICBjb25zdCB1c2VybmFtZVZhbGlkYXRvciA9IGNyZWF0ZUZpZWxkVmFsaWRhdG9yKFxuICAgICgpID0+IGZvcm1EYXRhKCkudXNlcm5hbWUgfHwgJycsXG4gICAgW1ZhbGlkYXRpb25SdWxlcy5yZXF1aXJlZCgpXVxuICApXG5cbiAgLy8gSW5pdGlhbGl6ZSBmb3JtIGRhdGEgd2l0aCBpbml0aWFsIHZhbHVlc1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9wcy5pbml0aWFsVmFsdWVzKSB7XG4gICAgICBzZXRGb3JtRGF0YShwcmV2ID0+ICh7IC4uLnByZXYsIC4uLnByb3BzLmluaXRpYWxWYWx1ZXMgfSkpXG4gICAgfVxuICB9KVxuXG4gIC8vIEhhbmRsZSBjYXBzIGxvY2sgZGV0ZWN0aW9uXG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgIHNldENhcHNMb2NrQWN0aXZlKGUuZ2V0TW9kaWZpZXJTdGF0ZSgnQ2Fwc0xvY2snKSlcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZUtleVVwID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICBzZXRDYXBzTG9ja0FjdGl2ZShlLmdldE1vZGlmaWVyU3RhdGUoJ0NhcHNMb2NrJykpXG4gIH1cblxuICBjb25zdCB1cGRhdGVGb3JtRGF0YSA9IDxLIGV4dGVuZHMga2V5b2YgQ2xpZW50QXV0aGVudGljYXRlUGF5bG9hZD4oXG4gICAga2V5OiBLLFxuICAgIHZhbHVlOiBDbGllbnRBdXRoZW50aWNhdGVQYXlsb2FkW0tdXG4gICkgPT4ge1xuICAgIHNldEZvcm1EYXRhKHByZXYgPT4gKHsgLi4ucHJldiwgW2tleV06IHZhbHVlIH0pKVxuICB9XG5cbiAgY29uc3QgaGFuZGxlRmlsZVVwbG9hZCA9IGFzeW5jIChlOiBFdmVudCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudFxuICAgIGNvbnN0IGZpbGUgPSBpbnB1dC5maWxlcz8uWzBdXG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBmaWxlLnRleHQoKVxuICAgICAgICB1cGRhdGVGb3JtRGF0YSgncHJpdmF0ZUtleScsIGNvbnRlbnQpXG4gICAgICAgIC8vIFZhbGlkYXRpb24gaGFwcGVucyBhdXRvbWF0aWNhbGx5IHZpYSByZWFjdGl2ZSBwcml2YXRlS2V5VmFsaWRhdGlvbiBob29rXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkZWJ1ZygnRXJyb3IgcmVhZGluZyBwcml2YXRlIGtleSBmaWxlOicsIGVycm9yKVxuICAgICAgICBhbGVydCgnRXJyb3IgcmVhZGluZyBwcml2YXRlIGtleSBmaWxlJylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGb3JtIHZhbGlkYXRpb25cbiAgY29uc3QgaXNGb3JtVmFsaWQgPSAoKSA9PiB7XG4gICAgY29uc3QgaGFzQ3JlZGVudGlhbHMgPSBmb3JtRGF0YSgpLnBhc3N3b3JkIHx8IGZvcm1EYXRhKCkucHJpdmF0ZUtleVxuICAgIHJldHVybiAoXG4gICAgICBob3N0VmFsaWRhdG9yLnZhbGlkYXRlKCkgJiZcbiAgICAgIHVzZXJuYW1lVmFsaWRhdG9yLnZhbGlkYXRlKCkgJiZcbiAgICAgIGhhc0NyZWRlbnRpYWxzICYmXG4gICAgICAoZm9ybURhdGEoKS5wcml2YXRlS2V5ID8gcHJpdmF0ZUtleVZhbGlkYXRpb24uaXNWYWxpZCgpIDogdHJ1ZSlcbiAgICApXG4gIH1cblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSAoZTogRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBpZiAoIWlzRm9ybVZhbGlkKCkpIHtcbiAgICAgIGRlYnVnKCdGb3JtIHZhbGlkYXRpb24gZmFpbGVkJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBwcm9wcy5vblN1Ym1pdChmb3JtRGF0YSgpKVxuICAgIHByb3BzLm9uQ2xvc2UoKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8TW9kYWwgXG4gICAgICBpc09wZW49e3Byb3BzLmlzT3Blbn0gXG4gICAgICBvbkNsb3NlPXtwcm9wcy5vbkNsb3NlfVxuICAgICAgc2hvd0Nsb3NlQnV0dG9uPXtmYWxzZX1cbiAgICAgIGNsb3NlT25CYWNrZHJvcENsaWNrPXtmYWxzZX1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwicmVsYXRpdmUgYmctd2hpdGUgdGV4dC1zbGF0ZS04MDAgYm9yZGVyIGJvcmRlci1uZXV0cmFsLTMwMCByb3VuZGVkLW1kIHNoYWRvdy1tZCBwLTYgdy04MCBzbTp3LVsyOHJlbV1cIj5cbiAgICAgICAgPGgyIGNsYXNzPVwidGV4dC1sZyBmb250LXNlbWlib2xkIHRleHQtc2xhdGUtOTAwIG1iLTRcIj5XZWJTU0gyIExvZ2luPC9oMj5cbiAgICAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdH0gY2xhc3M9XCJzcGFjZS15LTNcIj5cbiAgICAgICAgICB7LyogSG9zdCAqL31cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImhvc3RJbnB1dFwiIGNsYXNzPVwic3Itb25seVwiPkhvc3Q8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgaWQ9XCJob3N0SW5wdXRcIlxuICAgICAgICAgICAgICBuYW1lPVwiaG9zdFwiXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiSG9zdFwiXG4gICAgICAgICAgICAgIHJlcXVpcmVkXG4gICAgICAgICAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplPVwib2ZmXCJcbiAgICAgICAgICAgICAgc3BlbGxjaGVjaz17ZmFsc2V9XG4gICAgICAgICAgICAgIGVudGVya2V5aGludD1cIm5leHRcIlxuICAgICAgICAgICAgICBjbGFzcz1cImJsb2NrIHctZnVsbCByb3VuZGVkLW1kIGJvcmRlciBib3JkZXItc2xhdGUtMzAwIGJnLXdoaXRlIHRleHQtc2xhdGUtOTAwIHBsYWNlaG9sZGVyLXNsYXRlLTQwMCBweC0zIHB5LTIgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwIGZvY3VzOmJvcmRlci1ibHVlLTUwMFwiXG4gICAgICAgICAgICAgIHZhbHVlPXtmb3JtRGF0YSgpLmhvc3QgfHwgJyd9XG4gICAgICAgICAgICAgIG9uSW5wdXQ9eyhlKSA9PiB1cGRhdGVGb3JtRGF0YSgnaG9zdCcsIGUuY3VycmVudFRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIFBvcnQgKi99XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJwb3J0SW5wdXRcIiBjbGFzcz1cInNyLW9ubHlcIj5Qb3J0PC9sYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgIGlkPVwicG9ydElucHV0XCJcbiAgICAgICAgICAgICAgbmFtZT1cInBvcnRcIlxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlBvcnRcIlxuICAgICAgICAgICAgICBhdXRvY29tcGxldGU9XCJvZmZcIlxuICAgICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZT1cIm9mZlwiXG4gICAgICAgICAgICAgIHNwZWxsY2hlY2s9e2ZhbHNlfVxuICAgICAgICAgICAgICBlbnRlcmtleWhpbnQ9XCJuZXh0XCJcbiAgICAgICAgICAgICAgaW5wdXRtb2RlPVwibnVtZXJpY1wiXG4gICAgICAgICAgICAgIHBhdHRlcm49XCJbMC05XSpcIlxuICAgICAgICAgICAgICBjbGFzcz1cImJsb2NrIHctZnVsbCByb3VuZGVkLW1kIGJvcmRlciBib3JkZXItc2xhdGUtMzAwIGJnLXdoaXRlIHRleHQtc2xhdGUtOTAwIHBsYWNlaG9sZGVyLXNsYXRlLTQwMCBweC0zIHB5LTIgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwIGZvY3VzOmJvcmRlci1ibHVlLTUwMFwiXG4gICAgICAgICAgICAgIHZhbHVlPXtmb3JtRGF0YSgpLnBvcnQgfHwgJzIyJ31cbiAgICAgICAgICAgICAgb25JbnB1dD17KGUpID0+IHVwZGF0ZUZvcm1EYXRhKCdwb3J0JywgcGFyc2VJbnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKSB8fCAyMil9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIFVzZXJuYW1lICovfVxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwidXNlcm5hbWVJbnB1dFwiIGNsYXNzPVwic3Itb25seVwiPlVzZXJuYW1lPC9sYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgIGlkPVwidXNlcm5hbWVJbnB1dFwiXG4gICAgICAgICAgICAgIG5hbWU9XCJ1c2VybmFtZVwiXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVXNlcm5hbWVcIlxuICAgICAgICAgICAgICByZXF1aXJlZFxuICAgICAgICAgICAgICBhdXRvY29tcGxldGU9XCJ1c2VybmFtZVwiXG4gICAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplPVwib2ZmXCJcbiAgICAgICAgICAgICAgc3BlbGxjaGVjaz17ZmFsc2V9XG4gICAgICAgICAgICAgIGVudGVya2V5aGludD1cIm5leHRcIlxuICAgICAgICAgICAgICBjbGFzcz1cImJsb2NrIHctZnVsbCByb3VuZGVkLW1kIGJvcmRlciBib3JkZXItc2xhdGUtMzAwIGJnLXdoaXRlIHRleHQtc2xhdGUtOTAwIHBsYWNlaG9sZGVyLXNsYXRlLTQwMCBweC0zIHB5LTIgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwIGZvY3VzOmJvcmRlci1ibHVlLTUwMFwiXG4gICAgICAgICAgICAgIHZhbHVlPXtmb3JtRGF0YSgpLnVzZXJuYW1lIHx8ICcnfVxuICAgICAgICAgICAgICBvbklucHV0PXsoZSkgPT4gdXBkYXRlRm9ybURhdGEoJ3VzZXJuYW1lJywgZS5jdXJyZW50VGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICB7LyogUGFzc3dvcmQgKi99XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInBhc3N3b3JkLXdyYXBwZXIgcmVsYXRpdmUgdy1mdWxsXCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwicGFzc3dvcmRJbnB1dFwiIGNsYXNzPVwic3Itb25seVwiPlBhc3N3b3JkPC9sYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwicGFzc3dvcmRcIlxuICAgICAgICAgICAgICBpZD1cInBhc3N3b3JkSW5wdXRcIlxuICAgICAgICAgICAgICBuYW1lPVwicGFzc3dvcmRcIlxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCJcbiAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlPVwiY3VycmVudC1wYXNzd29yZFwiXG4gICAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplPVwib2ZmXCJcbiAgICAgICAgICAgICAgc3BlbGxjaGVjaz17ZmFsc2V9XG4gICAgICAgICAgICAgIGVudGVya2V5aGludD1cImdvXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJibG9jayB3LWZ1bGwgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXNsYXRlLTMwMCBiZy13aGl0ZSB0ZXh0LXNsYXRlLTkwMCBwbGFjZWhvbGRlci1zbGF0ZS00MDAgcHgtMyBweS0yIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ibHVlLTUwMCBmb2N1czpib3JkZXItYmx1ZS01MDBcIlxuICAgICAgICAgICAgICB2YWx1ZT17Zm9ybURhdGEoKS5wYXNzd29yZCB8fCAnJ31cbiAgICAgICAgICAgICAgb25JbnB1dD17KGUpID0+IHVwZGF0ZUZvcm1EYXRhKCdwYXNzd29yZCcsIGUuY3VycmVudFRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgIG9uS2V5RG93bj17aGFuZGxlS2V5RG93bn1cbiAgICAgICAgICAgICAgb25LZXlVcD17aGFuZGxlS2V5VXB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPHNwYW4gXG4gICAgICAgICAgICAgIGNsYXNzPXtgJHtjYXBzTG9ja0FjdGl2ZSgpID8gJycgOiAnaGlkZGVuJ30gYWJzb2x1dGUgcmlnaHQtMiB0b3AtMS8yIC10cmFuc2xhdGUteS0xLzIgdGV4dC1yZWQtNTAwIHBvaW50ZXItZXZlbnRzLW5vbmVgfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICDih6pcbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHsvKiBPcHRpb25zIHJvdyAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIGdhcC0yXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHJpdmF0ZS1rZXktdG9nZ2xlXCI+XG4gICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLW1kIGJvcmRlciBib3JkZXItdHJhbnNwYXJlbnQgcHgtMyBweS0yIHRleHQtc20gZm9udC1tZWRpdW0gYmctc2xhdGUtNjAwIHRleHQtd2hpdGUgaG92ZXI6Ymctc2xhdGUtNzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1vZmZzZXQtMiBmb2N1czpyaW5nLXNsYXRlLTUwMCBkaXNhYmxlZDpvcGFjaXR5LTUwIGRpc2FibGVkOnBvaW50ZXItZXZlbnRzLW5vbmUgc2hhZG93LXNtXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTaG93UHJpdmF0ZUtleVNlY3Rpb24oIXNob3dQcml2YXRlS2V5U2VjdGlvbigpKX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxJY29uIG5hbWU9XCJrZXlcIiBjbGFzcz1cImljb24tZndcIiAvPiB7c2hvd1ByaXZhdGVLZXlTZWN0aW9uKCkgPyAnSGlkZSBTU0ggS2V5JyA6ICdBZGQgU1NIIEtleSd9XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHB4LTMgcHktMiB0ZXh0LXNtIGZvbnQtbWVkaXVtIGJnLXNsYXRlLTcwMCB0ZXh0LXdoaXRlIGhvdmVyOmJnLXNsYXRlLTgwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctb2Zmc2V0LTIgZm9jdXM6cmluZy1zbGF0ZS01MDAgZGlzYWJsZWQ6b3BhY2l0eS01MCBkaXNhYmxlZDpwb2ludGVyLWV2ZW50cy1ub25lIHNoYWRvdy1zbVwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gcHJvcHMub25PcHRpb25zQ2xpY2s/LigpfVxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJPcHRpb25zXCJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIk9wdGlvbnNcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPEljb24gbmFtZT1cInNldHRpbmdzXCIgY2xhc3M9XCJpY29uLWZ3XCIgLz4gT3B0aW9uc1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIFByaXZhdGUga2V5IHNlY3Rpb24gKi99XG4gICAgICAgICAgPGRpdiBjbGFzcz17c2hvd1ByaXZhdGVLZXlTZWN0aW9uKCkgPyAnJyA6ICdoaWRkZW4nfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwcml2YXRlLWtleS1pbnB1dCBtdC0yIHAtMyByb3VuZGVkIGJvcmRlciBib3JkZXItbmV1dHJhbC0zMDAgYmctbmV1dHJhbC01MCB0ZXh0LW5ldXRyYWwtODAwXCI+XG4gICAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJwcml2YXRlS2V5VGV4dFwiIGNsYXNzPVwic3Itb25seVwiPlByaXZhdGUgS2V5PC9sYWJlbD5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJlbGF0aXZlXCI+XG4gICAgICAgICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICAgICAgICBpZD1cInByaXZhdGVLZXlUZXh0XCJcbiAgICAgICAgICAgICAgICAgIG5hbWU9XCJwcml2YXRlS2V5XCJcbiAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICAgICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZT1cIm9mZlwiXG4gICAgICAgICAgICAgICAgICBzcGVsbGNoZWNrPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiUGFzdGUgeW91ciBwcml2YXRlIGtleSBoZXJlXCJcbiAgICAgICAgICAgICAgICAgIHJvd3M9ezN9XG4gICAgICAgICAgICAgICAgICBjbGFzcz1cImJsb2NrIHctZnVsbCByb3VuZGVkLW1kIGJvcmRlciBweC0zIHB5LTIgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwIG1iLTJcIlxuICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0PXt7XG4gICAgICAgICAgICAgICAgICAgICdib3JkZXItc2xhdGUtMzAwIGJnLXdoaXRlIHRleHQtc2xhdGUtOTAwIHBsYWNlaG9sZGVyLXNsYXRlLTQwMCc6ICFmb3JtRGF0YSgpLnByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgICAgICdib3JkZXItcmVkLTUwMCBiZy1yZWQtNTAgdGV4dC1zbGF0ZS05MDAgcGxhY2Vob2xkZXItc2xhdGUtNDAwJzogZm9ybURhdGEoKS5wcml2YXRlS2V5ICYmICFwcml2YXRlS2V5VmFsaWRhdGlvbi5pc1ZhbGlkKCksXG4gICAgICAgICAgICAgICAgICAgICdib3JkZXItZ3JlZW4tNTAwIGJnLWdyZWVuLTUwIHRleHQtc2xhdGUtOTAwIHBsYWNlaG9sZGVyLXNsYXRlLTQwMCc6IGZvcm1EYXRhKCkucHJpdmF0ZUtleSAmJiBwcml2YXRlS2V5VmFsaWRhdGlvbi5pc1ZhbGlkKClcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICB2YWx1ZT17Zm9ybURhdGEoKS5wcml2YXRlS2V5IHx8ICcnfVxuICAgICAgICAgICAgICAgICAgb25JbnB1dD17KGUpID0+IHVwZGF0ZUZvcm1EYXRhKCdwcml2YXRlS2V5JywgZS5jdXJyZW50VGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICA+PC90ZXh0YXJlYT5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB7LyogVmFsaWRhdGlvbiBzdGF0dXMgaW5kaWNhdG9yICovfVxuICAgICAgICAgICAgICAgIHtmb3JtRGF0YSgpLnByaXZhdGVLZXkgJiYgKFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFic29sdXRlIHJpZ2h0LTIgdG9wLTJcIj5cbiAgICAgICAgICAgICAgICAgICAge3ByaXZhdGVLZXlWYWxpZGF0aW9uLmlzVmFsaWQoKSA/IChcbiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRleHQtZ3JlZW4tNTAwXCIgdGl0bGU9e2BWYWxpZCAke3ByaXZhdGVLZXlWYWxpZGF0aW9uLmZvcm1hdCgpfSBrZXlgfT7inJM8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LXJlZC01MDBcIiB0aXRsZT17cHJpdmF0ZUtleVZhbGlkYXRpb24uZXJyb3IoKX0+4pyXPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB7LyogVmFsaWRhdGlvbiBlcnJvciBtZXNzYWdlICovfVxuICAgICAgICAgICAgICB7Zm9ybURhdGEoKS5wcml2YXRlS2V5ICYmICFwcml2YXRlS2V5VmFsaWRhdGlvbi5pc1ZhbGlkKCkgJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYi0yIHRleHQtc21cIj5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwidGV4dC1yZWQtNjAwXCI+e3ByaXZhdGVLZXlWYWxpZGF0aW9uLmVycm9yKCl9PC9wPlxuICAgICAgICAgICAgICAgICAge3ByaXZhdGVLZXlWYWxpZGF0aW9uLnN1Z2dlc3Rpb24oKSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwidGV4dC1ncmF5LTYwMCBtdC0xXCI+e3ByaXZhdGVLZXlWYWxpZGF0aW9uLnN1Z2dlc3Rpb24oKX08L3A+XG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgey8qIEtleSBmb3JtYXQgYmFkZ2UgKi99XG4gICAgICAgICAgICAgIHtmb3JtRGF0YSgpLnByaXZhdGVLZXkgJiYgcHJpdmF0ZUtleVZhbGlkYXRpb24uaXNWYWxpZCgpICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWItMlwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIgcHgtMiBweS0xIHRleHQteHMgZm9udC1tZWRpdW0gcm91bmRlZC1mdWxsIGJnLWdyZWVuLTEwMCB0ZXh0LWdyZWVuLTgwMFwiPlxuICAgICAgICAgICAgICAgICAgICB7cHJpdmF0ZUtleVZhbGlkYXRpb24uZm9ybWF0KCl9IGZvcm1hdCBkZXRlY3RlZFxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpbGUtdXBsb2FkIG1iLTJcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJmaWxlXCJcbiAgICAgICAgICAgICAgICAgIGlkPVwicHJpdmF0ZUtleUZpbGVcIlxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJzci1vbmx5XCJcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVGaWxlVXBsb2FkfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPGxhYmVsXG4gICAgICAgICAgICAgICAgICBmb3I9XCJwcml2YXRlS2V5RmlsZVwiXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cImlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLW1kIGJvcmRlciBib3JkZXItdHJhbnNwYXJlbnQgcHgtMyBweS0yIHRleHQtc20gZm9udC1tZWRpdW0gYmctc2xhdGUtNjAwIHRleHQtd2hpdGUgaG92ZXI6Ymctc2xhdGUtNzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1vZmZzZXQtMiBmb2N1czpyaW5nLXNsYXRlLTUwMCBkaXNhYmxlZDpvcGFjaXR5LTUwIGRpc2FibGVkOnBvaW50ZXItZXZlbnRzLW5vbmUgc2hhZG93LXNtIGN1cnNvci1wb2ludGVyXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8SWNvbiBuYW1lPVwidXBsb2FkXCIgY2xhc3M9XCJpY29uLWZ3XCIgLz4gVXBsb2FkIEtleSBGaWxlXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cInBhc3NwaHJhc2VJbnB1dFwiIGNsYXNzPVwic3Itb25seVwiPktleSBQYXNzcGhyYXNlPC9sYWJlbD5cbiAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdHlwZT1cInBhc3N3b3JkXCJcbiAgICAgICAgICAgICAgICBpZD1cInBhc3NwaHJhc2VJbnB1dFwiXG4gICAgICAgICAgICAgICAgbmFtZT1cInBhc3NwaHJhc2VcIlxuICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU9XCJvZmZcIlxuICAgICAgICAgICAgICAgIHNwZWxsY2hlY2s9e2ZhbHNlfVxuICAgICAgICAgICAgICAgIGVudGVya2V5aGludD1cImdvXCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIktleSBwYXNzd29yZCAoaWYgZW5jcnlwdGVkKVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJibG9jayB3LWZ1bGwgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXNsYXRlLTMwMCBiZy13aGl0ZSB0ZXh0LXNsYXRlLTkwMCBwbGFjZWhvbGRlci1zbGF0ZS00MDAgcHgtMyBweS0yIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ibHVlLTUwMCBmb2N1czpib3JkZXItYmx1ZS01MDBcIlxuICAgICAgICAgICAgICAgIHZhbHVlPXtmb3JtRGF0YSgpLnBhc3NwaHJhc2UgfHwgJyd9XG4gICAgICAgICAgICAgICAgb25JbnB1dD17KGUpID0+IHVwZGF0ZUZvcm1EYXRhKCdwYXNzcGhyYXNlJywgZS5jdXJyZW50VGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIFN1Ym1pdCBidXR0b24gKi99XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImxvZ2luLWJ1dHRvbnMgbXQtNFwiPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFpc0Zvcm1WYWxpZCgpfVxuICAgICAgICAgICAgICBjbGFzcz1cImlubGluZS1mbGV4IHctZnVsbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHB4LTMgcHktMiB0ZXh0LXNtIGZvbnQtbWVkaXVtIGJnLWJsdWUtNjAwIHRleHQtd2hpdGUgaG92ZXI6YmctYmx1ZS03MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLW9mZnNldC0yIGZvY3VzOnJpbmctYmx1ZS01MDAgZGlzYWJsZWQ6b3BhY2l0eS01MCBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgZGlzYWJsZWQ6cG9pbnRlci1ldmVudHMtbm9uZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIENvbm5lY3RcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Zvcm0+XG4gICAgICA8L2Rpdj5cbiAgICA8L01vZGFsPlxuICApXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVTaWduYWwsIGNyZWF0ZUVmZmVjdCB9IGZyb20gJ3NvbGlkLWpzJ1xuaW1wb3J0IHsgTW9kYWwgfSBmcm9tICcuL01vZGFsJ1xuaW1wb3J0IHR5cGUgeyBJVGVybWluYWxPcHRpb25zIH0gZnJvbSAnQHh0ZXJtL3h0ZXJtJ1xuaW1wb3J0IHsgZ2V0U3RvcmVkU2V0dGluZ3MsIHNhdmVUZXJtaW5hbFNldHRpbmdzIH0gZnJvbSAnLi4vc2V0dGluZ3MuanMnXG5pbXBvcnQgeyBkZWZhdWx0U2V0dGluZ3MgfSBmcm9tICcuLi91dGlscy5qcydcbmltcG9ydCB0eXBlIHsgVGVybWluYWxTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3R5cGVzL2NvbmZpZy5kJ1xuXG5pbnRlcmZhY2UgVGVybWluYWxTZXR0aW5nc01vZGFsUHJvcHMge1xuICBpc09wZW46IGJvb2xlYW5cbiAgb25DbG9zZTogKCkgPT4gdm9pZFxuICBvblNhdmU6IChzZXR0aW5nczogUGFydGlhbDxJVGVybWluYWxPcHRpb25zPikgPT4gdm9pZFxufVxuXG5pbnRlcmZhY2UgVGVybWluYWxTZXR0aW5nc0Zvcm0ge1xuICBmb250U2l6ZTogbnVtYmVyXG4gIGZvbnRGYW1pbHk6IHN0cmluZ1xuICBjdXJzb3JCbGluazogYm9vbGVhblxuICBzY3JvbGxiYWNrOiBudW1iZXJcbiAgdGFiU3RvcFdpZHRoOiBudW1iZXJcbiAgYmVsbFN0eWxlOiAnc291bmQnIHwgJ25vbmUnXG59XG5cbmV4cG9ydCBjb25zdCBUZXJtaW5hbFNldHRpbmdzTW9kYWw6IENvbXBvbmVudDxUZXJtaW5hbFNldHRpbmdzTW9kYWxQcm9wcz4gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW3NldHRpbmdzLCBzZXRTZXR0aW5nc10gPSBjcmVhdGVTaWduYWw8VGVybWluYWxTZXR0aW5nc0Zvcm0+KHtcbiAgICBmb250U2l6ZTogZGVmYXVsdFNldHRpbmdzLmZvbnRTaXplLFxuICAgIGZvbnRGYW1pbHk6IGRlZmF1bHRTZXR0aW5ncy5mb250RmFtaWx5LFxuICAgIGN1cnNvckJsaW5rOiBkZWZhdWx0U2V0dGluZ3MuY3Vyc29yQmxpbmssXG4gICAgc2Nyb2xsYmFjazogZGVmYXVsdFNldHRpbmdzLnNjcm9sbGJhY2ssXG4gICAgdGFiU3RvcFdpZHRoOiBkZWZhdWx0U2V0dGluZ3MudGFiU3RvcFdpZHRoLFxuICAgIGJlbGxTdHlsZTogJ25vbmUnXG4gIH0pXG5cbiAgLy8gTG9hZCBjdXJyZW50IHNldHRpbmdzIHdoZW4gbW9kYWwgb3BlbnNcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvcHMuaXNPcGVuKSB7XG4gICAgICBjb25zdCBzdG9yZWQgPSBnZXRTdG9yZWRTZXR0aW5ncygpIGFzIFBhcnRpYWw8VGVybWluYWxTZXR0aW5ncz5cbiAgICAgIHNldFNldHRpbmdzKHtcbiAgICAgICAgZm9udFNpemU6IHN0b3JlZC5mb250U2l6ZSB8fCBkZWZhdWx0U2V0dGluZ3MuZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHk6IHN0b3JlZC5mb250RmFtaWx5IHx8IGRlZmF1bHRTZXR0aW5ncy5mb250RmFtaWx5LFxuICAgICAgICBjdXJzb3JCbGluazogc3RvcmVkLmN1cnNvckJsaW5rID8/IGRlZmF1bHRTZXR0aW5ncy5jdXJzb3JCbGluayxcbiAgICAgICAgc2Nyb2xsYmFjazogc3RvcmVkLnNjcm9sbGJhY2sgfHwgZGVmYXVsdFNldHRpbmdzLnNjcm9sbGJhY2ssXG4gICAgICAgIHRhYlN0b3BXaWR0aDogc3RvcmVkLnRhYlN0b3BXaWR0aCB8fCBkZWZhdWx0U2V0dGluZ3MudGFiU3RvcFdpZHRoLFxuICAgICAgICBiZWxsU3R5bGU6IChzdG9yZWQuYmVsbFN0eWxlIGFzICdzb3VuZCcgfCAnbm9uZScpIHx8ICdub25lJ1xuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgY29uc3QgdXBkYXRlU2V0dGluZyA9IDxLIGV4dGVuZHMga2V5b2YgVGVybWluYWxTZXR0aW5nc0Zvcm0+KFxuICAgIGtleTogSyxcbiAgICB2YWx1ZTogVGVybWluYWxTZXR0aW5nc0Zvcm1bS11cbiAgKSA9PiB7XG4gICAgc2V0U2V0dGluZ3MocHJldiA9PiAoeyAuLi5wcmV2LCBba2V5XTogdmFsdWUgfSkpXG4gIH1cblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSAoZTogRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBjb25zdCBjdXJyZW50U2V0dGluZ3MgPSBzZXR0aW5ncygpXG4gICAgXG4gICAgLy8gQ29udmVydCB0byBJVGVybWluYWxPcHRpb25zIGZvcm1hdFxuICAgIGNvbnN0IHRlcm1pbmFsT3B0aW9uczogUGFydGlhbDxJVGVybWluYWxPcHRpb25zPiA9IHtcbiAgICAgIGZvbnRTaXplOiBjdXJyZW50U2V0dGluZ3MuZm9udFNpemUsXG4gICAgICBmb250RmFtaWx5OiBjdXJyZW50U2V0dGluZ3MuZm9udEZhbWlseSxcbiAgICAgIGN1cnNvckJsaW5rOiBjdXJyZW50U2V0dGluZ3MuY3Vyc29yQmxpbmssXG4gICAgICBzY3JvbGxiYWNrOiBjdXJyZW50U2V0dGluZ3Muc2Nyb2xsYmFjayxcbiAgICAgIHRhYlN0b3BXaWR0aDogY3VycmVudFNldHRpbmdzLnRhYlN0b3BXaWR0aFxuICAgIH1cblxuICAgIC8vIFNhdmUgc2V0dGluZ3NcbiAgICBzYXZlVGVybWluYWxTZXR0aW5ncyhjdXJyZW50U2V0dGluZ3MgYXMgdW5rbm93biBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilcbiAgICBcbiAgICAvLyBBcHBseSB0byB0ZXJtaW5hbFxuICAgIHByb3BzLm9uU2F2ZSh0ZXJtaW5hbE9wdGlvbnMpXG4gICAgcHJvcHMub25DbG9zZSgpXG4gIH1cblxuICBjb25zdCBoYW5kbGVDYW5jZWwgPSAoKSA9PiB7XG4gICAgcHJvcHMub25DbG9zZSgpXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxNb2RhbCBcbiAgICAgIGlzT3Blbj17cHJvcHMuaXNPcGVufSBcbiAgICAgIG9uQ2xvc2U9e3Byb3BzLm9uQ2xvc2V9XG4gICAgICBzaG93Q2xvc2VCdXR0b249e2ZhbHNlfVxuICAgICAgY2xvc2VPbkJhY2tkcm9wQ2xpY2s9e2ZhbHNlfVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJyZWxhdGl2ZSBiZy13aGl0ZSB0ZXh0LXNsYXRlLTgwMCBib3JkZXIgYm9yZGVyLW5ldXRyYWwtMzAwIHJvdW5kZWQtbWQgc2hhZG93LW1kIHAtNiB3LTgwIHNtOnctWzM2cmVtXVwiPlxuICAgICAgICA8aDIgY2xhc3M9XCJ0ZXh0LWxnIGZvbnQtc2VtaWJvbGQgdGV4dC1zbGF0ZS05MDAgbWItNFwiPlRlcm1pbmFsIFNldHRpbmdzPC9oMj5cbiAgICAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdH0gY2xhc3M9XCJzcGFjZS15LTRcIj5cbiAgICAgICAgICA8ZmllbGRzZXQgY2xhc3M9XCJncmlkIGdyaWQtY29scy0xIHNtOmdyaWQtY29scy1bYXV0bywxZnJdIGdhcC14LTQgZ2FwLXktMyBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgIDxsZWdlbmQgY2xhc3M9XCJzci1vbmx5XCI+VGVybWluYWwgT3B0aW9uczwvbGVnZW5kPlxuXG4gICAgICAgICAgICB7LyogRm9udCBTaXplICovfVxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImZvbnRTaXplXCIgY2xhc3M9XCJ0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtc2xhdGUtNzAwIHNtOnRleHQtcmlnaHQgcHItMyB3aGl0ZXNwYWNlLW5vd3JhcFwiPlxuICAgICAgICAgICAgICBGb250IFNpemVcbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgICAgIGlkPVwiZm9udFNpemVcIlxuICAgICAgICAgICAgICBuYW1lPVwiZm9udFNpemVcIlxuICAgICAgICAgICAgICBtaW49XCI4XCJcbiAgICAgICAgICAgICAgbWF4PVwiNzJcIlxuICAgICAgICAgICAgICByZXF1aXJlZFxuICAgICAgICAgICAgICBjbGFzcz1cImJsb2NrIHctZnVsbCByb3VuZGVkLW1kIGJvcmRlciBib3JkZXItc2xhdGUtMzAwIGJnLXdoaXRlIHRleHQtc2xhdGUtOTAwIHBsYWNlaG9sZGVyLXNsYXRlLTQwMCBweC0zIHB5LTIgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwIGZvY3VzOmJvcmRlci1ibHVlLTUwMFwiXG4gICAgICAgICAgICAgIHZhbHVlPXtzZXR0aW5ncygpLmZvbnRTaXplfVxuICAgICAgICAgICAgICBvbklucHV0PXsoZSkgPT4gdXBkYXRlU2V0dGluZygnZm9udFNpemUnLCBwYXJzZUludChlLmN1cnJlbnRUYXJnZXQudmFsdWUpIHx8IGRlZmF1bHRTZXR0aW5ncy5mb250U2l6ZSl9XG4gICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICB7LyogRm9udCBGYW1pbHkgKi99XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwiZm9udEZhbWlseVwiIGNsYXNzPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LXNsYXRlLTcwMCBzbTp0ZXh0LXJpZ2h0IHByLTMgd2hpdGVzcGFjZS1ub3dyYXBcIj5cbiAgICAgICAgICAgICAgRm9udCBGYW1pbHlcbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICBpZD1cImZvbnRGYW1pbHlcIlxuICAgICAgICAgICAgICBuYW1lPVwiZm9udEZhbWlseVwiXG4gICAgICAgICAgICAgIHJlcXVpcmVkXG4gICAgICAgICAgICAgIGNsYXNzPVwiYmxvY2sgdy1mdWxsIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci1zbGF0ZS0zMDAgYmctd2hpdGUgdGV4dC1zbGF0ZS05MDAgcGxhY2Vob2xkZXItc2xhdGUtNDAwIHB4LTMgcHktMiBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYmx1ZS01MDAgZm9jdXM6Ym9yZGVyLWJsdWUtNTAwXCJcbiAgICAgICAgICAgICAgdmFsdWU9e3NldHRpbmdzKCkuZm9udEZhbWlseX1cbiAgICAgICAgICAgICAgb25JbnB1dD17KGUpID0+IHVwZGF0ZVNldHRpbmcoJ2ZvbnRGYW1pbHknLCBlLmN1cnJlbnRUYXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgLz5cblxuICAgICAgICAgICAgey8qIEN1cnNvciBCbGluayAqL31cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJjdXJzb3JCbGlua1wiIGNsYXNzPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LXNsYXRlLTcwMCBzbTp0ZXh0LXJpZ2h0IHByLTMgd2hpdGVzcGFjZS1ub3dyYXBcIj5cbiAgICAgICAgICAgICAgQ3Vyc29yIEJsaW5rXG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgICBpZD1cImN1cnNvckJsaW5rXCJcbiAgICAgICAgICAgICAgbmFtZT1cImN1cnNvckJsaW5rXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJibG9jayB3LWZ1bGwgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXNsYXRlLTMwMCBiZy13aGl0ZSB0ZXh0LXNsYXRlLTkwMCBweC0zIHB5LTIgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwIGZvY3VzOmJvcmRlci1ibHVlLTUwMFwiXG4gICAgICAgICAgICAgIHZhbHVlPXtzZXR0aW5ncygpLmN1cnNvckJsaW5rID8gJ3RydWUnIDogJ2ZhbHNlJ31cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiB1cGRhdGVTZXR0aW5nKCdjdXJzb3JCbGluaycsIGUuY3VycmVudFRhcmdldC52YWx1ZSA9PT0gJ3RydWUnKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInRydWVcIj5Pbjwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiZmFsc2VcIj5PZmY8L29wdGlvbj5cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuXG4gICAgICAgICAgICB7LyogU2Nyb2xsYmFjayAqL31cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJzY3JvbGxiYWNrXCIgY2xhc3M9XCJ0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtc2xhdGUtNzAwIHNtOnRleHQtcmlnaHQgcHItMyB3aGl0ZXNwYWNlLW5vd3JhcFwiPlxuICAgICAgICAgICAgICBTY3JvbGxiYWNrXG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgICBpZD1cInNjcm9sbGJhY2tcIlxuICAgICAgICAgICAgICBuYW1lPVwic2Nyb2xsYmFja1wiXG4gICAgICAgICAgICAgIG1pbj1cIjFcIlxuICAgICAgICAgICAgICBtYXg9XCIyMDAwMDBcIlxuICAgICAgICAgICAgICByZXF1aXJlZFxuICAgICAgICAgICAgICBjbGFzcz1cImJsb2NrIHctZnVsbCByb3VuZGVkLW1kIGJvcmRlciBib3JkZXItc2xhdGUtMzAwIGJnLXdoaXRlIHRleHQtc2xhdGUtOTAwIHBsYWNlaG9sZGVyLXNsYXRlLTQwMCBweC0zIHB5LTIgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwIGZvY3VzOmJvcmRlci1ibHVlLTUwMFwiXG4gICAgICAgICAgICAgIHZhbHVlPXtzZXR0aW5ncygpLnNjcm9sbGJhY2t9XG4gICAgICAgICAgICAgIG9uSW5wdXQ9eyhlKSA9PiB1cGRhdGVTZXR0aW5nKCdzY3JvbGxiYWNrJywgcGFyc2VJbnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKSB8fCBkZWZhdWx0U2V0dGluZ3Muc2Nyb2xsYmFjayl9XG4gICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICB7LyogVGFiIFN0b3AgV2lkdGggKi99XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwidGFiU3RvcFdpZHRoXCIgY2xhc3M9XCJ0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtc2xhdGUtNzAwIHNtOnRleHQtcmlnaHQgcHItMyB3aGl0ZXNwYWNlLW5vd3JhcFwiPlxuICAgICAgICAgICAgICBUYWIgU3RvcCBXaWR0aFxuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgaWQ9XCJ0YWJTdG9wV2lkdGhcIlxuICAgICAgICAgICAgICBuYW1lPVwidGFiU3RvcFdpZHRoXCJcbiAgICAgICAgICAgICAgbWluPVwiMVwiXG4gICAgICAgICAgICAgIG1heD1cIjEwMFwiXG4gICAgICAgICAgICAgIHJlcXVpcmVkXG4gICAgICAgICAgICAgIGNsYXNzPVwiYmxvY2sgdy1mdWxsIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci1zbGF0ZS0zMDAgYmctd2hpdGUgdGV4dC1zbGF0ZS05MDAgcGxhY2Vob2xkZXItc2xhdGUtNDAwIHB4LTMgcHktMiBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYmx1ZS01MDAgZm9jdXM6Ym9yZGVyLWJsdWUtNTAwXCJcbiAgICAgICAgICAgICAgdmFsdWU9e3NldHRpbmdzKCkudGFiU3RvcFdpZHRofVxuICAgICAgICAgICAgICBvbklucHV0PXsoZSkgPT4gdXBkYXRlU2V0dGluZygndGFiU3RvcFdpZHRoJywgcGFyc2VJbnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKSB8fCBkZWZhdWx0U2V0dGluZ3MudGFiU3RvcFdpZHRoKX1cbiAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgIHsvKiBCZWxsIFN0eWxlICovfVxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cImJlbGxTdHlsZVwiIGNsYXNzPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LXNsYXRlLTcwMCBzbTp0ZXh0LXJpZ2h0IHByLTMgd2hpdGVzcGFjZS1ub3dyYXBcIj5cbiAgICAgICAgICAgICAgQmVsbCBTdHlsZVxuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgIDxzZWxlY3RcbiAgICAgICAgICAgICAgaWQ9XCJiZWxsU3R5bGVcIlxuICAgICAgICAgICAgICBuYW1lPVwiYmVsbFN0eWxlXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJibG9jayB3LWZ1bGwgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXNsYXRlLTMwMCBiZy13aGl0ZSB0ZXh0LXNsYXRlLTkwMCBweC0zIHB5LTIgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwIGZvY3VzOmJvcmRlci1ibHVlLTUwMFwiXG4gICAgICAgICAgICAgIHZhbHVlPXtzZXR0aW5ncygpLmJlbGxTdHlsZX1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiB1cGRhdGVTZXR0aW5nKCdiZWxsU3R5bGUnLCBlLmN1cnJlbnRUYXJnZXQudmFsdWUgYXMgJ3NvdW5kJyB8ICdub25lJyl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzb3VuZFwiPlNvdW5kPC9vcHRpb24+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJub25lXCI+Tm9uZTwvb3B0aW9uPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgPC9maWVsZHNldD5cblxuICAgICAgICAgIHsvKiBCdXR0b25zICovfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGdhcC0yIHB0LTQganVzdGlmeS1lbmRcIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICAgIGNsYXNzPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci10cmFuc3BhcmVudCBweC0zIHB5LTIgdGV4dC1zbSBmb250LW1lZGl1bSBiZy1ibHVlLTYwMCB0ZXh0LXdoaXRlIGhvdmVyOmJnLWJsdWUtNzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1vZmZzZXQtMiBmb2N1czpyaW5nLWJsdWUtNTAwIGRpc2FibGVkOm9wYWNpdHktNTAgZGlzYWJsZWQ6cG9pbnRlci1ldmVudHMtbm9uZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFNhdmVcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHB4LTMgcHktMiB0ZXh0LXNtIGZvbnQtbWVkaXVtIGJnLXNsYXRlLTcwMCB0ZXh0LXdoaXRlIGhvdmVyOmJnLXNsYXRlLTgwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctb2Zmc2V0LTIgZm9jdXM6cmluZy1zbGF0ZS01MDAgZGlzYWJsZWQ6b3BhY2l0eS01MCBkaXNhYmxlZDpwb2ludGVyLWV2ZW50cy1ub25lXCJcbiAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2FuY2VsfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBDYW5jZWxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Zvcm0+XG4gICAgICA8L2Rpdj5cbiAgICA8L01vZGFsPlxuICApXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVTaWduYWwsIFNob3csIG9uTW91bnQsIG9uQ2xlYW51cCB9IGZyb20gJ3NvbGlkLWpzJ1xuaW1wb3J0IHsgc3RhdGUgfSBmcm9tICcuLi9zdGF0ZS1zb2xpZC5qcydcbmltcG9ydCB7IGhhc0xvZ0RhdGEgfSBmcm9tICcuLi9zZXJ2aWNlcy9sb2dnaW5nLXNlcnZpY2UuanMnXG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi9JY29uJ1xuXG5pbnRlcmZhY2UgTWVudURyb3Bkb3duUHJvcHMge1xuICBvbkNsZWFyTG9nPzogKCkgPT4gdm9pZFxuICBvblN0YXJ0TG9nPzogKCkgPT4gdm9pZFxuICBvblN0b3BMb2c/OiAoKSA9PiB2b2lkXG4gIG9uRG93bmxvYWRMb2c/OiAoKSA9PiB2b2lkXG4gIG9uUmVwbGF5Q3JlZGVudGlhbHM/OiAoKSA9PiB2b2lkXG4gIG9uUmVhdXRoPzogKCkgPT4gdm9pZFxuICBvblRlcm1pbmFsU2V0dGluZ3M/OiAoKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBjb25zdCBNZW51RHJvcGRvd246IENvbXBvbmVudDxNZW51RHJvcGRvd25Qcm9wcz4gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW2lzT3Blbiwgc2V0SXNPcGVuXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSlcbiAgbGV0IG1lbnVSZWY6IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkXG4gIGxldCBidXR0b25SZWY6IEhUTUxCdXR0b25FbGVtZW50IHwgdW5kZWZpbmVkXG5cblxuICBjb25zdCB0b2dnbGVNZW51ID0gKCkgPT4ge1xuICAgIHNldElzT3BlbighaXNPcGVuKCkpXG4gIH1cblxuICBjb25zdCBvcGVuTWVudSA9ICgpID0+IHtcbiAgICBzZXRJc09wZW4odHJ1ZSlcbiAgfVxuXG4gIGNvbnN0IGNsb3NlTWVudSA9ICgpID0+IHtcbiAgICBzZXRJc09wZW4oZmFsc2UpXG4gIH1cblxuICAvLyBIYW5kbGUgY2xpY2tzIG91dHNpZGUgdGhlIG1lbnVcbiAgY29uc3QgaGFuZGxlT3V0c2lkZUNsaWNrID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgaWYgKG1lbnVSZWYgJiYgIW1lbnVSZWYuY29udGFpbnMoZXZlbnQudGFyZ2V0IGFzIE5vZGUpICYmIFxuICAgICAgICBidXR0b25SZWYgJiYgIWJ1dHRvblJlZi5jb250YWlucyhldmVudC50YXJnZXQgYXMgTm9kZSkpIHtcbiAgICAgIGNsb3NlTWVudSgpXG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICBjbG9zZU1lbnUoKVxuICAgICAgYnV0dG9uUmVmPy5mb2N1cygpXG4gICAgfVxuICB9XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVPdXRzaWRlQ2xpY2spXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pXG4gIH0pXG5cbiAgb25DbGVhbnVwKCgpID0+IHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZU91dHNpZGVDbGljaylcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bilcbiAgfSlcblxuICBjb25zdCBoYW5kbGVNZW51SXRlbUNsaWNrID0gKGFjdGlvbjogKCkgPT4gdm9pZCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBhY3Rpb24oKVxuICAgICAgY2xvc2VNZW51KClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9XCJyZWxhdGl2ZSBncm91cCBweC0yXCIgb25Nb3VzZUxlYXZlPXtjbG9zZU1lbnV9PlxuICAgICAgPGJ1dHRvblxuICAgICAgICByZWY9e2J1dHRvblJlZn1cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJkcm9wdXBDb250ZW50XCJcbiAgICAgICAgYXJpYS1leHBhbmRlZD17aXNPcGVuKCl9XG4gICAgICAgIGNsYXNzPVwiaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGdhcC0xIHNlbGVjdC1ub25lIHRleHQtbmV1dHJhbC0xMDAgaG92ZXI6dGV4dC13aGl0ZSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYmx1ZS01MDAgcm91bmRlZCBweC0xIHB5LTFcIlxuICAgICAgICBvbkNsaWNrPXt0b2dnbGVNZW51fVxuICAgICAgICBvbk1vdXNlRW50ZXI9e29wZW5NZW51fVxuICAgICAgPlxuICAgICAgICA8SWNvbiBuYW1lPVwibWVudVwiIGNsYXNzPVwidy01IGgtNSBpbmxpbmUtYmxvY2tcIiAvPiBNZW51XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIFxuICAgICAgPFNob3cgd2hlbj17aXNPcGVuKCl9PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgcmVmPXttZW51UmVmfVxuICAgICAgICAgIGNsYXNzPVwiYWJzb2x1dGUgYm90dG9tLWZ1bGwgbGVmdC0wIG1pbi13LTU2IGJnLW5ldXRyYWwtNTAgdGV4dC1uZXV0cmFsLTcwMCB0ZXh0LWJhc2Ugc2hhZG93LW1kIGJvcmRlciBib3JkZXItbmV1dHJhbC0yMDAgei1bMTAxXSByb3VuZGVkLW1kIG92ZXJmbG93LWhpZGRlblwiXG4gICAgICAgICAgcm9sZT1cIm1lbnVcIlxuICAgICAgICAgIGFyaWEtb3JpZW50YXRpb249XCJ2ZXJ0aWNhbFwiXG4gICAgICAgID5cbiAgICAgICAgICB7LyogQ2xlYXIgTG9nIEJ1dHRvbiAqL31cbiAgICAgICAgICA8U2hvdyB3aGVuPXtoYXNMb2dEYXRhKCl9PlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJ3LWZ1bGwgdGV4dC1sZWZ0IHB4LTQgcHktMyBob3ZlcjpiZy1uZXV0cmFsLTIwMCB3aGl0ZXNwYWNlLW5vd3JhcCBpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTMgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOmJnLW5ldXRyYWwtMjAwXCJcbiAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlTWVudUl0ZW1DbGljayhwcm9wcy5vbkNsZWFyTG9nIHx8ICgoKSA9PiB7fSkpfVxuICAgICAgICAgICAgICByb2xlPVwibWVudWl0ZW1cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8SWNvbiBuYW1lPVwidHJhc2gtY2FuXCIgY2xhc3M9XCJ3LTUgaC01IGlubGluZS1ibG9ja1wiIC8+IENsZWFyIExvZ1xuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9TaG93PlxuXG4gICAgICAgICAgey8qIFN0b3AgTG9nIEJ1dHRvbiAqL31cbiAgICAgICAgICA8U2hvdyB3aGVuPXtzdGF0ZS5zZXNzaW9uTG9nRW5hYmxlfT5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIGNsYXNzPVwidy1mdWxsIHRleHQtbGVmdCBweC00IHB5LTMgaG92ZXI6YmctbmV1dHJhbC0yMDAgd2hpdGVzcGFjZS1ub3dyYXAgaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGdhcC0zIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpiZy1uZXV0cmFsLTIwMFwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZU1lbnVJdGVtQ2xpY2socHJvcHMub25TdG9wTG9nIHx8ICgoKSA9PiB7fSkpfVxuICAgICAgICAgICAgICByb2xlPVwibWVudWl0ZW1cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8SWNvbiBuYW1lPVwic2V0dGluZ3NcIiBjbGFzcz1cImFuaW1hdGUtc3BpbiBvcmlnaW4tY2VudGVyIHctNSBoLTUgaW5saW5lLWJsb2NrXCIgLz4gU3RvcCBMb2dcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvU2hvdz5cblxuICAgICAgICAgIHsvKiBTdGFydCBMb2cgQnV0dG9uICovfVxuICAgICAgICAgIDxTaG93IHdoZW49eyFzdGF0ZS5zZXNzaW9uTG9nRW5hYmxlfT5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIGNsYXNzPVwidy1mdWxsIHRleHQtbGVmdCBweC00IHB5LTMgaG92ZXI6YmctbmV1dHJhbC0yMDAgd2hpdGVzcGFjZS1ub3dyYXAgaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGdhcC0zIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpiZy1uZXV0cmFsLTIwMFwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZU1lbnVJdGVtQ2xpY2socHJvcHMub25TdGFydExvZyB8fCAoKCkgPT4ge30pKX1cbiAgICAgICAgICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPEljb24gbmFtZT1cImNsaXBib2FyZFwiIGNsYXNzPVwidy01IGgtNSBpbmxpbmUtYmxvY2tcIiAvPiBTdGFydCBMb2dcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvU2hvdz5cblxuICAgICAgICAgIHsvKiBEb3dubG9hZCBMb2cgQnV0dG9uICovfVxuICAgICAgICAgIDxTaG93IHdoZW49e2hhc0xvZ0RhdGEoKX0+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBjbGFzcz1cInctZnVsbCB0ZXh0LWxlZnQgcHgtNCBweS0zIGhvdmVyOmJnLW5ldXRyYWwtMjAwIHdoaXRlc3BhY2Utbm93cmFwIGlubGluZS1mbGV4IGl0ZW1zLWNlbnRlciBnYXAtMyBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6YmctbmV1dHJhbC0yMDBcIlxuICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVNZW51SXRlbUNsaWNrKHByb3BzLm9uRG93bmxvYWRMb2cgfHwgKCgpID0+IHt9KSl9XG4gICAgICAgICAgICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxJY29uIG5hbWU9XCJkb3dubG9hZFwiIGNsYXNzPVwidy01IGgtNSBpbmxpbmUtYmxvY2tcIiAvPiBEb3dubG9hZCBMb2dcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvU2hvdz5cblxuICAgICAgICAgIHsvKiBSZXBsYXkgQ3JlZGVudGlhbHMgQnV0dG9uICovfVxuICAgICAgICAgIDxTaG93IHdoZW49e3N0YXRlLmFsbG93UmVwbGF5fT5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIGNsYXNzPVwidy1mdWxsIHRleHQtbGVmdCBweC00IHB5LTMgaG92ZXI6YmctbmV1dHJhbC0yMDAgd2hpdGVzcGFjZS1ub3dyYXAgaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGdhcC0zIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpiZy1uZXV0cmFsLTIwMFwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZU1lbnVJdGVtQ2xpY2socHJvcHMub25SZXBsYXlDcmVkZW50aWFscyB8fCAoKCkgPT4ge30pKX1cbiAgICAgICAgICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPEljb24gbmFtZT1cImtleVwiIGNsYXNzPVwidy01IGgtNSBpbmxpbmUtYmxvY2tcIiAvPiBDcmVkZW50aWFsc1xuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9TaG93PlxuXG4gICAgICAgICAgey8qIFJlYXV0aCBCdXR0b24gKi99XG4gICAgICAgICAgPFNob3cgd2hlbj17c3RhdGUuYWxsb3dSZWF1dGh9PlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJ3LWZ1bGwgdGV4dC1sZWZ0IHB4LTQgcHktMyBob3ZlcjpiZy1uZXV0cmFsLTIwMCB3aGl0ZXNwYWNlLW5vd3JhcCBpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTMgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOmJnLW5ldXRyYWwtMjAwXCJcbiAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlTWVudUl0ZW1DbGljayhwcm9wcy5vblJlYXV0aCB8fCAoKCkgPT4ge30pKX1cbiAgICAgICAgICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPEljb24gbmFtZT1cImtleVwiIGNsYXNzPVwidy01IGgtNSBpbmxpbmUtYmxvY2tcIiAvPiBTd2l0Y2ggVXNlclxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9TaG93PlxuXG4gICAgICAgICAgey8qIFRlcm1pbmFsIFNldHRpbmdzIEJ1dHRvbiAqL31cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzPVwidy1mdWxsIHRleHQtbGVmdCBweC00IHB5LTMgaG92ZXI6YmctbmV1dHJhbC0yMDAgd2hpdGVzcGFjZS1ub3dyYXAgaW5saW5lLWZsZXggaXRlbXMtY2VudGVyIGdhcC0zIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpiZy1uZXV0cmFsLTIwMFwiXG4gICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVNZW51SXRlbUNsaWNrKHByb3BzLm9uVGVybWluYWxTZXR0aW5ncyB8fCAoKCkgPT4ge30pKX1cbiAgICAgICAgICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEljb24gbmFtZT1cInNldHRpbmdzXCIgY2xhc3M9XCJ3LTUgaC01IGlubGluZS1ibG9ja1wiIC8+IFNldHRpbmdzXG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9TaG93PlxuICAgIDwvZGl2PlxuICApXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVTaWduYWwsIG9uTW91bnQsIG9uQ2xlYW51cCwgU2hvdywgY3JlYXRlRWZmZWN0IH0gZnJvbSAnc29saWQtanMnXG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSAnZGVidWcnXG5cbi8vIEltcG9ydCBleGlzdGluZyB1dGlsaXRpZXMgYW5kIHR5cGVzXG5pbXBvcnQgdHlwZSB7IFdlYlNTSDJDb25maWcgfSBmcm9tICcuLi90eXBlcy9jb25maWcuZCdcbmltcG9ydCB7IGluaXRpYWxpemVDb25maWcsIGdldEJhc2ljQXV0aENvb2tpZSwgcG9wdWxhdGVGb3JtRnJvbVVybCB9IGZyb20gJy4vdXRpbHMuanMnXG5pbXBvcnQgeyBcbiAgY2hlY2tTYXZlZExvZywgXG4gIHNldFNlc3Npb25Gb290ZXIgYXMgc2V0R2xvYmFsU2Vzc2lvbkZvb3RlciwgXG4gIHN0YXJ0TG9nZ2luZywgXG4gIHN0b3BMb2dnaW5nLCBcbiAgZG93bmxvYWRMb2csIFxuICBhZGRUb0xvZyxcbiAgY2xlYXJMb2cgXG59IGZyb20gJy4vc2VydmljZXMvbG9nZ2luZy1zZXJ2aWNlLmpzJ1xuXG4vLyBJbXBvcnQgc3RhdGUgbWFuYWdlbWVudFxuaW1wb3J0IHsgXG4gIHN0YXRlLCBcbiAgc2V0U3RhdGUsXG4gIHNlc3Npb25Gb290ZXIsXG4gIHNldFNlc3Npb25Gb290ZXIsXG4gIGVycm9yTWVzc2FnZSxcbiAgc2V0RXJyb3JNZXNzYWdlLFxuICBpc0xvZ2luRGlhbG9nT3BlbixcbiAgc2V0SXNMb2dpbkRpYWxvZ09wZW4sXG4gIGlzRXJyb3JEaWFsb2dPcGVuLFxuICBzZXRJc0Vycm9yRGlhbG9nT3BlbixcbiAgaXNUZXJtaW5hbFNldHRpbmdzT3BlbixcbiAgc2V0SXNUZXJtaW5hbFNldHRpbmdzT3BlbixcbiAgc2hvd1JlY29ubmVjdEJ1dHRvbixcbiAgc2V0U2hvd1JlY29ubmVjdEJ1dHRvbixcbiAgaGVhZGVyQ29udGVudCxcbiAgc2V0SGVhZGVyQ29udGVudCxcbiAgcHJvbXB0RGF0YSxcbiAgc2V0UHJvbXB0RGF0YVxufSBmcm9tICcuL3N0YXRlLXNvbGlkLmpzJ1xuXG4vLyBJbXBvcnQgY29tcG9uZW50c1xuaW1wb3J0IHsgVGVybWluYWxDb21wb25lbnQsIHRlcm1pbmFsTWFuYWdlciB9IGZyb20gJy4vY29tcG9uZW50cy9UZXJtaW5hbCdcbmltcG9ydCB7IExvZ2luTW9kYWwgfSBmcm9tICcuL2NvbXBvbmVudHMvTG9naW5Nb2RhbCdcbmltcG9ydCB7IEVycm9yTW9kYWwsIFByb21wdE1vZGFsIH0gZnJvbSAnLi9jb21wb25lbnRzL01vZGFsJ1xuaW1wb3J0IHsgVGVybWluYWxTZXR0aW5nc01vZGFsIH0gZnJvbSAnLi9jb21wb25lbnRzL1Rlcm1pbmFsU2V0dGluZ3NNb2RhbCdcbmltcG9ydCB7IE1lbnVEcm9wZG93biB9IGZyb20gJy4vY29tcG9uZW50cy9NZW51RHJvcGRvd24nXG5cbi8vIEltcG9ydCBzb2NrZXQgc2VydmljZVxuaW1wb3J0IHsgc29ja2V0U2VydmljZSwgc2V0VGVybWluYWxEaW1lbnNpb25zLCBzdWJtaXRQcm9tcHRSZXNwb25zZXMsIGNvbm5lY3Rpb25TdGF0dXMsIGNvbm5lY3Rpb25TdGF0dXNDb2xvciB9IGZyb20gJy4vc2VydmljZXMvc29ja2V0LXNlcnZpY2UuanMnXG5cbi8vIEltcG9ydCB0eXBlc1xuaW1wb3J0IHR5cGUgeyBDbGllbnRBdXRoZW50aWNhdGVQYXlsb2FkIH0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzLmQnXG5pbXBvcnQgdHlwZSB7IFRlcm1pbmFsUmVmIH0gZnJvbSAnLi94dGVybS1zb2xpZC90eXBlcydcblxuLy8gSW1wb3J0IENTU1xuaW1wb3J0ICcuLi9jc3MvdGFpbHdpbmQuY3NzJ1xuaW1wb3J0ICdAeHRlcm0veHRlcm0vY3NzL3h0ZXJtLmNzcydcbmltcG9ydCAnLi4vY3NzL2ljb25zLmNzcydcblxuY29uc3QgZGVidWcgPSBjcmVhdGVEZWJ1Zygnd2Vic3NoMi1jbGllbnQ6YXBwJylcblxuY29uc3QgQXBwOiBDb21wb25lbnQgPSAoKSA9PiB7XG4gIGNvbnN0IFtjb25maWcsIHNldENvbmZpZ10gPSBjcmVhdGVTaWduYWw8V2ViU1NIMkNvbmZpZz4oKVxuICBjb25zdCBbaXNUZXJtaW5hbFZpc2libGUsIHNldElzVGVybWluYWxWaXNpYmxlXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSlcbiAgXG4gIGxldCB0ZXJtaW5hbFJlZjogVGVybWluYWxSZWYgfCB1bmRlZmluZWRcblxuICAvLyBEZWJ1ZyBlZmZlY3QgZm9yIGxvZ2luIGRpYWxvZyBzdGF0ZVxuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGRlYnVnKCdMb2dpbkRpYWxvZyBzdGF0ZSBjaGFuZ2VkOicsIGlzTG9naW5EaWFsb2dPcGVuKCkpXG4gIH0pXG5cbiAgb25Nb3VudChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKGBJbml0aWFsaXppbmcgV2ViU1NIMiBjbGllbnQgLSAkeyhnbG9iYWxUaGlzIGFzIGFueSkuQkFOTkVSX1NUUklOR31gKVxuICAgICAgXG4gICAgICBsZXQgaW5pdGlhbENvbmZpZyA9IGluaXRpYWxpemVDb25maWcoKVxuXG4gICAgICBjb25zdCBiYXNpY0F1dGhDb29raWUgPSBnZXRCYXNpY0F1dGhDb29raWUoKVxuICAgICAgaWYgKGJhc2ljQXV0aENvb2tpZSkge1xuICAgICAgICBpbml0aWFsQ29uZmlnLnNzaC5ob3N0ID0gYmFzaWNBdXRoQ29va2llLmhvc3QgfHwgaW5pdGlhbENvbmZpZy5zc2guaG9zdFxuICAgICAgICBpbml0aWFsQ29uZmlnLnNzaC5wb3J0ID0gYmFzaWNBdXRoQ29va2llLnBvcnQgfHwgaW5pdGlhbENvbmZpZy5zc2gucG9ydFxuICAgICAgICBzZXRTdGF0ZSgnaXNCYXNpY0F1dGhDb29raWVQcmVzZW50JywgdHJ1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFN0YXRlKCdpc0Jhc2ljQXV0aENvb2tpZVByZXNlbnQnLCBmYWxzZSlcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbENvbmZpZyA9IHBvcHVsYXRlRm9ybUZyb21VcmwoaW5pdGlhbENvbmZpZylcbiAgICAgIHNldENvbmZpZyhpbml0aWFsQ29uZmlnKVxuXG5cbiAgICAgIC8vIFNldCBzZXNzaW9uIGZvb3RlclxuICAgICAgY29uc3QgZm9vdGVyID0gaW5pdGlhbENvbmZpZy5zc2guaG9zdFxuICAgICAgICA/IGBzc2g6Ly8ke2luaXRpYWxDb25maWcuc3NoLmhvc3R9OiR7aW5pdGlhbENvbmZpZy5zc2gucG9ydH1gXG4gICAgICAgIDogbnVsbFxuICAgICAgc2V0U2Vzc2lvbkZvb3Rlcihmb290ZXIpXG4gICAgICBzZXRHbG9iYWxTZXNzaW9uRm9vdGVyKGZvb3RlcilcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBzb2NrZXQgc2VydmljZVxuICAgICAgc29ja2V0U2VydmljZS5pbml0U29ja2V0KFxuICAgICAgICBpbml0aWFsQ29uZmlnLFxuICAgICAgICBvbkNvbm5lY3QsXG4gICAgICAgIG9uRGlzY29ubmVjdCxcbiAgICAgICAgb25EYXRhLFxuICAgICAgICB3cml0ZVRvVGVybWluYWwsXG4gICAgICAgIGZvY3VzVGVybWluYWxcbiAgICAgIClcblxuICAgICAgLy8gU2V0IHVwIHJlYWN0aXZlIGVmZmVjdHMgd2l0aGluIHRoZSBTb2xpZEpTIGNvbnRleHRcbiAgICAgIHNvY2tldFNlcnZpY2Uuc2V0dXBSZWFjdGl2ZUVmZmVjdHMoKVxuXG4gICAgICAvLyBDaGVjayBmb3Igc2F2ZWQgc2Vzc2lvbiBsb2dcbiAgICAgIGNoZWNrU2F2ZWRMb2coKVxuXG4gICAgICAvLyBJbml0aWFsaXplIGxvZ2dlZERhdGEgc3RhdGUgYmFzZWQgb24gbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBoYXNTZXNzaW9uTG9nID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3ZWJzc2gyX3Nlc3Npb25fbG9nJylcbiAgICAgIHNldFN0YXRlKCdsb2dnZWREYXRhJywgISFoYXNTZXNzaW9uTG9nKVxuICAgICAgZGVidWcoJ0luaXRpYWxpemVkIGxvZ2dlZERhdGEgc3RhdGU6JywgISFoYXNTZXNzaW9uTG9nKVxuXG4gICAgICAvLyBJbml0aWFsaXplIGNvbm5lY3Rpb25cbiAgICAgIGluaXRpYWxpemVDb25uZWN0aW9uKGluaXRpYWxDb25maWcpXG5cbiAgICAgIGRlYnVnKCdXZWJTU0gyIGNsaWVudCBpbml0aWFsaXplZCcsIHsgXG4gICAgICAgIGF1dG9Db25uZWN0OiBpbml0aWFsQ29uZmlnLmF1dG9Db25uZWN0LCBcbiAgICAgICAgbG9naW5EaWFsb2dPcGVuOiBpc0xvZ2luRGlhbG9nT3BlbigpIFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignSW5pdGlhbGl6YXRpb24gZXJyb3I6JywgZXJyb3IpXG4gICAgICBoYW5kbGVFcnJvcignSW5pdGlhbGl6YXRpb24gZXJyb3I6JywgZXJyb3IpXG4gICAgfVxuICB9KVxuXG4gIG9uQ2xlYW51cCgoKSA9PiB7XG4gICAgZGVidWcoJ0FwcCBjbGVhbnVwJylcbiAgICBzb2NrZXRTZXJ2aWNlLmNsb3NlQ29ubmVjdGlvbigpXG4gIH0pXG5cbiAgLy8gVGVybWluYWwgZXZlbnQgaGFuZGxlcnNcbiAgY29uc3QgaGFuZGxlVGVybWluYWxSZWFkeSA9IChyZWY6IFRlcm1pbmFsUmVmKSA9PiB7XG4gICAgZGVidWcoJ1Rlcm1pbmFsIHJlYWR5JylcbiAgICB0ZXJtaW5hbFJlZiA9IHJlZlxuICAgIHRlcm1pbmFsTWFuYWdlci5zZXRUZXJtaW5hbFJlZihyZWYpXG4gICAgXG4gICAgLy8gU2V0IGluaXRpYWwgZGltZW5zaW9uc1xuICAgIGlmIChyZWYudGVybWluYWwpIHtcbiAgICAgIGNvbnN0IGRpbXMgPSB7IGNvbHM6IHJlZi50ZXJtaW5hbC5jb2xzLCByb3dzOiByZWYudGVybWluYWwucm93cyB9XG4gICAgICBzZXRUZXJtaW5hbERpbWVuc2lvbnMoZGltcylcbiAgICAgIGRlYnVnKCdUZXJtaW5hbCBkaW1lbnNpb25zIHNldDonLCBkaW1zKVxuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgdXAgcmVzaXplIGxpc3RlbmVyXG4gICAgaWYgKHJlZi50ZXJtaW5hbCkge1xuICAgICAgcmVmLnRlcm1pbmFsLm9uUmVzaXplKChkaW1lbnNpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpbXMgPSB7IGNvbHM6IGRpbWVuc2lvbnMuY29scywgcm93czogZGltZW5zaW9ucy5yb3dzIH1cbiAgICAgICAgc2V0VGVybWluYWxEaW1lbnNpb25zKGRpbXMpXG4gICAgICAgIGRlYnVnKCdUZXJtaW5hbCByZXNpemVkOicsIGRpbXMpXG4gICAgICAgIFxuICAgICAgICAvLyBNYW51YWxseSB0cmlnZ2VyIHJlc2l6ZSB0byBzb2NrZXRcbiAgICAgICAgc29ja2V0U2VydmljZS5lbWl0UmVzaXplKGRpbXMpXG4gICAgICB9KVxuICAgIH1cbiAgICBcbiAgICBzZXRJc1Rlcm1pbmFsVmlzaWJsZSh0cnVlKVxuICB9XG5cbiAgLy8gU29ja2V0IGV2ZW50IGhhbmRsZXJzXG4gIGNvbnN0IG9uQ29ubmVjdCA9ICgpID0+IHtcbiAgICBzZXRTaG93UmVjb25uZWN0QnV0dG9uKGZhbHNlKVxuICAgIHNldElzRXJyb3JEaWFsb2dPcGVuKGZhbHNlKVxuICAgIHNldFN0YXRlKCdzZXNzaW9uTG9nRW5hYmxlJywgZmFsc2UpXG4gICAgc2V0U3RhdGUoJ2xvZ2dlZERhdGEnLCBmYWxzZSlcbiAgICBkZWJ1ZygnQ29ubmVjdGVkIHRvIHNlcnZlcicpXG4gIH1cblxuICBjb25zdCBvbkRpc2Nvbm5lY3QgPSAocmVhc29uOiBzdHJpbmcsIGRldGFpbHM/OiB1bmtub3duKSA9PiB7XG4gICAgZGVidWcoJ0Rpc2Nvbm5lY3RlZDonLCByZWFzb24pXG4gICAgc3dpdGNoIChyZWFzb24pIHtcbiAgICAgIGNhc2UgJ2F1dGhfcmVxdWlyZWQnOlxuICAgICAgY2FzZSAnYXV0aF9mYWlsZWQnOlxuICAgICAgICBzZXRJc0xvZ2luRGlhbG9nT3Blbih0cnVlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncmVhdXRoX3JlcXVpcmVkJzpcbiAgICAgICAgZGVidWcoJ1JlYXV0aCByZXF1aXJlZCcpXG4gICAgICAgIHNldFN0YXRlKCdyZWF1dGhSZXF1aXJlZCcsIHRydWUpXG4gICAgICAgIHNldElzTG9naW5EaWFsb2dPcGVuKHRydWUpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICBjYXNlICdzc2hfZXJyb3InOlxuICAgICAgICBpZiAoIXN0YXRlLnJlYXV0aFJlcXVpcmVkKSB7XG4gICAgICAgICAgc2V0RXJyb3JNZXNzYWdlKGAke1N0cmluZyhkZXRhaWxzIHx8IHJlYXNvbil9YClcbiAgICAgICAgICBzZXRJc0Vycm9yRGlhbG9nT3Blbih0cnVlKVxuICAgICAgICAgIGNvbW1vblBvc3REaXNjb25uZWN0VGFza3MoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFN0YXRlKCdyZWF1dGhSZXF1aXJlZCcsIGZhbHNlKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZXRFcnJvck1lc3NhZ2UoYERpc2Nvbm5lY3RlZDogJHtTdHJpbmcoZGV0YWlscyB8fCByZWFzb24pfWApXG4gICAgICAgIHNldElzRXJyb3JEaWFsb2dPcGVuKHRydWUpXG4gICAgICAgIGNvbW1vblBvc3REaXNjb25uZWN0VGFza3MoKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9uRGF0YSA9IChkYXRhOiBzdHJpbmcpID0+IHtcbiAgICBhZGRUb0xvZyhkYXRhKVxuICB9XG5cbiAgY29uc3Qgd3JpdGVUb1Rlcm1pbmFsID0gKGRhdGE6IHN0cmluZykgPT4ge1xuICAgIHRlcm1pbmFsTWFuYWdlci53cml0ZVRvVGVybWluYWwoZGF0YSlcbiAgfVxuXG4gIGNvbnN0IGZvY3VzVGVybWluYWwgPSAoKSA9PiB7XG4gICAgdGVybWluYWxNYW5hZ2VyLmZvY3VzVGVybWluYWwoKVxuICB9XG5cbiAgLy8gVUkgZXZlbnQgaGFuZGxlcnNcbiAgY29uc3QgaGFuZGxlTG9naW4gPSAoZm9ybURhdGE6IFBhcnRpYWw8Q2xpZW50QXV0aGVudGljYXRlUGF5bG9hZD4pID0+IHtcbiAgICBkZWJ1ZygnSGFuZGxpbmcgbG9naW4nLCB7IGhvc3Q6IGZvcm1EYXRhLmhvc3QsIHBvcnQ6IGZvcm1EYXRhLnBvcnQgfSlcbiAgICBjb25uZWN0VG9TZXJ2ZXIoZm9ybURhdGEpXG4gIH1cblxuICBjb25zdCBoYW5kbGVUZXJtaW5hbFNldHRpbmdzID0gKHNldHRpbmdzOiBhbnkpID0+IHtcbiAgICB0ZXJtaW5hbE1hbmFnZXIuYXBwbHlUZXJtaW5hbFNldHRpbmdzKHNldHRpbmdzKVxuICB9XG5cbiAgY29uc3QgaGFuZGxlUmVjb25uZWN0ID0gKCkgPT4ge1xuICAgIHNldFNob3dSZWNvbm5lY3RCdXR0b24oZmFsc2UpXG4gICAgc2V0SXNFcnJvckRpYWxvZ09wZW4oZmFsc2UpXG4gICAgdGVybWluYWxNYW5hZ2VyLnJlc2V0VGVybWluYWwoKVxuICAgIGNvbm5lY3RUb1NlcnZlcigpXG4gIH1cblxuICBjb25zdCBoYW5kbGVQcm9tcHRTdWJtaXQgPSAocmVzcG9uc2VzOiBzdHJpbmdbXSkgPT4ge1xuICAgIC8vIEhhbmRsZSBrZXlib2FyZCBpbnRlcmFjdGl2ZSBhdXRoZW50aWNhdGlvbiByZXNwb25zZXNcbiAgICBkZWJ1ZygnUHJvbXB0IHJlc3BvbnNlczonLCByZXNwb25zZXMpXG4gICAgc3VibWl0UHJvbXB0UmVzcG9uc2VzKHJlc3BvbnNlcylcbiAgfVxuXG4gIC8vIE1lbnUgaGFuZGxlcnNcbiAgY29uc3QgaGFuZGxlU3RhcnRMb2cgPSAoKSA9PiB7XG4gICAgc3RhcnRMb2dnaW5nKClcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZVN0b3BMb2cgPSAoKSA9PiB7XG4gICAgc3RvcExvZ2dpbmcoKVxuICB9XG5cbiAgY29uc3QgaGFuZGxlRG93bmxvYWRMb2cgPSAoKSA9PiB7XG4gICAgZG93bmxvYWRMb2coKVxuICB9XG5cbiAgY29uc3QgaGFuZGxlQ2xlYXJMb2cgPSAoKSA9PiB7XG4gICAgY2xlYXJMb2coKVxuICB9XG5cbiAgY29uc3QgaGFuZGxlUmVwbGF5Q3JlZGVudGlhbHMgPSAoKSA9PiB7XG4gICAgc29ja2V0U2VydmljZS5yZXBsYXlDcmVkZW50aWFscygpXG4gIH1cblxuICBjb25zdCBoYW5kbGVSZWF1dGggPSAoKSA9PiB7XG4gICAgc29ja2V0U2VydmljZS5yZWF1dGgoKVxuICB9XG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbnNcbiAgY29uc3QgY29ubmVjdFRvU2VydmVyID0gKGZvcm1EYXRhPzogUGFydGlhbDxDbGllbnRBdXRoZW50aWNhdGVQYXlsb2FkPikgPT4ge1xuICAgIGRlYnVnKCdDb25uZWN0aW5nIHRvIHNlcnZlcicpXG4gICAgY29uc3QgY3VycmVudENvbmZpZyA9IGNvbmZpZygpXG4gICAgaWYgKCFjdXJyZW50Q29uZmlnKSByZXR1cm5cblxuICAgIGlmIChzdGF0ZS5pc0Nvbm5lY3RpbmcpIHJldHVyblxuICAgIFxuICAgIGlmIChzdGF0ZS5yZWF1dGhSZXF1aXJlZCkge1xuICAgICAgc2V0U3RhdGUoJ3JlYXV0aFJlcXVpcmVkJywgZmFsc2UpXG4gICAgICB0ZXJtaW5hbE1hbmFnZXIucmVzZXRUZXJtaW5hbCgpXG4gICAgfVxuICAgIFxuICAgIHNldFN0YXRlKCdpc0Nvbm5lY3RpbmcnLCB0cnVlKVxuICAgIGlmIChmb3JtRGF0YSkgc29ja2V0U2VydmljZS5zZXRGb3JtRGF0YShmb3JtRGF0YSlcbiAgICBzb2NrZXRTZXJ2aWNlLmluaXRpYWxpemVTb2NrZXRDb25uZWN0aW9uKClcblxuICAgIC8vIFNob3cgdGVybWluYWwgYW5kIHNldCBoZWFkZXIvZm9vdGVyXG4gICAgaWYgKHRlcm1pbmFsUmVmKSB7XG4gICAgICBpZiAoY3VycmVudENvbmZpZz8uaGVhZGVyPy50ZXh0ICYmIGN1cnJlbnRDb25maWc/LmhlYWRlcj8uYmFja2dyb3VuZCkge1xuICAgICAgICBzZXRIZWFkZXJDb250ZW50KHtcbiAgICAgICAgICB0ZXh0OiBjdXJyZW50Q29uZmlnLmhlYWRlci50ZXh0LFxuICAgICAgICAgIGJhY2tncm91bmQ6IGN1cnJlbnRDb25maWcuaGVhZGVyLmJhY2tncm91bmRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHNldElzVGVybWluYWxWaXNpYmxlKHRydWUpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29tbW9uUG9zdERpc2Nvbm5lY3RUYXNrcyA9ICgpID0+IHtcbiAgICBzZXRTdGF0ZSgnaXNDb25uZWN0aW5nJywgZmFsc2UpXG4gICAgaWYgKHN0YXRlLnNlc3Npb25Mb2dFbmFibGUpIHtcbiAgICAgIGRvd25sb2FkTG9nKClcbiAgICB9XG4gICAgcmVzZXRBcHBsaWNhdGlvbigpXG4gICAgaWYgKHN0YXRlLmFsbG93UmVjb25uZWN0ICYmICFzdGF0ZS5pc0Jhc2ljQXV0aENvb2tpZVByZXNlbnQpIHtcbiAgICAgIHNldFNob3dSZWNvbm5lY3RCdXR0b24odHJ1ZSlcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXNldEFwcGxpY2F0aW9uID0gKCkgPT4ge1xuICAgIHNldFN0YXRlKCdzZXNzaW9uTG9nRW5hYmxlJywgZmFsc2UpXG4gIH1cblxuICBjb25zdCBoYW5kbGVFcnJvciA9IChtZXNzYWdlOiBzdHJpbmcsIGVycm9yOiB1bmtub3duKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3I6JywgbWVzc2FnZSwgZXJyb3IpXG4gICAgc2V0U3RhdGUoJ2lzQ29ubmVjdGluZycsIGZhbHNlKVxuICAgIHNldEVycm9yTWVzc2FnZShtZXNzYWdlKVxuICAgIHNldElzRXJyb3JEaWFsb2dPcGVuKHRydWUpXG4gIH1cblxuICBjb25zdCBpbml0aWFsaXplQ29ubmVjdGlvbiA9IChjdXJyZW50Q29uZmlnOiBXZWJTU0gyQ29uZmlnKSA9PiB7XG4gICAgZGVidWcoJ0luaXRpYWxpemluZyBjb25uZWN0aW9uJywgeyBhdXRvQ29ubmVjdDogY3VycmVudENvbmZpZy5hdXRvQ29ubmVjdCB9KVxuICAgIHRyeSB7XG4gICAgICBpZiAoY3VycmVudENvbmZpZy5hdXRvQ29ubmVjdCkge1xuICAgICAgICBjb25zdCBsb2dpbkluZm86IFBhcnRpYWw8Q2xpZW50QXV0aGVudGljYXRlUGF5bG9hZD4gPSB7fVxuICAgICAgICBpZiAoY3VycmVudENvbmZpZy5zc2guaG9zdCkgbG9naW5JbmZvLmhvc3QgPSBjdXJyZW50Q29uZmlnLnNzaC5ob3N0XG4gICAgICAgIGxvZ2luSW5mby5wb3J0ID0gY3VycmVudENvbmZpZy5zc2gucG9ydFxuICAgICAgICBpZiAoY3VycmVudENvbmZpZy5zc2gudXNlcm5hbWUpIGxvZ2luSW5mby51c2VybmFtZSA9IGN1cnJlbnRDb25maWcuc3NoLnVzZXJuYW1lXG4gICAgICAgIGNvbm5lY3RUb1NlcnZlcihsb2dpbkluZm8pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaG93IGxvZ2luIGRpYWxvZyB3aGVuIGF1dG9Db25uZWN0IGlzIGZhbHNlXG4gICAgICAgIGRlYnVnKCdTZXR0aW5nIGxvZ2luIGRpYWxvZyB0byBvcGVuJylcbiAgICAgICAgLy8gQ29tcG9uZW50IGlzIGFscmVhZHkgbW91bnRlZCAoY2FsbGVkIGZyb20gb25Nb3VudCksIHNvIHdlIGNhbiBzZXQgc3RhdGUgZGlyZWN0bHlcbiAgICAgICAgc2V0SXNMb2dpbkRpYWxvZ09wZW4odHJ1ZSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaGFuZGxlRXJyb3IoJ0Nvbm5lY3Rpb24gaW5pdGlhbGl6YXRpb24gZmFpbGVkJywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPVwib3ZlcmZsb3ctaGlkZGVuIGJnLWJsYWNrIHRleHQtbmV1dHJhbC0xMDAgZmxleCBmbGV4LWNvbFwiIHN0eWxlPVwiaGVpZ2h0OiAxMDAlOyB3aWR0aDogMTAwJTtcIj5cbiAgICAgIHsvKiBNb2RhbHMgKi99XG4gICAgICA8TG9naW5Nb2RhbFxuICAgICAgICBpc09wZW49e2lzTG9naW5EaWFsb2dPcGVuKCl9XG4gICAgICAgIG9uQ2xvc2U9eygpID0+IHtcbiAgICAgICAgICBkZWJ1ZygnQ2xvc2luZyBsb2dpbiBkaWFsb2cnKVxuICAgICAgICAgIHNldElzTG9naW5EaWFsb2dPcGVuKGZhbHNlKVxuICAgICAgICB9fVxuICAgICAgICBvblN1Ym1pdD17aGFuZGxlTG9naW59XG4gICAgICAgIG9uT3B0aW9uc0NsaWNrPXsoKSA9PiBzZXRJc1Rlcm1pbmFsU2V0dGluZ3NPcGVuKHRydWUpfVxuICAgICAgICBpbml0aWFsVmFsdWVzPXtjb25maWcoKSA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBPYmplY3QuZW50cmllcyh7XG4gICAgICAgICAgICAuLi4oY29uZmlnKCkhLnNzaC5ob3N0ICYmIHsgaG9zdDogY29uZmlnKCkhLnNzaC5ob3N0IH0pLFxuICAgICAgICAgICAgLi4uKGNvbmZpZygpIS5zc2gucG9ydCAmJiB7IHBvcnQ6IGNvbmZpZygpIS5zc2gucG9ydCB9KSxcbiAgICAgICAgICAgIC4uLihjb25maWcoKSEuc3NoLnVzZXJuYW1lICYmIHsgdXNlcm5hbWU6IGNvbmZpZygpIS5zc2gudXNlcm5hbWUgfSlcbiAgICAgICAgICB9KS5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9IG51bGwpXG4gICAgICAgICkgYXMgUGFydGlhbDxDbGllbnRBdXRoZW50aWNhdGVQYXlsb2FkPiA6IHVuZGVmaW5lZH1cbiAgICAgIC8+XG5cbiAgICAgIDxFcnJvck1vZGFsXG4gICAgICAgIGlzT3Blbj17aXNFcnJvckRpYWxvZ09wZW4oKX1cbiAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0SXNFcnJvckRpYWxvZ09wZW4oZmFsc2UpfVxuICAgICAgICBtZXNzYWdlPXtlcnJvck1lc3NhZ2UoKSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQnfVxuICAgICAgLz5cblxuICAgICAgPFRlcm1pbmFsU2V0dGluZ3NNb2RhbFxuICAgICAgICBpc09wZW49e2lzVGVybWluYWxTZXR0aW5nc09wZW4oKX1cbiAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0SXNUZXJtaW5hbFNldHRpbmdzT3BlbihmYWxzZSl9XG4gICAgICAgIG9uU2F2ZT17aGFuZGxlVGVybWluYWxTZXR0aW5nc31cbiAgICAgIC8+XG5cbiAgICAgIDxTaG93IHdoZW49e3Byb21wdERhdGEoKX0+XG4gICAgICAgIDxQcm9tcHRNb2RhbFxuICAgICAgICAgIGlzT3Blbj17ISFwcm9tcHREYXRhKCl9XG4gICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0UHJvbXB0RGF0YShudWxsKX1cbiAgICAgICAgICB0aXRsZT17cHJvbXB0RGF0YSgpPy50aXRsZSB8fCAnQXV0aGVudGljYXRpb24gUmVxdWlyZWQnfVxuICAgICAgICAgIHByb21wdHM9e3Byb21wdERhdGEoKT8ucHJvbXB0cyB8fCBbXX1cbiAgICAgICAgICBvblN1Ym1pdD17aGFuZGxlUHJvbXB0U3VibWl0fVxuICAgICAgICAvPlxuICAgICAgPC9TaG93PlxuXG4gICAgICB7LyogUmVjb25uZWN0IEJ1dHRvbiAqL31cbiAgICAgIDxTaG93IHdoZW49e3Nob3dSZWNvbm5lY3RCdXR0b24oKX0+XG4gICAgICAgIDxidXR0b24gXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgY2xhc3M9XCJmaXhlZCBsZWZ0LTEvMiB0b3AtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiB6LVsxMDAxXSBiZy1ibHVlLTYwMCBob3ZlcjpiZy1ibHVlLTcwMCB0ZXh0LXdoaXRlIHRleHQtc20gcHgtNSBweS0yIHJvdW5kZWQgc2hhZG93IGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1vZmZzZXQtMiBmb2N1czpyaW5nLWJsdWUtNTAwXCJcbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVSZWNvbm5lY3R9XG4gICAgICAgID5cbiAgICAgICAgICBSZWNvbm5lY3RcbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L1Nob3c+XG5cbiAgICAgIHsvKiBNYWluIENvbnRhaW5lciAqL31cbiAgICAgIDxkaXYgY2xhc3M9XCJmbGV4LTEgZmxleCBmbGV4LWNvbCBtaW4taC0wXCI+XG4gICAgICAgIHsvKiBIZWFkZXIgKi99XG4gICAgICAgIDxTaG93IHdoZW49e2hlYWRlckNvbnRlbnQoKX0+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzPVwidy1mdWxsIHRleHQtY2VudGVyIHotWzk5XSBoLTYgbGVhZGluZy02IHRleHQtd2hpdGUgYm9yZGVyLWIgYm9yZGVyLW5ldXRyYWwtMjAwIHNocmluay0wXCJcbiAgICAgICAgICAgIHN0eWxlPXt7ICdiYWNrZ3JvdW5kLWNvbG9yJzogaGVhZGVyQ29udGVudCgpPy5iYWNrZ3JvdW5kIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2hlYWRlckNvbnRlbnQoKT8udGV4dH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9TaG93PlxuICAgICAgICBcbiAgICAgICAgey8qIFRlcm1pbmFsIENvbnRhaW5lciAqL31cbiAgICAgICAgPFNob3cgXG4gICAgICAgICAgd2hlbj17Y29uZmlnKCl9XG4gICAgICAgICAgZmFsbGJhY2s9e1xuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZsZXgtMSBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1uZXV0cmFsLTQwMFwiPkluaXRpYWxpemluZy4uLjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgfVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRlcm1pbmFsIGZsZXgtMSBtaW4taC0wIHctZnVsbCBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgICAgIDxUZXJtaW5hbENvbXBvbmVudFxuICAgICAgICAgICAgICBjb25maWc9e2NvbmZpZygpIX1cbiAgICAgICAgICAgICAgb25UZXJtaW5hbFJlYWR5PXtoYW5kbGVUZXJtaW5hbFJlYWR5fVxuICAgICAgICAgICAgICBjbGFzcz1cInctZnVsbCBoLWZ1bGxcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9TaG93PlxuICAgICAgICBcbiAgICAgICAgey8qIEJvdHRvbSBCYXIgKi99XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ6LVs5OV0gaC02IGZsZXggaXRlbXMtY2VudGVyIGJnLW5ldXRyYWwtODAwIHRleHQtbmV1dHJhbC0xMDAgYm9yZGVyLXQgYm9yZGVyLW5ldXRyYWwtMjAwIHNocmluay0wXCI+XG4gICAgICAgICAgey8qIE1lbnUgKi99XG4gICAgICAgICAgPE1lbnVEcm9wZG93blxuICAgICAgICAgICAgb25TdGFydExvZz17aGFuZGxlU3RhcnRMb2d9XG4gICAgICAgICAgICBvblN0b3BMb2c9e2hhbmRsZVN0b3BMb2d9XG4gICAgICAgICAgICBvbkRvd25sb2FkTG9nPXtoYW5kbGVEb3dubG9hZExvZ31cbiAgICAgICAgICAgIG9uQ2xlYXJMb2c9e2hhbmRsZUNsZWFyTG9nfVxuICAgICAgICAgICAgb25SZXBsYXlDcmVkZW50aWFscz17aGFuZGxlUmVwbGF5Q3JlZGVudGlhbHN9XG4gICAgICAgICAgICBvblJlYXV0aD17aGFuZGxlUmVhdXRofVxuICAgICAgICAgICAgb25UZXJtaW5hbFNldHRpbmdzPXsoKSA9PiBzZXRJc1Rlcm1pbmFsU2V0dGluZ3NPcGVuKHRydWUpfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgXG4gICAgICAgICAgey8qIEZvb3RlciBhbmQgU3RhdHVzICovfVxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJpbmxpbmUtYmxvY2sgdGV4dC1sZWZ0IHB4LVsxMHB4XSBib3JkZXItbCBib3JkZXItbmV1dHJhbC0yMDBcIj5cbiAgICAgICAgICAgIHtzZXNzaW9uRm9vdGVyKCl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGlkPVwic3RhdHVzXCJcbiAgICAgICAgICAgIHJvbGU9XCJzdGF0dXNcIiBcbiAgICAgICAgICAgIGFyaWEtbGl2ZT1cInBvbGl0ZVwiIFxuICAgICAgICAgICAgYXJpYS1hdG9taWM9XCJ0cnVlXCIgXG4gICAgICAgICAgICBjbGFzcz1cImlubGluZS1ibG9jayB0ZXh0LWxlZnQgcHgtWzEwcHhdIHotWzEwMF0gYm9yZGVyLXggYm9yZGVyLW5ldXRyYWwtMjAwXCJcbiAgICAgICAgICAgIHN0eWxlPXt7IGNvbG9yOiBjb25uZWN0aW9uU3RhdHVzQ29sb3IoKSB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjb25uZWN0aW9uU3RhdHVzKCl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBwIiwiLy8gU29saWRKUyBlbnRyeSBwb2ludCBmb3Igd2Vic3NoMl9jbGllbnRcbmltcG9ydCB7IHJlbmRlciB9IGZyb20gJ3NvbGlkLWpzL3dlYidcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnXG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ3dlYnNzaDItY2xpZW50OmluZGV4JylcblxuZGVidWcoJ1NvbGlkSlMgZW50cnkgcG9pbnQgbG9hZGluZycpXG5cbi8vIE1vdW50IHRoZSBTb2xpZEpTIGFwcFxuY29uc3QgYXBwRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5hcHBFbGVtZW50LmlkID0gJ2FwcCdcbmFwcEVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9ICdoZWlnaHQ6IDEwMHZoOyB3aWR0aDogMTAwJTsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7J1xuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhcHBFbGVtZW50KVxuXG5kZWJ1ZygnTW91bnRpbmcgU29saWRKUyBhcHAnKVxucmVuZGVyKCgpID0+IDxBcHAgLz4sIGFwcEVsZW1lbnQpXG5kZWJ1ZygnU29saWRKUyBhcHAgbW91bnRlZCcpIl0sImZpbGUiOiJ3ZWJzc2gyLmJ1bmRsZS5qcyJ9